Total duration: 0.0972753s
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py
File duration: 0.0725896s (74.62%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|#
     2|         0|            0|            0|  0.00%|# Secret Labs' Regular Expression Engine
     3|         0|            0|            0|  0.00%|#
     4|         0|            0|            0|  0.00%|# convert re-style regular expression to sre pattern
     5|         0|            0|            0|  0.00%|#
     6|         0|            0|            0|  0.00%|# Copyright (c) 1998-2001 by Secret Labs AB.  All rights reserved.
     7|         0|            0|            0|  0.00%|#
     8|         0|            0|            0|  0.00%|# See the __init__.py file for information on usage and redistribution.
     9|         0|            0|            0|  0.00%|#
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|"""Internal support module for sre"""
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|# XXX: show string offset and offending character for all errors
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|from ._constants import *
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|SPECIAL_CHARS = ".\\[{()*+?^$|"
    18|         0|            0|            0|  0.00%|REPEAT_CHARS = "*+?{"
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|DIGITS = frozenset("0123456789")
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|OCTDIGITS = frozenset("01234567")
    23|         0|            0|            0|  0.00%|HEXDIGITS = frozenset("0123456789abcdefABCDEF")
    24|         0|            0|            0|  0.00%|ASCIILETTERS = frozenset("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|WHITESPACE = frozenset(" \t\n\r\v\f")
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|_REPEATCODES = frozenset({MIN_REPEAT, MAX_REPEAT, POSSESSIVE_REPEAT})
    29|         0|            0|            0|  0.00%|_UNITCODES = frozenset({ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY})
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|ESCAPES = {
    32|         0|            0|            0|  0.00%|    r"\a": (LITERAL, ord("\a")),
    33|         0|            0|            0|  0.00%|    r"\b": (LITERAL, ord("\b")),
    34|         0|            0|            0|  0.00%|    r"\f": (LITERAL, ord("\f")),
    35|         0|            0|            0|  0.00%|    r"\n": (LITERAL, ord("\n")),
    36|         0|            0|            0|  0.00%|    r"\r": (LITERAL, ord("\r")),
    37|         0|            0|            0|  0.00%|    r"\t": (LITERAL, ord("\t")),
    38|         0|            0|            0|  0.00%|    r"\v": (LITERAL, ord("\v")),
    39|         0|            0|            0|  0.00%|    r"\\": (LITERAL, ord("\\"))
    40|         0|            0|            0|  0.00%|}
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|CATEGORIES = {
    43|         0|            0|            0|  0.00%|    r"\A": (AT, AT_BEGINNING_STRING), # start of string
    44|         0|            0|            0|  0.00%|    r"\b": (AT, AT_BOUNDARY),
    45|         0|            0|            0|  0.00%|    r"\B": (AT, AT_NON_BOUNDARY),
    46|         0|            0|            0|  0.00%|    r"\d": (IN, [(CATEGORY, CATEGORY_DIGIT)]),
    47|         0|            0|            0|  0.00%|    r"\D": (IN, [(CATEGORY, CATEGORY_NOT_DIGIT)]),
    48|         0|            0|            0|  0.00%|    r"\s": (IN, [(CATEGORY, CATEGORY_SPACE)]),
    49|         0|            0|            0|  0.00%|    r"\S": (IN, [(CATEGORY, CATEGORY_NOT_SPACE)]),
    50|         0|            0|            0|  0.00%|    r"\w": (IN, [(CATEGORY, CATEGORY_WORD)]),
    51|         0|            0|            0|  0.00%|    r"\W": (IN, [(CATEGORY, CATEGORY_NOT_WORD)]),
    52|         0|            0|            0|  0.00%|    r"\Z": (AT, AT_END_STRING), # end of string
    53|         0|            0|            0|  0.00%|}
    54|         0|            0|            0|  0.00%|
    55|         0|            0|            0|  0.00%|FLAGS = {
    56|         0|            0|            0|  0.00%|    # standard flags
    57|         0|            0|            0|  0.00%|    "i": SRE_FLAG_IGNORECASE,
    58|         0|            0|            0|  0.00%|    "L": SRE_FLAG_LOCALE,
    59|         0|            0|            0|  0.00%|    "m": SRE_FLAG_MULTILINE,
    60|         0|            0|            0|  0.00%|    "s": SRE_FLAG_DOTALL,
    61|         0|            0|            0|  0.00%|    "x": SRE_FLAG_VERBOSE,
    62|         0|            0|            0|  0.00%|    # extensions
    63|         0|            0|            0|  0.00%|    "a": SRE_FLAG_ASCII,
    64|         0|            0|            0|  0.00%|    "t": SRE_FLAG_TEMPLATE,
    65|         0|            0|            0|  0.00%|    "u": SRE_FLAG_UNICODE,
    66|         0|            0|            0|  0.00%|}
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|TYPE_FLAGS = SRE_FLAG_ASCII | SRE_FLAG_LOCALE | SRE_FLAG_UNICODE
    69|         0|            0|            0|  0.00%|GLOBAL_FLAGS = SRE_FLAG_DEBUG | SRE_FLAG_TEMPLATE
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|# Maximal value returned by SubPattern.getwidth().
    72|         0|            0|            0|  0.00%|# Must be larger than MAXREPEAT, MAXCODE and sys.maxsize.
    73|         0|            0|            0|  0.00%|MAXWIDTH = 1 << 64
    74|         0|            0|            0|  0.00%|
    75|         0|            0|            0|  0.00%|class State:
    76|         0|            0|            0|  0.00%|    # keeps track of state for parsing
    77|         1|   2.6226e-06|   2.6226e-06|  0.00%|    def __init__(self):
    78|         1|  2.14577e-06|  2.14577e-06|  0.00%|        self.flags = 0
    79|         1|  2.38419e-06|  2.38419e-06|  0.00%|        self.groupdict = {}
    80|         1|  7.86781e-06|  7.86781e-06|  0.01%|        self.groupwidths = [None]  # group 0
    81|         1|  1.90735e-06|  1.90735e-06|  0.00%|        self.lookbehindgroups = None
    82|         1|  1.66893e-06|  1.66893e-06|  0.00%|        self.grouprefpos = {}
    83|         4|  7.86781e-06|  1.96695e-06|  0.01%|    @property
    84|         0|            0|            0|  0.00%|    def groups(self):
    85|         4|  7.15256e-06|  1.78814e-06|  0.01%|        return len(self.groupwidths)
    86|         1|  2.07424e-05|  2.07424e-05|  0.02%|    def opengroup(self, name=None):
    87|         1|  8.82149e-06|  8.82149e-06|  0.01%|        gid = self.groups
(call)|         1|  5.00679e-06|  5.00679e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:83 groups
    88|         1|   2.6226e-06|   2.6226e-06|  0.00%|        self.groupwidths.append(None)
    89|         1|  6.67572e-06|  6.67572e-06|  0.01%|        if self.groups > MAXGROUPS:
(call)|         1|  2.38419e-06|  2.38419e-06|  0.00%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:83 groups
    90|         0|            0|            0|  0.00%|            raise error("too many groups")
    91|         1|  1.90735e-06|  1.90735e-06|  0.00%|        if name is not None:
    92|         1|  2.86102e-06|  2.86102e-06|  0.00%|            ogid = self.groupdict.get(name, None)
    93|         1|  2.14577e-06|  2.14577e-06|  0.00%|            if ogid is not None:
    94|         0|            0|            0|  0.00%|                raise error("redefinition of group name %r as group %d; "
    95|         0|            0|            0|  0.00%|                            "was group %d" % (name, gid,  ogid))
    96|         1|  1.90735e-06|  1.90735e-06|  0.00%|            self.groupdict[name] = gid
    97|         1|  4.05312e-06|  4.05312e-06|  0.00%|        return gid
    98|         1|  2.47955e-05|  2.47955e-05|  0.03%|    def closegroup(self, gid, p):
    99|         1|  2.98023e-05|  2.98023e-05|  0.03%|        self.groupwidths[gid] = p.getwidth()
(call)|         1|  0.000162363|  0.000162363|  0.17%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:178 getwidth
   100|         0|            0|            0|  0.00%|    def checkgroup(self, gid):
   101|         0|            0|            0|  0.00%|        return gid < self.groups and self.groupwidths[gid] is not None
   102|         0|            0|            0|  0.00%|
   103|         0|            0|            0|  0.00%|    def checklookbehindgroup(self, gid, source):
   104|         0|            0|            0|  0.00%|        if self.lookbehindgroups is not None:
   105|         0|            0|            0|  0.00%|            if not self.checkgroup(gid):
   106|         0|            0|            0|  0.00%|                raise source.error('cannot refer to an open group')
   107|         0|            0|            0|  0.00%|            if gid >= self.lookbehindgroups:
   108|         0|            0|            0|  0.00%|                raise source.error('cannot refer to group defined in the same '
   109|         0|            0|            0|  0.00%|                                   'lookbehind subpattern')
   110|         0|            0|            0|  0.00%|
   111|         0|            0|            0|  0.00%|class SubPattern:
   112|         0|            0|            0|  0.00%|    # a subpattern, in intermediate form
   113|         3|  3.14713e-05|  1.04904e-05|  0.03%|    def __init__(self, state, data=None):
   114|         3|  4.76837e-06|  1.58946e-06|  0.00%|        self.state = state
   115|         3|  4.05312e-06|  1.35104e-06|  0.00%|        if data is None:
   116|         2|   2.6226e-06|   1.3113e-06|  0.00%|            data = []
   117|         3|  3.57628e-06|  1.19209e-06|  0.00%|        self.data = data
   118|         3|   3.8147e-06|  1.27157e-06|  0.00%|        self.width = None
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|    def dump(self, level=0):
   121|         0|            0|            0|  0.00%|        seqtypes = (tuple, list)
   122|         0|            0|            0|  0.00%|        for op, av in self.data:
   123|         0|            0|            0|  0.00%|            print(level*"  " + str(op), end='')
   124|         0|            0|            0|  0.00%|            if op is IN:
   125|         0|            0|            0|  0.00%|                # member sublanguage
   126|         0|            0|            0|  0.00%|                print()
   127|         0|            0|            0|  0.00%|                for op, a in av:
   128|         0|            0|            0|  0.00%|                    print((level+1)*"  " + str(op), a)
   129|         0|            0|            0|  0.00%|            elif op is BRANCH:
   130|         0|            0|            0|  0.00%|                print()
   131|         0|            0|            0|  0.00%|                for i, a in enumerate(av[1]):
   132|         0|            0|            0|  0.00%|                    if i:
   133|         0|            0|            0|  0.00%|                        print(level*"  " + "OR")
   134|         0|            0|            0|  0.00%|                    a.dump(level+1)
   135|         0|            0|            0|  0.00%|            elif op is GROUPREF_EXISTS:
   136|         0|            0|            0|  0.00%|                condgroup, item_yes, item_no = av
   137|         0|            0|            0|  0.00%|                print('', condgroup)
   138|         0|            0|            0|  0.00%|                item_yes.dump(level+1)
   139|         0|            0|            0|  0.00%|                if item_no:
   140|         0|            0|            0|  0.00%|                    print(level*"  " + "ELSE")
   141|         0|            0|            0|  0.00%|                    item_no.dump(level+1)
   142|         0|            0|            0|  0.00%|            elif isinstance(av, SubPattern):
   143|         0|            0|            0|  0.00%|                print()
   144|         0|            0|            0|  0.00%|                av.dump(level+1)
   145|         0|            0|            0|  0.00%|            elif isinstance(av, seqtypes):
   146|         0|            0|            0|  0.00%|                nl = False
   147|         0|            0|            0|  0.00%|                for a in av:
   148|         0|            0|            0|  0.00%|                    if isinstance(a, SubPattern):
   149|         0|            0|            0|  0.00%|                        if not nl:
   150|         0|            0|            0|  0.00%|                            print()
   151|         0|            0|            0|  0.00%|                        a.dump(level+1)
   152|         0|            0|            0|  0.00%|                        nl = True
   153|         0|            0|            0|  0.00%|                    else:
   154|         0|            0|            0|  0.00%|                        if not nl:
   155|         0|            0|            0|  0.00%|                            print(' ', end='')
   156|         0|            0|            0|  0.00%|                        print(a, end='')
   157|         0|            0|            0|  0.00%|                        nl = False
   158|         0|            0|            0|  0.00%|                if not nl:
   159|         0|            0|            0|  0.00%|                    print()
   160|         0|            0|            0|  0.00%|            else:
   161|         0|            0|            0|  0.00%|                print('', av)
   162|         0|            0|            0|  0.00%|    def __repr__(self):
   163|         0|            0|            0|  0.00%|        return repr(self.data)
   164|         5|  6.31809e-05|  1.26362e-05|  0.06%|    def __len__(self):
   165|         5|  1.14441e-05|  2.28882e-06|  0.01%|        return len(self.data)
   166|         0|            0|            0|  0.00%|    def __delitem__(self, index):
   167|         0|            0|            0|  0.00%|        del self.data[index]
   168|        19|  0.000222445|  1.17076e-05|  0.23%|    def __getitem__(self, index):
   169|        19|  4.76837e-05|  2.50967e-06|  0.05%|        if isinstance(index, slice):
   170|         1|  6.67572e-06|  6.67572e-06|  0.01%|            return SubPattern(self.state, self.data[index])
(call)|         1|  5.96046e-06|  5.96046e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:113 __init__
   171|        18|  3.67165e-05|   2.0398e-06|  0.04%|        return self.data[index]
   172|         1|  1.93119e-05|  1.93119e-05|  0.02%|    def __setitem__(self, index, code):
   173|         1|  2.38419e-06|  2.38419e-06|  0.00%|        self.data[index] = code
   174|         0|            0|            0|  0.00%|    def insert(self, index, code):
   175|         0|            0|            0|  0.00%|        self.data.insert(index, code)
   176|        10|  0.000109911|  1.09911e-05|  0.11%|    def append(self, code):
   177|        10|  1.38283e-05|  1.38283e-06|  0.01%|        self.data.append(code)
   178|         4|  3.55244e-05|  8.88109e-06|  0.04%|    def getwidth(self):
   179|         0|            0|            0|  0.00%|        # determine the width (min, max) for this subpattern
   180|         4|  2.07424e-05|   5.1856e-06|  0.02%|        if self.width is not None:
   181|         1|  2.38419e-06|  2.38419e-06|  0.00%|            return self.width
   182|         3|  1.26362e-05|  4.21206e-06|  0.01%|        lo = hi = 0
   183|        14|  5.55515e-05|  3.96797e-06|  0.06%|        for op, av in self.data:
   184|        11|  3.83854e-05|  3.48958e-06|  0.04%|            if op is BRANCH:
   185|         0|            0|            0|  0.00%|                i = MAXWIDTH
   186|         0|            0|            0|  0.00%|                j = 0
   187|         0|            0|            0|  0.00%|                for av in av[1]:
   188|         0|            0|            0|  0.00%|                    l, h = av.getwidth()
   189|         0|            0|            0|  0.00%|                    i = min(i, l)
   190|         0|            0|            0|  0.00%|                    j = max(j, h)
   191|         0|            0|            0|  0.00%|                lo = lo + i
   192|         0|            0|            0|  0.00%|                hi = hi + j
   193|        11|  4.74453e-05|  4.31321e-06|  0.05%|            elif op is ATOMIC_GROUP:
   194|         0|            0|            0|  0.00%|                i, j = av.getwidth()
   195|         0|            0|            0|  0.00%|                lo = lo + i
   196|         0|            0|            0|  0.00%|                hi = hi + j
   197|        11|  3.74317e-05|  3.40288e-06|  0.04%|            elif op is SUBPATTERN:
   198|         1|  3.09944e-05|  3.09944e-05|  0.03%|                i, j = av[-1].getwidth()
(call)|         1|  9.53674e-06|  9.53674e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:178 getwidth
   199|         1|  1.12057e-05|  1.12057e-05|  0.01%|                lo = lo + i
   200|         1|  5.72205e-06|  5.72205e-06|  0.01%|                hi = hi + j
   201|        10|  3.19481e-05|  3.19481e-06|  0.03%|            elif op in _REPEATCODES:
   202|         1|  2.55108e-05|  2.55108e-05|  0.03%|                i, j = av[2].getwidth()
(call)|         1|  6.03199e-05|  6.03199e-05|  0.06%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:178 getwidth
   203|         1|  4.29153e-06|  4.29153e-06|  0.00%|                lo = lo + i * av[0]
   204|         1|  4.52995e-06|  4.52995e-06|  0.00%|                if av[1] == MAXREPEAT and j:
   205|         1|  4.52995e-06|  4.52995e-06|  0.00%|                    hi = MAXWIDTH
   206|         0|            0|            0|  0.00%|                else:
   207|         0|            0|            0|  0.00%|                    hi = hi + j * av[1]
   208|         9|   2.6226e-05|    2.914e-06|  0.03%|            elif op in _UNITCODES:
   209|         7|  2.16961e-05|  3.09944e-06|  0.02%|                lo = lo + 1
   210|         7|  2.31266e-05|   3.3038e-06|  0.02%|                hi = hi + 1
   211|         2|  5.48363e-06|  2.74181e-06|  0.01%|            elif op is GROUPREF:
   212|         0|            0|            0|  0.00%|                i, j = self.state.groupwidths[av]
   213|         0|            0|            0|  0.00%|                lo = lo + i
   214|         0|            0|            0|  0.00%|                hi = hi + j
   215|         2|  1.00136e-05|  5.00679e-06|  0.01%|            elif op is GROUPREF_EXISTS:
   216|         0|            0|            0|  0.00%|                i, j = av[1].getwidth()
   217|         0|            0|            0|  0.00%|                if av[2] is not None:
   218|         0|            0|            0|  0.00%|                    l, h = av[2].getwidth()
   219|         0|            0|            0|  0.00%|                    i = min(i, l)
   220|         0|            0|            0|  0.00%|                    j = max(j, h)
   221|         0|            0|            0|  0.00%|                else:
   222|         0|            0|            0|  0.00%|                    i = 0
   223|         0|            0|            0|  0.00%|                lo = lo + i
   224|         0|            0|            0|  0.00%|                hi = hi + j
   225|         2|  9.05991e-06|  4.52995e-06|  0.01%|            elif op is SUCCESS:
   226|         0|            0|            0|  0.00%|                break
   227|         3|  1.19209e-05|  3.97364e-06|  0.01%|        self.width = min(lo, MAXWIDTH), min(hi, MAXWIDTH)
   228|         3|  9.05991e-06|  3.01997e-06|  0.01%|        return self.width
   229|         0|            0|            0|  0.00%|
   230|         0|            0|            0|  0.00%|class Tokenizer:
   231|         1|  3.09944e-06|  3.09944e-06|  0.00%|    def __init__(self, string):
   232|         1|  2.38419e-06|  2.38419e-06|  0.00%|        self.istext = isinstance(string, str)
   233|         1|  1.43051e-06|  1.43051e-06|  0.00%|        self.string = string
   234|         1|  2.14577e-06|  2.14577e-06|  0.00%|        if not self.istext:
   235|         0|            0|            0|  0.00%|            string = str(string, 'latin1')
   236|         1|  1.43051e-06|  1.43051e-06|  0.00%|        self.decoded_string = string
   237|         1|  2.14577e-06|  2.14577e-06|  0.00%|        self.index = 0
   238|         1|  1.43051e-06|  1.43051e-06|  0.00%|        self.next = None
   239|         1|  1.21593e-05|  1.21593e-05|  0.01%|        self.__next()
(call)|         1|  2.02656e-05|  2.02656e-05|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:240 __next
   240|        27|  4.62532e-05|  1.71308e-06|  0.05%|    def __next(self):
   241|        27|  3.93391e-05|    1.457e-06|  0.04%|        index = self.index
   242|        27|  3.74317e-05|  1.38636e-06|  0.04%|        try:
   243|        27|  4.14848e-05|  1.53648e-06|  0.04%|            char = self.decoded_string[index]
   244|         1|  1.66893e-06|  1.66893e-06|  0.00%|        except IndexError:
   245|         1|  2.86102e-06|  2.86102e-06|  0.00%|            self.next = None
   246|         1|   2.6226e-06|   2.6226e-06|  0.00%|            return
   247|        26|  3.40939e-05|   1.3113e-06|  0.04%|        if char == "\\":
   248|         0|            0|            0|  0.00%|            index += 1
   249|         0|            0|            0|  0.00%|            try:
   250|         0|            0|            0|  0.00%|                char += self.decoded_string[index]
   251|         0|            0|            0|  0.00%|            except IndexError:
   252|         0|            0|            0|  0.00%|                raise error("bad escape (end of pattern)",
   253|         0|            0|            0|  0.00%|                            self.string, len(self.string) - 1) from None
   254|        26|  3.26633e-05|  1.25628e-06|  0.03%|        self.index = index + 1
   255|        26|  3.26633e-05|  1.25628e-06|  0.03%|        self.next = char
   256|         9|  8.82149e-05|  9.80165e-06|  0.09%|    def match(self, char):
   257|         9|  1.69277e-05|  1.88086e-06|  0.02%|        if char == self.next:
   258|         4|  2.14577e-05|  5.36442e-06|  0.02%|            self.__next()
(call)|         4|  3.86238e-05|  9.65595e-06|  0.04%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:240 __next
   259|         4|  5.48363e-06|  1.37091e-06|  0.01%|            return True
   260|         5|  5.24521e-06|  1.04904e-06|  0.01%|        return False
   261|        14|  0.000148535|  1.06096e-05|  0.15%|    def get(self):
   262|        14|  1.54972e-05|  1.10694e-06|  0.02%|        this = self.next
   263|        14|  6.65188e-05|  4.75134e-06|  0.07%|        self.__next()
(call)|        14|  0.000134706|  9.62189e-06|  0.14%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:240 __next
   264|        14|   1.5974e-05|    1.141e-06|  0.02%|        return this
   265|         0|            0|            0|  0.00%|    def getwhile(self, n, charset):
   266|         0|            0|            0|  0.00%|        result = ''
   267|         0|            0|            0|  0.00%|        for _ in range(n):
   268|         0|            0|            0|  0.00%|            c = self.next
   269|         0|            0|            0|  0.00%|            if c not in charset:
   270|         0|            0|            0|  0.00%|                break
   271|         0|            0|            0|  0.00%|            result += c
   272|         0|            0|            0|  0.00%|            self.__next()
   273|         0|            0|            0|  0.00%|        return result
   274|         1|    0.0636938|    0.0636938| 65.48%|    def getuntil(self, terminator, name):
   275|         1|  1.85966e-05|  1.85966e-05|  0.02%|        result = ''
   276|         8|  1.33514e-05|  1.66893e-06|  0.01%|        while True:
   277|         8|  1.16825e-05|  1.46031e-06|  0.01%|            c = self.next
   278|         8|  5.57899e-05|  6.97374e-06|  0.06%|            self.__next()
(call)|         8|   7.7486e-05|  9.68575e-06|  0.08%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:240 __next
   279|         8|  1.23978e-05|  1.54972e-06|  0.01%|            if c is None:
   280|         0|            0|            0|  0.00%|                if not result:
   281|         0|            0|            0|  0.00%|                    raise self.error("missing " + name)
   282|         0|            0|            0|  0.00%|                raise self.error("missing %s, unterminated name" % terminator,
   283|         0|            0|            0|  0.00%|                                 len(result))
   284|         8|  1.09673e-05|  1.37091e-06|  0.01%|            if c == terminator:
   285|         1|  1.43051e-06|  1.43051e-06|  0.00%|                if not result:
   286|         0|            0|            0|  0.00%|                    raise self.error("missing " + name, 1)
   287|         1|  2.38419e-06|  2.38419e-06|  0.00%|                break
   288|         7|  9.29832e-06|  1.32833e-06|  0.01%|            result += c
   289|         1|  2.38419e-06|  2.38419e-06|  0.00%|        return result
   290|         0|            0|            0|  0.00%|    @property
   291|         0|            0|            0|  0.00%|    def pos(self):
   292|         0|            0|            0|  0.00%|        return self.index - len(self.next or '')
   293|         5|  4.50611e-05|  9.01222e-06|  0.05%|    def tell(self):
   294|         5|  7.39098e-06|   1.4782e-06|  0.01%|        return self.index - len(self.next or '')
   295|         0|            0|            0|  0.00%|    def seek(self, index):
   296|         0|            0|            0|  0.00%|        self.index = index
   297|         0|            0|            0|  0.00%|        self.__next()
   298|         0|            0|            0|  0.00%|
   299|         0|            0|            0|  0.00%|    def error(self, msg, offset=0):
   300|         0|            0|            0|  0.00%|        if not self.istext:
   301|         0|            0|            0|  0.00%|            msg = msg.encode('ascii', 'backslashreplace').decode('ascii')
   302|         0|            0|            0|  0.00%|        return error(msg, self.string, self.tell() - offset)
   303|         0|            0|            0|  0.00%|
   304|         1|  2.07424e-05|  2.07424e-05|  0.02%|    def checkgroupname(self, name, offset):
   305|         1|  2.38419e-06|  2.38419e-06|  0.00%|        if not (self.istext or name.isascii()):
   306|         0|            0|            0|  0.00%|            msg = "bad character in group name %a" % name
   307|         0|            0|            0|  0.00%|            raise self.error(msg, len(name) + offset)
   308|         1|  3.09944e-06|  3.09944e-06|  0.00%|        if not name.isidentifier():
   309|         0|            0|            0|  0.00%|            msg = "bad character in group name %r" % name
   310|         0|            0|            0|  0.00%|            raise self.error(msg, len(name) + offset)
   311|         0|            0|            0|  0.00%|
   312|         0|            0|            0|  0.00%|def _class_escape(source, escape):
   313|         0|            0|            0|  0.00%|    # handle escape code inside character class
   314|         0|            0|            0|  0.00%|    code = ESCAPES.get(escape)
   315|         0|            0|            0|  0.00%|    if code:
   316|         0|            0|            0|  0.00%|        return code
   317|         0|            0|            0|  0.00%|    code = CATEGORIES.get(escape)
   318|         0|            0|            0|  0.00%|    if code and code[0] is IN:
   319|         0|            0|            0|  0.00%|        return code
   320|         0|            0|            0|  0.00%|    try:
   321|         0|            0|            0|  0.00%|        c = escape[1:2]
   322|         0|            0|            0|  0.00%|        if c == "x":
   323|         0|            0|            0|  0.00%|            # hexadecimal escape (exactly two digits)
   324|         0|            0|            0|  0.00%|            escape += source.getwhile(2, HEXDIGITS)
   325|         0|            0|            0|  0.00%|            if len(escape) != 4:
   326|         0|            0|            0|  0.00%|                raise source.error("incomplete escape %s" % escape, len(escape))
   327|         0|            0|            0|  0.00%|            return LITERAL, int(escape[2:], 16)
   328|         0|            0|            0|  0.00%|        elif c == "u" and source.istext:
   329|         0|            0|            0|  0.00%|            # unicode escape (exactly four digits)
   330|         0|            0|            0|  0.00%|            escape += source.getwhile(4, HEXDIGITS)
   331|         0|            0|            0|  0.00%|            if len(escape) != 6:
   332|         0|            0|            0|  0.00%|                raise source.error("incomplete escape %s" % escape, len(escape))
   333|         0|            0|            0|  0.00%|            return LITERAL, int(escape[2:], 16)
   334|         0|            0|            0|  0.00%|        elif c == "U" and source.istext:
   335|         0|            0|            0|  0.00%|            # unicode escape (exactly eight digits)
   336|         0|            0|            0|  0.00%|            escape += source.getwhile(8, HEXDIGITS)
   337|         0|            0|            0|  0.00%|            if len(escape) != 10:
   338|         0|            0|            0|  0.00%|                raise source.error("incomplete escape %s" % escape, len(escape))
   339|         0|            0|            0|  0.00%|            c = int(escape[2:], 16)
   340|         0|            0|            0|  0.00%|            chr(c) # raise ValueError for invalid code
   341|         0|            0|            0|  0.00%|            return LITERAL, c
   342|         0|            0|            0|  0.00%|        elif c == "N" and source.istext:
   343|         0|            0|            0|  0.00%|            import unicodedata
   344|         0|            0|            0|  0.00%|            # named unicode escape e.g. \N{EM DASH}
   345|         0|            0|            0|  0.00%|            if not source.match('{'):
   346|         0|            0|            0|  0.00%|                raise source.error("missing {")
   347|         0|            0|            0|  0.00%|            charname = source.getuntil('}', 'character name')
   348|         0|            0|            0|  0.00%|            try:
   349|         0|            0|            0|  0.00%|                c = ord(unicodedata.lookup(charname))
   350|         0|            0|            0|  0.00%|            except (KeyError, TypeError):
   351|         0|            0|            0|  0.00%|                raise source.error("undefined character name %r" % charname,
   352|         0|            0|            0|  0.00%|                                   len(charname) + len(r'\N{}')) from None
   353|         0|            0|            0|  0.00%|            return LITERAL, c
   354|         0|            0|            0|  0.00%|        elif c in OCTDIGITS:
   355|         0|            0|            0|  0.00%|            # octal escape (up to three digits)
   356|         0|            0|            0|  0.00%|            escape += source.getwhile(2, OCTDIGITS)
   357|         0|            0|            0|  0.00%|            c = int(escape[1:], 8)
   358|         0|            0|            0|  0.00%|            if c > 0o377:
   359|         0|            0|            0|  0.00%|                raise source.error('octal escape value %s outside of '
   360|         0|            0|            0|  0.00%|                                   'range 0-0o377' % escape, len(escape))
   361|         0|            0|            0|  0.00%|            return LITERAL, c
   362|         0|            0|            0|  0.00%|        elif c in DIGITS:
   363|         0|            0|            0|  0.00%|            raise ValueError
   364|         0|            0|            0|  0.00%|        if len(escape) == 2:
   365|         0|            0|            0|  0.00%|            if c in ASCIILETTERS:
   366|         0|            0|            0|  0.00%|                raise source.error('bad escape %s' % escape, len(escape))
   367|         0|            0|            0|  0.00%|            return LITERAL, ord(escape[1])
   368|         0|            0|            0|  0.00%|    except ValueError:
   369|         0|            0|            0|  0.00%|        pass
   370|         0|            0|            0|  0.00%|    raise source.error("bad escape %s" % escape, len(escape))
   371|         0|            0|            0|  0.00%|
   372|         0|            0|            0|  0.00%|def _escape(source, escape, state):
   373|         0|            0|            0|  0.00%|    # handle escape code in expression
   374|         0|            0|            0|  0.00%|    code = CATEGORIES.get(escape)
   375|         0|            0|            0|  0.00%|    if code:
   376|         0|            0|            0|  0.00%|        return code
   377|         0|            0|            0|  0.00%|    code = ESCAPES.get(escape)
   378|         0|            0|            0|  0.00%|    if code:
   379|         0|            0|            0|  0.00%|        return code
   380|         0|            0|            0|  0.00%|    try:
   381|         0|            0|            0|  0.00%|        c = escape[1:2]
   382|         0|            0|            0|  0.00%|        if c == "x":
   383|         0|            0|            0|  0.00%|            # hexadecimal escape
   384|         0|            0|            0|  0.00%|            escape += source.getwhile(2, HEXDIGITS)
   385|         0|            0|            0|  0.00%|            if len(escape) != 4:
   386|         0|            0|            0|  0.00%|                raise source.error("incomplete escape %s" % escape, len(escape))
   387|         0|            0|            0|  0.00%|            return LITERAL, int(escape[2:], 16)
   388|         0|            0|            0|  0.00%|        elif c == "u" and source.istext:
   389|         0|            0|            0|  0.00%|            # unicode escape (exactly four digits)
   390|         0|            0|            0|  0.00%|            escape += source.getwhile(4, HEXDIGITS)
   391|         0|            0|            0|  0.00%|            if len(escape) != 6:
   392|         0|            0|            0|  0.00%|                raise source.error("incomplete escape %s" % escape, len(escape))
   393|         0|            0|            0|  0.00%|            return LITERAL, int(escape[2:], 16)
   394|         0|            0|            0|  0.00%|        elif c == "U" and source.istext:
   395|         0|            0|            0|  0.00%|            # unicode escape (exactly eight digits)
   396|         0|            0|            0|  0.00%|            escape += source.getwhile(8, HEXDIGITS)
   397|         0|            0|            0|  0.00%|            if len(escape) != 10:
   398|         0|            0|            0|  0.00%|                raise source.error("incomplete escape %s" % escape, len(escape))
   399|         0|            0|            0|  0.00%|            c = int(escape[2:], 16)
   400|         0|            0|            0|  0.00%|            chr(c) # raise ValueError for invalid code
   401|         0|            0|            0|  0.00%|            return LITERAL, c
   402|         0|            0|            0|  0.00%|        elif c == "N" and source.istext:
   403|         0|            0|            0|  0.00%|            import unicodedata
   404|         0|            0|            0|  0.00%|            # named unicode escape e.g. \N{EM DASH}
   405|         0|            0|            0|  0.00%|            if not source.match('{'):
   406|         0|            0|            0|  0.00%|                raise source.error("missing {")
   407|         0|            0|            0|  0.00%|            charname = source.getuntil('}', 'character name')
   408|         0|            0|            0|  0.00%|            try:
   409|         0|            0|            0|  0.00%|                c = ord(unicodedata.lookup(charname))
   410|         0|            0|            0|  0.00%|            except (KeyError, TypeError):
   411|         0|            0|            0|  0.00%|                raise source.error("undefined character name %r" % charname,
   412|         0|            0|            0|  0.00%|                                   len(charname) + len(r'\N{}')) from None
   413|         0|            0|            0|  0.00%|            return LITERAL, c
   414|         0|            0|            0|  0.00%|        elif c == "0":
   415|         0|            0|            0|  0.00%|            # octal escape
   416|         0|            0|            0|  0.00%|            escape += source.getwhile(2, OCTDIGITS)
   417|         0|            0|            0|  0.00%|            return LITERAL, int(escape[1:], 8)
   418|         0|            0|            0|  0.00%|        elif c in DIGITS:
   419|         0|            0|            0|  0.00%|            # octal escape *or* decimal group reference (sigh)
   420|         0|            0|            0|  0.00%|            if source.next in DIGITS:
   421|         0|            0|            0|  0.00%|                escape += source.get()
   422|         0|            0|            0|  0.00%|                if (escape[1] in OCTDIGITS and escape[2] in OCTDIGITS and
   423|         0|            0|            0|  0.00%|                    source.next in OCTDIGITS):
   424|         0|            0|            0|  0.00%|                    # got three octal digits; this is an octal escape
   425|         0|            0|            0|  0.00%|                    escape += source.get()
   426|         0|            0|            0|  0.00%|                    c = int(escape[1:], 8)
   427|         0|            0|            0|  0.00%|                    if c > 0o377:
   428|         0|            0|            0|  0.00%|                        raise source.error('octal escape value %s outside of '
   429|         0|            0|            0|  0.00%|                                           'range 0-0o377' % escape,
   430|         0|            0|            0|  0.00%|                                           len(escape))
   431|         0|            0|            0|  0.00%|                    return LITERAL, c
   432|         0|            0|            0|  0.00%|            # not an octal escape, so this is a group reference
   433|         0|            0|            0|  0.00%|            group = int(escape[1:])
   434|         0|            0|            0|  0.00%|            if group < state.groups:
   435|         0|            0|            0|  0.00%|                if not state.checkgroup(group):
   436|         0|            0|            0|  0.00%|                    raise source.error("cannot refer to an open group",
   437|         0|            0|            0|  0.00%|                                       len(escape))
   438|         0|            0|            0|  0.00%|                state.checklookbehindgroup(group, source)
   439|         0|            0|            0|  0.00%|                return GROUPREF, group
   440|         0|            0|            0|  0.00%|            raise source.error("invalid group reference %d" % group, len(escape) - 1)
   441|         0|            0|            0|  0.00%|        if len(escape) == 2:
   442|         0|            0|            0|  0.00%|            if c in ASCIILETTERS:
   443|         0|            0|            0|  0.00%|                raise source.error("bad escape %s" % escape, len(escape))
   444|         0|            0|            0|  0.00%|            return LITERAL, ord(escape[1])
   445|         0|            0|            0|  0.00%|    except ValueError:
   446|         0|            0|            0|  0.00%|        pass
   447|         0|            0|            0|  0.00%|    raise source.error("bad escape %s" % escape, len(escape))
   448|         0|            0|            0|  0.00%|
   449|         1|  1.90735e-05|  1.90735e-05|  0.02%|def _uniq(items):
   450|         1|  5.48363e-06|  5.48363e-06|  0.01%|    return list(dict.fromkeys(items))
   451|         0|            0|            0|  0.00%|
   452|         2|  2.76566e-05|  1.38283e-05|  0.03%|def _parse_sub(source, state, verbose, nested):
   453|         0|            0|            0|  0.00%|    # parse an alternation: a|b|c
   454|         0|            0|            0|  0.00%|
   455|         2|  8.34465e-06|  4.17233e-06|  0.01%|    items = []
   456|         2|  5.72205e-06|  2.86102e-06|  0.01%|    itemsappend = items.append
   457|         2|  7.86781e-06|  3.93391e-06|  0.01%|    sourcematch = source.match
   458|         2|  1.88351e-05|  9.41753e-06|  0.02%|    start = source.tell()
(call)|         2|  9.53674e-06|  4.76837e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:293 tell
   459|         2|  7.62939e-06|   3.8147e-06|  0.01%|    while True:
   460|         4|  0.000185728|   4.6432e-05|  0.19%|        itemsappend(_parse(source, state, verbose, nested + 1,
(call)|         2|    0.0717409|    0.0358704| 73.75%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:512 _parse
   461|         2|  5.48363e-06|  2.74181e-06|  0.01%|                           not nested and not items))
   462|         2|  1.83582e-05|  9.17912e-06|  0.02%|        if not sourcematch("|"):
(call)|         2|  1.23978e-05|  6.19888e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:256 match
   463|         2|  1.52588e-05|  7.62939e-06|  0.02%|            break
   464|         0|            0|            0|  0.00%|        if not nested:
   465|         0|            0|            0|  0.00%|            verbose = state.flags & SRE_FLAG_VERBOSE
   466|         0|            0|            0|  0.00%|
   467|         2|  6.91414e-06|  3.45707e-06|  0.01%|    if len(items) == 1:
   468|         2|  5.72205e-06|  2.86102e-06|  0.01%|        return items[0]
   469|         0|            0|            0|  0.00%|
   470|         0|            0|            0|  0.00%|    subpattern = SubPattern(state)
   471|         0|            0|            0|  0.00%|
   472|         0|            0|            0|  0.00%|    # check if all items share a common prefix
   473|         0|            0|            0|  0.00%|    while True:
   474|         0|            0|            0|  0.00%|        prefix = None
   475|         0|            0|            0|  0.00%|        for item in items:
   476|         0|            0|            0|  0.00%|            if not item:
   477|         0|            0|            0|  0.00%|                break
   478|         0|            0|            0|  0.00%|            if prefix is None:
   479|         0|            0|            0|  0.00%|                prefix = item[0]
   480|         0|            0|            0|  0.00%|            elif item[0] != prefix:
   481|         0|            0|            0|  0.00%|                break
   482|         0|            0|            0|  0.00%|        else:
   483|         0|            0|            0|  0.00%|            # all subitems start with a common "prefix".
   484|         0|            0|            0|  0.00%|            # move it out of the branch
   485|         0|            0|            0|  0.00%|            for item in items:
   486|         0|            0|            0|  0.00%|                del item[0]
   487|         0|            0|            0|  0.00%|            subpattern.append(prefix)
   488|         0|            0|            0|  0.00%|            continue # check next one
   489|         0|            0|            0|  0.00%|        break
   490|         0|            0|            0|  0.00%|
   491|         0|            0|            0|  0.00%|    # check if the branch can be replaced by a character set
   492|         0|            0|            0|  0.00%|    set = []
   493|         0|            0|            0|  0.00%|    for item in items:
   494|         0|            0|            0|  0.00%|        if len(item) != 1:
   495|         0|            0|            0|  0.00%|            break
   496|         0|            0|            0|  0.00%|        op, av = item[0]
   497|         0|            0|            0|  0.00%|        if op is LITERAL:
   498|         0|            0|            0|  0.00%|            set.append((op, av))
   499|         0|            0|            0|  0.00%|        elif op is IN and av[0][0] is not NEGATE:
   500|         0|            0|            0|  0.00%|            set.extend(av)
   501|         0|            0|            0|  0.00%|        else:
   502|         0|            0|            0|  0.00%|            break
   503|         0|            0|            0|  0.00%|    else:
   504|         0|            0|            0|  0.00%|        # we can store this as a character set instead of a
   505|         0|            0|            0|  0.00%|        # branch (the compiler may optimize this even more)
   506|         0|            0|            0|  0.00%|        subpattern.append((IN, _uniq(set)))
   507|         0|            0|            0|  0.00%|        return subpattern
   508|         0|            0|            0|  0.00%|
   509|         0|            0|            0|  0.00%|    subpattern.append((BRANCH, (None, items)))
   510|         0|            0|            0|  0.00%|    return subpattern
   511|         0|            0|            0|  0.00%|
   512|         2|  4.00543e-05|  2.00272e-05|  0.04%|def _parse(source, state, verbose, nested, first=False):
   513|         0|            0|            0|  0.00%|    # parse a simple pattern
   514|         2|   8.4877e-05|  4.24385e-05|  0.09%|    subpattern = SubPattern(state)
(call)|         2|  4.43459e-05|  2.21729e-05|  0.05%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:113 __init__
   515|         0|            0|            0|  0.00%|
   516|         0|            0|            0|  0.00%|    # precompute constants into local variables
   517|         2|  2.93255e-05|  1.46627e-05|  0.03%|    subpatternappend = subpattern.append
   518|         2|  2.90871e-05|  1.45435e-05|  0.03%|    sourceget = source.get
   519|         2|  3.12328e-05|  1.56164e-05|  0.03%|    sourcematch = source.match
   520|         2|  3.43323e-05|  1.71661e-05|  0.04%|    _len = len
   521|         2|  2.98023e-05|  1.49012e-05|  0.03%|    _ord = ord
   522|         0|            0|            0|  0.00%|
   523|        13|  0.000339031|  2.60793e-05|  0.35%|    while True:
   524|         0|            0|            0|  0.00%|
   525|        13|  0.000150442|  1.15725e-05|  0.15%|        this = source.next
   526|        13|  0.000141621|  1.08939e-05|  0.15%|        if this is None:
   527|         1|  2.07424e-05|  2.07424e-05|  0.02%|            break # end of pattern
   528|        12|  0.000128984|  1.07487e-05|  0.13%|        if this in "|)":
   529|         1|  1.69277e-05|  1.69277e-05|  0.02%|            break # end of subpattern
   530|        11|  0.000353336|  3.21215e-05|  0.36%|        sourceget()
(call)|        11|  0.000305176|  2.77433e-05|  0.31%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:261 get
   531|         0|            0|            0|  0.00%|
   532|        11|  0.000117302|  1.06638e-05|  0.12%|        if verbose:
   533|         0|            0|            0|  0.00%|            # skip whitespace and comments
   534|         0|            0|            0|  0.00%|            if this in WHITESPACE:
   535|         0|            0|            0|  0.00%|                continue
   536|         0|            0|            0|  0.00%|            if this == "#":
   537|         0|            0|            0|  0.00%|                while True:
   538|         0|            0|            0|  0.00%|                    this = sourceget()
   539|         0|            0|            0|  0.00%|                    if this is None or this == "\n":
   540|         0|            0|            0|  0.00%|                        break
   541|         0|            0|            0|  0.00%|                continue
   542|         0|            0|            0|  0.00%|
   543|        11|  0.000124931|  1.13574e-05|  0.13%|        if this[0] == "\\":
   544|         0|            0|            0|  0.00%|            code = _escape(source, this, state)
   545|         0|            0|            0|  0.00%|            subpatternappend(code)
   546|         0|            0|            0|  0.00%|
   547|        11|  0.000123978|  1.12707e-05|  0.13%|        elif this not in SPECIAL_CHARS:
   548|         6|  0.000232697|  3.87828e-05|  0.24%|            subpatternappend((LITERAL, _ord(this)))
(call)|         6|   6.4373e-05|  1.07288e-05|  0.07%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:176 append
   549|         0|            0|            0|  0.00%|
   550|         5|  5.88894e-05|  1.17779e-05|  0.06%|        elif this == "[":
   551|         1|  4.00543e-05|  4.00543e-05|  0.04%|            here = source.tell() - 1
(call)|         1|  1.09673e-05|  1.09673e-05|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:293 tell
   552|         0|            0|            0|  0.00%|            # character set
   553|         1|  1.97887e-05|  1.97887e-05|  0.02%|            set = []
   554|         1|  1.95503e-05|  1.95503e-05|  0.02%|            setappend = set.append
   555|         0|            0|            0|  0.00%|##          if sourcematch(":"):
   556|         0|            0|            0|  0.00%|##              pass # handle character classes
   557|         1|  1.95503e-05|  1.95503e-05|  0.02%|            if source.next == '[':
   558|         0|            0|            0|  0.00%|                import warnings
   559|         0|            0|            0|  0.00%|                warnings.warn(
   560|         0|            0|            0|  0.00%|                    'Possible nested set at position %d' % source.tell(),
   561|         0|            0|            0|  0.00%|                    FutureWarning, stacklevel=nested + 6
   562|         0|            0|            0|  0.00%|                )
   563|         1|  5.55515e-05|  5.55515e-05|  0.06%|            negate = sourcematch("^")
(call)|         1|   2.7895e-05|   2.7895e-05|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:256 match
   564|         0|            0|            0|  0.00%|            # check remaining characters
   565|         2|  3.88622e-05|  1.94311e-05|  0.04%|            while True:
   566|         2|  8.01086e-05|  4.00543e-05|  0.08%|                this = sourceget()
(call)|         2|  5.03063e-05|  2.51532e-05|  0.05%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:261 get
   567|         2|  2.90871e-05|  1.45435e-05|  0.03%|                if this is None:
   568|         0|            0|            0|  0.00%|                    raise source.error("unterminated character set",
   569|         0|            0|            0|  0.00%|                                       source.tell() - here)
   570|         2|  2.95639e-05|   1.4782e-05|  0.03%|                if this == "]" and set:
   571|         1|  1.00136e-05|  1.00136e-05|  0.01%|                    break
   572|         1|  1.95503e-05|  1.95503e-05|  0.02%|                elif this[0] == "\\":
   573|         0|            0|            0|  0.00%|                    code1 = _class_escape(source, this)
   574|         0|            0|            0|  0.00%|                else:
   575|         1|  1.90735e-05|  1.90735e-05|  0.02%|                    if set and this in '-&~|' and source.next == this:
   576|         0|            0|            0|  0.00%|                        import warnings
   577|         0|            0|            0|  0.00%|                        warnings.warn(
   578|         0|            0|            0|  0.00%|                            'Possible set %s at position %d' % (
   579|         0|            0|            0|  0.00%|                                'difference' if this == '-' else
   580|         0|            0|            0|  0.00%|                                'intersection' if this == '&' else
   581|         0|            0|            0|  0.00%|                                'symmetric difference' if this == '~' else
   582|         0|            0|            0|  0.00%|                                'union',
   583|         0|            0|            0|  0.00%|                                source.tell() - 1),
   584|         0|            0|            0|  0.00%|                            FutureWarning, stacklevel=nested + 6
   585|         0|            0|            0|  0.00%|                        )
   586|         1|  1.95503e-05|  1.95503e-05|  0.02%|                    code1 = LITERAL, _ord(this)
   587|         1|  5.34058e-05|  5.34058e-05|  0.05%|                if sourcematch("-"):
(call)|         1|  1.45435e-05|  1.45435e-05|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:256 match
   588|         0|            0|            0|  0.00%|                    # potential range
   589|         0|            0|            0|  0.00%|                    that = sourceget()
   590|         0|            0|            0|  0.00%|                    if that is None:
   591|         0|            0|            0|  0.00%|                        raise source.error("unterminated character set",
   592|         0|            0|            0|  0.00%|                                           source.tell() - here)
   593|         0|            0|            0|  0.00%|                    if that == "]":
   594|         0|            0|            0|  0.00%|                        if code1[0] is IN:
   595|         0|            0|            0|  0.00%|                            code1 = code1[1][0]
   596|         0|            0|            0|  0.00%|                        setappend(code1)
   597|         0|            0|            0|  0.00%|                        setappend((LITERAL, _ord("-")))
   598|         0|            0|            0|  0.00%|                        break
   599|         0|            0|            0|  0.00%|                    if that[0] == "\\":
   600|         0|            0|            0|  0.00%|                        code2 = _class_escape(source, that)
   601|         0|            0|            0|  0.00%|                    else:
   602|         0|            0|            0|  0.00%|                        if that == '-':
   603|         0|            0|            0|  0.00%|                            import warnings
   604|         0|            0|            0|  0.00%|                            warnings.warn(
   605|         0|            0|            0|  0.00%|                                'Possible set difference at position %d' % (
   606|         0|            0|            0|  0.00%|                                    source.tell() - 2),
   607|         0|            0|            0|  0.00%|                                FutureWarning, stacklevel=nested + 6
   608|         0|            0|            0|  0.00%|                            )
   609|         0|            0|            0|  0.00%|                        code2 = LITERAL, _ord(that)
   610|         0|            0|            0|  0.00%|                    if code1[0] != LITERAL or code2[0] != LITERAL:
   611|         0|            0|            0|  0.00%|                        msg = "bad character range %s-%s" % (this, that)
   612|         0|            0|            0|  0.00%|                        raise source.error(msg, len(this) + 1 + len(that))
   613|         0|            0|            0|  0.00%|                    lo = code1[1]
   614|         0|            0|            0|  0.00%|                    hi = code2[1]
   615|         0|            0|            0|  0.00%|                    if hi < lo:
   616|         0|            0|            0|  0.00%|                        msg = "bad character range %s-%s" % (this, that)
   617|         0|            0|            0|  0.00%|                        raise source.error(msg, len(this) + 1 + len(that))
   618|         0|            0|            0|  0.00%|                    setappend((RANGE, (lo, hi)))
   619|         0|            0|            0|  0.00%|                else:
   620|         1|  1.97887e-05|  1.97887e-05|  0.02%|                    if code1[0] is IN:
   621|         0|            0|            0|  0.00%|                        code1 = code1[1][0]
   622|         1|  1.95503e-05|  1.95503e-05|  0.02%|                    setappend(code1)
   623|         0|            0|            0|  0.00%|
   624|         1|  5.34058e-05|  5.34058e-05|  0.05%|            set = _uniq(set)
(call)|         1|  2.45571e-05|  2.45571e-05|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:449 _uniq
   625|         0|            0|            0|  0.00%|            # XXX: <fl> should move set optimization to compiler!
   626|         1|  2.00272e-05|  2.00272e-05|  0.02%|            if _len(set) == 1 and set[0][0] is LITERAL:
   627|         0|            0|            0|  0.00%|                # optimization
   628|         1|  1.90735e-05|  1.90735e-05|  0.02%|                if negate:
   629|         1|  5.96046e-05|  5.96046e-05|  0.06%|                    subpatternappend((NOT_LITERAL, set[0][1]))
(call)|         1|  1.12057e-05|  1.12057e-05|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:176 append
   630|         0|            0|            0|  0.00%|                else:
   631|         0|            0|            0|  0.00%|                    subpatternappend(set[0])
   632|         0|            0|            0|  0.00%|            else:
   633|         0|            0|            0|  0.00%|                if negate:
   634|         0|            0|            0|  0.00%|                    set.insert(0, (NEGATE, None))
   635|         0|            0|            0|  0.00%|                # charmap optimization can't be added here because
   636|         0|            0|            0|  0.00%|                # global flags still are not known
   637|         0|            0|            0|  0.00%|                subpatternappend((IN, set))
   638|         0|            0|            0|  0.00%|
   639|         4|  4.95911e-05|  1.23978e-05|  0.05%|        elif this in REPEAT_CHARS:
   640|         0|            0|            0|  0.00%|            # repeat previous item
   641|         1|  4.14848e-05|  4.14848e-05|  0.04%|            here = source.tell()
(call)|         1|  1.12057e-05|  1.12057e-05|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:293 tell
   642|         1|  2.16961e-05|  2.16961e-05|  0.02%|            if this == "?":
   643|         0|            0|            0|  0.00%|                min, max = 0, 1
   644|         1|  1.95503e-05|  1.95503e-05|  0.02%|            elif this == "*":
   645|         0|            0|            0|  0.00%|                min, max = 0, MAXREPEAT
   646|         0|            0|            0|  0.00%|
   647|         1|  1.90735e-05|  1.90735e-05|  0.02%|            elif this == "+":
   648|         1|  1.95503e-05|  1.95503e-05|  0.02%|                min, max = 1, MAXREPEAT
   649|         0|            0|            0|  0.00%|            elif this == "{":
   650|         0|            0|            0|  0.00%|                if source.next == "}":
   651|         0|            0|            0|  0.00%|                    subpatternappend((LITERAL, _ord(this)))
   652|         0|            0|            0|  0.00%|                    continue
   653|         0|            0|            0|  0.00%|
   654|         0|            0|            0|  0.00%|                min, max = 0, MAXREPEAT
   655|         0|            0|            0|  0.00%|                lo = hi = ""
   656|         0|            0|            0|  0.00%|                while source.next in DIGITS:
   657|         0|            0|            0|  0.00%|                    lo += sourceget()
   658|         0|            0|            0|  0.00%|                if sourcematch(","):
   659|         0|            0|            0|  0.00%|                    while source.next in DIGITS:
   660|         0|            0|            0|  0.00%|                        hi += sourceget()
   661|         0|            0|            0|  0.00%|                else:
   662|         0|            0|            0|  0.00%|                    hi = lo
   663|         0|            0|            0|  0.00%|                if not sourcematch("}"):
   664|         0|            0|            0|  0.00%|                    subpatternappend((LITERAL, _ord(this)))
   665|         0|            0|            0|  0.00%|                    source.seek(here)
   666|         0|            0|            0|  0.00%|                    continue
   667|         0|            0|            0|  0.00%|
   668|         0|            0|            0|  0.00%|                if lo:
   669|         0|            0|            0|  0.00%|                    min = int(lo)
   670|         0|            0|            0|  0.00%|                    if min >= MAXREPEAT:
   671|         0|            0|            0|  0.00%|                        raise OverflowError("the repetition number is too large")
   672|         0|            0|            0|  0.00%|                if hi:
   673|         0|            0|            0|  0.00%|                    max = int(hi)
   674|         0|            0|            0|  0.00%|                    if max >= MAXREPEAT:
   675|         0|            0|            0|  0.00%|                        raise OverflowError("the repetition number is too large")
   676|         0|            0|            0|  0.00%|                    if max < min:
   677|         0|            0|            0|  0.00%|                        raise source.error("min repeat greater than max repeat",
   678|         0|            0|            0|  0.00%|                                           source.tell() - here)
   679|         0|            0|            0|  0.00%|            else:
   680|         0|            0|            0|  0.00%|                raise AssertionError("unsupported quantifier %r" % (char,))
   681|         0|            0|            0|  0.00%|            # figure out which item to repeat
   682|         1|  5.43594e-05|  5.43594e-05|  0.06%|            if subpattern:
(call)|         1|  2.67029e-05|  2.67029e-05|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:164 __len__
   683|         1|  5.53131e-05|  5.53131e-05|  0.06%|                item = subpattern[-1:]
(call)|         1|  3.79086e-05|  3.79086e-05|  0.04%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:168 __getitem__
   684|         0|            0|            0|  0.00%|            else:
   685|         0|            0|            0|  0.00%|                item = None
   686|         1|  8.58307e-05|  8.58307e-05|  0.09%|            if not item or item[0][0] is AT:
(call)|         1|  1.12057e-05|  1.12057e-05|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:164 __len__
(call)|         1|  1.28746e-05|  1.28746e-05|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:168 __getitem__
   687|         0|            0|            0|  0.00%|                raise source.error("nothing to repeat",
   688|         0|            0|            0|  0.00%|                                   source.tell() - here + len(this))
   689|         1|  5.43594e-05|  5.43594e-05|  0.06%|            if item[0][0] in _REPEATCODES:
(call)|         1|  1.21593e-05|  1.21593e-05|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:168 __getitem__
   690|         0|            0|            0|  0.00%|                raise source.error("multiple repeat",
   691|         0|            0|            0|  0.00%|                                   source.tell() - here + len(this))
   692|         1|  5.17368e-05|  5.17368e-05|  0.05%|            if item[0][0] is SUBPATTERN:
(call)|         1|  1.21593e-05|  1.21593e-05|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:168 __getitem__
   693|         0|            0|            0|  0.00%|                group, add_flags, del_flags, p = item[0][1]
   694|         0|            0|            0|  0.00%|                if group is None and not add_flags and not del_flags:
   695|         0|            0|            0|  0.00%|                    item = p
   696|         1|  5.17368e-05|  5.17368e-05|  0.05%|            if sourcematch("?"):
(call)|         1|  1.23978e-05|  1.23978e-05|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:256 match
   697|         0|            0|            0|  0.00%|                # Non-Greedy Match
   698|         0|            0|            0|  0.00%|                subpattern[-1] = (MIN_REPEAT, (min, max, item))
   699|         1|  5.14984e-05|  5.14984e-05|  0.05%|            elif sourcematch("+"):
(call)|         1|  1.21593e-05|  1.21593e-05|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:256 match
   700|         0|            0|            0|  0.00%|                # Possessive Match (Always Greedy)
   701|         0|            0|            0|  0.00%|                subpattern[-1] = (POSSESSIVE_REPEAT, (min, max, item))
   702|         0|            0|            0|  0.00%|            else:
   703|         0|            0|            0|  0.00%|                # Greedy Match
   704|         1|  6.46114e-05|  6.46114e-05|  0.07%|                subpattern[-1] = (MAX_REPEAT, (min, max, item))
(call)|         1|  2.16961e-05|  2.16961e-05|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:172 __setitem__
   705|         0|            0|            0|  0.00%|
   706|         3|  3.93391e-05|   1.3113e-05|  0.04%|        elif this == ".":
   707|         0|            0|            0|  0.00%|            subpatternappend((ANY, None))
   708|         0|            0|            0|  0.00%|
   709|         3|  5.93662e-05|  1.97887e-05|  0.06%|        elif this == "(":
   710|         1|  4.26769e-05|  4.26769e-05|  0.04%|            start = source.tell() - 1
(call)|         1|  2.07424e-05|  2.07424e-05|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:293 tell
   711|         1|  1.97887e-05|  1.97887e-05|  0.02%|            capture = True
   712|         1|  2.16961e-05|  2.16961e-05|  0.02%|            atomic = False
   713|         1|  1.93119e-05|  1.93119e-05|  0.02%|            name = None
   714|         1|  1.90735e-05|  1.90735e-05|  0.02%|            add_flags = 0
   715|         1|  1.90735e-05|  1.90735e-05|  0.02%|            del_flags = 0
   716|         1|  5.96046e-05|  5.96046e-05|  0.06%|            if sourcematch("?"):
(call)|         1|  4.22001e-05|  4.22001e-05|  0.04%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:256 match
   717|         0|            0|            0|  0.00%|                # options
   718|         1|  5.24521e-05|  5.24521e-05|  0.05%|                char = sourceget()
(call)|         1|  2.57492e-05|  2.57492e-05|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:261 get
   719|         1|  1.93119e-05|  1.93119e-05|  0.02%|                if char is None:
   720|         0|            0|            0|  0.00%|                    raise source.error("unexpected end of pattern")
   721|         1|  1.95503e-05|  1.95503e-05|  0.02%|                if char == "P":
   722|         0|            0|            0|  0.00%|                    # python extensions
   723|         1|  5.19753e-05|  5.19753e-05|  0.05%|                    if sourcematch("<"):
(call)|         1|  2.52724e-05|  2.52724e-05|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:256 match
   724|         0|            0|            0|  0.00%|                        # named group: skip forward to end of name
   725|         1|  7.65324e-05|  7.65324e-05|  0.08%|                        name = source.getuntil(">", "group name")
(call)|         1|    0.0639095|    0.0639095| 65.70%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:274 getuntil
   726|         1|  6.93798e-05|  6.93798e-05|  0.07%|                        source.checkgroupname(name, 1)
(call)|         1|   2.6226e-05|   2.6226e-05|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:304 checkgroupname
   727|         0|            0|            0|  0.00%|                    elif sourcematch("="):
   728|         0|            0|            0|  0.00%|                        # named backreference
   729|         0|            0|            0|  0.00%|                        name = source.getuntil(")", "group name")
   730|         0|            0|            0|  0.00%|                        source.checkgroupname(name, 1)
   731|         0|            0|            0|  0.00%|                        gid = state.groupdict.get(name)
   732|         0|            0|            0|  0.00%|                        if gid is None:
   733|         0|            0|            0|  0.00%|                            msg = "unknown group name %r" % name
   734|         0|            0|            0|  0.00%|                            raise source.error(msg, len(name) + 1)
   735|         0|            0|            0|  0.00%|                        if not state.checkgroup(gid):
   736|         0|            0|            0|  0.00%|                            raise source.error("cannot refer to an open group",
   737|         0|            0|            0|  0.00%|                                               len(name) + 1)
   738|         0|            0|            0|  0.00%|                        state.checklookbehindgroup(gid, source)
   739|         0|            0|            0|  0.00%|                        subpatternappend((GROUPREF, gid))
   740|         0|            0|            0|  0.00%|                        continue
   741|         0|            0|            0|  0.00%|
   742|         0|            0|            0|  0.00%|                    else:
   743|         0|            0|            0|  0.00%|                        char = sourceget()
   744|         0|            0|            0|  0.00%|                        if char is None:
   745|         0|            0|            0|  0.00%|                            raise source.error("unexpected end of pattern")
   746|         0|            0|            0|  0.00%|                        raise source.error("unknown extension ?P" + char,
   747|         0|            0|            0|  0.00%|                                           len(char) + 2)
   748|         0|            0|            0|  0.00%|                elif char == ":":
   749|         0|            0|            0|  0.00%|                    # non-capturing group
   750|         0|            0|            0|  0.00%|                    capture = False
   751|         0|            0|            0|  0.00%|                elif char == "#":
   752|         0|            0|            0|  0.00%|                    # comment
   753|         0|            0|            0|  0.00%|                    while True:
   754|         0|            0|            0|  0.00%|                        if source.next is None:
   755|         0|            0|            0|  0.00%|                            raise source.error("missing ), unterminated comment",
   756|         0|            0|            0|  0.00%|                                               source.tell() - start)
   757|         0|            0|            0|  0.00%|                        if sourceget() == ")":
   758|         0|            0|            0|  0.00%|                            break
   759|         0|            0|            0|  0.00%|                    continue
   760|         0|            0|            0|  0.00%|
   761|         0|            0|            0|  0.00%|                elif char in "=!<":
   762|         0|            0|            0|  0.00%|                    # lookahead assertions
   763|         0|            0|            0|  0.00%|                    dir = 1
   764|         0|            0|            0|  0.00%|                    if char == "<":
   765|         0|            0|            0|  0.00%|                        char = sourceget()
   766|         0|            0|            0|  0.00%|                        if char is None:
   767|         0|            0|            0|  0.00%|                            raise source.error("unexpected end of pattern")
   768|         0|            0|            0|  0.00%|                        if char not in "=!":
   769|         0|            0|            0|  0.00%|                            raise source.error("unknown extension ?<" + char,
   770|         0|            0|            0|  0.00%|                                               len(char) + 2)
   771|         0|            0|            0|  0.00%|                        dir = -1 # lookbehind
   772|         0|            0|            0|  0.00%|                        lookbehindgroups = state.lookbehindgroups
   773|         0|            0|            0|  0.00%|                        if lookbehindgroups is None:
   774|         0|            0|            0|  0.00%|                            state.lookbehindgroups = state.groups
   775|         0|            0|            0|  0.00%|                    p = _parse_sub(source, state, verbose, nested + 1)
   776|         0|            0|            0|  0.00%|                    if dir < 0:
   777|         0|            0|            0|  0.00%|                        if lookbehindgroups is None:
   778|         0|            0|            0|  0.00%|                            state.lookbehindgroups = None
   779|         0|            0|            0|  0.00%|                    if not sourcematch(")"):
   780|         0|            0|            0|  0.00%|                        raise source.error("missing ), unterminated subpattern",
   781|         0|            0|            0|  0.00%|                                           source.tell() - start)
   782|         0|            0|            0|  0.00%|                    if char == "=":
   783|         0|            0|            0|  0.00%|                        subpatternappend((ASSERT, (dir, p)))
   784|         0|            0|            0|  0.00%|                    else:
   785|         0|            0|            0|  0.00%|                        subpatternappend((ASSERT_NOT, (dir, p)))
   786|         0|            0|            0|  0.00%|                    continue
   787|         0|            0|            0|  0.00%|
   788|         0|            0|            0|  0.00%|                elif char == "(":
   789|         0|            0|            0|  0.00%|                    # conditional backreference group
   790|         0|            0|            0|  0.00%|                    condname = source.getuntil(")", "group name")
   791|         0|            0|            0|  0.00%|                    if not (condname.isdecimal() and condname.isascii()):
   792|         0|            0|            0|  0.00%|                        source.checkgroupname(condname, 1)
   793|         0|            0|            0|  0.00%|                        condgroup = state.groupdict.get(condname)
   794|         0|            0|            0|  0.00%|                        if condgroup is None:
   795|         0|            0|            0|  0.00%|                            msg = "unknown group name %r" % condname
   796|         0|            0|            0|  0.00%|                            raise source.error(msg, len(condname) + 1)
   797|         0|            0|            0|  0.00%|                    else:
   798|         0|            0|            0|  0.00%|                        condgroup = int(condname)
   799|         0|            0|            0|  0.00%|                        if not condgroup:
   800|         0|            0|            0|  0.00%|                            raise source.error("bad group number",
   801|         0|            0|            0|  0.00%|                                               len(condname) + 1)
   802|         0|            0|            0|  0.00%|                        if condgroup >= MAXGROUPS:
   803|         0|            0|            0|  0.00%|                            msg = "invalid group reference %d" % condgroup
   804|         0|            0|            0|  0.00%|                            raise source.error(msg, len(condname) + 1)
   805|         0|            0|            0|  0.00%|                        if condgroup not in state.grouprefpos:
   806|         0|            0|            0|  0.00%|                            state.grouprefpos[condgroup] = (
   807|         0|            0|            0|  0.00%|                                source.tell() - len(condname) - 1
   808|         0|            0|            0|  0.00%|                            )
   809|         0|            0|            0|  0.00%|                        if not (condname.isdecimal() and condname.isascii()):
   810|         0|            0|            0|  0.00%|                            import warnings
   811|         0|            0|            0|  0.00%|                            warnings.warn(
   812|         0|            0|            0|  0.00%|                                "bad character in group name %s at position %d" %
   813|         0|            0|            0|  0.00%|                                (repr(condname) if source.istext else ascii(condname),
   814|         0|            0|            0|  0.00%|                                 source.tell() - len(condname) - 1),
   815|         0|            0|            0|  0.00%|                                DeprecationWarning, stacklevel=nested + 6
   816|         0|            0|            0|  0.00%|                            )
   817|         0|            0|            0|  0.00%|                    state.checklookbehindgroup(condgroup, source)
   818|         0|            0|            0|  0.00%|                    item_yes = _parse(source, state, verbose, nested + 1)
   819|         0|            0|            0|  0.00%|                    if source.match("|"):
   820|         0|            0|            0|  0.00%|                        item_no = _parse(source, state, verbose, nested + 1)
   821|         0|            0|            0|  0.00%|                        if source.next == "|":
   822|         0|            0|            0|  0.00%|                            raise source.error("conditional backref with more than two branches")
   823|         0|            0|            0|  0.00%|                    else:
   824|         0|            0|            0|  0.00%|                        item_no = None
   825|         0|            0|            0|  0.00%|                    if not source.match(")"):
   826|         0|            0|            0|  0.00%|                        raise source.error("missing ), unterminated subpattern",
   827|         0|            0|            0|  0.00%|                                           source.tell() - start)
   828|         0|            0|            0|  0.00%|                    subpatternappend((GROUPREF_EXISTS, (condgroup, item_yes, item_no)))
   829|         0|            0|            0|  0.00%|                    continue
   830|         0|            0|            0|  0.00%|
   831|         0|            0|            0|  0.00%|                elif char == ">":
   832|         0|            0|            0|  0.00%|                    # non-capturing, atomic group
   833|         0|            0|            0|  0.00%|                    capture = False
   834|         0|            0|            0|  0.00%|                    atomic = True
   835|         0|            0|            0|  0.00%|                elif char in FLAGS or char == "-":
   836|         0|            0|            0|  0.00%|                    # flags
   837|         0|            0|            0|  0.00%|                    flags = _parse_flags(source, state, char)
   838|         0|            0|            0|  0.00%|                    if flags is None:  # global flags
   839|         0|            0|            0|  0.00%|                        if not first or subpattern:
   840|         0|            0|            0|  0.00%|                            raise source.error('global flags not at the start '
   841|         0|            0|            0|  0.00%|                                               'of the expression',
   842|         0|            0|            0|  0.00%|                                               source.tell() - start)
   843|         0|            0|            0|  0.00%|                        verbose = state.flags & SRE_FLAG_VERBOSE
   844|         0|            0|            0|  0.00%|                        continue
   845|         0|            0|            0|  0.00%|
   846|         0|            0|            0|  0.00%|                    add_flags, del_flags = flags
   847|         0|            0|            0|  0.00%|                    capture = False
   848|         0|            0|            0|  0.00%|                else:
   849|         0|            0|            0|  0.00%|                    raise source.error("unknown extension ?" + char,
   850|         0|            0|            0|  0.00%|                                       len(char) + 1)
   851|         0|            0|            0|  0.00%|
   852|         0|            0|            0|  0.00%|            # parse group contents
   853|         1|  3.43323e-05|  3.43323e-05|  0.04%|            if capture:
   854|         1|  4.00543e-05|  4.00543e-05|  0.04%|                try:
   855|         1|  7.36713e-05|  7.36713e-05|  0.08%|                    group = state.opengroup(name)
(call)|         1|  5.91278e-05|  5.91278e-05|  0.06%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:86 opengroup
   856|         0|            0|            0|  0.00%|                except error as err:
   857|         0|            0|            0|  0.00%|                    raise source.error(err.msg, len(name) + 1) from None
   858|         0|            0|            0|  0.00%|            else:
   859|         0|            0|            0|  0.00%|                group = None
   860|         1|  5.81741e-05|  5.81741e-05|  0.06%|            sub_verbose = ((verbose or (add_flags & SRE_FLAG_VERBOSE)) and
   861|         0|            0|            0|  0.00%|                           not (del_flags & SRE_FLAG_VERBOSE))
   862|         1|  7.51019e-05|  7.51019e-05|  0.08%|            p = _parse_sub(source, state, sub_verbose, nested + 1)
(call)|         1|   0.00242829|   0.00242829|  2.50%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:452 _parse_sub
   863|         1|  8.27312e-05|  8.27312e-05|  0.09%|            if not source.match(")"):
(call)|         1|  2.90871e-05|  2.90871e-05|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:256 match
   864|         0|            0|            0|  0.00%|                raise source.error("missing ), unterminated subpattern",
   865|         0|            0|            0|  0.00%|                                   source.tell() - start)
   866|         1|   4.1008e-05|   4.1008e-05|  0.04%|            if group is not None:
   867|         1|  8.17776e-05|  8.17776e-05|  0.08%|                state.closegroup(group, p)
(call)|         1|  0.000216961|  0.000216961|  0.22%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:98 closegroup
   868|         1|  3.31402e-05|  3.31402e-05|  0.03%|            if atomic:
   869|         0|            0|            0|  0.00%|                assert group is None
   870|         0|            0|            0|  0.00%|                subpatternappend((ATOMIC_GROUP, p))
   871|         0|            0|            0|  0.00%|            else:
   872|         1|  7.20024e-05|  7.20024e-05|  0.07%|                subpatternappend((SUBPATTERN, (group, add_flags, del_flags, p)))
(call)|         1|  1.21593e-05|  1.21593e-05|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:176 append
   873|         0|            0|            0|  0.00%|
   874|         2|  5.93662e-05|  2.96831e-05|  0.06%|        elif this == "^":
   875|         1|  7.29561e-05|  7.29561e-05|  0.07%|            subpatternappend((AT, AT_BEGINNING))
(call)|         1|  2.12193e-05|  2.12193e-05|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:176 append
   876|         0|            0|            0|  0.00%|
   877|         1|  2.38419e-05|  2.38419e-05|  0.02%|        elif this == "$":
   878|         1|  8.27312e-05|  8.27312e-05|  0.09%|            subpatternappend((AT, AT_END))
(call)|         1|   1.4782e-05|   1.4782e-05|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:176 append
   879|         0|            0|            0|  0.00%|
   880|         0|            0|            0|  0.00%|        else:
   881|         0|            0|            0|  0.00%|            raise AssertionError("unsupported special character %r" % (char,))
   882|         0|            0|            0|  0.00%|
   883|         0|            0|            0|  0.00%|    # unpack non-capturing groups
   884|        12|  0.000473499|  3.94583e-05|  0.49%|    for i in range(len(subpattern))[::-1]:
(call)|         2|  3.09944e-05|  1.54972e-05|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:164 __len__
   885|        10|  0.000620842|  6.20842e-05|  0.64%|        op, av = subpattern[i]
(call)|        10|  0.000175238|  1.75238e-05|  0.18%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:168 __getitem__
   886|        10|  0.000273943|  2.73943e-05|  0.28%|        if op is SUBPATTERN:
   887|         1|  2.74181e-05|  2.74181e-05|  0.03%|            group, add_flags, del_flags, p = av
   888|         1|  6.05583e-05|  6.05583e-05|  0.06%|            if group is None and not add_flags and not del_flags:
   889|         0|            0|            0|  0.00%|                subpattern[i: i+1] = p
   890|         0|            0|            0|  0.00%|
   891|         2|  2.00272e-05|  1.00136e-05|  0.02%|    return subpattern
   892|         0|            0|            0|  0.00%|
   893|         0|            0|            0|  0.00%|def _parse_flags(source, state, char):
   894|         0|            0|            0|  0.00%|    sourceget = source.get
   895|         0|            0|            0|  0.00%|    add_flags = 0
   896|         0|            0|            0|  0.00%|    del_flags = 0
   897|         0|            0|            0|  0.00%|    if char != "-":
   898|         0|            0|            0|  0.00%|        while True:
   899|         0|            0|            0|  0.00%|            flag = FLAGS[char]
   900|         0|            0|            0|  0.00%|            if source.istext:
   901|         0|            0|            0|  0.00%|                if char == 'L':
   902|         0|            0|            0|  0.00%|                    msg = "bad inline flags: cannot use 'L' flag with a str pattern"
   903|         0|            0|            0|  0.00%|                    raise source.error(msg)
   904|         0|            0|            0|  0.00%|            else:
   905|         0|            0|            0|  0.00%|                if char == 'u':
   906|         0|            0|            0|  0.00%|                    msg = "bad inline flags: cannot use 'u' flag with a bytes pattern"
   907|         0|            0|            0|  0.00%|                    raise source.error(msg)
   908|         0|            0|            0|  0.00%|            add_flags |= flag
   909|         0|            0|            0|  0.00%|            if (flag & TYPE_FLAGS) and (add_flags & TYPE_FLAGS) != flag:
   910|         0|            0|            0|  0.00%|                msg = "bad inline flags: flags 'a', 'u' and 'L' are incompatible"
   911|         0|            0|            0|  0.00%|                raise source.error(msg)
   912|         0|            0|            0|  0.00%|            char = sourceget()
   913|         0|            0|            0|  0.00%|            if char is None:
   914|         0|            0|            0|  0.00%|                raise source.error("missing -, : or )")
   915|         0|            0|            0|  0.00%|            if char in ")-:":
   916|         0|            0|            0|  0.00%|                break
   917|         0|            0|            0|  0.00%|            if char not in FLAGS:
   918|         0|            0|            0|  0.00%|                msg = "unknown flag" if char.isalpha() else "missing -, : or )"
   919|         0|            0|            0|  0.00%|                raise source.error(msg, len(char))
   920|         0|            0|            0|  0.00%|    if char == ")":
   921|         0|            0|            0|  0.00%|        state.flags |= add_flags
   922|         0|            0|            0|  0.00%|        return None
   923|         0|            0|            0|  0.00%|    if add_flags & GLOBAL_FLAGS:
   924|         0|            0|            0|  0.00%|        raise source.error("bad inline flags: cannot turn on global flag", 1)
   925|         0|            0|            0|  0.00%|    if char == "-":
   926|         0|            0|            0|  0.00%|        char = sourceget()
   927|         0|            0|            0|  0.00%|        if char is None:
   928|         0|            0|            0|  0.00%|            raise source.error("missing flag")
   929|         0|            0|            0|  0.00%|        if char not in FLAGS:
   930|         0|            0|            0|  0.00%|            msg = "unknown flag" if char.isalpha() else "missing flag"
   931|         0|            0|            0|  0.00%|            raise source.error(msg, len(char))
   932|         0|            0|            0|  0.00%|        while True:
   933|         0|            0|            0|  0.00%|            flag = FLAGS[char]
   934|         0|            0|            0|  0.00%|            if flag & TYPE_FLAGS:
   935|         0|            0|            0|  0.00%|                msg = "bad inline flags: cannot turn off flags 'a', 'u' and 'L'"
   936|         0|            0|            0|  0.00%|                raise source.error(msg)
   937|         0|            0|            0|  0.00%|            del_flags |= flag
   938|         0|            0|            0|  0.00%|            char = sourceget()
   939|         0|            0|            0|  0.00%|            if char is None:
   940|         0|            0|            0|  0.00%|                raise source.error("missing :")
   941|         0|            0|            0|  0.00%|            if char == ":":
   942|         0|            0|            0|  0.00%|                break
   943|         0|            0|            0|  0.00%|            if char not in FLAGS:
   944|         0|            0|            0|  0.00%|                msg = "unknown flag" if char.isalpha() else "missing :"
   945|         0|            0|            0|  0.00%|                raise source.error(msg, len(char))
   946|         0|            0|            0|  0.00%|    assert char == ":"
   947|         0|            0|            0|  0.00%|    if del_flags & GLOBAL_FLAGS:
   948|         0|            0|            0|  0.00%|        raise source.error("bad inline flags: cannot turn off global flag", 1)
   949|         0|            0|            0|  0.00%|    if add_flags & del_flags:
   950|         0|            0|            0|  0.00%|        raise source.error("bad inline flags: flag turned on and off", 1)
   951|         0|            0|            0|  0.00%|    return add_flags, del_flags
   952|         0|            0|            0|  0.00%|
   953|         1|  1.00136e-05|  1.00136e-05|  0.01%|def fix_flags(src, flags):
   954|         0|            0|            0|  0.00%|    # Check and fix flags according to the type of pattern (str or bytes)
   955|         1|  1.14441e-05|  1.14441e-05|  0.01%|    if isinstance(src, str):
   956|         1|  5.96046e-06|  5.96046e-06|  0.01%|        if flags & SRE_FLAG_LOCALE:
   957|         0|            0|            0|  0.00%|            raise ValueError("cannot use LOCALE flag with a str pattern")
   958|         1|  5.00679e-06|  5.00679e-06|  0.01%|        if not flags & SRE_FLAG_ASCII:
   959|         1|  4.76837e-06|  4.76837e-06|  0.00%|            flags |= SRE_FLAG_UNICODE
   960|         0|            0|            0|  0.00%|        elif flags & SRE_FLAG_UNICODE:
   961|         0|            0|            0|  0.00%|            raise ValueError("ASCII and UNICODE flags are incompatible")
   962|         0|            0|            0|  0.00%|    else:
   963|         0|            0|            0|  0.00%|        if flags & SRE_FLAG_UNICODE:
   964|         0|            0|            0|  0.00%|            raise ValueError("cannot use UNICODE flag with a bytes pattern")
   965|         0|            0|            0|  0.00%|        if flags & SRE_FLAG_LOCALE and flags & SRE_FLAG_ASCII:
   966|         0|            0|            0|  0.00%|            raise ValueError("ASCII and LOCALE flags are incompatible")
   967|         1|  7.86781e-06|  7.86781e-06|  0.01%|    return flags
   968|         0|            0|            0|  0.00%|
   969|         1|   3.8147e-06|   3.8147e-06|  0.00%|def parse(str, flags=0, state=None):
   970|         0|            0|            0|  0.00%|    # parse 're' pattern into list of (opcode, argument) tuples
   971|         0|            0|            0|  0.00%|
   972|         1|  1.28746e-05|  1.28746e-05|  0.01%|    source = Tokenizer(str)
(call)|         1|  4.64916e-05|  4.64916e-05|  0.05%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:231 __init__
   973|         0|            0|            0|  0.00%|
   974|         1|   2.6226e-06|   2.6226e-06|  0.00%|    if state is None:
   975|         1|  1.04904e-05|  1.04904e-05|  0.01%|        state = State()
(call)|         1|  1.85966e-05|  1.85966e-05|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:77 __init__
   976|         1|  2.38419e-06|  2.38419e-06|  0.00%|    state.flags = flags
   977|         1|   2.6226e-06|   2.6226e-06|  0.00%|    state.str = str
   978|         0|            0|            0|  0.00%|
   979|         1|  2.64645e-05|  2.64645e-05|  0.03%|    p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)
(call)|         1|     0.071938|     0.071938| 73.95%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:452 _parse_sub
   980|         1|  4.91142e-05|  4.91142e-05|  0.05%|    p.state.flags = fix_flags(str, p.state.flags)
(call)|         1|  4.50611e-05|  4.50611e-05|  0.05%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:953 fix_flags
   981|         0|            0|            0|  0.00%|
   982|         1|  7.86781e-06|  7.86781e-06|  0.01%|    if source.next is not None:
   983|         0|            0|            0|  0.00%|        assert source.next == ")"
   984|         0|            0|            0|  0.00%|        raise source.error("unbalanced parenthesis")
   985|         0|            0|            0|  0.00%|
   986|         1|   6.4373e-06|   6.4373e-06|  0.01%|    for g in p.state.grouprefpos:
   987|         0|            0|            0|  0.00%|        if g >= p.state.groups:
   988|         0|            0|            0|  0.00%|            msg = "invalid group reference %d" % g
   989|         0|            0|            0|  0.00%|            raise error(msg, str, p.state.grouprefpos[g])
   990|         0|            0|            0|  0.00%|
   991|         1|  5.72205e-06|  5.72205e-06|  0.01%|    if flags & SRE_FLAG_DEBUG:
   992|         0|            0|            0|  0.00%|        p.dump()
   993|         0|            0|            0|  0.00%|
   994|         1|  5.48363e-06|  5.48363e-06|  0.01%|    return p
   995|         0|            0|            0|  0.00%|
   996|         0|            0|            0|  0.00%|def parse_template(source, pattern):
   997|         0|            0|            0|  0.00%|    # parse 're' replacement string into list of literals and
   998|         0|            0|            0|  0.00%|    # group references
   999|         0|            0|            0|  0.00%|    s = Tokenizer(source)
  1000|         0|            0|            0|  0.00%|    sget = s.get
  1001|         0|            0|            0|  0.00%|    result = []
  1002|         0|            0|            0|  0.00%|    literal = []
  1003|         0|            0|            0|  0.00%|    lappend = literal.append
  1004|         0|            0|            0|  0.00%|    def addliteral():
  1005|         0|            0|            0|  0.00%|        if s.istext:
  1006|         0|            0|            0|  0.00%|            result.append(''.join(literal))
  1007|         0|            0|            0|  0.00%|        else:
  1008|         0|            0|            0|  0.00%|            # The tokenizer implicitly decodes bytes objects as latin-1, we must
  1009|         0|            0|            0|  0.00%|            # therefore re-encode the final representation.
  1010|         0|            0|            0|  0.00%|            result.append(''.join(literal).encode('latin-1'))
  1011|         0|            0|            0|  0.00%|        del literal[:]
  1012|         0|            0|            0|  0.00%|    def addgroup(index, pos):
  1013|         0|            0|            0|  0.00%|        if index > pattern.groups:
  1014|         0|            0|            0|  0.00%|            raise s.error("invalid group reference %d" % index, pos)
  1015|         0|            0|            0|  0.00%|        addliteral()
  1016|         0|            0|            0|  0.00%|        result.append(index)
  1017|         0|            0|            0|  0.00%|    groupindex = pattern.groupindex
  1018|         0|            0|            0|  0.00%|    while True:
  1019|         0|            0|            0|  0.00%|        this = sget()
  1020|         0|            0|            0|  0.00%|        if this is None:
  1021|         0|            0|            0|  0.00%|            break # end of replacement string
  1022|         0|            0|            0|  0.00%|        if this[0] == "\\":
  1023|         0|            0|            0|  0.00%|            # group
  1024|         0|            0|            0|  0.00%|            c = this[1]
  1025|         0|            0|            0|  0.00%|            if c == "g":
  1026|         0|            0|            0|  0.00%|                if not s.match("<"):
  1027|         0|            0|            0|  0.00%|                    raise s.error("missing <")
  1028|         0|            0|            0|  0.00%|                name = s.getuntil(">", "group name")
  1029|         0|            0|            0|  0.00%|                if not (name.isdecimal() and name.isascii()):
  1030|         0|            0|            0|  0.00%|                    s.checkgroupname(name, 1)
  1031|         0|            0|            0|  0.00%|                    try:
  1032|         0|            0|            0|  0.00%|                        index = groupindex[name]
  1033|         0|            0|            0|  0.00%|                    except KeyError:
  1034|         0|            0|            0|  0.00%|                        raise IndexError("unknown group name %r" % name) from None
  1035|         0|            0|            0|  0.00%|                else:
  1036|         0|            0|            0|  0.00%|                    index = int(name)
  1037|         0|            0|            0|  0.00%|                    if index >= MAXGROUPS:
  1038|         0|            0|            0|  0.00%|                        raise s.error("invalid group reference %d" % index,
  1039|         0|            0|            0|  0.00%|                                      len(name) + 1)
  1040|         0|            0|            0|  0.00%|                    if not (name.isdecimal() and name.isascii()):
  1041|         0|            0|            0|  0.00%|                        import warnings
  1042|         0|            0|            0|  0.00%|                        warnings.warn(
  1043|         0|            0|            0|  0.00%|                            "bad character in group name %s at position %d" %
  1044|         0|            0|            0|  0.00%|                            (repr(name) if s.istext else ascii(name),
  1045|         0|            0|            0|  0.00%|                             s.tell() - len(name) - 1),
  1046|         0|            0|            0|  0.00%|                            DeprecationWarning, stacklevel=5
  1047|         0|            0|            0|  0.00%|                        )
  1048|         0|            0|            0|  0.00%|                addgroup(index, len(name) + 1)
  1049|         0|            0|            0|  0.00%|            elif c == "0":
  1050|         0|            0|            0|  0.00%|                if s.next in OCTDIGITS:
  1051|         0|            0|            0|  0.00%|                    this += sget()
  1052|         0|            0|            0|  0.00%|                    if s.next in OCTDIGITS:
  1053|         0|            0|            0|  0.00%|                        this += sget()
  1054|         0|            0|            0|  0.00%|                lappend(chr(int(this[1:], 8) & 0xff))
  1055|         0|            0|            0|  0.00%|            elif c in DIGITS:
  1056|         0|            0|            0|  0.00%|                isoctal = False
  1057|         0|            0|            0|  0.00%|                if s.next in DIGITS:
  1058|         0|            0|            0|  0.00%|                    this += sget()
  1059|         0|            0|            0|  0.00%|                    if (c in OCTDIGITS and this[2] in OCTDIGITS and
  1060|         0|            0|            0|  0.00%|                        s.next in OCTDIGITS):
  1061|         0|            0|            0|  0.00%|                        this += sget()
  1062|         0|            0|            0|  0.00%|                        isoctal = True
  1063|         0|            0|            0|  0.00%|                        c = int(this[1:], 8)
  1064|         0|            0|            0|  0.00%|                        if c > 0o377:
  1065|         0|            0|            0|  0.00%|                            raise s.error('octal escape value %s outside of '
  1066|         0|            0|            0|  0.00%|                                          'range 0-0o377' % this, len(this))
  1067|         0|            0|            0|  0.00%|                        lappend(chr(c))
  1068|         0|            0|            0|  0.00%|                if not isoctal:
  1069|         0|            0|            0|  0.00%|                    addgroup(int(this[1:]), len(this) - 1)
  1070|         0|            0|            0|  0.00%|            else:
  1071|         0|            0|            0|  0.00%|                try:
  1072|         0|            0|            0|  0.00%|                    this = chr(ESCAPES[this][1])
  1073|         0|            0|            0|  0.00%|                except KeyError:
  1074|         0|            0|            0|  0.00%|                    if c in ASCIILETTERS:
  1075|         0|            0|            0|  0.00%|                        raise s.error('bad escape %s' % this, len(this)) from None
  1076|         0|            0|            0|  0.00%|                lappend(this)
  1077|         0|            0|            0|  0.00%|        else:
  1078|         0|            0|            0|  0.00%|            lappend(this)
  1079|         0|            0|            0|  0.00%|    addliteral()
  1080|         0|            0|            0|  0.00%|    return result
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py
File duration: 0.00259233s (2.66%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Convert python types to pydantic-core schema."""
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|from __future__ import annotations as _annotations
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|import collections.abc
     6|         0|            0|            0|  0.00%|import dataclasses
     7|         0|            0|            0|  0.00%|import inspect
     8|         0|            0|            0|  0.00%|import re
     9|         0|            0|            0|  0.00%|import sys
    10|         0|            0|            0|  0.00%|import typing
    11|         0|            0|            0|  0.00%|import warnings
    12|         0|            0|            0|  0.00%|from contextlib import ExitStack, contextmanager
    13|         0|            0|            0|  0.00%|from copy import copy, deepcopy
    14|         0|            0|            0|  0.00%|from enum import Enum
    15|         0|            0|            0|  0.00%|from functools import partial
    16|         0|            0|            0|  0.00%|from inspect import Parameter, _ParameterKind, signature
    17|         0|            0|            0|  0.00%|from itertools import chain
    18|         0|            0|            0|  0.00%|from operator import attrgetter
    19|         0|            0|            0|  0.00%|from types import FunctionType, LambdaType, MethodType
    20|         0|            0|            0|  0.00%|from typing import (
    21|         0|            0|            0|  0.00%|    TYPE_CHECKING,
    22|         0|            0|            0|  0.00%|    Any,
    23|         0|            0|            0|  0.00%|    Callable,
    24|         0|            0|            0|  0.00%|    Dict,
    25|         0|            0|            0|  0.00%|    Final,
    26|         0|            0|            0|  0.00%|    ForwardRef,
    27|         0|            0|            0|  0.00%|    Iterable,
    28|         0|            0|            0|  0.00%|    Iterator,
    29|         0|            0|            0|  0.00%|    Mapping,
    30|         0|            0|            0|  0.00%|    Type,
    31|         0|            0|            0|  0.00%|    TypeVar,
    32|         0|            0|            0|  0.00%|    Union,
    33|         0|            0|            0|  0.00%|    cast,
    34|         0|            0|            0|  0.00%|    overload,
    35|         0|            0|            0|  0.00%|)
    36|         0|            0|            0|  0.00%|from warnings import warn
    37|         0|            0|            0|  0.00%|
    38|         0|            0|            0|  0.00%|from pydantic_core import CoreSchema, PydanticUndefined, core_schema, to_jsonable_python
    39|         0|            0|            0|  0.00%|from typing_extensions import Annotated, Literal, TypeAliasType, TypedDict, get_args, get_origin, is_typeddict
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|from ..aliases import AliasGenerator
    42|         0|            0|            0|  0.00%|from ..annotated_handlers import GetCoreSchemaHandler, GetJsonSchemaHandler
    43|         0|            0|            0|  0.00%|from ..config import ConfigDict, JsonDict, JsonEncoder
    44|         0|            0|            0|  0.00%|from ..errors import PydanticSchemaGenerationError, PydanticUndefinedAnnotation, PydanticUserError
    45|         0|            0|            0|  0.00%|from ..json_schema import JsonSchemaValue
    46|         0|            0|            0|  0.00%|from ..version import version_short
    47|         0|            0|            0|  0.00%|from ..warnings import PydanticDeprecatedSince20
    48|         0|            0|            0|  0.00%|from . import _core_utils, _decorators, _discriminated_union, _known_annotated_metadata, _typing_extra
    49|         0|            0|            0|  0.00%|from ._config import ConfigWrapper, ConfigWrapperStack
    50|         0|            0|            0|  0.00%|from ._core_metadata import CoreMetadataHandler, build_metadata_dict
    51|         0|            0|            0|  0.00%|from ._core_utils import (
    52|         0|            0|            0|  0.00%|    CoreSchemaOrField,
    53|         0|            0|            0|  0.00%|    collect_invalid_schemas,
    54|         0|            0|            0|  0.00%|    define_expected_missing_refs,
    55|         0|            0|            0|  0.00%|    get_ref,
    56|         0|            0|            0|  0.00%|    get_type_ref,
    57|         0|            0|            0|  0.00%|    is_function_with_inner_schema,
    58|         0|            0|            0|  0.00%|    is_list_like_schema_with_items_schema,
    59|         0|            0|            0|  0.00%|    simplify_schema_references,
    60|         0|            0|            0|  0.00%|    validate_core_schema,
    61|         0|            0|            0|  0.00%|)
    62|         0|            0|            0|  0.00%|from ._decorators import (
    63|         0|            0|            0|  0.00%|    Decorator,
    64|         0|            0|            0|  0.00%|    DecoratorInfos,
    65|         0|            0|            0|  0.00%|    FieldSerializerDecoratorInfo,
    66|         0|            0|            0|  0.00%|    FieldValidatorDecoratorInfo,
    67|         0|            0|            0|  0.00%|    ModelSerializerDecoratorInfo,
    68|         0|            0|            0|  0.00%|    ModelValidatorDecoratorInfo,
    69|         0|            0|            0|  0.00%|    RootValidatorDecoratorInfo,
    70|         0|            0|            0|  0.00%|    ValidatorDecoratorInfo,
    71|         0|            0|            0|  0.00%|    get_attribute_from_bases,
    72|         0|            0|            0|  0.00%|    inspect_field_serializer,
    73|         0|            0|            0|  0.00%|    inspect_model_serializer,
    74|         0|            0|            0|  0.00%|    inspect_validator,
    75|         0|            0|            0|  0.00%|)
    76|         0|            0|            0|  0.00%|from ._docs_extraction import extract_docstrings_from_cls
    77|         0|            0|            0|  0.00%|from ._fields import collect_dataclass_fields, get_type_hints_infer_globalns
    78|         0|            0|            0|  0.00%|from ._forward_ref import PydanticRecursiveRef
    79|         0|            0|            0|  0.00%|from ._generics import get_standard_typevars_map, has_instance_in_type, recursively_defined_type_refs, replace_types
    80|         0|            0|            0|  0.00%|from ._mock_val_ser import MockCoreSchema
    81|         0|            0|            0|  0.00%|from ._schema_generation_shared import CallbackGetCoreSchemaHandler
    82|         0|            0|            0|  0.00%|from ._typing_extra import is_finalvar, is_self_type
    83|         0|            0|            0|  0.00%|from ._utils import lenient_issubclass
    84|         0|            0|            0|  0.00%|
    85|         0|            0|            0|  0.00%|if TYPE_CHECKING:
    86|         0|            0|            0|  0.00%|    from ..fields import ComputedFieldInfo, FieldInfo
    87|         0|            0|            0|  0.00%|    from ..main import BaseModel
    88|         0|            0|            0|  0.00%|    from ..types import Discriminator
    89|         0|            0|            0|  0.00%|    from ..validators import FieldValidatorModes
    90|         0|            0|            0|  0.00%|    from ._dataclasses import StandardDataclass
    91|         0|            0|            0|  0.00%|    from ._schema_generation_shared import GetJsonSchemaFunction
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|_SUPPORTS_TYPEDDICT = sys.version_info >= (3, 12)
    94|         0|            0|            0|  0.00%|_AnnotatedType = type(Annotated[int, 123])
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|FieldDecoratorInfo = Union[ValidatorDecoratorInfo, FieldValidatorDecoratorInfo, FieldSerializerDecoratorInfo]
    97|         0|            0|            0|  0.00%|FieldDecoratorInfoType = TypeVar('FieldDecoratorInfoType', bound=FieldDecoratorInfo)
    98|         0|            0|            0|  0.00%|AnyFieldDecorator = Union[
    99|         0|            0|            0|  0.00%|    Decorator[ValidatorDecoratorInfo],
   100|         0|            0|            0|  0.00%|    Decorator[FieldValidatorDecoratorInfo],
   101|         0|            0|            0|  0.00%|    Decorator[FieldSerializerDecoratorInfo],
   102|         0|            0|            0|  0.00%|]
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|ModifyCoreSchemaWrapHandler = GetCoreSchemaHandler
   105|         0|            0|            0|  0.00%|GetCoreSchemaFunction = Callable[[Any, ModifyCoreSchemaWrapHandler], core_schema.CoreSchema]
   106|         0|            0|            0|  0.00%|
   107|         0|            0|            0|  0.00%|TUPLE_TYPES: list[type] = [tuple, typing.Tuple]
   108|         0|            0|            0|  0.00%|LIST_TYPES: list[type] = [list, typing.List, collections.abc.MutableSequence]
   109|         0|            0|            0|  0.00%|SET_TYPES: list[type] = [set, typing.Set, collections.abc.MutableSet]
   110|         0|            0|            0|  0.00%|FROZEN_SET_TYPES: list[type] = [frozenset, typing.FrozenSet, collections.abc.Set]
   111|         0|            0|            0|  0.00%|DICT_TYPES: list[type] = [dict, typing.Dict, collections.abc.MutableMapping, collections.abc.Mapping]
   112|         0|            0|            0|  0.00%|
   113|         0|            0|            0|  0.00%|
   114|         0|            0|            0|  0.00%|def check_validator_fields_against_field_name(
   115|         0|            0|            0|  0.00%|    info: FieldDecoratorInfo,
   116|         0|            0|            0|  0.00%|    field: str,
   117|         0|            0|            0|  0.00%|) -> bool:
   118|         0|            0|            0|  0.00%|    """Check if field name is in validator fields.
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|    Args:
   121|         0|            0|            0|  0.00%|        info: The field info.
   122|         0|            0|            0|  0.00%|        field: The field name to check.
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|    Returns:
   125|         0|            0|            0|  0.00%|        `True` if field name is in validator fields, `False` otherwise.
   126|         0|            0|            0|  0.00%|    """
   127|         0|            0|            0|  0.00%|    if '*' in info.fields:
   128|         0|            0|            0|  0.00%|        return True
   129|         0|            0|            0|  0.00%|    for v_field_name in info.fields:
   130|         0|            0|            0|  0.00%|        if v_field_name == field:
   131|         0|            0|            0|  0.00%|            return True
   132|         0|            0|            0|  0.00%|    return False
   133|         0|            0|            0|  0.00%|
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|def check_decorator_fields_exist(decorators: Iterable[AnyFieldDecorator], fields: Iterable[str]) -> None:
   136|         0|            0|            0|  0.00%|    """Check if the defined fields in decorators exist in `fields` param.
   137|         0|            0|            0|  0.00%|
   138|         0|            0|            0|  0.00%|    It ignores the check for a decorator if the decorator has `*` as field or `check_fields=False`.
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|    Args:
   141|         0|            0|            0|  0.00%|        decorators: An iterable of decorators.
   142|         0|            0|            0|  0.00%|        fields: An iterable of fields name.
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|    Raises:
   145|         0|            0|            0|  0.00%|        PydanticUserError: If one of the field names does not exist in `fields` param.
   146|         0|            0|            0|  0.00%|    """
   147|         0|            0|            0|  0.00%|    fields = set(fields)
   148|         0|            0|            0|  0.00%|    for dec in decorators:
   149|         0|            0|            0|  0.00%|        if '*' in dec.info.fields:
   150|         0|            0|            0|  0.00%|            continue
   151|         0|            0|            0|  0.00%|        if dec.info.check_fields is False:
   152|         0|            0|            0|  0.00%|            continue
   153|         0|            0|            0|  0.00%|        for field in dec.info.fields:
   154|         0|            0|            0|  0.00%|            if field not in fields:
   155|         0|            0|            0|  0.00%|                raise PydanticUserError(
   156|         0|            0|            0|  0.00%|                    f'Decorators defined with incorrect fields: {dec.cls_ref}.{dec.cls_var_name}'
   157|         0|            0|            0|  0.00%|                    " (use check_fields=False if you're inheriting from the model and intended this)",
   158|         0|            0|            0|  0.00%|                    code='decorator-missing-field',
   159|         0|            0|            0|  0.00%|                )
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|def filter_field_decorator_info_by_field(
   163|         0|            0|            0|  0.00%|    validator_functions: Iterable[Decorator[FieldDecoratorInfoType]], field: str
   164|         0|            0|            0|  0.00%|) -> list[Decorator[FieldDecoratorInfoType]]:
   165|         0|            0|            0|  0.00%|    return [dec for dec in validator_functions if check_validator_fields_against_field_name(dec.info, field)]
   166|         0|            0|            0|  0.00%|
   167|         0|            0|            0|  0.00%|
   168|         0|            0|            0|  0.00%|def apply_each_item_validators(
   169|         0|            0|            0|  0.00%|    schema: core_schema.CoreSchema,
   170|         0|            0|            0|  0.00%|    each_item_validators: list[Decorator[ValidatorDecoratorInfo]],
   171|         0|            0|            0|  0.00%|    field_name: str | None,
   172|         0|            0|            0|  0.00%|) -> core_schema.CoreSchema:
   173|         0|            0|            0|  0.00%|    # This V1 compatibility shim should eventually be removed
   174|         0|            0|            0|  0.00%|
   175|         0|            0|            0|  0.00%|    # push down any `each_item=True` validators
   176|         0|            0|            0|  0.00%|    # note that this won't work for any Annotated types that get wrapped by a function validator
   177|         0|            0|            0|  0.00%|    # but that's okay because that didn't exist in V1
   178|         0|            0|            0|  0.00%|    if schema['type'] == 'nullable':
   179|         0|            0|            0|  0.00%|        schema['schema'] = apply_each_item_validators(schema['schema'], each_item_validators, field_name)
   180|         0|            0|            0|  0.00%|        return schema
   181|         0|            0|            0|  0.00%|    elif schema['type'] == 'tuple':
   182|         0|            0|            0|  0.00%|        if (variadic_item_index := schema.get('variadic_item_index')) is not None:
   183|         0|            0|            0|  0.00%|            schema['items_schema'][variadic_item_index] = apply_validators(
   184|         0|            0|            0|  0.00%|                schema['items_schema'][variadic_item_index], each_item_validators, field_name
   185|         0|            0|            0|  0.00%|            )
   186|         0|            0|            0|  0.00%|    elif is_list_like_schema_with_items_schema(schema):
   187|         0|            0|            0|  0.00%|        inner_schema = schema.get('items_schema', None)
   188|         0|            0|            0|  0.00%|        if inner_schema is None:
   189|         0|            0|            0|  0.00%|            inner_schema = core_schema.any_schema()
   190|         0|            0|            0|  0.00%|        schema['items_schema'] = apply_validators(inner_schema, each_item_validators, field_name)
   191|         0|            0|            0|  0.00%|    elif schema['type'] == 'dict':
   192|         0|            0|            0|  0.00%|        # push down any `each_item=True` validators onto dict _values_
   193|         0|            0|            0|  0.00%|        # this is super arbitrary but it's the V1 behavior
   194|         0|            0|            0|  0.00%|        inner_schema = schema.get('values_schema', None)
   195|         0|            0|            0|  0.00%|        if inner_schema is None:
   196|         0|            0|            0|  0.00%|            inner_schema = core_schema.any_schema()
   197|         0|            0|            0|  0.00%|        schema['values_schema'] = apply_validators(inner_schema, each_item_validators, field_name)
   198|         0|            0|            0|  0.00%|    elif each_item_validators:
   199|         0|            0|            0|  0.00%|        raise TypeError(
   200|         0|            0|            0|  0.00%|            f"`@validator(..., each_item=True)` cannot be applied to fields with a schema of {schema['type']}"
   201|         0|            0|            0|  0.00%|        )
   202|         0|            0|            0|  0.00%|    return schema
   203|         0|            0|            0|  0.00%|
   204|         0|            0|            0|  0.00%|
   205|         0|            0|            0|  0.00%|def modify_model_json_schema(
   206|         0|            0|            0|  0.00%|    schema_or_field: CoreSchemaOrField,
   207|         0|            0|            0|  0.00%|    handler: GetJsonSchemaHandler,
   208|         0|            0|            0|  0.00%|    *,
   209|         0|            0|            0|  0.00%|    cls: Any,
   210|         0|            0|            0|  0.00%|    title: str | None = None,
   211|         0|            0|            0|  0.00%|) -> JsonSchemaValue:
   212|         0|            0|            0|  0.00%|    """Add title and description for model-like classes' JSON schema.
   213|         0|            0|            0|  0.00%|
   214|         0|            0|            0|  0.00%|    Args:
   215|         0|            0|            0|  0.00%|        schema_or_field: The schema data to generate a JSON schema from.
   216|         0|            0|            0|  0.00%|        handler: The `GetCoreSchemaHandler` instance.
   217|         0|            0|            0|  0.00%|        cls: The model-like class.
   218|         0|            0|            0|  0.00%|        title: The title to set for the model's schema, defaults to the model's name
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|    Returns:
   221|         0|            0|            0|  0.00%|        JsonSchemaValue: The updated JSON schema.
   222|         0|            0|            0|  0.00%|    """
   223|         0|            0|            0|  0.00%|    from ..dataclasses import is_pydantic_dataclass
   224|         0|            0|            0|  0.00%|    from ..main import BaseModel
   225|         0|            0|            0|  0.00%|    from ..root_model import RootModel
   226|         0|            0|            0|  0.00%|    from ._dataclasses import is_builtin_dataclass
   227|         0|            0|            0|  0.00%|
   228|         0|            0|            0|  0.00%|    json_schema = handler(schema_or_field)
   229|         0|            0|            0|  0.00%|    original_schema = handler.resolve_ref_schema(json_schema)
   230|         0|            0|            0|  0.00%|    # Preserve the fact that definitions schemas should never have sibling keys:
   231|         0|            0|            0|  0.00%|    if '$ref' in original_schema:
   232|         0|            0|            0|  0.00%|        ref = original_schema['$ref']
   233|         0|            0|            0|  0.00%|        original_schema.clear()
   234|         0|            0|            0|  0.00%|        original_schema['allOf'] = [{'$ref': ref}]
   235|         0|            0|            0|  0.00%|    if title is not None:
   236|         0|            0|            0|  0.00%|        original_schema['title'] = title
   237|         0|            0|            0|  0.00%|    elif 'title' not in original_schema:
   238|         0|            0|            0|  0.00%|        original_schema['title'] = cls.__name__
   239|         0|            0|            0|  0.00%|    # BaseModel + Dataclass; don't use cls.__doc__ as it will contain the verbose class signature by default
   240|         0|            0|            0|  0.00%|    docstring = None if cls is BaseModel or is_builtin_dataclass(cls) or is_pydantic_dataclass(cls) else cls.__doc__
   241|         0|            0|            0|  0.00%|    if docstring and 'description' not in original_schema:
   242|         0|            0|            0|  0.00%|        original_schema['description'] = inspect.cleandoc(docstring)
   243|         0|            0|            0|  0.00%|    elif issubclass(cls, RootModel) and cls.model_fields['root'].description:
   244|         0|            0|            0|  0.00%|        original_schema['description'] = cls.model_fields['root'].description
   245|         0|            0|            0|  0.00%|    return json_schema
   246|         0|            0|            0|  0.00%|
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|JsonEncoders = Dict[Type[Any], JsonEncoder]
   249|         0|            0|            0|  0.00%|
   250|         0|            0|            0|  0.00%|
   251|         4|  1.21593e-05|  3.03984e-06|  0.01%|def _add_custom_serialization_from_json_encoders(
   252|         0|            0|            0|  0.00%|    json_encoders: JsonEncoders | None, tp: Any, schema: CoreSchema
   253|         0|            0|            0|  0.00%|) -> CoreSchema:
   254|         0|            0|            0|  0.00%|    """Iterate over the json_encoders and add the first matching encoder to the schema.
   255|         0|            0|            0|  0.00%|
   256|         0|            0|            0|  0.00%|    Args:
   257|         0|            0|            0|  0.00%|        json_encoders: A dictionary of types and their encoder functions.
   258|         0|            0|            0|  0.00%|        tp: The type to check for a matching encoder.
   259|         0|            0|            0|  0.00%|        schema: The schema to add the encoder to.
   260|         0|            0|            0|  0.00%|    """
   261|         4|  7.62939e-06|  1.90735e-06|  0.01%|    if not json_encoders:
   262|         4|  6.67572e-06|  1.66893e-06|  0.01%|        return schema
   263|         0|            0|            0|  0.00%|    if 'serialization' in schema:
   264|         0|            0|            0|  0.00%|        return schema
   265|         0|            0|            0|  0.00%|    # Check the class type and its superclasses for a matching encoder
   266|         0|            0|            0|  0.00%|    # Decimal.__class__.__mro__ (and probably other cases) doesn't include Decimal itself
   267|         0|            0|            0|  0.00%|    # if the type is a GenericAlias (e.g. from list[int]) we need to use __class__ instead of .__mro__
   268|         0|            0|            0|  0.00%|    for base in (tp, *getattr(tp, '__mro__', tp.__class__.__mro__)[:-1]):
   269|         0|            0|            0|  0.00%|        encoder = json_encoders.get(base)
   270|         0|            0|            0|  0.00%|        if encoder is None:
   271|         0|            0|            0|  0.00%|            continue
   272|         0|            0|            0|  0.00%|
   273|         0|            0|            0|  0.00%|        warnings.warn(
   274|         0|            0|            0|  0.00%|            f'`json_encoders` is deprecated. See https://docs.pydantic.dev/{version_short()}/concepts/serialization/#custom-serializers for alternatives',
   275|         0|            0|            0|  0.00%|            PydanticDeprecatedSince20,
   276|         0|            0|            0|  0.00%|        )
   277|         0|            0|            0|  0.00%|
   278|         0|            0|            0|  0.00%|        # TODO: in theory we should check that the schema accepts a serialization key
   279|         0|            0|            0|  0.00%|        schema['serialization'] = core_schema.plain_serializer_function_ser_schema(encoder, when_used='json')
   280|         0|            0|            0|  0.00%|        return schema
   281|         0|            0|            0|  0.00%|
   282|         0|            0|            0|  0.00%|    return schema
   283|         0|            0|            0|  0.00%|
   284|         0|            0|            0|  0.00%|
   285|         0|            0|            0|  0.00%|TypesNamespace = Union[Dict[str, Any], None]
   286|         0|            0|            0|  0.00%|
   287|         0|            0|            0|  0.00%|
   288|         0|            0|            0|  0.00%|class TypesNamespaceStack:
   289|         0|            0|            0|  0.00%|    """A stack of types namespaces."""
   290|         0|            0|            0|  0.00%|
   291|         2|  3.09944e-06|  1.54972e-06|  0.00%|    def __init__(self, types_namespace: TypesNamespace):
   292|         2|  3.09944e-06|  1.54972e-06|  0.00%|        self._types_namespace_stack: list[TypesNamespace] = [types_namespace]
   293|         0|            0|            0|  0.00%|
   294|         0|            0|            0|  0.00%|    @property
   295|         0|            0|            0|  0.00%|    def tail(self) -> TypesNamespace:
   296|         0|            0|            0|  0.00%|        return self._types_namespace_stack[-1]
   297|         0|            0|            0|  0.00%|
   298|         0|            0|            0|  0.00%|    @contextmanager
   299|         0|            0|            0|  0.00%|    def push(self, for_type: type[Any]):
   300|         0|            0|            0|  0.00%|        types_namespace = {**_typing_extra.get_cls_types_namespace(for_type), **(self.tail or {})}
   301|         0|            0|            0|  0.00%|        self._types_namespace_stack.append(types_namespace)
   302|         0|            0|            0|  0.00%|        try:
   303|         0|            0|            0|  0.00%|            yield
   304|         0|            0|            0|  0.00%|        finally:
   305|         0|            0|            0|  0.00%|            self._types_namespace_stack.pop()
   306|         0|            0|            0|  0.00%|
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|def _get_first_non_null(a: Any, b: Any) -> Any:
   309|         0|            0|            0|  0.00%|    """Return the first argument if it is not None, otherwise return the second argument.
   310|         0|            0|            0|  0.00%|
   311|         0|            0|            0|  0.00%|    Use case: serialization_alias (argument a) and alias (argument b) are both defined, and serialization_alias is ''.
   312|         0|            0|            0|  0.00%|    This function will return serialization_alias, which is the first argument, even though it is an empty string.
   313|         0|            0|            0|  0.00%|    """
   314|         0|            0|            0|  0.00%|    return a if a is not None else b
   315|         0|            0|            0|  0.00%|
   316|         0|            0|            0|  0.00%|
   317|         0|            0|            0|  0.00%|class GenerateSchema:
   318|         0|            0|            0|  0.00%|    """Generate core schema for a Pydantic model, dataclass and types like `str`, `datetime`, ... ."""
   319|         0|            0|            0|  0.00%|
   320|         0|            0|            0|  0.00%|    __slots__ = (
   321|         0|            0|            0|  0.00%|        '_config_wrapper_stack',
   322|         0|            0|            0|  0.00%|        '_types_namespace_stack',
   323|         0|            0|            0|  0.00%|        '_typevars_map',
   324|         0|            0|            0|  0.00%|        'field_name_stack',
   325|         0|            0|            0|  0.00%|        'model_type_stack',
   326|         0|            0|            0|  0.00%|        'defs',
   327|         0|            0|            0|  0.00%|    )
   328|         0|            0|            0|  0.00%|
   329|         2|  5.24521e-06|   2.6226e-06|  0.01%|    def __init__(
   330|         0|            0|            0|  0.00%|        self,
   331|         0|            0|            0|  0.00%|        config_wrapper: ConfigWrapper,
   332|         0|            0|            0|  0.00%|        types_namespace: dict[str, Any] | None,
   333|         0|            0|            0|  0.00%|        typevars_map: dict[Any, Any] | None = None,
   334|         0|            0|            0|  0.00%|    ) -> None:
   335|         0|            0|            0|  0.00%|        # we need a stack for recursing into child models
   336|         2|  1.69277e-05|  8.46386e-06|  0.02%|        self._config_wrapper_stack = ConfigWrapperStack(config_wrapper)
(call)|         2|  8.82149e-06|  4.41074e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_config.py:209 __init__
   337|         2|  1.35899e-05|  6.79493e-06|  0.01%|        self._types_namespace_stack = TypesNamespaceStack(types_namespace)
(call)|         2|  6.19888e-06|  3.09944e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:291 __init__
   338|         2|  5.48363e-06|  2.74181e-06|  0.01%|        self._typevars_map = typevars_map
   339|         2|  1.71661e-05|  8.58307e-06|  0.02%|        self.field_name_stack = _FieldNameStack()
(call)|         2|  1.16825e-05|  5.84126e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:2344 __init__
   340|         2|   1.7643e-05|  8.82149e-06|  0.02%|        self.model_type_stack = _ModelTypeStack()
(call)|         2|  1.00136e-05|  5.00679e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:2363 __init__
   341|         2|  2.02656e-05|  1.01328e-05|  0.02%|        self.defs = _Definitions()
(call)|         2|  1.74046e-05|  8.70228e-06|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:2296 __init__
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|    @classmethod
   344|         0|            0|            0|  0.00%|    def __from_parent(
   345|         0|            0|            0|  0.00%|        cls,
   346|         0|            0|            0|  0.00%|        config_wrapper_stack: ConfigWrapperStack,
   347|         0|            0|            0|  0.00%|        types_namespace_stack: TypesNamespaceStack,
   348|         0|            0|            0|  0.00%|        model_type_stack: _ModelTypeStack,
   349|         0|            0|            0|  0.00%|        typevars_map: dict[Any, Any] | None,
   350|         0|            0|            0|  0.00%|        defs: _Definitions,
   351|         0|            0|            0|  0.00%|    ) -> GenerateSchema:
   352|         0|            0|            0|  0.00%|        obj = cls.__new__(cls)
   353|         0|            0|            0|  0.00%|        obj._config_wrapper_stack = config_wrapper_stack
   354|         0|            0|            0|  0.00%|        obj._types_namespace_stack = types_namespace_stack
   355|         0|            0|            0|  0.00%|        obj.model_type_stack = model_type_stack
   356|         0|            0|            0|  0.00%|        obj._typevars_map = typevars_map
   357|         0|            0|            0|  0.00%|        obj.field_name_stack = _FieldNameStack()
   358|         0|            0|            0|  0.00%|        obj.defs = defs
   359|         0|            0|            0|  0.00%|        return obj
   360|         0|            0|            0|  0.00%|
   361|        20|  2.76566e-05|  1.38283e-06|  0.03%|    @property
   362|         0|            0|            0|  0.00%|    def _config_wrapper(self) -> ConfigWrapper:
   363|        20|  7.08103e-05|  3.54052e-06|  0.07%|        return self._config_wrapper_stack.tail
(call)|        20|  4.48227e-05|  2.24113e-06|  0.05%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_config.py:212 tail
   364|         0|            0|            0|  0.00%|
   365|         0|            0|            0|  0.00%|    @property
   366|         0|            0|            0|  0.00%|    def _types_namespace(self) -> dict[str, Any] | None:
   367|         0|            0|            0|  0.00%|        return self._types_namespace_stack.tail
   368|         0|            0|            0|  0.00%|
   369|         0|            0|            0|  0.00%|    @property
   370|         0|            0|            0|  0.00%|    def _current_generate_schema(self) -> GenerateSchema:
   371|         0|            0|            0|  0.00%|        cls = self._config_wrapper.schema_generator or GenerateSchema
   372|         0|            0|            0|  0.00%|        return cls.__from_parent(
   373|         0|            0|            0|  0.00%|            self._config_wrapper_stack,
   374|         0|            0|            0|  0.00%|            self._types_namespace_stack,
   375|         0|            0|            0|  0.00%|            self.model_type_stack,
   376|         0|            0|            0|  0.00%|            self._typevars_map,
   377|         0|            0|            0|  0.00%|            self.defs,
   378|         0|            0|            0|  0.00%|        )
   379|         0|            0|            0|  0.00%|
   380|         0|            0|            0|  0.00%|    @property
   381|         0|            0|            0|  0.00%|    def _arbitrary_types(self) -> bool:
   382|         0|            0|            0|  0.00%|        return self._config_wrapper.arbitrary_types_allowed
   383|         0|            0|            0|  0.00%|
   384|         2|  1.07288e-05|  5.36442e-06|  0.01%|    def str_schema(self) -> CoreSchema:
   385|         0|            0|            0|  0.00%|        """Generate a CoreSchema for `str`"""
   386|         2|  1.33514e-05|  6.67572e-06|  0.01%|        return core_schema.str_schema()
(call)|         2|  0.000101566|  5.07832e-05|  0.10%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic_core/core_schema.py:761 str_schema
   387|         0|            0|            0|  0.00%|
   388|         0|            0|            0|  0.00%|    # the following methods can be overridden but should be considered
   389|         0|            0|            0|  0.00%|    # unstable / private APIs
   390|         0|            0|            0|  0.00%|    def _list_schema(self, tp: Any, items_type: Any) -> CoreSchema:
   391|         0|            0|            0|  0.00%|        return core_schema.list_schema(self.generate_schema(items_type))
   392|         0|            0|            0|  0.00%|
   393|         0|            0|            0|  0.00%|    def _dict_schema(self, tp: Any, keys_type: Any, values_type: Any) -> CoreSchema:
   394|         0|            0|            0|  0.00%|        return core_schema.dict_schema(self.generate_schema(keys_type), self.generate_schema(values_type))
   395|         0|            0|            0|  0.00%|
   396|         0|            0|            0|  0.00%|    def _set_schema(self, tp: Any, items_type: Any) -> CoreSchema:
   397|         0|            0|            0|  0.00%|        return core_schema.set_schema(self.generate_schema(items_type))
   398|         0|            0|            0|  0.00%|
   399|         0|            0|            0|  0.00%|    def _frozenset_schema(self, tp: Any, items_type: Any) -> CoreSchema:
   400|         0|            0|            0|  0.00%|        return core_schema.frozenset_schema(self.generate_schema(items_type))
   401|         0|            0|            0|  0.00%|
   402|         0|            0|            0|  0.00%|    def _arbitrary_type_schema(self, tp: Any) -> CoreSchema:
   403|         0|            0|            0|  0.00%|        if not isinstance(tp, type):
   404|         0|            0|            0|  0.00%|            warn(
   405|         0|            0|            0|  0.00%|                f'{tp!r} is not a Python type (it may be an instance of an object),'
   406|         0|            0|            0|  0.00%|                ' Pydantic will allow any object with no validation since we cannot even'
   407|         0|            0|            0|  0.00%|                ' enforce that the input is an instance of the given type.'
   408|         0|            0|            0|  0.00%|                ' To get rid of this error wrap the type with `pydantic.SkipValidation`.',
   409|         0|            0|            0|  0.00%|                UserWarning,
   410|         0|            0|            0|  0.00%|            )
   411|         0|            0|            0|  0.00%|            return core_schema.any_schema()
   412|         0|            0|            0|  0.00%|        return core_schema.is_instance_schema(tp)
   413|         0|            0|            0|  0.00%|
   414|         0|            0|            0|  0.00%|    def _unknown_type_schema(self, obj: Any) -> CoreSchema:
   415|         0|            0|            0|  0.00%|        raise PydanticSchemaGenerationError(
   416|         0|            0|            0|  0.00%|            f'Unable to generate pydantic-core schema for {obj!r}. '
   417|         0|            0|            0|  0.00%|            'Set `arbitrary_types_allowed=True` in the model_config to ignore this error'
   418|         0|            0|            0|  0.00%|            ' or implement `__get_pydantic_core_schema__` on your type to fully support it.'
   419|         0|            0|            0|  0.00%|            '\n\nIf you got this error by calling handler(<some type>) within'
   420|         0|            0|            0|  0.00%|            ' `__get_pydantic_core_schema__` then you likely need to call'
   421|         0|            0|            0|  0.00%|            ' `handler.generate_schema(<some type>)` since we do not call'
   422|         0|            0|            0|  0.00%|            ' `__get_pydantic_core_schema__` on `<some type>` otherwise to avoid infinite recursion.'
   423|         0|            0|            0|  0.00%|        )
   424|         0|            0|            0|  0.00%|
   425|         0|            0|            0|  0.00%|    def _apply_discriminator_to_union(
   426|         0|            0|            0|  0.00%|        self, schema: CoreSchema, discriminator: str | Discriminator | None
   427|         0|            0|            0|  0.00%|    ) -> CoreSchema:
   428|         0|            0|            0|  0.00%|        if discriminator is None:
   429|         0|            0|            0|  0.00%|            return schema
   430|         0|            0|            0|  0.00%|        try:
   431|         0|            0|            0|  0.00%|            return _discriminated_union.apply_discriminator(
   432|         0|            0|            0|  0.00%|                schema,
   433|         0|            0|            0|  0.00%|                discriminator,
   434|         0|            0|            0|  0.00%|            )
   435|         0|            0|            0|  0.00%|        except _discriminated_union.MissingDefinitionForUnionRef:
   436|         0|            0|            0|  0.00%|            # defer until defs are resolved
   437|         0|            0|            0|  0.00%|            _discriminated_union.set_discriminator_in_metadata(
   438|         0|            0|            0|  0.00%|                schema,
   439|         0|            0|            0|  0.00%|                discriminator,
   440|         0|            0|            0|  0.00%|            )
   441|         0|            0|            0|  0.00%|            return schema
   442|         0|            0|            0|  0.00%|
   443|         0|            0|            0|  0.00%|    class CollectedInvalid(Exception):
   444|         0|            0|            0|  0.00%|        pass
   445|         0|            0|            0|  0.00%|
   446|         2|  6.91414e-06|  3.45707e-06|  0.01%|    def clean_schema(self, schema: CoreSchema) -> CoreSchema:
   447|         2|  1.35899e-05|  6.79493e-06|  0.01%|        schema = self.collect_definitions(schema)
(call)|         2|  6.81877e-05|  3.40939e-05|  0.07%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:455 collect_definitions
   448|         2|  6.77109e-05|  3.38554e-05|  0.07%|        schema = simplify_schema_references(schema)
(call)|         2|  0.000643253|  0.000321627|  0.66%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:417 simplify_schema_references
   449|         2|  1.40667e-05|  7.03335e-06|  0.01%|        if collect_invalid_schemas(schema):
(call)|         2|  0.000112534|  5.62668e-05|  0.12%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:158 collect_invalid_schemas
   450|         0|            0|            0|  0.00%|            raise self.CollectedInvalid()
   451|         2|  2.02656e-05|  1.01328e-05|  0.02%|        schema = _discriminated_union.apply_discriminators(schema)
(call)|         2|   0.00035882|   0.00017941|  0.37%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_discriminated_union.py:37 apply_discriminators
   452|         2|  1.90735e-05|  9.53674e-06|  0.02%|        schema = validate_core_schema(schema)
(call)|         2|  0.000181198|  9.05991e-05|  0.19%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:565 validate_core_schema
   453|         2|  6.19888e-06|  3.09944e-06|  0.01%|        return schema
   454|         0|            0|            0|  0.00%|
   455|         2|  6.19888e-06|  3.09944e-06|  0.01%|    def collect_definitions(self, schema: CoreSchema) -> CoreSchema:
   456|         2|  1.21593e-05|  6.07967e-06|  0.01%|        ref = cast('str | None', schema.get('ref', None))
(call)|         2|  7.39098e-06|  3.69549e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:2154 cast
   457|         2|  3.57628e-06|  1.78814e-06|  0.00%|        if ref:
   458|         0|            0|            0|  0.00%|            self.defs.definitions[ref] = schema
   459|         2|  3.57628e-06|  1.78814e-06|  0.00%|        if 'ref' in schema:
   460|         0|            0|            0|  0.00%|            schema = core_schema.definition_reference_schema(schema['ref'])
   461|         4|  1.66893e-05|  4.17233e-06|  0.02%|        return core_schema.definitions_schema(
(call)|         2|  9.77516e-06|  4.88758e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic_core/core_schema.py:3681 definitions_schema
   462|         2|   3.8147e-06|  1.90735e-06|  0.00%|            schema,
   463|         2|  5.00679e-06|   2.5034e-06|  0.01%|            list(self.defs.definitions.values()),
   464|         0|            0|            0|  0.00%|        )
   465|         0|            0|            0|  0.00%|
   466|         0|            0|            0|  0.00%|    def _add_js_function(self, metadata_schema: CoreSchema, js_function: Callable[..., Any]) -> None:
   467|         0|            0|            0|  0.00%|        metadata = CoreMetadataHandler(metadata_schema).metadata
   468|         0|            0|            0|  0.00%|        pydantic_js_functions = metadata.setdefault('pydantic_js_functions', [])
   469|         0|            0|            0|  0.00%|        # because of how we generate core schemas for nested generic models
   470|         0|            0|            0|  0.00%|        # we can end up adding `BaseModel.__get_pydantic_json_schema__` multiple times
   471|         0|            0|            0|  0.00%|        # this check may fail to catch duplicates if the function is a `functools.partial`
   472|         0|            0|            0|  0.00%|        # or something like that
   473|         0|            0|            0|  0.00%|        # but if it does it'll fail by inserting the duplicate
   474|         0|            0|            0|  0.00%|        if js_function not in pydantic_js_functions:
   475|         0|            0|            0|  0.00%|            pydantic_js_functions.append(js_function)
   476|         0|            0|            0|  0.00%|
   477|         2|  9.29832e-06|  4.64916e-06|  0.01%|    def generate_schema(
   478|         0|            0|            0|  0.00%|        self,
   479|         0|            0|            0|  0.00%|        obj: Any,
   480|         0|            0|            0|  0.00%|        from_dunder_get_core_schema: bool = True,
   481|         0|            0|            0|  0.00%|    ) -> core_schema.CoreSchema:
   482|         0|            0|            0|  0.00%|        """Generate core schema.
   483|         0|            0|            0|  0.00%|
   484|         0|            0|            0|  0.00%|        Args:
   485|         0|            0|            0|  0.00%|            obj: The object to generate core schema for.
   486|         0|            0|            0|  0.00%|            from_dunder_get_core_schema: Whether to generate schema from either the
   487|         0|            0|            0|  0.00%|                `__get_pydantic_core_schema__` function or `__pydantic_core_schema__` property.
   488|         0|            0|            0|  0.00%|
   489|         0|            0|            0|  0.00%|        Returns:
   490|         0|            0|            0|  0.00%|            The generated core schema.
   491|         0|            0|            0|  0.00%|
   492|         0|            0|            0|  0.00%|        Raises:
   493|         0|            0|            0|  0.00%|            PydanticUndefinedAnnotation:
   494|         0|            0|            0|  0.00%|                If it is not possible to evaluate forward reference.
   495|         0|            0|            0|  0.00%|            PydanticSchemaGenerationError:
   496|         0|            0|            0|  0.00%|                If it is not possible to generate pydantic-core schema.
   497|         0|            0|            0|  0.00%|            TypeError:
   498|         0|            0|            0|  0.00%|                - If `alias_generator` returns a disallowed type (must be str, AliasPath or AliasChoices).
   499|         0|            0|            0|  0.00%|                - If V1 style validator with `each_item=True` applied on a wrong field.
   500|         0|            0|            0|  0.00%|            PydanticUserError:
   501|         0|            0|            0|  0.00%|                - If `typing.TypedDict` is used instead of `typing_extensions.TypedDict` on Python < 3.12.
   502|         0|            0|            0|  0.00%|                - If `__modify_schema__` method is used instead of `__get_pydantic_json_schema__`.
   503|         0|            0|            0|  0.00%|        """
   504|         2|  5.96046e-06|  2.98023e-06|  0.01%|        schema: CoreSchema | None = None
   505|         0|            0|            0|  0.00%|
   506|         2|  6.19888e-06|  3.09944e-06|  0.01%|        if from_dunder_get_core_schema:
   507|         2|  4.17233e-05|  2.08616e-05|  0.04%|            from_property = self._generate_schema_from_property(obj, obj)
(call)|         2|   0.00128698|  0.000643492|  1.32%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:654 _generate_schema_from_property
   508|         2|  5.72205e-06|  2.86102e-06|  0.01%|            if from_property is not None:
   509|         0|            0|            0|  0.00%|                schema = from_property
   510|         0|            0|            0|  0.00%|
   511|         2|  5.48363e-06|  2.74181e-06|  0.01%|        if schema is None:
   512|         2|  2.43187e-05|  1.21593e-05|  0.02%|            schema = self._generate_schema_inner(obj)
(call)|         2|   0.00545478|   0.00272739|  5.61%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:766 _generate_schema_inner
   513|         0|            0|            0|  0.00%|
   514|         2|   1.4782e-05|  7.39098e-06|  0.02%|        metadata_js_function = _extract_get_pydantic_json_schema(obj, schema)
(call)|         2|  0.000167131|  8.35657e-05|  0.17%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:2212 _extract_get_pydantic_json_schema
   515|         2|  4.52995e-06|  2.26498e-06|  0.00%|        if metadata_js_function is not None:
   516|         0|            0|            0|  0.00%|            metadata_schema = resolve_original_schema(schema, self.defs.definitions)
   517|         0|            0|            0|  0.00%|            if metadata_schema:
   518|         0|            0|            0|  0.00%|                self._add_js_function(metadata_schema, metadata_js_function)
   519|         0|            0|            0|  0.00%|
   520|         2|  2.83718e-05|  1.41859e-05|  0.03%|        schema = _add_custom_serialization_from_json_encoders(self._config_wrapper.json_encoders, obj, schema)
(call)|         2|  1.40667e-05|  7.03335e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:361 _config_wrapper
(call)|         2|  1.66893e-05|  8.34465e-06|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_config.py:147 __getattr__
(call)|         2|   1.0252e-05|    5.126e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:251 _add_custom_serialization_from_json_encoders
   521|         0|            0|            0|  0.00%|
   522|         2|   3.8147e-06|  1.90735e-06|  0.00%|        return schema
   523|         0|            0|            0|  0.00%|
   524|         0|            0|            0|  0.00%|    def _model_schema(self, cls: type[BaseModel]) -> core_schema.CoreSchema:
   525|         0|            0|            0|  0.00%|        """Generate schema for a Pydantic model."""
   526|         0|            0|            0|  0.00%|        with self.defs.get_schema_or_ref(cls) as (model_ref, maybe_schema):
   527|         0|            0|            0|  0.00%|            if maybe_schema is not None:
   528|         0|            0|            0|  0.00%|                return maybe_schema
   529|         0|            0|            0|  0.00%|
   530|         0|            0|            0|  0.00%|            fields = cls.model_fields
   531|         0|            0|            0|  0.00%|            decorators = cls.__pydantic_decorators__
   532|         0|            0|            0|  0.00%|            computed_fields = decorators.computed_fields
   533|         0|            0|            0|  0.00%|            check_decorator_fields_exist(
   534|         0|            0|            0|  0.00%|                chain(
   535|         0|            0|            0|  0.00%|                    decorators.field_validators.values(),
   536|         0|            0|            0|  0.00%|                    decorators.field_serializers.values(),
   537|         0|            0|            0|  0.00%|                    decorators.validators.values(),
   538|         0|            0|            0|  0.00%|                ),
   539|         0|            0|            0|  0.00%|                {*fields.keys(), *computed_fields.keys()},
   540|         0|            0|            0|  0.00%|            )
   541|         0|            0|            0|  0.00%|            config_wrapper = ConfigWrapper(cls.model_config, check=False)
   542|         0|            0|            0|  0.00%|            core_config = config_wrapper.core_config(cls)
   543|         0|            0|            0|  0.00%|            title = self._get_model_title_from_config(cls, config_wrapper)
   544|         0|            0|            0|  0.00%|            metadata = build_metadata_dict(js_functions=[partial(modify_model_json_schema, cls=cls, title=title)])
   545|         0|            0|            0|  0.00%|
   546|         0|            0|            0|  0.00%|            model_validators = decorators.model_validators.values()
   547|         0|            0|            0|  0.00%|
   548|         0|            0|            0|  0.00%|            extras_schema = None
   549|         0|            0|            0|  0.00%|            if core_config.get('extra_fields_behavior') == 'allow':
   550|         0|            0|            0|  0.00%|                assert cls.__mro__[0] is cls
   551|         0|            0|            0|  0.00%|                assert cls.__mro__[-1] is object
   552|         0|            0|            0|  0.00%|                for candidate_cls in cls.__mro__[:-1]:
   553|         0|            0|            0|  0.00%|                    extras_annotation = getattr(candidate_cls, '__annotations__', {}).get('__pydantic_extra__', None)
   554|         0|            0|            0|  0.00%|                    if extras_annotation is not None:
   555|         0|            0|            0|  0.00%|                        if isinstance(extras_annotation, str):
   556|         0|            0|            0|  0.00%|                            extras_annotation = _typing_extra.eval_type_backport(
   557|         0|            0|            0|  0.00%|                                _typing_extra._make_forward_ref(extras_annotation, is_argument=False, is_class=True),
   558|         0|            0|            0|  0.00%|                                self._types_namespace,
   559|         0|            0|            0|  0.00%|                            )
   560|         0|            0|            0|  0.00%|                        tp = get_origin(extras_annotation)
   561|         0|            0|            0|  0.00%|                        if tp not in (Dict, dict):
   562|         0|            0|            0|  0.00%|                            raise PydanticSchemaGenerationError(
   563|         0|            0|            0|  0.00%|                                'The type annotation for `__pydantic_extra__` must be `Dict[str, ...]`'
   564|         0|            0|            0|  0.00%|                            )
   565|         0|            0|            0|  0.00%|                        extra_items_type = self._get_args_resolving_forward_refs(
   566|         0|            0|            0|  0.00%|                            extras_annotation,
   567|         0|            0|            0|  0.00%|                            required=True,
   568|         0|            0|            0|  0.00%|                        )[1]
   569|         0|            0|            0|  0.00%|                        if extra_items_type is not Any:
   570|         0|            0|            0|  0.00%|                            extras_schema = self.generate_schema(extra_items_type)
   571|         0|            0|            0|  0.00%|                            break
   572|         0|            0|            0|  0.00%|
   573|         0|            0|            0|  0.00%|            with self._config_wrapper_stack.push(config_wrapper), self._types_namespace_stack.push(cls):
   574|         0|            0|            0|  0.00%|                self = self._current_generate_schema
   575|         0|            0|            0|  0.00%|                if cls.__pydantic_root_model__:
   576|         0|            0|            0|  0.00%|                    root_field = self._common_field_schema('root', fields['root'], decorators)
   577|         0|            0|            0|  0.00%|                    inner_schema = root_field['schema']
   578|         0|            0|            0|  0.00%|                    inner_schema = apply_model_validators(inner_schema, model_validators, 'inner')
   579|         0|            0|            0|  0.00%|                    model_schema = core_schema.model_schema(
   580|         0|            0|            0|  0.00%|                        cls,
   581|         0|            0|            0|  0.00%|                        inner_schema,
   582|         0|            0|            0|  0.00%|                        custom_init=getattr(cls, '__pydantic_custom_init__', None),
   583|         0|            0|            0|  0.00%|                        root_model=True,
   584|         0|            0|            0|  0.00%|                        post_init=getattr(cls, '__pydantic_post_init__', None),
   585|         0|            0|            0|  0.00%|                        config=core_config,
   586|         0|            0|            0|  0.00%|                        ref=model_ref,
   587|         0|            0|            0|  0.00%|                        metadata=metadata,
   588|         0|            0|            0|  0.00%|                    )
   589|         0|            0|            0|  0.00%|                else:
   590|         0|            0|            0|  0.00%|                    fields_schema: core_schema.CoreSchema = core_schema.model_fields_schema(
   591|         0|            0|            0|  0.00%|                        {k: self._generate_md_field_schema(k, v, decorators) for k, v in fields.items()},
   592|         0|            0|            0|  0.00%|                        computed_fields=[
   593|         0|            0|            0|  0.00%|                            self._computed_field_schema(d, decorators.field_serializers)
   594|         0|            0|            0|  0.00%|                            for d in computed_fields.values()
   595|         0|            0|            0|  0.00%|                        ],
   596|         0|            0|            0|  0.00%|                        extras_schema=extras_schema,
   597|         0|            0|            0|  0.00%|                        model_name=cls.__name__,
   598|         0|            0|            0|  0.00%|                    )
   599|         0|            0|            0|  0.00%|                    inner_schema = apply_validators(fields_schema, decorators.root_validators.values(), None)
   600|         0|            0|            0|  0.00%|                    new_inner_schema = define_expected_missing_refs(inner_schema, recursively_defined_type_refs())
   601|         0|            0|            0|  0.00%|                    if new_inner_schema is not None:
   602|         0|            0|            0|  0.00%|                        inner_schema = new_inner_schema
   603|         0|            0|            0|  0.00%|                    inner_schema = apply_model_validators(inner_schema, model_validators, 'inner')
   604|         0|            0|            0|  0.00%|
   605|         0|            0|            0|  0.00%|                    model_schema = core_schema.model_schema(
   606|         0|            0|            0|  0.00%|                        cls,
   607|         0|            0|            0|  0.00%|                        inner_schema,
   608|         0|            0|            0|  0.00%|                        custom_init=getattr(cls, '__pydantic_custom_init__', None),
   609|         0|            0|            0|  0.00%|                        root_model=False,
   610|         0|            0|            0|  0.00%|                        post_init=getattr(cls, '__pydantic_post_init__', None),
   611|         0|            0|            0|  0.00%|                        config=core_config,
   612|         0|            0|            0|  0.00%|                        ref=model_ref,
   613|         0|            0|            0|  0.00%|                        metadata=metadata,
   614|         0|            0|            0|  0.00%|                    )
   615|         0|            0|            0|  0.00%|
   616|         0|            0|            0|  0.00%|                schema = self._apply_model_serializers(model_schema, decorators.model_serializers.values())
   617|         0|            0|            0|  0.00%|                schema = apply_model_validators(schema, model_validators, 'outer')
   618|         0|            0|            0|  0.00%|                self.defs.definitions[model_ref] = schema
   619|         0|            0|            0|  0.00%|                return core_schema.definition_reference_schema(model_ref)
   620|         0|            0|            0|  0.00%|
   621|         0|            0|            0|  0.00%|    @staticmethod
   622|         0|            0|            0|  0.00%|    def _get_model_title_from_config(
   623|         0|            0|            0|  0.00%|        model: type[BaseModel | StandardDataclass], config_wrapper: ConfigWrapper | None = None
   624|         0|            0|            0|  0.00%|    ) -> str | None:
   625|         0|            0|            0|  0.00%|        """Get the title of a model if `model_title_generator` or `title` are set in the config, else return None"""
   626|         0|            0|            0|  0.00%|        if config_wrapper is None:
   627|         0|            0|            0|  0.00%|            return None
   628|         0|            0|            0|  0.00%|
   629|         0|            0|            0|  0.00%|        if config_wrapper.title:
   630|         0|            0|            0|  0.00%|            return config_wrapper.title
   631|         0|            0|            0|  0.00%|
   632|         0|            0|            0|  0.00%|        model_title_generator = config_wrapper.model_title_generator
   633|         0|            0|            0|  0.00%|        if model_title_generator:
   634|         0|            0|            0|  0.00%|            title = model_title_generator(model)
   635|         0|            0|            0|  0.00%|            if not isinstance(title, str):
   636|         0|            0|            0|  0.00%|                raise TypeError(f'model_title_generator {model_title_generator} must return str, not {title.__class__}')
   637|         0|            0|            0|  0.00%|            return title
   638|         0|            0|            0|  0.00%|
   639|         0|            0|            0|  0.00%|        return None
   640|         0|            0|            0|  0.00%|
   641|         0|            0|            0|  0.00%|    def _unpack_refs_defs(self, schema: CoreSchema) -> CoreSchema:
   642|         0|            0|            0|  0.00%|        """Unpack all 'definitions' schemas into `GenerateSchema.defs.definitions`
   643|         0|            0|            0|  0.00%|        and return the inner schema.
   644|         0|            0|            0|  0.00%|        """
   645|         0|            0|            0|  0.00%|
   646|         0|            0|            0|  0.00%|        def get_ref(s: CoreSchema) -> str:
   647|         0|            0|            0|  0.00%|            return s['ref']  # type: ignore
   648|         0|            0|            0|  0.00%|
   649|         0|            0|            0|  0.00%|        if schema['type'] == 'definitions':
   650|         0|            0|            0|  0.00%|            self.defs.definitions.update({get_ref(s): s for s in schema['definitions']})
   651|         0|            0|            0|  0.00%|            schema = schema['schema']
   652|         0|            0|            0|  0.00%|        return schema
   653|         0|            0|            0|  0.00%|
   654|         4|   2.3365e-05|  5.84126e-06|  0.02%|    def _generate_schema_from_property(self, obj: Any, source: Any) -> core_schema.CoreSchema | None:
   655|         0|            0|            0|  0.00%|        """Try to generate schema from either the `__get_pydantic_core_schema__` function or
   656|         0|            0|            0|  0.00%|        `__pydantic_core_schema__` property.
   657|         0|            0|            0|  0.00%|
   658|         0|            0|            0|  0.00%|        Note: `__get_pydantic_core_schema__` takes priority so it can
   659|         0|            0|            0|  0.00%|        decide whether to use a `__pydantic_core_schema__` attribute, or generate a fresh schema.
   660|         0|            0|            0|  0.00%|        """
   661|         0|            0|            0|  0.00%|        # avoid calling `__get_pydantic_core_schema__` if we've already visited this object
   662|         4|  3.98159e-05|  9.95398e-06|  0.04%|        if is_self_type(obj):
(call)|         4|  2.64645e-05|  6.61612e-06|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_typing_extra.py:506 is_self_type
   663|         0|            0|            0|  0.00%|            obj = self.model_type_stack.get()
   664|         8|  0.000150442|  1.88053e-05|  0.15%|        with self.defs.get_schema_or_ref(obj) as (_, maybe_schema):
(call)|         4|  8.03471e-05|  2.00868e-05|  0.08%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/contextlib.py:299 helper
(call)|         4|  0.000912666|  0.000228167|  0.94%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/contextlib.py:132 __enter__
(call)|         4|  0.000140667|  3.51667e-05|  0.14%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/contextlib.py:141 __exit__
   665|         4|  1.33514e-05|  3.33786e-06|  0.01%|            if maybe_schema is not None:
   666|         0|            0|            0|  0.00%|                return maybe_schema
   667|         4|  1.19209e-05|  2.98023e-06|  0.01%|        if obj is source:
   668|         4|  1.35899e-05|  3.39746e-06|  0.01%|            ref_mode = 'unpack'
   669|         0|            0|            0|  0.00%|        else:
   670|         0|            0|            0|  0.00%|            ref_mode = 'to-def'
   671|         0|            0|            0|  0.00%|
   672|         0|            0|            0|  0.00%|        schema: CoreSchema
   673|         0|            0|            0|  0.00%|
   674|         4|  3.31402e-05|  8.28505e-06|  0.03%|        if (get_schema := getattr(obj, '__get_pydantic_core_schema__', None)) is not None:
(call)|         2|  5.65052e-05|  2.82526e-05|  0.06%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:2025 __getattr__
   675|         0|            0|            0|  0.00%|            if len(inspect.signature(get_schema).parameters) == 1:
   676|         0|            0|            0|  0.00%|                # (source) -> CoreSchema
   677|         0|            0|            0|  0.00%|                schema = get_schema(source)
   678|         0|            0|            0|  0.00%|            else:
   679|         0|            0|            0|  0.00%|                schema = get_schema(
   680|         0|            0|            0|  0.00%|                    source, CallbackGetCoreSchemaHandler(self._generate_schema_inner, self, ref_mode=ref_mode)
   681|         0|            0|            0|  0.00%|                )
   682|         0|            0|            0|  0.00%|        # fmt: off
   683|         0|            0|            0|  0.00%|        elif (
   684|         4|  4.00543e-05|  1.00136e-05|  0.04%|            (existing_schema := getattr(obj, '__pydantic_core_schema__', None)) is not None
(call)|         2|   6.4373e-05|  3.21865e-05|  0.07%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:2025 __getattr__
   685|         0|            0|            0|  0.00%|            and not isinstance(existing_schema, MockCoreSchema)
   686|         0|            0|            0|  0.00%|            and existing_schema.get('cls', None) == obj
   687|         0|            0|            0|  0.00%|        ):
   688|         0|            0|            0|  0.00%|            schema = existing_schema
   689|         0|            0|            0|  0.00%|        # fmt: on
   690|         4|  3.24249e-05|  8.10623e-06|  0.03%|        elif (validators := getattr(obj, '__get_validators__', None)) is not None:
(call)|         2|  6.00815e-05|  3.00407e-05|  0.06%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:2025 __getattr__
   691|         0|            0|            0|  0.00%|            warn(
   692|         0|            0|            0|  0.00%|                '`__get_validators__` is deprecated and will be removed, use `__get_pydantic_core_schema__` instead.',
   693|         0|            0|            0|  0.00%|                PydanticDeprecatedSince20,
   694|         0|            0|            0|  0.00%|            )
   695|         0|            0|            0|  0.00%|            schema = core_schema.chain_schema([core_schema.with_info_plain_validator_function(v) for v in validators()])
   696|         0|            0|            0|  0.00%|        else:
   697|         0|            0|            0|  0.00%|            # we have no existing schema information on the property, exit early so that we can go generate a schema
   698|         4|  1.28746e-05|  3.21865e-06|  0.01%|            return None
   699|         0|            0|            0|  0.00%|
   700|         0|            0|            0|  0.00%|        schema = self._unpack_refs_defs(schema)
   701|         0|            0|            0|  0.00%|
   702|         0|            0|            0|  0.00%|        if is_function_with_inner_schema(schema):
   703|         0|            0|            0|  0.00%|            ref = schema['schema'].pop('ref', None)  # pyright: ignore[reportCallIssue, reportArgumentType]
   704|         0|            0|            0|  0.00%|            if ref:
   705|         0|            0|            0|  0.00%|                schema['ref'] = ref
   706|         0|            0|            0|  0.00%|        else:
   707|         0|            0|            0|  0.00%|            ref = get_ref(schema)
   708|         0|            0|            0|  0.00%|
   709|         0|            0|            0|  0.00%|        if ref:
   710|         0|            0|            0|  0.00%|            self.defs.definitions[ref] = schema
   711|         0|            0|            0|  0.00%|            return core_schema.definition_reference_schema(ref)
   712|         0|            0|            0|  0.00%|
   713|         0|            0|            0|  0.00%|        return schema
   714|         0|            0|            0|  0.00%|
   715|         0|            0|            0|  0.00%|    def _resolve_forward_ref(self, obj: Any) -> Any:
   716|         0|            0|            0|  0.00%|        # we assume that types_namespace has the target of forward references in its scope,
   717|         0|            0|            0|  0.00%|        # but this could fail, for example, if calling Validator on an imported type which contains
   718|         0|            0|            0|  0.00%|        # forward references to other types only defined in the module from which it was imported
   719|         0|            0|            0|  0.00%|        # `Validator(SomeImportedTypeAliasWithAForwardReference)`
   720|         0|            0|            0|  0.00%|        # or the equivalent for BaseModel
   721|         0|            0|            0|  0.00%|        # class Model(BaseModel):
   722|         0|            0|            0|  0.00%|        #   x: SomeImportedTypeAliasWithAForwardReference
   723|         0|            0|            0|  0.00%|        try:
   724|         0|            0|            0|  0.00%|            obj = _typing_extra.eval_type_backport(obj, globalns=self._types_namespace)
   725|         0|            0|            0|  0.00%|        except NameError as e:
   726|         0|            0|            0|  0.00%|            raise PydanticUndefinedAnnotation.from_name_error(e) from e
   727|         0|            0|            0|  0.00%|
   728|         0|            0|            0|  0.00%|        # if obj is still a ForwardRef, it means we can't evaluate it, raise PydanticUndefinedAnnotation
   729|         0|            0|            0|  0.00%|        if isinstance(obj, ForwardRef):
   730|         0|            0|            0|  0.00%|            raise PydanticUndefinedAnnotation(obj.__forward_arg__, f'Unable to evaluate forward reference {obj}')
   731|         0|            0|            0|  0.00%|
   732|         0|            0|            0|  0.00%|        if self._typevars_map:
   733|         0|            0|            0|  0.00%|            obj = replace_types(obj, self._typevars_map)
   734|         0|            0|            0|  0.00%|
   735|         0|            0|            0|  0.00%|        return obj
   736|         0|            0|            0|  0.00%|
   737|         0|            0|            0|  0.00%|    @overload
   738|         0|            0|            0|  0.00%|    def _get_args_resolving_forward_refs(self, obj: Any, required: Literal[True]) -> tuple[Any, ...]: ...
   739|         0|            0|            0|  0.00%|
   740|         0|            0|            0|  0.00%|    @overload
   741|         0|            0|            0|  0.00%|    def _get_args_resolving_forward_refs(self, obj: Any) -> tuple[Any, ...] | None: ...
   742|         0|            0|            0|  0.00%|
   743|         2|  5.00679e-06|   2.5034e-06|  0.01%|    def _get_args_resolving_forward_refs(self, obj: Any, required: bool = False) -> tuple[Any, ...] | None:
   744|         2|  3.43323e-05|  1.71661e-05|  0.04%|        args = get_args(obj)
(call)|         2|  1.26362e-05|  6.31809e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:2340 get_args
   745|         2|  3.57628e-06|  1.78814e-06|  0.00%|        if args:
   746|         6|   1.3113e-05|   2.1855e-06|  0.01%|            args = tuple([self._resolve_forward_ref(a) if isinstance(a, ForwardRef) else a for a in args])
   747|         0|            0|            0|  0.00%|        elif required:  # pragma: no cover
   748|         0|            0|            0|  0.00%|            raise TypeError(f'Expected {obj} to have generic parameters but it had none')
   749|         2|   2.6226e-06|   1.3113e-06|  0.00%|        return args
   750|         0|            0|            0|  0.00%|
   751|         0|            0|            0|  0.00%|    def _get_first_arg_or_any(self, obj: Any) -> Any:
   752|         0|            0|            0|  0.00%|        args = self._get_args_resolving_forward_refs(obj)
   753|         0|            0|            0|  0.00%|        if not args:
   754|         0|            0|            0|  0.00%|            return Any
   755|         0|            0|            0|  0.00%|        return args[0]
   756|         0|            0|            0|  0.00%|
   757|         0|            0|            0|  0.00%|    def _get_first_two_args_or_any(self, obj: Any) -> tuple[Any, Any]:
   758|         0|            0|            0|  0.00%|        args = self._get_args_resolving_forward_refs(obj)
   759|         0|            0|            0|  0.00%|        if not args:
   760|         0|            0|            0|  0.00%|            return (Any, Any)
   761|         0|            0|            0|  0.00%|        if len(args) < 2:
   762|         0|            0|            0|  0.00%|            origin = get_origin(obj)
   763|         0|            0|            0|  0.00%|            raise TypeError(f'Expected two type arguments for {origin}, got 1')
   764|         0|            0|            0|  0.00%|        return args[0], args[1]
   765|         0|            0|            0|  0.00%|
   766|         4|  1.69277e-05|  4.23193e-06|  0.02%|    def _generate_schema_inner(self, obj: Any) -> core_schema.CoreSchema:
   767|         4|  1.07288e-05|  2.68221e-06|  0.01%|        if isinstance(obj, _AnnotatedType):
   768|         2|  2.12193e-05|  1.06096e-05|  0.02%|            return self._annotated_schema(obj)
(call)|         2|   0.00541592|   0.00270796|  5.57%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:1814 _annotated_schema
   769|         0|            0|            0|  0.00%|
   770|         2|  3.33786e-06|  1.66893e-06|  0.00%|        if isinstance(obj, dict):
   771|         0|            0|            0|  0.00%|            # we assume this is already a valid schema
   772|         0|            0|            0|  0.00%|            return obj  # type: ignore[return-value]
   773|         0|            0|            0|  0.00%|
   774|         2|  4.76837e-06|  2.38419e-06|  0.00%|        if isinstance(obj, str):
   775|         0|            0|            0|  0.00%|            obj = ForwardRef(obj)
   776|         0|            0|            0|  0.00%|
   777|         2|  4.29153e-06|  2.14577e-06|  0.00%|        if isinstance(obj, ForwardRef):
   778|         0|            0|            0|  0.00%|            return self.generate_schema(self._resolve_forward_ref(obj))
   779|         0|            0|            0|  0.00%|
   780|         2|  4.52995e-05|  2.26498e-05|  0.05%|        from ..main import BaseModel
(call)|         2|  1.21593e-05|  6.07967e-06|  0.01%|# <frozen importlib._bootstrap>:645 parent
(call)|         2|  2.71797e-05|  1.35899e-05|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_migration.py:262 wrapper
   781|         0|            0|            0|  0.00%|
   782|         2|  1.52588e-05|  7.62939e-06|  0.02%|        if lenient_issubclass(obj, BaseModel):
(call)|         2|  2.74181e-05|  1.37091e-05|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_utils.py:75 lenient_issubclass
   783|         0|            0|            0|  0.00%|            with self.model_type_stack.push(obj):
   784|         0|            0|            0|  0.00%|                return self._model_schema(obj)
   785|         0|            0|            0|  0.00%|
   786|         2|  5.48363e-06|  2.74181e-06|  0.01%|        if isinstance(obj, PydanticRecursiveRef):
   787|         0|            0|            0|  0.00%|            return core_schema.definition_reference_schema(schema_ref=obj.type_ref)
   788|         0|            0|            0|  0.00%|
   789|         2|   4.8399e-05|  2.41995e-05|  0.05%|        return self.match_type(obj)
(call)|         2|  0.000181675|  9.08375e-05|  0.19%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:791 match_type
   790|         0|            0|            0|  0.00%|
   791|         2|  1.54972e-05|   7.7486e-06|  0.02%|    def match_type(self, obj: Any) -> core_schema.CoreSchema:  # noqa: C901
   792|         0|            0|            0|  0.00%|        """Main mapping of types to schemas.
   793|         0|            0|            0|  0.00%|
   794|         0|            0|            0|  0.00%|        The general structure is a series of if statements starting with the simple cases
   795|         0|            0|            0|  0.00%|        (non-generic primitive types) and then handling generics and other more complex cases.
   796|         0|            0|            0|  0.00%|
   797|         0|            0|            0|  0.00%|        Each case either generates a schema directly, calls into a public user-overridable method
   798|         0|            0|            0|  0.00%|        (like `GenerateSchema.tuple_variable_schema`) or calls into a private method that handles some
   799|         0|            0|            0|  0.00%|        boilerplate before calling into the user-facing method (e.g. `GenerateSchema._tuple_schema`).
   800|         0|            0|            0|  0.00%|
   801|         0|            0|            0|  0.00%|        The idea is that we'll evolve this into adding more and more user facing methods over time
   802|         0|            0|            0|  0.00%|        as they get requested and we figure out what the right API for them is.
   803|         0|            0|            0|  0.00%|        """
   804|         2|  1.26362e-05|  6.31809e-06|  0.01%|        if obj is str:
   805|         2|   2.7895e-05|  1.39475e-05|  0.03%|            return self.str_schema()
(call)|         2|  0.000125647|  6.28233e-05|  0.13%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:384 str_schema
   806|         0|            0|            0|  0.00%|        elif obj is bytes:
   807|         0|            0|            0|  0.00%|            return core_schema.bytes_schema()
   808|         0|            0|            0|  0.00%|        elif obj is int:
   809|         0|            0|            0|  0.00%|            return core_schema.int_schema()
   810|         0|            0|            0|  0.00%|        elif obj is float:
   811|         0|            0|            0|  0.00%|            return core_schema.float_schema()
   812|         0|            0|            0|  0.00%|        elif obj is bool:
   813|         0|            0|            0|  0.00%|            return core_schema.bool_schema()
   814|         0|            0|            0|  0.00%|        elif obj is Any or obj is object:
   815|         0|            0|            0|  0.00%|            return core_schema.any_schema()
   816|         0|            0|            0|  0.00%|        elif obj is None or obj is _typing_extra.NoneType:
   817|         0|            0|            0|  0.00%|            return core_schema.none_schema()
   818|         0|            0|            0|  0.00%|        elif obj in TUPLE_TYPES:
   819|         0|            0|            0|  0.00%|            return self._tuple_schema(obj)
   820|         0|            0|            0|  0.00%|        elif obj in LIST_TYPES:
   821|         0|            0|            0|  0.00%|            return self._list_schema(obj, self._get_first_arg_or_any(obj))
   822|         0|            0|            0|  0.00%|        elif obj in SET_TYPES:
   823|         0|            0|            0|  0.00%|            return self._set_schema(obj, self._get_first_arg_or_any(obj))
   824|         0|            0|            0|  0.00%|        elif obj in FROZEN_SET_TYPES:
   825|         0|            0|            0|  0.00%|            return self._frozenset_schema(obj, self._get_first_arg_or_any(obj))
   826|         0|            0|            0|  0.00%|        elif obj in DICT_TYPES:
   827|         0|            0|            0|  0.00%|            return self._dict_schema(obj, *self._get_first_two_args_or_any(obj))
   828|         0|            0|            0|  0.00%|        elif isinstance(obj, TypeAliasType):
   829|         0|            0|            0|  0.00%|            return self._type_alias_type_schema(obj)
   830|         0|            0|            0|  0.00%|        elif obj is type:
   831|         0|            0|            0|  0.00%|            return self._type_schema()
   832|         0|            0|            0|  0.00%|        elif _typing_extra.is_callable_type(obj):
   833|         0|            0|            0|  0.00%|            return core_schema.callable_schema()
   834|         0|            0|            0|  0.00%|        elif _typing_extra.is_literal_type(obj):
   835|         0|            0|            0|  0.00%|            return self._literal_schema(obj)
   836|         0|            0|            0|  0.00%|        elif is_typeddict(obj):
   837|         0|            0|            0|  0.00%|            return self._typed_dict_schema(obj, None)
   838|         0|            0|            0|  0.00%|        elif _typing_extra.is_namedtuple(obj):
   839|         0|            0|            0|  0.00%|            return self._namedtuple_schema(obj, None)
   840|         0|            0|            0|  0.00%|        elif _typing_extra.is_new_type(obj):
   841|         0|            0|            0|  0.00%|            # NewType, can't use isinstance because it fails <3.10
   842|         0|            0|            0|  0.00%|            return self.generate_schema(obj.__supertype__)
   843|         0|            0|            0|  0.00%|        elif obj == re.Pattern:
   844|         0|            0|            0|  0.00%|            return self._pattern_schema(obj)
   845|         0|            0|            0|  0.00%|        elif obj is collections.abc.Hashable or obj is typing.Hashable:
   846|         0|            0|            0|  0.00%|            return self._hashable_schema()
   847|         0|            0|            0|  0.00%|        elif isinstance(obj, typing.TypeVar):
   848|         0|            0|            0|  0.00%|            return self._unsubstituted_typevar_schema(obj)
   849|         0|            0|            0|  0.00%|        elif is_finalvar(obj):
   850|         0|            0|            0|  0.00%|            if obj is Final:
   851|         0|            0|            0|  0.00%|                return core_schema.any_schema()
   852|         0|            0|            0|  0.00%|            return self.generate_schema(
   853|         0|            0|            0|  0.00%|                self._get_first_arg_or_any(obj),
   854|         0|            0|            0|  0.00%|            )
   855|         0|            0|            0|  0.00%|        elif isinstance(obj, (FunctionType, LambdaType, MethodType, partial)):
   856|         0|            0|            0|  0.00%|            return self._callable_schema(obj)
   857|         0|            0|            0|  0.00%|        elif inspect.isclass(obj) and issubclass(obj, Enum):
   858|         0|            0|            0|  0.00%|            from ._std_types_schema import get_enum_core_schema
   859|         0|            0|            0|  0.00%|
   860|         0|            0|            0|  0.00%|            return get_enum_core_schema(obj, self._config_wrapper.config_dict)
   861|         0|            0|            0|  0.00%|
   862|         0|            0|            0|  0.00%|        if _typing_extra.is_dataclass(obj):
   863|         0|            0|            0|  0.00%|            return self._dataclass_schema(obj, None)
   864|         0|            0|            0|  0.00%|        res = self._get_prepare_pydantic_annotations_for_known_type(obj, ())
   865|         0|            0|            0|  0.00%|        if res is not None:
   866|         0|            0|            0|  0.00%|            source_type, annotations = res
   867|         0|            0|            0|  0.00%|            return self._apply_annotations(source_type, annotations)
   868|         0|            0|            0|  0.00%|
   869|         0|            0|            0|  0.00%|        origin = get_origin(obj)
   870|         0|            0|            0|  0.00%|        if origin is not None:
   871|         0|            0|            0|  0.00%|            return self._match_generic_type(obj, origin)
   872|         0|            0|            0|  0.00%|
   873|         0|            0|            0|  0.00%|        if self._arbitrary_types:
   874|         0|            0|            0|  0.00%|            return self._arbitrary_type_schema(obj)
   875|         0|            0|            0|  0.00%|        return self._unknown_type_schema(obj)
   876|         0|            0|            0|  0.00%|
   877|         0|            0|            0|  0.00%|    def _match_generic_type(self, obj: Any, origin: Any) -> CoreSchema:  # noqa: C901
   878|         0|            0|            0|  0.00%|        if isinstance(origin, TypeAliasType):
   879|         0|            0|            0|  0.00%|            return self._type_alias_type_schema(obj)
   880|         0|            0|            0|  0.00%|
   881|         0|            0|            0|  0.00%|        # Need to handle generic dataclasses before looking for the schema properties because attribute accesses
   882|         0|            0|            0|  0.00%|        # on _GenericAlias delegate to the origin type, so lose the information about the concrete parametrization
   883|         0|            0|            0|  0.00%|        # As a result, currently, there is no way to cache the schema for generic dataclasses. This may be possible
   884|         0|            0|            0|  0.00%|        # to resolve by modifying the value returned by `Generic.__class_getitem__`, but that is a dangerous game.
   885|         0|            0|            0|  0.00%|        if _typing_extra.is_dataclass(origin):
   886|         0|            0|            0|  0.00%|            return self._dataclass_schema(obj, origin)
   887|         0|            0|            0|  0.00%|        if _typing_extra.is_namedtuple(origin):
   888|         0|            0|            0|  0.00%|            return self._namedtuple_schema(obj, origin)
   889|         0|            0|            0|  0.00%|
   890|         0|            0|            0|  0.00%|        from_property = self._generate_schema_from_property(origin, obj)
   891|         0|            0|            0|  0.00%|        if from_property is not None:
   892|         0|            0|            0|  0.00%|            return from_property
   893|         0|            0|            0|  0.00%|
   894|         0|            0|            0|  0.00%|        if _typing_extra.origin_is_union(origin):
   895|         0|            0|            0|  0.00%|            return self._union_schema(obj)
   896|         0|            0|            0|  0.00%|        elif origin in TUPLE_TYPES:
   897|         0|            0|            0|  0.00%|            return self._tuple_schema(obj)
   898|         0|            0|            0|  0.00%|        elif origin in LIST_TYPES:
   899|         0|            0|            0|  0.00%|            return self._list_schema(obj, self._get_first_arg_or_any(obj))
   900|         0|            0|            0|  0.00%|        elif origin in SET_TYPES:
   901|         0|            0|            0|  0.00%|            return self._set_schema(obj, self._get_first_arg_or_any(obj))
   902|         0|            0|            0|  0.00%|        elif origin in FROZEN_SET_TYPES:
   903|         0|            0|            0|  0.00%|            return self._frozenset_schema(obj, self._get_first_arg_or_any(obj))
   904|         0|            0|            0|  0.00%|        elif origin in DICT_TYPES:
   905|         0|            0|            0|  0.00%|            return self._dict_schema(obj, *self._get_first_two_args_or_any(obj))
   906|         0|            0|            0|  0.00%|        elif is_typeddict(origin):
   907|         0|            0|            0|  0.00%|            return self._typed_dict_schema(obj, origin)
   908|         0|            0|            0|  0.00%|        elif origin in (typing.Type, type):
   909|         0|            0|            0|  0.00%|            return self._subclass_schema(obj)
   910|         0|            0|            0|  0.00%|        elif origin in {typing.Sequence, collections.abc.Sequence}:
   911|         0|            0|            0|  0.00%|            return self._sequence_schema(obj)
   912|         0|            0|            0|  0.00%|        elif origin in {typing.Iterable, collections.abc.Iterable, typing.Generator, collections.abc.Generator}:
   913|         0|            0|            0|  0.00%|            return self._iterable_schema(obj)
   914|         0|            0|            0|  0.00%|        elif origin in (re.Pattern, typing.Pattern):
   915|         0|            0|            0|  0.00%|            return self._pattern_schema(obj)
   916|         0|            0|            0|  0.00%|
   917|         0|            0|            0|  0.00%|        if self._arbitrary_types:
   918|         0|            0|            0|  0.00%|            return self._arbitrary_type_schema(origin)
   919|         0|            0|            0|  0.00%|        return self._unknown_type_schema(obj)
   920|         0|            0|            0|  0.00%|
   921|         0|            0|            0|  0.00%|    def _generate_td_field_schema(
   922|         0|            0|            0|  0.00%|        self,
   923|         0|            0|            0|  0.00%|        name: str,
   924|         0|            0|            0|  0.00%|        field_info: FieldInfo,
   925|         0|            0|            0|  0.00%|        decorators: DecoratorInfos,
   926|         0|            0|            0|  0.00%|        *,
   927|         0|            0|            0|  0.00%|        required: bool = True,
   928|         0|            0|            0|  0.00%|    ) -> core_schema.TypedDictField:
   929|         0|            0|            0|  0.00%|        """Prepare a TypedDictField to represent a model or typeddict field."""
   930|         0|            0|            0|  0.00%|        common_field = self._common_field_schema(name, field_info, decorators)
   931|         0|            0|            0|  0.00%|        return core_schema.typed_dict_field(
   932|         0|            0|            0|  0.00%|            common_field['schema'],
   933|         0|            0|            0|  0.00%|            required=False if not field_info.is_required() else required,
   934|         0|            0|            0|  0.00%|            serialization_exclude=common_field['serialization_exclude'],
   935|         0|            0|            0|  0.00%|            validation_alias=common_field['validation_alias'],
   936|         0|            0|            0|  0.00%|            serialization_alias=common_field['serialization_alias'],
   937|         0|            0|            0|  0.00%|            metadata=common_field['metadata'],
   938|         0|            0|            0|  0.00%|        )
   939|         0|            0|            0|  0.00%|
   940|         0|            0|            0|  0.00%|    def _generate_md_field_schema(
   941|         0|            0|            0|  0.00%|        self,
   942|         0|            0|            0|  0.00%|        name: str,
   943|         0|            0|            0|  0.00%|        field_info: FieldInfo,
   944|         0|            0|            0|  0.00%|        decorators: DecoratorInfos,
   945|         0|            0|            0|  0.00%|    ) -> core_schema.ModelField:
   946|         0|            0|            0|  0.00%|        """Prepare a ModelField to represent a model field."""
   947|         0|            0|            0|  0.00%|        common_field = self._common_field_schema(name, field_info, decorators)
   948|         0|            0|            0|  0.00%|        return core_schema.model_field(
   949|         0|            0|            0|  0.00%|            common_field['schema'],
   950|         0|            0|            0|  0.00%|            serialization_exclude=common_field['serialization_exclude'],
   951|         0|            0|            0|  0.00%|            validation_alias=common_field['validation_alias'],
   952|         0|            0|            0|  0.00%|            serialization_alias=common_field['serialization_alias'],
   953|         0|            0|            0|  0.00%|            frozen=common_field['frozen'],
   954|         0|            0|            0|  0.00%|            metadata=common_field['metadata'],
   955|         0|            0|            0|  0.00%|        )
   956|         0|            0|            0|  0.00%|
   957|         0|            0|            0|  0.00%|    def _generate_dc_field_schema(
   958|         0|            0|            0|  0.00%|        self,
   959|         0|            0|            0|  0.00%|        name: str,
   960|         0|            0|            0|  0.00%|        field_info: FieldInfo,
   961|         0|            0|            0|  0.00%|        decorators: DecoratorInfos,
   962|         0|            0|            0|  0.00%|    ) -> core_schema.DataclassField:
   963|         0|            0|            0|  0.00%|        """Prepare a DataclassField to represent the parameter/field, of a dataclass."""
   964|         0|            0|            0|  0.00%|        common_field = self._common_field_schema(name, field_info, decorators)
   965|         0|            0|            0|  0.00%|        return core_schema.dataclass_field(
   966|         0|            0|            0|  0.00%|            name,
   967|         0|            0|            0|  0.00%|            common_field['schema'],
   968|         0|            0|            0|  0.00%|            init=field_info.init,
   969|         0|            0|            0|  0.00%|            init_only=field_info.init_var or None,
   970|         0|            0|            0|  0.00%|            kw_only=None if field_info.kw_only else False,
   971|         0|            0|            0|  0.00%|            serialization_exclude=common_field['serialization_exclude'],
   972|         0|            0|            0|  0.00%|            validation_alias=common_field['validation_alias'],
   973|         0|            0|            0|  0.00%|            serialization_alias=common_field['serialization_alias'],
   974|         0|            0|            0|  0.00%|            frozen=common_field['frozen'],
   975|         0|            0|            0|  0.00%|            metadata=common_field['metadata'],
   976|         0|            0|            0|  0.00%|        )
   977|         0|            0|            0|  0.00%|
   978|         0|            0|            0|  0.00%|    @staticmethod
   979|         0|            0|            0|  0.00%|    def _apply_alias_generator_to_field_info(
   980|         0|            0|            0|  0.00%|        alias_generator: Callable[[str], str] | AliasGenerator, field_info: FieldInfo, field_name: str
   981|         0|            0|            0|  0.00%|    ) -> None:
   982|         0|            0|            0|  0.00%|        """Apply an alias_generator to aliases on a FieldInfo instance if appropriate.
   983|         0|            0|            0|  0.00%|
   984|         0|            0|            0|  0.00%|        Args:
   985|         0|            0|            0|  0.00%|            alias_generator: A callable that takes a string and returns a string, or an AliasGenerator instance.
   986|         0|            0|            0|  0.00%|            field_info: The FieldInfo instance to which the alias_generator is (maybe) applied.
   987|         0|            0|            0|  0.00%|            field_name: The name of the field from which to generate the alias.
   988|         0|            0|            0|  0.00%|        """
   989|         0|            0|            0|  0.00%|        # Apply an alias_generator if
   990|         0|            0|            0|  0.00%|        # 1. An alias is not specified
   991|         0|            0|            0|  0.00%|        # 2. An alias is specified, but the priority is <= 1
   992|         0|            0|            0|  0.00%|        if (
   993|         0|            0|            0|  0.00%|            field_info.alias_priority is None
   994|         0|            0|            0|  0.00%|            or field_info.alias_priority <= 1
   995|         0|            0|            0|  0.00%|            or field_info.alias is None
   996|         0|            0|            0|  0.00%|            or field_info.validation_alias is None
   997|         0|            0|            0|  0.00%|            or field_info.serialization_alias is None
   998|         0|            0|            0|  0.00%|        ):
   999|         0|            0|            0|  0.00%|            alias, validation_alias, serialization_alias = None, None, None
  1000|         0|            0|            0|  0.00%|
  1001|         0|            0|            0|  0.00%|            if isinstance(alias_generator, AliasGenerator):
  1002|         0|            0|            0|  0.00%|                alias, validation_alias, serialization_alias = alias_generator.generate_aliases(field_name)
  1003|         0|            0|            0|  0.00%|            elif isinstance(alias_generator, Callable):
  1004|         0|            0|            0|  0.00%|                alias = alias_generator(field_name)
  1005|         0|            0|            0|  0.00%|                if not isinstance(alias, str):
  1006|         0|            0|            0|  0.00%|                    raise TypeError(f'alias_generator {alias_generator} must return str, not {alias.__class__}')
  1007|         0|            0|            0|  0.00%|
  1008|         0|            0|            0|  0.00%|            # if priority is not set, we set to 1
  1009|         0|            0|            0|  0.00%|            # which supports the case where the alias_generator from a child class is used
  1010|         0|            0|            0|  0.00%|            # to generate an alias for a field in a parent class
  1011|         0|            0|            0|  0.00%|            if field_info.alias_priority is None or field_info.alias_priority <= 1:
  1012|         0|            0|            0|  0.00%|                field_info.alias_priority = 1
  1013|         0|            0|            0|  0.00%|
  1014|         0|            0|            0|  0.00%|            # if the priority is 1, then we set the aliases to the generated alias
  1015|         0|            0|            0|  0.00%|            if field_info.alias_priority == 1:
  1016|         0|            0|            0|  0.00%|                field_info.serialization_alias = _get_first_non_null(serialization_alias, alias)
  1017|         0|            0|            0|  0.00%|                field_info.validation_alias = _get_first_non_null(validation_alias, alias)
  1018|         0|            0|            0|  0.00%|                field_info.alias = alias
  1019|         0|            0|            0|  0.00%|
  1020|         0|            0|            0|  0.00%|            # if any of the aliases are not set, then we set them to the corresponding generated alias
  1021|         0|            0|            0|  0.00%|            if field_info.alias is None:
  1022|         0|            0|            0|  0.00%|                field_info.alias = alias
  1023|         0|            0|            0|  0.00%|            if field_info.serialization_alias is None:
  1024|         0|            0|            0|  0.00%|                field_info.serialization_alias = _get_first_non_null(serialization_alias, alias)
  1025|         0|            0|            0|  0.00%|            if field_info.validation_alias is None:
  1026|         0|            0|            0|  0.00%|                field_info.validation_alias = _get_first_non_null(validation_alias, alias)
  1027|         0|            0|            0|  0.00%|
  1028|         0|            0|            0|  0.00%|    @staticmethod
  1029|         0|            0|            0|  0.00%|    def _apply_alias_generator_to_computed_field_info(
  1030|         0|            0|            0|  0.00%|        alias_generator: Callable[[str], str] | AliasGenerator,
  1031|         0|            0|            0|  0.00%|        computed_field_info: ComputedFieldInfo,
  1032|         0|            0|            0|  0.00%|        computed_field_name: str,
  1033|         0|            0|            0|  0.00%|    ):
  1034|         0|            0|            0|  0.00%|        """Apply an alias_generator to alias on a ComputedFieldInfo instance if appropriate.
  1035|         0|            0|            0|  0.00%|
  1036|         0|            0|            0|  0.00%|        Args:
  1037|         0|            0|            0|  0.00%|            alias_generator: A callable that takes a string and returns a string, or an AliasGenerator instance.
  1038|         0|            0|            0|  0.00%|            computed_field_info: The ComputedFieldInfo instance to which the alias_generator is (maybe) applied.
  1039|         0|            0|            0|  0.00%|            computed_field_name: The name of the computed field from which to generate the alias.
  1040|         0|            0|            0|  0.00%|        """
  1041|         0|            0|            0|  0.00%|        # Apply an alias_generator if
  1042|         0|            0|            0|  0.00%|        # 1. An alias is not specified
  1043|         0|            0|            0|  0.00%|        # 2. An alias is specified, but the priority is <= 1
  1044|         0|            0|            0|  0.00%|
  1045|         0|            0|            0|  0.00%|        if (
  1046|         0|            0|            0|  0.00%|            computed_field_info.alias_priority is None
  1047|         0|            0|            0|  0.00%|            or computed_field_info.alias_priority <= 1
  1048|         0|            0|            0|  0.00%|            or computed_field_info.alias is None
  1049|         0|            0|            0|  0.00%|        ):
  1050|         0|            0|            0|  0.00%|            alias, validation_alias, serialization_alias = None, None, None
  1051|         0|            0|            0|  0.00%|
  1052|         0|            0|            0|  0.00%|            if isinstance(alias_generator, AliasGenerator):
  1053|         0|            0|            0|  0.00%|                alias, validation_alias, serialization_alias = alias_generator.generate_aliases(computed_field_name)
  1054|         0|            0|            0|  0.00%|            elif isinstance(alias_generator, Callable):
  1055|         0|            0|            0|  0.00%|                alias = alias_generator(computed_field_name)
  1056|         0|            0|            0|  0.00%|                if not isinstance(alias, str):
  1057|         0|            0|            0|  0.00%|                    raise TypeError(f'alias_generator {alias_generator} must return str, not {alias.__class__}')
  1058|         0|            0|            0|  0.00%|
  1059|         0|            0|            0|  0.00%|            # if priority is not set, we set to 1
  1060|         0|            0|            0|  0.00%|            # which supports the case where the alias_generator from a child class is used
  1061|         0|            0|            0|  0.00%|            # to generate an alias for a field in a parent class
  1062|         0|            0|            0|  0.00%|            if computed_field_info.alias_priority is None or computed_field_info.alias_priority <= 1:
  1063|         0|            0|            0|  0.00%|                computed_field_info.alias_priority = 1
  1064|         0|            0|            0|  0.00%|
  1065|         0|            0|            0|  0.00%|            # if the priority is 1, then we set the aliases to the generated alias
  1066|         0|            0|            0|  0.00%|            # note that we use the serialization_alias with priority over alias, as computed_field
  1067|         0|            0|            0|  0.00%|            # aliases are used for serialization only (not validation)
  1068|         0|            0|            0|  0.00%|            if computed_field_info.alias_priority == 1:
  1069|         0|            0|            0|  0.00%|                computed_field_info.alias = _get_first_non_null(serialization_alias, alias)
  1070|         0|            0|            0|  0.00%|
  1071|         0|            0|            0|  0.00%|    @staticmethod
  1072|         0|            0|            0|  0.00%|    def _apply_field_title_generator_to_field_info(
  1073|         0|            0|            0|  0.00%|        config_wrapper: ConfigWrapper, field_info: FieldInfo | ComputedFieldInfo, field_name: str
  1074|         0|            0|            0|  0.00%|    ) -> None:
  1075|         0|            0|            0|  0.00%|        """Apply a field_title_generator on a FieldInfo or ComputedFieldInfo instance if appropriate
  1076|         0|            0|            0|  0.00%|        Args:
  1077|         0|            0|            0|  0.00%|            config_wrapper: The config of the model
  1078|         0|            0|            0|  0.00%|            field_info: The FieldInfo or ComputedField instance to which the title_generator is (maybe) applied.
  1079|         0|            0|            0|  0.00%|            field_name: The name of the field from which to generate the title.
  1080|         0|            0|            0|  0.00%|        """
  1081|         0|            0|            0|  0.00%|        field_title_generator = field_info.field_title_generator or config_wrapper.field_title_generator
  1082|         0|            0|            0|  0.00%|
  1083|         0|            0|            0|  0.00%|        if field_title_generator is None:
  1084|         0|            0|            0|  0.00%|            return
  1085|         0|            0|            0|  0.00%|
  1086|         0|            0|            0|  0.00%|        if field_info.title is None:
  1087|         0|            0|            0|  0.00%|            title = field_title_generator(field_name, field_info)  # type: ignore
  1088|         0|            0|            0|  0.00%|            if not isinstance(title, str):
  1089|         0|            0|            0|  0.00%|                raise TypeError(f'field_title_generator {field_title_generator} must return str, not {title.__class__}')
  1090|         0|            0|            0|  0.00%|
  1091|         0|            0|            0|  0.00%|            field_info.title = title
  1092|         0|            0|            0|  0.00%|
  1093|         0|            0|            0|  0.00%|    def _common_field_schema(  # C901
  1094|         0|            0|            0|  0.00%|        self, name: str, field_info: FieldInfo, decorators: DecoratorInfos
  1095|         0|            0|            0|  0.00%|    ) -> _CommonField:
  1096|         0|            0|            0|  0.00%|        # Update FieldInfo annotation if appropriate:
  1097|         0|            0|            0|  0.00%|        from .. import AliasChoices, AliasPath
  1098|         0|            0|            0|  0.00%|        from ..fields import FieldInfo
  1099|         0|            0|            0|  0.00%|
  1100|         0|            0|            0|  0.00%|        if has_instance_in_type(field_info.annotation, (ForwardRef, str)):
  1101|         0|            0|            0|  0.00%|            types_namespace = self._types_namespace
  1102|         0|            0|            0|  0.00%|            if self._typevars_map:
  1103|         0|            0|            0|  0.00%|                types_namespace = (types_namespace or {}).copy()
  1104|         0|            0|            0|  0.00%|                # Ensure that typevars get mapped to their concrete types:
  1105|         0|            0|            0|  0.00%|                types_namespace.update({k.__name__: v for k, v in self._typevars_map.items()})
  1106|         0|            0|            0|  0.00%|
  1107|         0|            0|            0|  0.00%|            evaluated = _typing_extra.eval_type_lenient(field_info.annotation, types_namespace)
  1108|         0|            0|            0|  0.00%|            if evaluated is not field_info.annotation and not has_instance_in_type(evaluated, PydanticRecursiveRef):
  1109|         0|            0|            0|  0.00%|                new_field_info = FieldInfo.from_annotation(evaluated)
  1110|         0|            0|            0|  0.00%|                field_info.annotation = new_field_info.annotation
  1111|         0|            0|            0|  0.00%|
  1112|         0|            0|            0|  0.00%|                # Handle any field info attributes that may have been obtained from now-resolved annotations
  1113|         0|            0|            0|  0.00%|                for k, v in new_field_info._attributes_set.items():
  1114|         0|            0|            0|  0.00%|                    # If an attribute is already set, it means it was set by assigning to a call to Field (or just a
  1115|         0|            0|            0|  0.00%|                    # default value), and that should take the highest priority. So don't overwrite existing attributes.
  1116|         0|            0|            0|  0.00%|                    # We skip over "attributes" that are present in the metadata_lookup dict because these won't
  1117|         0|            0|            0|  0.00%|                    # actually end up as attributes of the `FieldInfo` instance.
  1118|         0|            0|            0|  0.00%|                    if k not in field_info._attributes_set and k not in field_info.metadata_lookup:
  1119|         0|            0|            0|  0.00%|                        setattr(field_info, k, v)
  1120|         0|            0|            0|  0.00%|
  1121|         0|            0|            0|  0.00%|                # Finally, ensure the field info also reflects all the `_attributes_set` that are actually metadata.
  1122|         0|            0|            0|  0.00%|                field_info.metadata = [*new_field_info.metadata, *field_info.metadata]
  1123|         0|            0|            0|  0.00%|
  1124|         0|            0|            0|  0.00%|        source_type, annotations = field_info.annotation, field_info.metadata
  1125|         0|            0|            0|  0.00%|
  1126|         0|            0|            0|  0.00%|        def set_discriminator(schema: CoreSchema) -> CoreSchema:
  1127|         0|            0|            0|  0.00%|            schema = self._apply_discriminator_to_union(schema, field_info.discriminator)
  1128|         0|            0|            0|  0.00%|            return schema
  1129|         0|            0|            0|  0.00%|
  1130|         0|            0|            0|  0.00%|        with self.field_name_stack.push(name):
  1131|         0|            0|            0|  0.00%|            if field_info.discriminator is not None:
  1132|         0|            0|            0|  0.00%|                schema = self._apply_annotations(source_type, annotations, transform_inner_schema=set_discriminator)
  1133|         0|            0|            0|  0.00%|            else:
  1134|         0|            0|            0|  0.00%|                schema = self._apply_annotations(
  1135|         0|            0|            0|  0.00%|                    source_type,
  1136|         0|            0|            0|  0.00%|                    annotations,
  1137|         0|            0|            0|  0.00%|                )
  1138|         0|            0|            0|  0.00%|
  1139|         0|            0|            0|  0.00%|        # This V1 compatibility shim should eventually be removed
  1140|         0|            0|            0|  0.00%|        # push down any `each_item=True` validators
  1141|         0|            0|            0|  0.00%|        # note that this won't work for any Annotated types that get wrapped by a function validator
  1142|         0|            0|            0|  0.00%|        # but that's okay because that didn't exist in V1
  1143|         0|            0|            0|  0.00%|        this_field_validators = filter_field_decorator_info_by_field(decorators.validators.values(), name)
  1144|         0|            0|            0|  0.00%|        if _validators_require_validate_default(this_field_validators):
  1145|         0|            0|            0|  0.00%|            field_info.validate_default = True
  1146|         0|            0|            0|  0.00%|        each_item_validators = [v for v in this_field_validators if v.info.each_item is True]
  1147|         0|            0|            0|  0.00%|        this_field_validators = [v for v in this_field_validators if v not in each_item_validators]
  1148|         0|            0|            0|  0.00%|        schema = apply_each_item_validators(schema, each_item_validators, name)
  1149|         0|            0|            0|  0.00%|
  1150|         0|            0|            0|  0.00%|        schema = apply_validators(schema, filter_field_decorator_info_by_field(this_field_validators, name), name)
  1151|         0|            0|            0|  0.00%|        schema = apply_validators(
  1152|         0|            0|            0|  0.00%|            schema, filter_field_decorator_info_by_field(decorators.field_validators.values(), name), name
  1153|         0|            0|            0|  0.00%|        )
  1154|         0|            0|            0|  0.00%|
  1155|         0|            0|            0|  0.00%|        # the default validator needs to go outside of any other validators
  1156|         0|            0|            0|  0.00%|        # so that it is the topmost validator for the field validator
  1157|         0|            0|            0|  0.00%|        # which uses it to check if the field has a default value or not
  1158|         0|            0|            0|  0.00%|        if not field_info.is_required():
  1159|         0|            0|            0|  0.00%|            schema = wrap_default(field_info, schema)
  1160|         0|            0|            0|  0.00%|
  1161|         0|            0|            0|  0.00%|        schema = self._apply_field_serializers(
  1162|         0|            0|            0|  0.00%|            schema, filter_field_decorator_info_by_field(decorators.field_serializers.values(), name)
  1163|         0|            0|            0|  0.00%|        )
  1164|         0|            0|            0|  0.00%|        self._apply_field_title_generator_to_field_info(self._config_wrapper, field_info, name)
  1165|         0|            0|            0|  0.00%|
  1166|         0|            0|            0|  0.00%|        json_schema_updates = {
  1167|         0|            0|            0|  0.00%|            'title': field_info.title,
  1168|         0|            0|            0|  0.00%|            'description': field_info.description,
  1169|         0|            0|            0|  0.00%|            'deprecated': bool(field_info.deprecated) or field_info.deprecated == '' or None,
  1170|         0|            0|            0|  0.00%|            'examples': to_jsonable_python(field_info.examples),
  1171|         0|            0|            0|  0.00%|        }
  1172|         0|            0|            0|  0.00%|        json_schema_updates = {k: v for k, v in json_schema_updates.items() if v is not None}
  1173|         0|            0|            0|  0.00%|
  1174|         0|            0|            0|  0.00%|        json_schema_extra = field_info.json_schema_extra
  1175|         0|            0|            0|  0.00%|
  1176|         0|            0|            0|  0.00%|        metadata = build_metadata_dict(
  1177|         0|            0|            0|  0.00%|            js_annotation_functions=[get_json_schema_update_func(json_schema_updates, json_schema_extra)]
  1178|         0|            0|            0|  0.00%|        )
  1179|         0|            0|            0|  0.00%|
  1180|         0|            0|            0|  0.00%|        alias_generator = self._config_wrapper.alias_generator
  1181|         0|            0|            0|  0.00%|        if alias_generator is not None:
  1182|         0|            0|            0|  0.00%|            self._apply_alias_generator_to_field_info(alias_generator, field_info, name)
  1183|         0|            0|            0|  0.00%|
  1184|         0|            0|            0|  0.00%|        if isinstance(field_info.validation_alias, (AliasChoices, AliasPath)):
  1185|         0|            0|            0|  0.00%|            validation_alias = field_info.validation_alias.convert_to_aliases()
  1186|         0|            0|            0|  0.00%|        else:
  1187|         0|            0|            0|  0.00%|            validation_alias = field_info.validation_alias
  1188|         0|            0|            0|  0.00%|
  1189|         0|            0|            0|  0.00%|        return _common_field(
  1190|         0|            0|            0|  0.00%|            schema,
  1191|         0|            0|            0|  0.00%|            serialization_exclude=True if field_info.exclude else None,
  1192|         0|            0|            0|  0.00%|            validation_alias=validation_alias,
  1193|         0|            0|            0|  0.00%|            serialization_alias=field_info.serialization_alias,
  1194|         0|            0|            0|  0.00%|            frozen=field_info.frozen,
  1195|         0|            0|            0|  0.00%|            metadata=metadata,
  1196|         0|            0|            0|  0.00%|        )
  1197|         0|            0|            0|  0.00%|
  1198|         0|            0|            0|  0.00%|    def _union_schema(self, union_type: Any) -> core_schema.CoreSchema:
  1199|         0|            0|            0|  0.00%|        """Generate schema for a Union."""
  1200|         0|            0|            0|  0.00%|        args = self._get_args_resolving_forward_refs(union_type, required=True)
  1201|         0|            0|            0|  0.00%|        choices: list[CoreSchema] = []
  1202|         0|            0|            0|  0.00%|        nullable = False
  1203|         0|            0|            0|  0.00%|        for arg in args:
  1204|         0|            0|            0|  0.00%|            if arg is None or arg is _typing_extra.NoneType:
  1205|         0|            0|            0|  0.00%|                nullable = True
  1206|         0|            0|            0|  0.00%|            else:
  1207|         0|            0|            0|  0.00%|                choices.append(self.generate_schema(arg))
  1208|         0|            0|            0|  0.00%|
  1209|         0|            0|            0|  0.00%|        if len(choices) == 1:
  1210|         0|            0|            0|  0.00%|            s = choices[0]
  1211|         0|            0|            0|  0.00%|        else:
  1212|         0|            0|            0|  0.00%|            choices_with_tags: list[CoreSchema | tuple[CoreSchema, str]] = []
  1213|         0|            0|            0|  0.00%|            for choice in choices:
  1214|         0|            0|            0|  0.00%|                tag = choice.get('metadata', {}).get(_core_utils.TAGGED_UNION_TAG_KEY)
  1215|         0|            0|            0|  0.00%|                if tag is not None:
  1216|         0|            0|            0|  0.00%|                    choices_with_tags.append((choice, tag))
  1217|         0|            0|            0|  0.00%|                else:
  1218|         0|            0|            0|  0.00%|                    choices_with_tags.append(choice)
  1219|         0|            0|            0|  0.00%|            s = core_schema.union_schema(choices_with_tags)
  1220|         0|            0|            0|  0.00%|
  1221|         0|            0|            0|  0.00%|        if nullable:
  1222|         0|            0|            0|  0.00%|            s = core_schema.nullable_schema(s)
  1223|         0|            0|            0|  0.00%|        return s
  1224|         0|            0|            0|  0.00%|
  1225|         0|            0|            0|  0.00%|    def _type_alias_type_schema(
  1226|         0|            0|            0|  0.00%|        self,
  1227|         0|            0|            0|  0.00%|        obj: Any,  # TypeAliasType
  1228|         0|            0|            0|  0.00%|    ) -> CoreSchema:
  1229|         0|            0|            0|  0.00%|        with self.defs.get_schema_or_ref(obj) as (ref, maybe_schema):
  1230|         0|            0|            0|  0.00%|            if maybe_schema is not None:
  1231|         0|            0|            0|  0.00%|                return maybe_schema
  1232|         0|            0|            0|  0.00%|
  1233|         0|            0|            0|  0.00%|            origin = get_origin(obj) or obj
  1234|         0|            0|            0|  0.00%|
  1235|         0|            0|            0|  0.00%|            annotation = origin.__value__
  1236|         0|            0|            0|  0.00%|            typevars_map = get_standard_typevars_map(obj)
  1237|         0|            0|            0|  0.00%|
  1238|         0|            0|            0|  0.00%|            with self._types_namespace_stack.push(origin):
  1239|         0|            0|            0|  0.00%|                annotation = _typing_extra.eval_type_lenient(annotation, self._types_namespace)
  1240|         0|            0|            0|  0.00%|                annotation = replace_types(annotation, typevars_map)
  1241|         0|            0|            0|  0.00%|                schema = self.generate_schema(annotation)
  1242|         0|            0|            0|  0.00%|                assert schema['type'] != 'definitions'
  1243|         0|            0|            0|  0.00%|                schema['ref'] = ref  # type: ignore
  1244|         0|            0|            0|  0.00%|            self.defs.definitions[ref] = schema
  1245|         0|            0|            0|  0.00%|            return core_schema.definition_reference_schema(ref)
  1246|         0|            0|            0|  0.00%|
  1247|         0|            0|            0|  0.00%|    def _literal_schema(self, literal_type: Any) -> CoreSchema:
  1248|         0|            0|            0|  0.00%|        """Generate schema for a Literal."""
  1249|         0|            0|            0|  0.00%|        expected = _typing_extra.all_literal_values(literal_type)
  1250|         0|            0|            0|  0.00%|        assert expected, f'literal "expected" cannot be empty, obj={literal_type}'
  1251|         0|            0|            0|  0.00%|        return core_schema.literal_schema(expected)
  1252|         0|            0|            0|  0.00%|
  1253|         0|            0|            0|  0.00%|    def _typed_dict_schema(self, typed_dict_cls: Any, origin: Any) -> core_schema.CoreSchema:
  1254|         0|            0|            0|  0.00%|        """Generate schema for a TypedDict.
  1255|         0|            0|            0|  0.00%|
  1256|         0|            0|            0|  0.00%|        It is not possible to track required/optional keys in TypedDict without __required_keys__
  1257|         0|            0|            0|  0.00%|        since TypedDict.__new__ erases the base classes (it replaces them with just `dict`)
  1258|         0|            0|            0|  0.00%|        and thus we can track usage of total=True/False
  1259|         0|            0|            0|  0.00%|        __required_keys__ was added in Python 3.9
  1260|         0|            0|            0|  0.00%|        (https://github.com/miss-islington/cpython/blob/1e9939657dd1f8eb9f596f77c1084d2d351172fc/Doc/library/typing.rst?plain=1#L1546-L1548)
  1261|         0|            0|            0|  0.00%|        however it is buggy
  1262|         0|            0|            0|  0.00%|        (https://github.com/python/typing_extensions/blob/ac52ac5f2cb0e00e7988bae1e2a1b8257ac88d6d/src/typing_extensions.py#L657-L666).
  1263|         0|            0|            0|  0.00%|
  1264|         0|            0|            0|  0.00%|        On 3.11 but < 3.12 TypedDict does not preserve inheritance information.
  1265|         0|            0|            0|  0.00%|
  1266|         0|            0|            0|  0.00%|        Hence to avoid creating validators that do not do what users expect we only
  1267|         0|            0|            0|  0.00%|        support typing.TypedDict on Python >= 3.12 or typing_extension.TypedDict on all versions
  1268|         0|            0|            0|  0.00%|        """
  1269|         0|            0|            0|  0.00%|        from ..fields import FieldInfo
  1270|         0|            0|            0|  0.00%|
  1271|         0|            0|            0|  0.00%|        with self.model_type_stack.push(typed_dict_cls), self.defs.get_schema_or_ref(typed_dict_cls) as (
  1272|         0|            0|            0|  0.00%|            typed_dict_ref,
  1273|         0|            0|            0|  0.00%|            maybe_schema,
  1274|         0|            0|            0|  0.00%|        ):
  1275|         0|            0|            0|  0.00%|            if maybe_schema is not None:
  1276|         0|            0|            0|  0.00%|                return maybe_schema
  1277|         0|            0|            0|  0.00%|
  1278|         0|            0|            0|  0.00%|            typevars_map = get_standard_typevars_map(typed_dict_cls)
  1279|         0|            0|            0|  0.00%|            if origin is not None:
  1280|         0|            0|            0|  0.00%|                typed_dict_cls = origin
  1281|         0|            0|            0|  0.00%|
  1282|         0|            0|            0|  0.00%|            if not _SUPPORTS_TYPEDDICT and type(typed_dict_cls).__module__ == 'typing':
  1283|         0|            0|            0|  0.00%|                raise PydanticUserError(
  1284|         0|            0|            0|  0.00%|                    'Please use `typing_extensions.TypedDict` instead of `typing.TypedDict` on Python < 3.12.',
  1285|         0|            0|            0|  0.00%|                    code='typed-dict-version',
  1286|         0|            0|            0|  0.00%|                )
  1287|         0|            0|            0|  0.00%|
  1288|         0|            0|            0|  0.00%|            try:
  1289|         0|            0|            0|  0.00%|                config: ConfigDict | None = get_attribute_from_bases(typed_dict_cls, '__pydantic_config__')
  1290|         0|            0|            0|  0.00%|            except AttributeError:
  1291|         0|            0|            0|  0.00%|                config = None
  1292|         0|            0|            0|  0.00%|
  1293|         0|            0|            0|  0.00%|            with self._config_wrapper_stack.push(config), self._types_namespace_stack.push(typed_dict_cls):
  1294|         0|            0|            0|  0.00%|                core_config = self._config_wrapper.core_config(typed_dict_cls)
  1295|         0|            0|            0|  0.00%|
  1296|         0|            0|            0|  0.00%|                self = self._current_generate_schema
  1297|         0|            0|            0|  0.00%|
  1298|         0|            0|            0|  0.00%|                required_keys: frozenset[str] = typed_dict_cls.__required_keys__
  1299|         0|            0|            0|  0.00%|
  1300|         0|            0|            0|  0.00%|                fields: dict[str, core_schema.TypedDictField] = {}
  1301|         0|            0|            0|  0.00%|
  1302|         0|            0|            0|  0.00%|                decorators = DecoratorInfos.build(typed_dict_cls)
  1303|         0|            0|            0|  0.00%|
  1304|         0|            0|            0|  0.00%|                if self._config_wrapper.use_attribute_docstrings:
  1305|         0|            0|            0|  0.00%|                    field_docstrings = extract_docstrings_from_cls(typed_dict_cls, use_inspect=True)
  1306|         0|            0|            0|  0.00%|                else:
  1307|         0|            0|            0|  0.00%|                    field_docstrings = None
  1308|         0|            0|            0|  0.00%|
  1309|         0|            0|            0|  0.00%|                for field_name, annotation in get_type_hints_infer_globalns(
  1310|         0|            0|            0|  0.00%|                    typed_dict_cls, localns=self._types_namespace, include_extras=True
  1311|         0|            0|            0|  0.00%|                ).items():
  1312|         0|            0|            0|  0.00%|                    annotation = replace_types(annotation, typevars_map)
  1313|         0|            0|            0|  0.00%|                    required = field_name in required_keys
  1314|         0|            0|            0|  0.00%|
  1315|         0|            0|            0|  0.00%|                    if get_origin(annotation) == _typing_extra.Required:
  1316|         0|            0|            0|  0.00%|                        required = True
  1317|         0|            0|            0|  0.00%|                        annotation = self._get_args_resolving_forward_refs(
  1318|         0|            0|            0|  0.00%|                            annotation,
  1319|         0|            0|            0|  0.00%|                            required=True,
  1320|         0|            0|            0|  0.00%|                        )[0]
  1321|         0|            0|            0|  0.00%|                    elif get_origin(annotation) == _typing_extra.NotRequired:
  1322|         0|            0|            0|  0.00%|                        required = False
  1323|         0|            0|            0|  0.00%|                        annotation = self._get_args_resolving_forward_refs(
  1324|         0|            0|            0|  0.00%|                            annotation,
  1325|         0|            0|            0|  0.00%|                            required=True,
  1326|         0|            0|            0|  0.00%|                        )[0]
  1327|         0|            0|            0|  0.00%|
  1328|         0|            0|            0|  0.00%|                    field_info = FieldInfo.from_annotation(annotation)
  1329|         0|            0|            0|  0.00%|                    if (
  1330|         0|            0|            0|  0.00%|                        field_docstrings is not None
  1331|         0|            0|            0|  0.00%|                        and field_info.description is None
  1332|         0|            0|            0|  0.00%|                        and field_name in field_docstrings
  1333|         0|            0|            0|  0.00%|                    ):
  1334|         0|            0|            0|  0.00%|                        field_info.description = field_docstrings[field_name]
  1335|         0|            0|            0|  0.00%|                    self._apply_field_title_generator_to_field_info(self._config_wrapper, field_info, field_name)
  1336|         0|            0|            0|  0.00%|                    fields[field_name] = self._generate_td_field_schema(
  1337|         0|            0|            0|  0.00%|                        field_name, field_info, decorators, required=required
  1338|         0|            0|            0|  0.00%|                    )
  1339|         0|            0|            0|  0.00%|
  1340|         0|            0|            0|  0.00%|                title = self._get_model_title_from_config(typed_dict_cls, ConfigWrapper(config))
  1341|         0|            0|            0|  0.00%|                metadata = build_metadata_dict(
  1342|         0|            0|            0|  0.00%|                    js_functions=[partial(modify_model_json_schema, cls=typed_dict_cls, title=title)],
  1343|         0|            0|            0|  0.00%|                    typed_dict_cls=typed_dict_cls,
  1344|         0|            0|            0|  0.00%|                )
  1345|         0|            0|            0|  0.00%|                td_schema = core_schema.typed_dict_schema(
  1346|         0|            0|            0|  0.00%|                    fields,
  1347|         0|            0|            0|  0.00%|                    computed_fields=[
  1348|         0|            0|            0|  0.00%|                        self._computed_field_schema(d, decorators.field_serializers)
  1349|         0|            0|            0|  0.00%|                        for d in decorators.computed_fields.values()
  1350|         0|            0|            0|  0.00%|                    ],
  1351|         0|            0|            0|  0.00%|                    ref=typed_dict_ref,
  1352|         0|            0|            0|  0.00%|                    metadata=metadata,
  1353|         0|            0|            0|  0.00%|                    config=core_config,
  1354|         0|            0|            0|  0.00%|                )
  1355|         0|            0|            0|  0.00%|
  1356|         0|            0|            0|  0.00%|                schema = self._apply_model_serializers(td_schema, decorators.model_serializers.values())
  1357|         0|            0|            0|  0.00%|                schema = apply_model_validators(schema, decorators.model_validators.values(), 'all')
  1358|         0|            0|            0|  0.00%|                self.defs.definitions[typed_dict_ref] = schema
  1359|         0|            0|            0|  0.00%|                return core_schema.definition_reference_schema(typed_dict_ref)
  1360|         0|            0|            0|  0.00%|
  1361|         0|            0|            0|  0.00%|    def _namedtuple_schema(self, namedtuple_cls: Any, origin: Any) -> core_schema.CoreSchema:
  1362|         0|            0|            0|  0.00%|        """Generate schema for a NamedTuple."""
  1363|         0|            0|            0|  0.00%|        with self.model_type_stack.push(namedtuple_cls), self.defs.get_schema_or_ref(namedtuple_cls) as (
  1364|         0|            0|            0|  0.00%|            namedtuple_ref,
  1365|         0|            0|            0|  0.00%|            maybe_schema,
  1366|         0|            0|            0|  0.00%|        ):
  1367|         0|            0|            0|  0.00%|            if maybe_schema is not None:
  1368|         0|            0|            0|  0.00%|                return maybe_schema
  1369|         0|            0|            0|  0.00%|            typevars_map = get_standard_typevars_map(namedtuple_cls)
  1370|         0|            0|            0|  0.00%|            if origin is not None:
  1371|         0|            0|            0|  0.00%|                namedtuple_cls = origin
  1372|         0|            0|            0|  0.00%|
  1373|         0|            0|            0|  0.00%|            annotations: dict[str, Any] = get_type_hints_infer_globalns(
  1374|         0|            0|            0|  0.00%|                namedtuple_cls, include_extras=True, localns=self._types_namespace
  1375|         0|            0|            0|  0.00%|            )
  1376|         0|            0|            0|  0.00%|            if not annotations:
  1377|         0|            0|            0|  0.00%|                # annotations is empty, happens if namedtuple_cls defined via collections.namedtuple(...)
  1378|         0|            0|            0|  0.00%|                annotations = {k: Any for k in namedtuple_cls._fields}
  1379|         0|            0|            0|  0.00%|
  1380|         0|            0|            0|  0.00%|            if typevars_map:
  1381|         0|            0|            0|  0.00%|                annotations = {
  1382|         0|            0|            0|  0.00%|                    field_name: replace_types(annotation, typevars_map)
  1383|         0|            0|            0|  0.00%|                    for field_name, annotation in annotations.items()
  1384|         0|            0|            0|  0.00%|                }
  1385|         0|            0|            0|  0.00%|
  1386|         0|            0|            0|  0.00%|            arguments_schema = core_schema.arguments_schema(
  1387|         0|            0|            0|  0.00%|                [
  1388|         0|            0|            0|  0.00%|                    self._generate_parameter_schema(
  1389|         0|            0|            0|  0.00%|                        field_name, annotation, default=namedtuple_cls._field_defaults.get(field_name, Parameter.empty)
  1390|         0|            0|            0|  0.00%|                    )
  1391|         0|            0|            0|  0.00%|                    for field_name, annotation in annotations.items()
  1392|         0|            0|            0|  0.00%|                ],
  1393|         0|            0|            0|  0.00%|                metadata=build_metadata_dict(js_prefer_positional_arguments=True),
  1394|         0|            0|            0|  0.00%|            )
  1395|         0|            0|            0|  0.00%|            return core_schema.call_schema(arguments_schema, namedtuple_cls, ref=namedtuple_ref)
  1396|         0|            0|            0|  0.00%|
  1397|         0|            0|            0|  0.00%|    def _generate_parameter_schema(
  1398|         0|            0|            0|  0.00%|        self,
  1399|         0|            0|            0|  0.00%|        name: str,
  1400|         0|            0|            0|  0.00%|        annotation: type[Any],
  1401|         0|            0|            0|  0.00%|        default: Any = Parameter.empty,
  1402|         0|            0|            0|  0.00%|        mode: Literal['positional_only', 'positional_or_keyword', 'keyword_only'] | None = None,
  1403|         0|            0|            0|  0.00%|    ) -> core_schema.ArgumentsParameter:
  1404|         0|            0|            0|  0.00%|        """Prepare a ArgumentsParameter to represent a field in a namedtuple or function signature."""
  1405|         0|            0|            0|  0.00%|        from ..fields import FieldInfo
  1406|         0|            0|            0|  0.00%|
  1407|         0|            0|            0|  0.00%|        if default is Parameter.empty:
  1408|         0|            0|            0|  0.00%|            field = FieldInfo.from_annotation(annotation)
  1409|         0|            0|            0|  0.00%|        else:
  1410|         0|            0|            0|  0.00%|            field = FieldInfo.from_annotated_attribute(annotation, default)
  1411|         0|            0|            0|  0.00%|        assert field.annotation is not None, 'field.annotation should not be None when generating a schema'
  1412|         0|            0|            0|  0.00%|        source_type, annotations = field.annotation, field.metadata
  1413|         0|            0|            0|  0.00%|        with self.field_name_stack.push(name):
  1414|         0|            0|            0|  0.00%|            schema = self._apply_annotations(source_type, annotations)
  1415|         0|            0|            0|  0.00%|
  1416|         0|            0|            0|  0.00%|        if not field.is_required():
  1417|         0|            0|            0|  0.00%|            schema = wrap_default(field, schema)
  1418|         0|            0|            0|  0.00%|
  1419|         0|            0|            0|  0.00%|        parameter_schema = core_schema.arguments_parameter(name, schema)
  1420|         0|            0|            0|  0.00%|        if mode is not None:
  1421|         0|            0|            0|  0.00%|            parameter_schema['mode'] = mode
  1422|         0|            0|            0|  0.00%|        if field.alias is not None:
  1423|         0|            0|            0|  0.00%|            parameter_schema['alias'] = field.alias
  1424|         0|            0|            0|  0.00%|        else:
  1425|         0|            0|            0|  0.00%|            alias_generator = self._config_wrapper.alias_generator
  1426|         0|            0|            0|  0.00%|            if isinstance(alias_generator, AliasGenerator) and alias_generator.alias is not None:
  1427|         0|            0|            0|  0.00%|                parameter_schema['alias'] = alias_generator.alias(name)
  1428|         0|            0|            0|  0.00%|            elif isinstance(alias_generator, Callable):
  1429|         0|            0|            0|  0.00%|                parameter_schema['alias'] = alias_generator(name)
  1430|         0|            0|            0|  0.00%|        return parameter_schema
  1431|         0|            0|            0|  0.00%|
  1432|         0|            0|            0|  0.00%|    def _tuple_schema(self, tuple_type: Any) -> core_schema.CoreSchema:
  1433|         0|            0|            0|  0.00%|        """Generate schema for a Tuple, e.g. `tuple[int, str]` or `tuple[int, ...]`."""
  1434|         0|            0|            0|  0.00%|        # TODO: do we really need to resolve type vars here?
  1435|         0|            0|            0|  0.00%|        typevars_map = get_standard_typevars_map(tuple_type)
  1436|         0|            0|            0|  0.00%|        params = self._get_args_resolving_forward_refs(tuple_type)
  1437|         0|            0|            0|  0.00%|
  1438|         0|            0|            0|  0.00%|        if typevars_map and params:
  1439|         0|            0|            0|  0.00%|            params = tuple(replace_types(param, typevars_map) for param in params)
  1440|         0|            0|            0|  0.00%|
  1441|         0|            0|            0|  0.00%|        # NOTE: subtle difference: `tuple[()]` gives `params=()`, whereas `typing.Tuple[()]` gives `params=((),)`
  1442|         0|            0|            0|  0.00%|        # This is only true for <3.11, on Python 3.11+ `typing.Tuple[()]` gives `params=()`
  1443|         0|            0|            0|  0.00%|        if not params:
  1444|         0|            0|            0|  0.00%|            if tuple_type in TUPLE_TYPES:
  1445|         0|            0|            0|  0.00%|                return core_schema.tuple_schema([core_schema.any_schema()], variadic_item_index=0)
  1446|         0|            0|            0|  0.00%|            else:
  1447|         0|            0|            0|  0.00%|                # special case for `tuple[()]` which means `tuple[]` - an empty tuple
  1448|         0|            0|            0|  0.00%|                return core_schema.tuple_schema([])
  1449|         0|            0|            0|  0.00%|        elif params[-1] is Ellipsis:
  1450|         0|            0|            0|  0.00%|            if len(params) == 2:
  1451|         0|            0|            0|  0.00%|                return core_schema.tuple_schema([self.generate_schema(params[0])], variadic_item_index=0)
  1452|         0|            0|            0|  0.00%|            else:
  1453|         0|            0|            0|  0.00%|                # TODO: something like https://github.com/pydantic/pydantic/issues/5952
  1454|         0|            0|            0|  0.00%|                raise ValueError('Variable tuples can only have one type')
  1455|         0|            0|            0|  0.00%|        elif len(params) == 1 and params[0] == ():
  1456|         0|            0|            0|  0.00%|            # special case for `Tuple[()]` which means `Tuple[]` - an empty tuple
  1457|         0|            0|            0|  0.00%|            # NOTE: This conditional can be removed when we drop support for Python 3.10.
  1458|         0|            0|            0|  0.00%|            return core_schema.tuple_schema([])
  1459|         0|            0|            0|  0.00%|        else:
  1460|         0|            0|            0|  0.00%|            return core_schema.tuple_schema([self.generate_schema(param) for param in params])
  1461|         0|            0|            0|  0.00%|
  1462|         0|            0|            0|  0.00%|    def _type_schema(self) -> core_schema.CoreSchema:
  1463|         0|            0|            0|  0.00%|        return core_schema.custom_error_schema(
  1464|         0|            0|            0|  0.00%|            core_schema.is_instance_schema(type),
  1465|         0|            0|            0|  0.00%|            custom_error_type='is_type',
  1466|         0|            0|            0|  0.00%|            custom_error_message='Input should be a type',
  1467|         0|            0|            0|  0.00%|        )
  1468|         0|            0|            0|  0.00%|
  1469|         0|            0|            0|  0.00%|    def _union_is_subclass_schema(self, union_type: Any) -> core_schema.CoreSchema:
  1470|         0|            0|            0|  0.00%|        """Generate schema for `Type[Union[X, ...]]`."""
  1471|         0|            0|            0|  0.00%|        args = self._get_args_resolving_forward_refs(union_type, required=True)
  1472|         0|            0|            0|  0.00%|        return core_schema.union_schema([self.generate_schema(typing.Type[args]) for args in args])
  1473|         0|            0|            0|  0.00%|
  1474|         0|            0|            0|  0.00%|    def _subclass_schema(self, type_: Any) -> core_schema.CoreSchema:
  1475|         0|            0|            0|  0.00%|        """Generate schema for a Type, e.g. `Type[int]`."""
  1476|         0|            0|            0|  0.00%|        type_param = self._get_first_arg_or_any(type_)
  1477|         0|            0|            0|  0.00%|        if type_param == Any:
  1478|         0|            0|            0|  0.00%|            return self._type_schema()
  1479|         0|            0|            0|  0.00%|        elif isinstance(type_param, typing.TypeVar):
  1480|         0|            0|            0|  0.00%|            if type_param.__bound__:
  1481|         0|            0|            0|  0.00%|                if _typing_extra.origin_is_union(get_origin(type_param.__bound__)):
  1482|         0|            0|            0|  0.00%|                    return self._union_is_subclass_schema(type_param.__bound__)
  1483|         0|            0|            0|  0.00%|                return core_schema.is_subclass_schema(type_param.__bound__)
  1484|         0|            0|            0|  0.00%|            elif type_param.__constraints__:
  1485|         0|            0|            0|  0.00%|                return core_schema.union_schema(
  1486|         0|            0|            0|  0.00%|                    [self.generate_schema(typing.Type[c]) for c in type_param.__constraints__]
  1487|         0|            0|            0|  0.00%|                )
  1488|         0|            0|            0|  0.00%|            else:
  1489|         0|            0|            0|  0.00%|                return self._type_schema()
  1490|         0|            0|            0|  0.00%|        elif _typing_extra.origin_is_union(get_origin(type_param)):
  1491|         0|            0|            0|  0.00%|            return self._union_is_subclass_schema(type_param)
  1492|         0|            0|            0|  0.00%|        else:
  1493|         0|            0|            0|  0.00%|            return core_schema.is_subclass_schema(type_param)
  1494|         0|            0|            0|  0.00%|
  1495|         0|            0|            0|  0.00%|    def _sequence_schema(self, sequence_type: Any) -> core_schema.CoreSchema:
  1496|         0|            0|            0|  0.00%|        """Generate schema for a Sequence, e.g. `Sequence[int]`."""
  1497|         0|            0|            0|  0.00%|        from ._std_types_schema import serialize_sequence_via_list
  1498|         0|            0|            0|  0.00%|
  1499|         0|            0|            0|  0.00%|        item_type = self._get_first_arg_or_any(sequence_type)
  1500|         0|            0|            0|  0.00%|        item_type_schema = self.generate_schema(item_type)
  1501|         0|            0|            0|  0.00%|        list_schema = core_schema.list_schema(item_type_schema)
  1502|         0|            0|            0|  0.00%|
  1503|         0|            0|            0|  0.00%|        python_schema = core_schema.is_instance_schema(typing.Sequence, cls_repr='Sequence')
  1504|         0|            0|            0|  0.00%|        if item_type != Any:
  1505|         0|            0|            0|  0.00%|            from ._validators import sequence_validator
  1506|         0|            0|            0|  0.00%|
  1507|         0|            0|            0|  0.00%|            python_schema = core_schema.chain_schema(
  1508|         0|            0|            0|  0.00%|                [python_schema, core_schema.no_info_wrap_validator_function(sequence_validator, list_schema)],
  1509|         0|            0|            0|  0.00%|            )
  1510|         0|            0|            0|  0.00%|
  1511|         0|            0|            0|  0.00%|        serialization = core_schema.wrap_serializer_function_ser_schema(
  1512|         0|            0|            0|  0.00%|            serialize_sequence_via_list, schema=item_type_schema, info_arg=True
  1513|         0|            0|            0|  0.00%|        )
  1514|         0|            0|            0|  0.00%|        return core_schema.json_or_python_schema(
  1515|         0|            0|            0|  0.00%|            json_schema=list_schema, python_schema=python_schema, serialization=serialization
  1516|         0|            0|            0|  0.00%|        )
  1517|         0|            0|            0|  0.00%|
  1518|         0|            0|            0|  0.00%|    def _iterable_schema(self, type_: Any) -> core_schema.GeneratorSchema:
  1519|         0|            0|            0|  0.00%|        """Generate a schema for an `Iterable`."""
  1520|         0|            0|            0|  0.00%|        item_type = self._get_first_arg_or_any(type_)
  1521|         0|            0|            0|  0.00%|
  1522|         0|            0|            0|  0.00%|        return core_schema.generator_schema(self.generate_schema(item_type))
  1523|         0|            0|            0|  0.00%|
  1524|         0|            0|            0|  0.00%|    def _pattern_schema(self, pattern_type: Any) -> core_schema.CoreSchema:
  1525|         0|            0|            0|  0.00%|        from . import _validators
  1526|         0|            0|            0|  0.00%|
  1527|         0|            0|            0|  0.00%|        metadata = build_metadata_dict(js_functions=[lambda _1, _2: {'type': 'string', 'format': 'regex'}])
  1528|         0|            0|            0|  0.00%|        ser = core_schema.plain_serializer_function_ser_schema(
  1529|         0|            0|            0|  0.00%|            attrgetter('pattern'), when_used='json', return_schema=core_schema.str_schema()
  1530|         0|            0|            0|  0.00%|        )
  1531|         0|            0|            0|  0.00%|        if pattern_type == typing.Pattern or pattern_type == re.Pattern:
  1532|         0|            0|            0|  0.00%|            # bare type
  1533|         0|            0|            0|  0.00%|            return core_schema.no_info_plain_validator_function(
  1534|         0|            0|            0|  0.00%|                _validators.pattern_either_validator, serialization=ser, metadata=metadata
  1535|         0|            0|            0|  0.00%|            )
  1536|         0|            0|            0|  0.00%|
  1537|         0|            0|            0|  0.00%|        param = self._get_args_resolving_forward_refs(
  1538|         0|            0|            0|  0.00%|            pattern_type,
  1539|         0|            0|            0|  0.00%|            required=True,
  1540|         0|            0|            0|  0.00%|        )[0]
  1541|         0|            0|            0|  0.00%|        if param is str:
  1542|         0|            0|            0|  0.00%|            return core_schema.no_info_plain_validator_function(
  1543|         0|            0|            0|  0.00%|                _validators.pattern_str_validator, serialization=ser, metadata=metadata
  1544|         0|            0|            0|  0.00%|            )
  1545|         0|            0|            0|  0.00%|        elif param is bytes:
  1546|         0|            0|            0|  0.00%|            return core_schema.no_info_plain_validator_function(
  1547|         0|            0|            0|  0.00%|                _validators.pattern_bytes_validator, serialization=ser, metadata=metadata
  1548|         0|            0|            0|  0.00%|            )
  1549|         0|            0|            0|  0.00%|        else:
  1550|         0|            0|            0|  0.00%|            raise PydanticSchemaGenerationError(f'Unable to generate pydantic-core schema for {pattern_type!r}.')
  1551|         0|            0|            0|  0.00%|
  1552|         0|            0|            0|  0.00%|    def _hashable_schema(self) -> core_schema.CoreSchema:
  1553|         0|            0|            0|  0.00%|        return core_schema.custom_error_schema(
  1554|         0|            0|            0|  0.00%|            core_schema.is_instance_schema(collections.abc.Hashable),
  1555|         0|            0|            0|  0.00%|            custom_error_type='is_hashable',
  1556|         0|            0|            0|  0.00%|            custom_error_message='Input should be hashable',
  1557|         0|            0|            0|  0.00%|        )
  1558|         0|            0|            0|  0.00%|
  1559|         0|            0|            0|  0.00%|    def _dataclass_schema(
  1560|         0|            0|            0|  0.00%|        self, dataclass: type[StandardDataclass], origin: type[StandardDataclass] | None
  1561|         0|            0|            0|  0.00%|    ) -> core_schema.CoreSchema:
  1562|         0|            0|            0|  0.00%|        """Generate schema for a dataclass."""
  1563|         0|            0|            0|  0.00%|        with self.model_type_stack.push(dataclass), self.defs.get_schema_or_ref(dataclass) as (
  1564|         0|            0|            0|  0.00%|            dataclass_ref,
  1565|         0|            0|            0|  0.00%|            maybe_schema,
  1566|         0|            0|            0|  0.00%|        ):
  1567|         0|            0|            0|  0.00%|            if maybe_schema is not None:
  1568|         0|            0|            0|  0.00%|                return maybe_schema
  1569|         0|            0|            0|  0.00%|
  1570|         0|            0|            0|  0.00%|            typevars_map = get_standard_typevars_map(dataclass)
  1571|         0|            0|            0|  0.00%|            if origin is not None:
  1572|         0|            0|            0|  0.00%|                dataclass = origin
  1573|         0|            0|            0|  0.00%|
  1574|         0|            0|            0|  0.00%|            with ExitStack() as dataclass_bases_stack:
  1575|         0|            0|            0|  0.00%|                # Pushing a namespace prioritises items already in the stack, so iterate though the MRO forwards
  1576|         0|            0|            0|  0.00%|                for dataclass_base in dataclass.__mro__:
  1577|         0|            0|            0|  0.00%|                    if dataclasses.is_dataclass(dataclass_base):
  1578|         0|            0|            0|  0.00%|                        dataclass_bases_stack.enter_context(self._types_namespace_stack.push(dataclass_base))
  1579|         0|            0|            0|  0.00%|
  1580|         0|            0|            0|  0.00%|                # Pushing a config overwrites the previous config, so iterate though the MRO backwards
  1581|         0|            0|            0|  0.00%|                config = None
  1582|         0|            0|            0|  0.00%|                for dataclass_base in reversed(dataclass.__mro__):
  1583|         0|            0|            0|  0.00%|                    if dataclasses.is_dataclass(dataclass_base):
  1584|         0|            0|            0|  0.00%|                        config = getattr(dataclass_base, '__pydantic_config__', None)
  1585|         0|            0|            0|  0.00%|                        dataclass_bases_stack.enter_context(self._config_wrapper_stack.push(config))
  1586|         0|            0|            0|  0.00%|
  1587|         0|            0|            0|  0.00%|                core_config = self._config_wrapper.core_config(dataclass)
  1588|         0|            0|            0|  0.00%|
  1589|         0|            0|            0|  0.00%|                self = self._current_generate_schema
  1590|         0|            0|            0|  0.00%|
  1591|         0|            0|            0|  0.00%|                from ..dataclasses import is_pydantic_dataclass
  1592|         0|            0|            0|  0.00%|
  1593|         0|            0|            0|  0.00%|                if is_pydantic_dataclass(dataclass):
  1594|         0|            0|            0|  0.00%|                    fields = deepcopy(dataclass.__pydantic_fields__)
  1595|         0|            0|            0|  0.00%|                    if typevars_map:
  1596|         0|            0|            0|  0.00%|                        for field in fields.values():
  1597|         0|            0|            0|  0.00%|                            field.apply_typevars_map(typevars_map, self._types_namespace)
  1598|         0|            0|            0|  0.00%|                else:
  1599|         0|            0|            0|  0.00%|                    fields = collect_dataclass_fields(
  1600|         0|            0|            0|  0.00%|                        dataclass,
  1601|         0|            0|            0|  0.00%|                        self._types_namespace,
  1602|         0|            0|            0|  0.00%|                        typevars_map=typevars_map,
  1603|         0|            0|            0|  0.00%|                    )
  1604|         0|            0|            0|  0.00%|
  1605|         0|            0|            0|  0.00%|                # disallow combination of init=False on a dataclass field and extra='allow' on a dataclass
  1606|         0|            0|            0|  0.00%|                if self._config_wrapper_stack.tail.extra == 'allow':
  1607|         0|            0|            0|  0.00%|                    # disallow combination of init=False on a dataclass field and extra='allow' on a dataclass
  1608|         0|            0|            0|  0.00%|                    for field_name, field in fields.items():
  1609|         0|            0|            0|  0.00%|                        if field.init is False:
  1610|         0|            0|            0|  0.00%|                            raise PydanticUserError(
  1611|         0|            0|            0|  0.00%|                                f'Field {field_name} has `init=False` and dataclass has config setting `extra="allow"`. '
  1612|         0|            0|            0|  0.00%|                                f'This combination is not allowed.',
  1613|         0|            0|            0|  0.00%|                                code='dataclass-init-false-extra-allow',
  1614|         0|            0|            0|  0.00%|                            )
  1615|         0|            0|            0|  0.00%|
  1616|         0|            0|            0|  0.00%|                decorators = dataclass.__dict__.get('__pydantic_decorators__') or DecoratorInfos.build(dataclass)
  1617|         0|            0|            0|  0.00%|                # Move kw_only=False args to the start of the list, as this is how vanilla dataclasses work.
  1618|         0|            0|            0|  0.00%|                # Note that when kw_only is missing or None, it is treated as equivalent to kw_only=True
  1619|         0|            0|            0|  0.00%|                args = sorted(
  1620|         0|            0|            0|  0.00%|                    (self._generate_dc_field_schema(k, v, decorators) for k, v in fields.items()),
  1621|         0|            0|            0|  0.00%|                    key=lambda a: a.get('kw_only') is not False,
  1622|         0|            0|            0|  0.00%|                )
  1623|         0|            0|            0|  0.00%|                has_post_init = hasattr(dataclass, '__post_init__')
  1624|         0|            0|            0|  0.00%|                has_slots = hasattr(dataclass, '__slots__')
  1625|         0|            0|            0|  0.00%|
  1626|         0|            0|            0|  0.00%|                args_schema = core_schema.dataclass_args_schema(
  1627|         0|            0|            0|  0.00%|                    dataclass.__name__,
  1628|         0|            0|            0|  0.00%|                    args,
  1629|         0|            0|            0|  0.00%|                    computed_fields=[
  1630|         0|            0|            0|  0.00%|                        self._computed_field_schema(d, decorators.field_serializers)
  1631|         0|            0|            0|  0.00%|                        for d in decorators.computed_fields.values()
  1632|         0|            0|            0|  0.00%|                    ],
  1633|         0|            0|            0|  0.00%|                    collect_init_only=has_post_init,
  1634|         0|            0|            0|  0.00%|                )
  1635|         0|            0|            0|  0.00%|
  1636|         0|            0|            0|  0.00%|                inner_schema = apply_validators(args_schema, decorators.root_validators.values(), None)
  1637|         0|            0|            0|  0.00%|
  1638|         0|            0|            0|  0.00%|                model_validators = decorators.model_validators.values()
  1639|         0|            0|            0|  0.00%|                inner_schema = apply_model_validators(inner_schema, model_validators, 'inner')
  1640|         0|            0|            0|  0.00%|
  1641|         0|            0|            0|  0.00%|                title = self._get_model_title_from_config(dataclass, ConfigWrapper(config))
  1642|         0|            0|            0|  0.00%|                metadata = build_metadata_dict(
  1643|         0|            0|            0|  0.00%|                    js_functions=[partial(modify_model_json_schema, cls=dataclass, title=title)]
  1644|         0|            0|            0|  0.00%|                )
  1645|         0|            0|            0|  0.00%|
  1646|         0|            0|            0|  0.00%|                dc_schema = core_schema.dataclass_schema(
  1647|         0|            0|            0|  0.00%|                    dataclass,
  1648|         0|            0|            0|  0.00%|                    inner_schema,
  1649|         0|            0|            0|  0.00%|                    post_init=has_post_init,
  1650|         0|            0|            0|  0.00%|                    ref=dataclass_ref,
  1651|         0|            0|            0|  0.00%|                    fields=[field.name for field in dataclasses.fields(dataclass)],
  1652|         0|            0|            0|  0.00%|                    slots=has_slots,
  1653|         0|            0|            0|  0.00%|                    config=core_config,
  1654|         0|            0|            0|  0.00%|                    metadata=metadata,
  1655|         0|            0|            0|  0.00%|                )
  1656|         0|            0|            0|  0.00%|                schema = self._apply_model_serializers(dc_schema, decorators.model_serializers.values())
  1657|         0|            0|            0|  0.00%|                schema = apply_model_validators(schema, model_validators, 'outer')
  1658|         0|            0|            0|  0.00%|                self.defs.definitions[dataclass_ref] = schema
  1659|         0|            0|            0|  0.00%|                return core_schema.definition_reference_schema(dataclass_ref)
  1660|         0|            0|            0|  0.00%|
  1661|         0|            0|            0|  0.00%|            # Type checkers seem to assume ExitStack may suppress exceptions and therefore
  1662|         0|            0|            0|  0.00%|            # control flow can exit the `with` block without returning.
  1663|         0|            0|            0|  0.00%|            assert False, 'Unreachable'
  1664|         0|            0|            0|  0.00%|
  1665|         0|            0|            0|  0.00%|    def _callable_schema(self, function: Callable[..., Any]) -> core_schema.CallSchema:
  1666|         0|            0|            0|  0.00%|        """Generate schema for a Callable.
  1667|         0|            0|            0|  0.00%|
  1668|         0|            0|            0|  0.00%|        TODO support functional validators once we support them in Config
  1669|         0|            0|            0|  0.00%|        """
  1670|         0|            0|            0|  0.00%|        sig = signature(function)
  1671|         0|            0|            0|  0.00%|
  1672|         0|            0|            0|  0.00%|        type_hints = _typing_extra.get_function_type_hints(function, types_namespace=self._types_namespace)
  1673|         0|            0|            0|  0.00%|
  1674|         0|            0|            0|  0.00%|        mode_lookup: dict[_ParameterKind, Literal['positional_only', 'positional_or_keyword', 'keyword_only']] = {
  1675|         0|            0|            0|  0.00%|            Parameter.POSITIONAL_ONLY: 'positional_only',
  1676|         0|            0|            0|  0.00%|            Parameter.POSITIONAL_OR_KEYWORD: 'positional_or_keyword',
  1677|         0|            0|            0|  0.00%|            Parameter.KEYWORD_ONLY: 'keyword_only',
  1678|         0|            0|            0|  0.00%|        }
  1679|         0|            0|            0|  0.00%|
  1680|         0|            0|            0|  0.00%|        arguments_list: list[core_schema.ArgumentsParameter] = []
  1681|         0|            0|            0|  0.00%|        var_args_schema: core_schema.CoreSchema | None = None
  1682|         0|            0|            0|  0.00%|        var_kwargs_schema: core_schema.CoreSchema | None = None
  1683|         0|            0|            0|  0.00%|
  1684|         0|            0|            0|  0.00%|        for name, p in sig.parameters.items():
  1685|         0|            0|            0|  0.00%|            if p.annotation is sig.empty:
  1686|         0|            0|            0|  0.00%|                annotation = typing.cast(Any, Any)
  1687|         0|            0|            0|  0.00%|            else:
  1688|         0|            0|            0|  0.00%|                annotation = type_hints[name]
  1689|         0|            0|            0|  0.00%|
  1690|         0|            0|            0|  0.00%|            parameter_mode = mode_lookup.get(p.kind)
  1691|         0|            0|            0|  0.00%|            if parameter_mode is not None:
  1692|         0|            0|            0|  0.00%|                arg_schema = self._generate_parameter_schema(name, annotation, p.default, parameter_mode)
  1693|         0|            0|            0|  0.00%|                arguments_list.append(arg_schema)
  1694|         0|            0|            0|  0.00%|            elif p.kind == Parameter.VAR_POSITIONAL:
  1695|         0|            0|            0|  0.00%|                var_args_schema = self.generate_schema(annotation)
  1696|         0|            0|            0|  0.00%|            else:
  1697|         0|            0|            0|  0.00%|                assert p.kind == Parameter.VAR_KEYWORD, p.kind
  1698|         0|            0|            0|  0.00%|                var_kwargs_schema = self.generate_schema(annotation)
  1699|         0|            0|            0|  0.00%|
  1700|         0|            0|            0|  0.00%|        return_schema: core_schema.CoreSchema | None = None
  1701|         0|            0|            0|  0.00%|        config_wrapper = self._config_wrapper
  1702|         0|            0|            0|  0.00%|        if config_wrapper.validate_return:
  1703|         0|            0|            0|  0.00%|            return_hint = type_hints.get('return')
  1704|         0|            0|            0|  0.00%|            if return_hint is not None:
  1705|         0|            0|            0|  0.00%|                return_schema = self.generate_schema(return_hint)
  1706|         0|            0|            0|  0.00%|
  1707|         0|            0|            0|  0.00%|        return core_schema.call_schema(
  1708|         0|            0|            0|  0.00%|            core_schema.arguments_schema(
  1709|         0|            0|            0|  0.00%|                arguments_list,
  1710|         0|            0|            0|  0.00%|                var_args_schema=var_args_schema,
  1711|         0|            0|            0|  0.00%|                var_kwargs_schema=var_kwargs_schema,
  1712|         0|            0|            0|  0.00%|                populate_by_name=config_wrapper.populate_by_name,
  1713|         0|            0|            0|  0.00%|            ),
  1714|         0|            0|            0|  0.00%|            function,
  1715|         0|            0|            0|  0.00%|            return_schema=return_schema,
  1716|         0|            0|            0|  0.00%|        )
  1717|         0|            0|            0|  0.00%|
  1718|         0|            0|            0|  0.00%|    def _unsubstituted_typevar_schema(self, typevar: typing.TypeVar) -> core_schema.CoreSchema:
  1719|         0|            0|            0|  0.00%|        assert isinstance(typevar, typing.TypeVar)
  1720|         0|            0|            0|  0.00%|
  1721|         0|            0|            0|  0.00%|        bound = typevar.__bound__
  1722|         0|            0|            0|  0.00%|        constraints = typevar.__constraints__
  1723|         0|            0|            0|  0.00%|
  1724|         0|            0|            0|  0.00%|        try:
  1725|         0|            0|            0|  0.00%|            typevar_has_default = typevar.has_default()  # type: ignore
  1726|         0|            0|            0|  0.00%|        except AttributeError:
  1727|         0|            0|            0|  0.00%|            # could still have a default if it's an old version of typing_extensions.TypeVar
  1728|         0|            0|            0|  0.00%|            typevar_has_default = getattr(typevar, '__default__', None) is not None
  1729|         0|            0|            0|  0.00%|
  1730|         0|            0|            0|  0.00%|        if (bound is not None) + (len(constraints) != 0) + typevar_has_default > 1:
  1731|         0|            0|            0|  0.00%|            raise NotImplementedError(
  1732|         0|            0|            0|  0.00%|                'Pydantic does not support mixing more than one of TypeVar bounds, constraints and defaults'
  1733|         0|            0|            0|  0.00%|            )
  1734|         0|            0|            0|  0.00%|
  1735|         0|            0|            0|  0.00%|        if typevar_has_default:
  1736|         0|            0|            0|  0.00%|            return self.generate_schema(typevar.__default__)  # type: ignore
  1737|         0|            0|            0|  0.00%|        elif constraints:
  1738|         0|            0|            0|  0.00%|            return self._union_schema(typing.Union[constraints])  # type: ignore
  1739|         0|            0|            0|  0.00%|        elif bound:
  1740|         0|            0|            0|  0.00%|            schema = self.generate_schema(bound)
  1741|         0|            0|            0|  0.00%|            schema['serialization'] = core_schema.wrap_serializer_function_ser_schema(
  1742|         0|            0|            0|  0.00%|                lambda x, h: h(x), schema=core_schema.any_schema()
  1743|         0|            0|            0|  0.00%|            )
  1744|         0|            0|            0|  0.00%|            return schema
  1745|         0|            0|            0|  0.00%|        else:
  1746|         0|            0|            0|  0.00%|            return core_schema.any_schema()
  1747|         0|            0|            0|  0.00%|
  1748|         0|            0|            0|  0.00%|    def _computed_field_schema(
  1749|         0|            0|            0|  0.00%|        self,
  1750|         0|            0|            0|  0.00%|        d: Decorator[ComputedFieldInfo],
  1751|         0|            0|            0|  0.00%|        field_serializers: dict[str, Decorator[FieldSerializerDecoratorInfo]],
  1752|         0|            0|            0|  0.00%|    ) -> core_schema.ComputedField:
  1753|         0|            0|            0|  0.00%|        try:
  1754|         0|            0|            0|  0.00%|            return_type = _decorators.get_function_return_type(d.func, d.info.return_type, self._types_namespace)
  1755|         0|            0|            0|  0.00%|        except NameError as e:
  1756|         0|            0|            0|  0.00%|            raise PydanticUndefinedAnnotation.from_name_error(e) from e
  1757|         0|            0|            0|  0.00%|        if return_type is PydanticUndefined:
  1758|         0|            0|            0|  0.00%|            raise PydanticUserError(
  1759|         0|            0|            0|  0.00%|                'Computed field is missing return type annotation or specifying `return_type`'
  1760|         0|            0|            0|  0.00%|                ' to the `@computed_field` decorator (e.g. `@computed_field(return_type=int|str)`)',
  1761|         0|            0|            0|  0.00%|                code='model-field-missing-annotation',
  1762|         0|            0|            0|  0.00%|            )
  1763|         0|            0|            0|  0.00%|
  1764|         0|            0|            0|  0.00%|        return_type = replace_types(return_type, self._typevars_map)
  1765|         0|            0|            0|  0.00%|        # Create a new ComputedFieldInfo so that different type parametrizations of the same
  1766|         0|            0|            0|  0.00%|        # generic model's computed field can have different return types.
  1767|         0|            0|            0|  0.00%|        d.info = dataclasses.replace(d.info, return_type=return_type)
  1768|         0|            0|            0|  0.00%|        return_type_schema = self.generate_schema(return_type)
  1769|         0|            0|            0|  0.00%|        # Apply serializers to computed field if there exist
  1770|         0|            0|            0|  0.00%|        return_type_schema = self._apply_field_serializers(
  1771|         0|            0|            0|  0.00%|            return_type_schema,
  1772|         0|            0|            0|  0.00%|            filter_field_decorator_info_by_field(field_serializers.values(), d.cls_var_name),
  1773|         0|            0|            0|  0.00%|            computed_field=True,
  1774|         0|            0|            0|  0.00%|        )
  1775|         0|            0|            0|  0.00%|
  1776|         0|            0|            0|  0.00%|        alias_generator = self._config_wrapper.alias_generator
  1777|         0|            0|            0|  0.00%|        if alias_generator is not None:
  1778|         0|            0|            0|  0.00%|            self._apply_alias_generator_to_computed_field_info(
  1779|         0|            0|            0|  0.00%|                alias_generator=alias_generator, computed_field_info=d.info, computed_field_name=d.cls_var_name
  1780|         0|            0|            0|  0.00%|            )
  1781|         0|            0|            0|  0.00%|        self._apply_field_title_generator_to_field_info(self._config_wrapper, d.info, d.cls_var_name)
  1782|         0|            0|            0|  0.00%|
  1783|         0|            0|            0|  0.00%|        def set_computed_field_metadata(schema: CoreSchemaOrField, handler: GetJsonSchemaHandler) -> JsonSchemaValue:
  1784|         0|            0|            0|  0.00%|            json_schema = handler(schema)
  1785|         0|            0|            0|  0.00%|
  1786|         0|            0|            0|  0.00%|            json_schema['readOnly'] = True
  1787|         0|            0|            0|  0.00%|
  1788|         0|            0|            0|  0.00%|            title = d.info.title
  1789|         0|            0|            0|  0.00%|            if title is not None:
  1790|         0|            0|            0|  0.00%|                json_schema['title'] = title
  1791|         0|            0|            0|  0.00%|
  1792|         0|            0|            0|  0.00%|            description = d.info.description
  1793|         0|            0|            0|  0.00%|            if description is not None:
  1794|         0|            0|            0|  0.00%|                json_schema['description'] = description
  1795|         0|            0|            0|  0.00%|
  1796|         0|            0|            0|  0.00%|            if d.info.deprecated or d.info.deprecated == '':
  1797|         0|            0|            0|  0.00%|                json_schema['deprecated'] = True
  1798|         0|            0|            0|  0.00%|
  1799|         0|            0|            0|  0.00%|            examples = d.info.examples
  1800|         0|            0|            0|  0.00%|            if examples is not None:
  1801|         0|            0|            0|  0.00%|                json_schema['examples'] = to_jsonable_python(examples)
  1802|         0|            0|            0|  0.00%|
  1803|         0|            0|            0|  0.00%|            json_schema_extra = d.info.json_schema_extra
  1804|         0|            0|            0|  0.00%|            if json_schema_extra is not None:
  1805|         0|            0|            0|  0.00%|                add_json_schema_extra(json_schema, json_schema_extra)
  1806|         0|            0|            0|  0.00%|
  1807|         0|            0|            0|  0.00%|            return json_schema
  1808|         0|            0|            0|  0.00%|
  1809|         0|            0|            0|  0.00%|        metadata = build_metadata_dict(js_annotation_functions=[set_computed_field_metadata])
  1810|         0|            0|            0|  0.00%|        return core_schema.computed_field(
  1811|         0|            0|            0|  0.00%|            d.cls_var_name, return_schema=return_type_schema, alias=d.info.alias, metadata=metadata
  1812|         0|            0|            0|  0.00%|        )
  1813|         0|            0|            0|  0.00%|
  1814|         2|  7.86781e-06|  3.93391e-06|  0.01%|    def _annotated_schema(self, annotated_type: Any) -> core_schema.CoreSchema:
  1815|         0|            0|            0|  0.00%|        """Generate schema for an Annotated type, e.g. `Annotated[int, Field(...)]` or `Annotated[int, Gt(0)]`."""
  1816|         2|  2.98023e-05|  1.49012e-05|  0.03%|        from ..fields import FieldInfo
(call)|         2|  2.43187e-05|  1.21593e-05|  0.02%|# <frozen importlib._bootstrap>:645 parent
  1817|         0|            0|            0|  0.00%|
  1818|         4|  4.00543e-05|  1.00136e-05|  0.04%|        source_type, *annotations = self._get_args_resolving_forward_refs(
(call)|         2|  7.12872e-05|  3.56436e-05|  0.07%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:743 _get_args_resolving_forward_refs
  1819|         2|  3.57628e-06|  1.78814e-06|  0.00%|            annotated_type,
  1820|         2|  3.33786e-06|  1.66893e-06|  0.00%|            required=True,
  1821|         0|            0|            0|  0.00%|        )
  1822|         2|   2.5034e-05|   1.2517e-05|  0.03%|        schema = self._apply_annotations(source_type, annotations)
(call)|         2|   0.00516486|   0.00258243|  5.31%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:1849 _apply_annotations
  1823|         0|            0|            0|  0.00%|        # put the default validator last so that TypeAdapter.get_default_value() works
  1824|         0|            0|            0|  0.00%|        # even if there are function validators involved
  1825|         4|  7.86781e-06|  1.96695e-06|  0.01%|        for annotation in annotations:
  1826|         2|  3.57628e-06|  1.78814e-06|  0.00%|            if isinstance(annotation, FieldInfo):
  1827|         2|  1.50204e-05|  7.51019e-06|  0.02%|                schema = wrap_default(annotation, schema)
(call)|         2|  1.69277e-05|  8.46386e-06|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:2190 wrap_default
  1828|         2|  2.38419e-06|  1.19209e-06|  0.00%|        return schema
  1829|         0|            0|            0|  0.00%|
  1830|         2|  7.15256e-06|  3.57628e-06|  0.01%|    def _get_prepare_pydantic_annotations_for_known_type(
  1831|         0|            0|            0|  0.00%|        self, obj: Any, annotations: tuple[Any, ...]
  1832|         0|            0|            0|  0.00%|    ) -> tuple[Any, list[Any]] | None:
  1833|         2|   1.7643e-05|  8.82149e-06|  0.02%|        from ._std_types_schema import PREPARE_METHODS
(call)|         2|  1.04904e-05|  5.24521e-06|  0.01%|# <frozen importlib._bootstrap>:645 parent
  1834|         0|            0|            0|  0.00%|
  1835|         0|            0|            0|  0.00%|        # Check for hashability
  1836|         2|   3.8147e-06|  1.90735e-06|  0.00%|        try:
  1837|         2|  4.29153e-06|  2.14577e-06|  0.00%|            hash(obj)
  1838|         0|            0|            0|  0.00%|        except TypeError:
  1839|         0|            0|            0|  0.00%|            # obj is definitely not a known type if this fails
  1840|         0|            0|            0|  0.00%|            return None
  1841|         0|            0|            0|  0.00%|
  1842|        18|  2.64645e-05|  1.47025e-06|  0.03%|        for gen in PREPARE_METHODS:
  1843|        16|   0.00022459|  1.40369e-05|  0.23%|            res = gen(obj, annotations, self._config_wrapper.config_dict)
(call)|        16|  0.000113249|  7.07805e-06|  0.12%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:361 _config_wrapper
(call)|         2|  1.71661e-05|  8.58307e-06|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_std_types_schema.py:153 decimal_prepare_pydantic_annotations
(call)|         2|  5.96046e-05|  2.98023e-05|  0.06%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_std_types_schema.py:400 sequence_like_prepare_pydantic_annotations
(call)|         2|  0.000881672|  0.000440836|  0.91%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_std_types_schema.py:171 datetime_prepare_pydantic_annotations
(call)|         2|  1.93119e-05|  9.65595e-06|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_std_types_schema.py:192 uuid_prepare_pydantic_annotations
(call)|         2|  8.03471e-05|  4.01735e-05|  0.08%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_std_types_schema.py:205 path_schema_prepare_pydantic_annotations
(call)|         2|  7.00951e-05|  3.50475e-05|  0.07%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_std_types_schema.py:571 mapping_like_prepare_pydantic_annotations
(call)|         2|  9.70364e-05|  4.85182e-05|  0.10%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_std_types_schema.py:606 ip_prepare_pydantic_annotations
(call)|         2|  2.09808e-05|  1.04904e-05|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_std_types_schema.py:692 url_prepare_pydantic_annotations
  1844|        16|  2.38419e-05|  1.49012e-06|  0.02%|            if res is not None:
  1845|         0|            0|            0|  0.00%|                return res
  1846|         0|            0|            0|  0.00%|
  1847|         2|  2.38419e-06|  1.19209e-06|  0.00%|        return None
  1848|         0|            0|            0|  0.00%|
  1849|         2|  2.40803e-05|  1.20401e-05|  0.02%|    def _apply_annotations(
  1850|         0|            0|            0|  0.00%|        self,
  1851|         0|            0|            0|  0.00%|        source_type: Any,
  1852|         0|            0|            0|  0.00%|        annotations: list[Any],
  1853|         4|  6.19888e-06|  1.54972e-06|  0.01%|        transform_inner_schema: Callable[[CoreSchema], CoreSchema] = lambda x: x,
  1854|         0|            0|            0|  0.00%|    ) -> CoreSchema:
  1855|         0|            0|            0|  0.00%|        """Apply arguments from `Annotated` or from `FieldInfo` to a schema.
  1856|         0|            0|            0|  0.00%|
  1857|         0|            0|            0|  0.00%|        This gets called by `GenerateSchema._annotated_schema` but differs from it in that it does
  1858|         0|            0|            0|  0.00%|        not expect `source_type` to be an `Annotated` object, it expects it to be  the first argument of that
  1859|         0|            0|            0|  0.00%|        (in other words, `GenerateSchema._annotated_schema` just unpacks `Annotated`, this process it).
  1860|         0|            0|            0|  0.00%|        """
  1861|         2|  4.36306e-05|  2.18153e-05|  0.04%|        annotations = list(_known_annotated_metadata.expand_grouped_metadata(annotations))
(call)|         4|    0.0018518|  0.000462949|  1.90%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_known_annotated_metadata.py:120 expand_grouped_metadata
  1862|         2|  2.57492e-05|  1.28746e-05|  0.03%|        res = self._get_prepare_pydantic_annotations_for_known_type(source_type, tuple(annotations))
(call)|         2|   0.00168014|  0.000840068|  1.73%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:1830 _get_prepare_pydantic_annotations_for_known_type
  1863|         2|   6.4373e-06|  3.21865e-06|  0.01%|        if res is not None:
  1864|         0|            0|            0|  0.00%|            source_type, annotations = res
  1865|         0|            0|            0|  0.00%|
  1866|         2|  5.00679e-06|   2.5034e-06|  0.01%|        pydantic_js_annotation_functions: list[GetJsonSchemaFunction] = []
  1867|         0|            0|            0|  0.00%|
  1868|         4|  1.00136e-05|   2.5034e-06|  0.01%|        def inner_handler(obj: Any) -> CoreSchema:
  1869|         2|  2.19345e-05|  1.09673e-05|  0.02%|            from_property = self._generate_schema_from_property(obj, source_type)
(call)|         2|    0.0004251|   0.00021255|  0.44%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:654 _generate_schema_from_property
  1870|         2|  4.05312e-06|  2.02656e-06|  0.00%|            if from_property is None:
  1871|         2|  1.81198e-05|  9.05991e-06|  0.02%|                schema = self._generate_schema_inner(obj)
(call)|         2|  0.000385284|  0.000192642|  0.40%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:766 _generate_schema_inner
  1872|         0|            0|            0|  0.00%|            else:
  1873|         0|            0|            0|  0.00%|                schema = from_property
  1874|         2|  2.14577e-05|  1.07288e-05|  0.02%|            metadata_js_function = _extract_get_pydantic_json_schema(obj, schema)
(call)|         2|  3.24249e-05|  1.62125e-05|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:2212 _extract_get_pydantic_json_schema
  1875|         2|  3.33786e-06|  1.66893e-06|  0.00%|            if metadata_js_function is not None:
  1876|         0|            0|            0|  0.00%|                metadata_schema = resolve_original_schema(schema, self.defs.definitions)
  1877|         0|            0|            0|  0.00%|                if metadata_schema is not None:
  1878|         0|            0|            0|  0.00%|                    self._add_js_function(metadata_schema, metadata_js_function)
  1879|         2|   1.3113e-05|  6.55651e-06|  0.01%|            return transform_inner_schema(schema)
(call)|         2|  6.19888e-06|  3.09944e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:1853 <lambda>
  1880|         0|            0|            0|  0.00%|
  1881|         2|  2.12193e-05|  1.06096e-05|  0.02%|        get_inner_schema = CallbackGetCoreSchemaHandler(inner_handler, self)
(call)|         2|  1.81198e-05|  9.05991e-06|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_schema_generation_shared.py:72 __init__
  1882|         0|            0|            0|  0.00%|
  1883|         4|  9.53674e-06|  2.38419e-06|  0.01%|        for annotation in annotations:
  1884|         2|  6.91414e-06|  3.45707e-06|  0.01%|            if annotation is None:
  1885|         0|            0|            0|  0.00%|                continue
  1886|         4|  2.74181e-05|  6.85453e-06|  0.03%|            get_inner_schema = self._get_wrapped_inner_schema(
(call)|         2|  5.10216e-05|  2.55108e-05|  0.05%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:1961 _get_wrapped_inner_schema
  1887|         2|  4.52995e-06|  2.26498e-06|  0.00%|                get_inner_schema, annotation, pydantic_js_annotation_functions
  1888|         0|            0|            0|  0.00%|            )
  1889|         0|            0|            0|  0.00%|
  1890|         2|  1.97887e-05|  9.89437e-06|  0.02%|        schema = get_inner_schema(source_type)
(call)|         2|   0.00124669|  0.000623345|  1.28%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_schema_generation_shared.py:82 __call__
  1891|         2|  5.72205e-06|  2.86102e-06|  0.01%|        if pydantic_js_annotation_functions:
  1892|         0|            0|            0|  0.00%|            metadata = CoreMetadataHandler(schema).metadata
  1893|         0|            0|            0|  0.00%|            metadata.setdefault('pydantic_js_annotation_functions', []).extend(pydantic_js_annotation_functions)
  1894|         2|  4.88758e-05|  2.44379e-05|  0.05%|        return _add_custom_serialization_from_json_encoders(self._config_wrapper.json_encoders, source_type, schema)
(call)|         2|   1.5974e-05|  7.98702e-06|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:361 _config_wrapper
(call)|         2|  3.00407e-05|  1.50204e-05|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_config.py:147 __getattr__
(call)|         2|  1.62125e-05|  8.10623e-06|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:251 _add_custom_serialization_from_json_encoders
  1895|         0|            0|            0|  0.00%|
  1896|         2|  7.39098e-06|  3.69549e-06|  0.01%|    def _apply_single_annotation(self, schema: core_schema.CoreSchema, metadata: Any) -> core_schema.CoreSchema:
  1897|         2|  1.97887e-05|  9.89437e-06|  0.02%|        from ..fields import FieldInfo
(call)|         2|  1.12057e-05|  5.60284e-06|  0.01%|# <frozen importlib._bootstrap>:645 parent
  1898|         0|            0|            0|  0.00%|
  1899|         2|   6.4373e-06|  3.21865e-06|  0.01%|        if isinstance(metadata, FieldInfo):
  1900|         2|  5.96046e-06|  2.98023e-06|  0.01%|            for field_metadata in metadata.metadata:
  1901|         0|            0|            0|  0.00%|                schema = self._apply_single_annotation(schema, field_metadata)
  1902|         0|            0|            0|  0.00%|
  1903|         2|  5.72205e-06|  2.86102e-06|  0.01%|            if metadata.discriminator is not None:
  1904|         0|            0|            0|  0.00%|                schema = self._apply_discriminator_to_union(schema, metadata.discriminator)
  1905|         2|  5.48363e-06|  2.74181e-06|  0.01%|            return schema
  1906|         0|            0|            0|  0.00%|
  1907|         0|            0|            0|  0.00%|        if schema['type'] == 'nullable':
  1908|         0|            0|            0|  0.00%|            # for nullable schemas, metadata is automatically applied to the inner schema
  1909|         0|            0|            0|  0.00%|            inner = schema.get('schema', core_schema.any_schema())
  1910|         0|            0|            0|  0.00%|            inner = self._apply_single_annotation(inner, metadata)
  1911|         0|            0|            0|  0.00%|            if inner:
  1912|         0|            0|            0|  0.00%|                schema['schema'] = inner
  1913|         0|            0|            0|  0.00%|            return schema
  1914|         0|            0|            0|  0.00%|
  1915|         0|            0|            0|  0.00%|        original_schema = schema
  1916|         0|            0|            0|  0.00%|        ref = schema.get('ref', None)
  1917|         0|            0|            0|  0.00%|        if ref is not None:
  1918|         0|            0|            0|  0.00%|            schema = schema.copy()
  1919|         0|            0|            0|  0.00%|            new_ref = ref + f'_{repr(metadata)}'
  1920|         0|            0|            0|  0.00%|            if new_ref in self.defs.definitions:
  1921|         0|            0|            0|  0.00%|                return self.defs.definitions[new_ref]
  1922|         0|            0|            0|  0.00%|            schema['ref'] = new_ref  # type: ignore
  1923|         0|            0|            0|  0.00%|        elif schema['type'] == 'definition-ref':
  1924|         0|            0|            0|  0.00%|            ref = schema['schema_ref']
  1925|         0|            0|            0|  0.00%|            if ref in self.defs.definitions:
  1926|         0|            0|            0|  0.00%|                schema = self.defs.definitions[ref].copy()
  1927|         0|            0|            0|  0.00%|                new_ref = ref + f'_{repr(metadata)}'
  1928|         0|            0|            0|  0.00%|                if new_ref in self.defs.definitions:
  1929|         0|            0|            0|  0.00%|                    return self.defs.definitions[new_ref]
  1930|         0|            0|            0|  0.00%|                schema['ref'] = new_ref  # type: ignore
  1931|         0|            0|            0|  0.00%|
  1932|         0|            0|            0|  0.00%|        maybe_updated_schema = _known_annotated_metadata.apply_known_metadata(metadata, schema.copy())
  1933|         0|            0|            0|  0.00%|
  1934|         0|            0|            0|  0.00%|        if maybe_updated_schema is not None:
  1935|         0|            0|            0|  0.00%|            return maybe_updated_schema
  1936|         0|            0|            0|  0.00%|        return original_schema
  1937|         0|            0|            0|  0.00%|
  1938|         2|  7.39098e-06|  3.69549e-06|  0.01%|    def _apply_single_annotation_json_schema(
  1939|         0|            0|            0|  0.00%|        self, schema: core_schema.CoreSchema, metadata: Any
  1940|         0|            0|            0|  0.00%|    ) -> core_schema.CoreSchema:
  1941|         2|  1.28746e-05|   6.4373e-06|  0.01%|        from ..fields import FieldInfo
(call)|         2|  8.58307e-06|  4.29153e-06|  0.01%|# <frozen importlib._bootstrap>:645 parent
  1942|         0|            0|            0|  0.00%|
  1943|         2|  4.05312e-06|  2.02656e-06|  0.00%|        if isinstance(metadata, FieldInfo):
  1944|         2|  4.05312e-06|  2.02656e-06|  0.00%|            for field_metadata in metadata.metadata:
  1945|         0|            0|            0|  0.00%|                schema = self._apply_single_annotation_json_schema(schema, field_metadata)
  1946|         2|  3.57628e-06|  1.78814e-06|  0.00%|            json_schema_update: JsonSchemaValue = {}
  1947|         2|  4.05312e-06|  2.02656e-06|  0.00%|            if metadata.title:
  1948|         0|            0|            0|  0.00%|                json_schema_update['title'] = metadata.title
  1949|         2|  5.72205e-06|  2.86102e-06|  0.01%|            if metadata.description:
  1950|         0|            0|            0|  0.00%|                json_schema_update['description'] = metadata.description
  1951|         2|   3.8147e-06|  1.90735e-06|  0.00%|            if metadata.examples:
  1952|         0|            0|            0|  0.00%|                json_schema_update['examples'] = to_jsonable_python(metadata.examples)
  1953|         0|            0|            0|  0.00%|
  1954|         2|  4.05312e-06|  2.02656e-06|  0.00%|            json_schema_extra = metadata.json_schema_extra
  1955|         2|  4.05312e-06|  2.02656e-06|  0.00%|            if json_schema_update or json_schema_extra:
  1956|         0|            0|            0|  0.00%|                CoreMetadataHandler(schema).metadata.setdefault('pydantic_js_annotation_functions', []).append(
  1957|         0|            0|            0|  0.00%|                    get_json_schema_update_func(json_schema_update, json_schema_extra)
  1958|         0|            0|            0|  0.00%|                )
  1959|         2|   3.8147e-06|  1.90735e-06|  0.00%|        return schema
  1960|         0|            0|            0|  0.00%|
  1961|         2|  9.77516e-06|  4.88758e-06|  0.01%|    def _get_wrapped_inner_schema(
  1962|         0|            0|            0|  0.00%|        self,
  1963|         0|            0|            0|  0.00%|        get_inner_schema: GetCoreSchemaHandler,
  1964|         0|            0|            0|  0.00%|        annotation: Any,
  1965|         0|            0|            0|  0.00%|        pydantic_js_annotation_functions: list[GetJsonSchemaFunction],
  1966|         0|            0|            0|  0.00%|    ) -> CallbackGetCoreSchemaHandler:
  1967|         4|  1.09673e-05|  2.74181e-06|  0.01%|        metadata_get_schema: GetCoreSchemaFunction = getattr(annotation, '__get_pydantic_core_schema__', None) or (
  1968|         6|  1.66893e-05|  2.78155e-06|  0.02%|            lambda source, handler: handler(source)
(call)|         2|  0.000967026|  0.000483513|  0.99%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_schema_generation_shared.py:82 __call__
  1969|         0|            0|            0|  0.00%|        )
  1970|         0|            0|            0|  0.00%|
  1971|         4|  6.91414e-06|  1.72853e-06|  0.01%|        def new_handler(source: Any) -> core_schema.CoreSchema:
  1972|         2|  1.04904e-05|  5.24521e-06|  0.01%|            schema = metadata_get_schema(source, get_inner_schema)
(call)|         2|  0.000979662|  0.000489831|  1.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:1968 <lambda>
  1973|         2|  2.86102e-05|  1.43051e-05|  0.03%|            schema = self._apply_single_annotation(schema, annotation)
(call)|         2|  6.19888e-05|  3.09944e-05|  0.06%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:1896 _apply_single_annotation
  1974|         2|  1.85966e-05|  9.29832e-06|  0.02%|            schema = self._apply_single_annotation_json_schema(schema, annotation)
(call)|         2|  6.60419e-05|   3.3021e-05|  0.07%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:1938 _apply_single_annotation_json_schema
  1975|         0|            0|            0|  0.00%|
  1976|         2|   1.3113e-05|  6.55651e-06|  0.01%|            metadata_js_function = _extract_get_pydantic_json_schema(annotation, schema)
(call)|         2|  2.26498e-05|  1.13249e-05|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:2212 _extract_get_pydantic_json_schema
  1977|         2|  3.33786e-06|  1.66893e-06|  0.00%|            if metadata_js_function is not None:
  1978|         0|            0|            0|  0.00%|                pydantic_js_annotation_functions.append(metadata_js_function)
  1979|         2|  3.33786e-06|  1.66893e-06|  0.00%|            return schema
  1980|         0|            0|            0|  0.00%|
  1981|         2|  1.26362e-05|  6.31809e-06|  0.01%|        return CallbackGetCoreSchemaHandler(new_handler, self)
(call)|         2|  1.04904e-05|  5.24521e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_schema_generation_shared.py:72 __init__
  1982|         0|            0|            0|  0.00%|
  1983|         0|            0|            0|  0.00%|    def _apply_field_serializers(
  1984|         0|            0|            0|  0.00%|        self,
  1985|         0|            0|            0|  0.00%|        schema: core_schema.CoreSchema,
  1986|         0|            0|            0|  0.00%|        serializers: list[Decorator[FieldSerializerDecoratorInfo]],
  1987|         0|            0|            0|  0.00%|        computed_field: bool = False,
  1988|         0|            0|            0|  0.00%|    ) -> core_schema.CoreSchema:
  1989|         0|            0|            0|  0.00%|        """Apply field serializers to a schema."""
  1990|         0|            0|            0|  0.00%|        if serializers:
  1991|         0|            0|            0|  0.00%|            schema = copy(schema)
  1992|         0|            0|            0|  0.00%|            if schema['type'] == 'definitions':
  1993|         0|            0|            0|  0.00%|                inner_schema = schema['schema']
  1994|         0|            0|            0|  0.00%|                schema['schema'] = self._apply_field_serializers(inner_schema, serializers)
  1995|         0|            0|            0|  0.00%|                return schema
  1996|         0|            0|            0|  0.00%|            else:
  1997|         0|            0|            0|  0.00%|                ref = typing.cast('str|None', schema.get('ref', None))
  1998|         0|            0|            0|  0.00%|                if ref is not None:
  1999|         0|            0|            0|  0.00%|                    schema = core_schema.definition_reference_schema(ref)
  2000|         0|            0|            0|  0.00%|
  2001|         0|            0|            0|  0.00%|            # use the last serializer to make it easy to override a serializer set on a parent model
  2002|         0|            0|            0|  0.00%|            serializer = serializers[-1]
  2003|         0|            0|            0|  0.00%|            is_field_serializer, info_arg = inspect_field_serializer(
  2004|         0|            0|            0|  0.00%|                serializer.func, serializer.info.mode, computed_field=computed_field
  2005|         0|            0|            0|  0.00%|            )
  2006|         0|            0|            0|  0.00%|
  2007|         0|            0|            0|  0.00%|            try:
  2008|         0|            0|            0|  0.00%|                return_type = _decorators.get_function_return_type(
  2009|         0|            0|            0|  0.00%|                    serializer.func, serializer.info.return_type, self._types_namespace
  2010|         0|            0|            0|  0.00%|                )
  2011|         0|            0|            0|  0.00%|            except NameError as e:
  2012|         0|            0|            0|  0.00%|                raise PydanticUndefinedAnnotation.from_name_error(e) from e
  2013|         0|            0|            0|  0.00%|
  2014|         0|            0|            0|  0.00%|            if return_type is PydanticUndefined:
  2015|         0|            0|            0|  0.00%|                return_schema = None
  2016|         0|            0|            0|  0.00%|            else:
  2017|         0|            0|            0|  0.00%|                return_schema = self.generate_schema(return_type)
  2018|         0|            0|            0|  0.00%|
  2019|         0|            0|            0|  0.00%|            if serializer.info.mode == 'wrap':
  2020|         0|            0|            0|  0.00%|                schema['serialization'] = core_schema.wrap_serializer_function_ser_schema(
  2021|         0|            0|            0|  0.00%|                    serializer.func,
  2022|         0|            0|            0|  0.00%|                    is_field_serializer=is_field_serializer,
  2023|         0|            0|            0|  0.00%|                    info_arg=info_arg,
  2024|         0|            0|            0|  0.00%|                    return_schema=return_schema,
  2025|         0|            0|            0|  0.00%|                    when_used=serializer.info.when_used,
  2026|         0|            0|            0|  0.00%|                )
  2027|         0|            0|            0|  0.00%|            else:
  2028|         0|            0|            0|  0.00%|                assert serializer.info.mode == 'plain'
  2029|         0|            0|            0|  0.00%|                schema['serialization'] = core_schema.plain_serializer_function_ser_schema(
  2030|         0|            0|            0|  0.00%|                    serializer.func,
  2031|         0|            0|            0|  0.00%|                    is_field_serializer=is_field_serializer,
  2032|         0|            0|            0|  0.00%|                    info_arg=info_arg,
  2033|         0|            0|            0|  0.00%|                    return_schema=return_schema,
  2034|         0|            0|            0|  0.00%|                    when_used=serializer.info.when_used,
  2035|         0|            0|            0|  0.00%|                )
  2036|         0|            0|            0|  0.00%|        return schema
  2037|         0|            0|            0|  0.00%|
  2038|         0|            0|            0|  0.00%|    def _apply_model_serializers(
  2039|         0|            0|            0|  0.00%|        self, schema: core_schema.CoreSchema, serializers: Iterable[Decorator[ModelSerializerDecoratorInfo]]
  2040|         0|            0|            0|  0.00%|    ) -> core_schema.CoreSchema:
  2041|         0|            0|            0|  0.00%|        """Apply model serializers to a schema."""
  2042|         0|            0|            0|  0.00%|        ref: str | None = schema.pop('ref', None)  # type: ignore
  2043|         0|            0|            0|  0.00%|        if serializers:
  2044|         0|            0|            0|  0.00%|            serializer = list(serializers)[-1]
  2045|         0|            0|            0|  0.00%|            info_arg = inspect_model_serializer(serializer.func, serializer.info.mode)
  2046|         0|            0|            0|  0.00%|
  2047|         0|            0|            0|  0.00%|            try:
  2048|         0|            0|            0|  0.00%|                return_type = _decorators.get_function_return_type(
  2049|         0|            0|            0|  0.00%|                    serializer.func, serializer.info.return_type, self._types_namespace
  2050|         0|            0|            0|  0.00%|                )
  2051|         0|            0|            0|  0.00%|            except NameError as e:
  2052|         0|            0|            0|  0.00%|                raise PydanticUndefinedAnnotation.from_name_error(e) from e
  2053|         0|            0|            0|  0.00%|            if return_type is PydanticUndefined:
  2054|         0|            0|            0|  0.00%|                return_schema = None
  2055|         0|            0|            0|  0.00%|            else:
  2056|         0|            0|            0|  0.00%|                return_schema = self.generate_schema(return_type)
  2057|         0|            0|            0|  0.00%|
  2058|         0|            0|            0|  0.00%|            if serializer.info.mode == 'wrap':
  2059|         0|            0|            0|  0.00%|                ser_schema: core_schema.SerSchema = core_schema.wrap_serializer_function_ser_schema(
  2060|         0|            0|            0|  0.00%|                    serializer.func,
  2061|         0|            0|            0|  0.00%|                    info_arg=info_arg,
  2062|         0|            0|            0|  0.00%|                    return_schema=return_schema,
  2063|         0|            0|            0|  0.00%|                    when_used=serializer.info.when_used,
  2064|         0|            0|            0|  0.00%|                )
  2065|         0|            0|            0|  0.00%|            else:
  2066|         0|            0|            0|  0.00%|                # plain
  2067|         0|            0|            0|  0.00%|                ser_schema = core_schema.plain_serializer_function_ser_schema(
  2068|         0|            0|            0|  0.00%|                    serializer.func,
  2069|         0|            0|            0|  0.00%|                    info_arg=info_arg,
  2070|         0|            0|            0|  0.00%|                    return_schema=return_schema,
  2071|         0|            0|            0|  0.00%|                    when_used=serializer.info.when_used,
  2072|         0|            0|            0|  0.00%|                )
  2073|         0|            0|            0|  0.00%|            schema['serialization'] = ser_schema
  2074|         0|            0|            0|  0.00%|        if ref:
  2075|         0|            0|            0|  0.00%|            schema['ref'] = ref  # type: ignore
  2076|         0|            0|            0|  0.00%|        return schema
  2077|         0|            0|            0|  0.00%|
  2078|         0|            0|            0|  0.00%|
  2079|         0|            0|            0|  0.00%|_VALIDATOR_F_MATCH: Mapping[
  2080|         0|            0|            0|  0.00%|    tuple[FieldValidatorModes, Literal['no-info', 'with-info']],
  2081|         0|            0|            0|  0.00%|    Callable[[Callable[..., Any], core_schema.CoreSchema, str | None], core_schema.CoreSchema],
  2082|         0|            0|            0|  0.00%|] = {
  2083|         0|            0|            0|  0.00%|    ('before', 'no-info'): lambda f, schema, _: core_schema.no_info_before_validator_function(f, schema),
  2084|         0|            0|            0|  0.00%|    ('after', 'no-info'): lambda f, schema, _: core_schema.no_info_after_validator_function(f, schema),
  2085|         0|            0|            0|  0.00%|    ('plain', 'no-info'): lambda f, _1, _2: core_schema.no_info_plain_validator_function(f),
  2086|         0|            0|            0|  0.00%|    ('wrap', 'no-info'): lambda f, schema, _: core_schema.no_info_wrap_validator_function(f, schema),
  2087|         0|            0|            0|  0.00%|    ('before', 'with-info'): lambda f, schema, field_name: core_schema.with_info_before_validator_function(
  2088|         0|            0|            0|  0.00%|        f, schema, field_name=field_name
  2089|         0|            0|            0|  0.00%|    ),
  2090|         0|            0|            0|  0.00%|    ('after', 'with-info'): lambda f, schema, field_name: core_schema.with_info_after_validator_function(
  2091|         0|            0|            0|  0.00%|        f, schema, field_name=field_name
  2092|         0|            0|            0|  0.00%|    ),
  2093|         0|            0|            0|  0.00%|    ('plain', 'with-info'): lambda f, _, field_name: core_schema.with_info_plain_validator_function(
  2094|         0|            0|            0|  0.00%|        f, field_name=field_name
  2095|         0|            0|            0|  0.00%|    ),
  2096|         0|            0|            0|  0.00%|    ('wrap', 'with-info'): lambda f, schema, field_name: core_schema.with_info_wrap_validator_function(
  2097|         0|            0|            0|  0.00%|        f, schema, field_name=field_name
  2098|         0|            0|            0|  0.00%|    ),
  2099|         0|            0|            0|  0.00%|}
  2100|         0|            0|            0|  0.00%|
  2101|         0|            0|            0|  0.00%|
  2102|         0|            0|            0|  0.00%|def apply_validators(
  2103|         0|            0|            0|  0.00%|    schema: core_schema.CoreSchema,
  2104|         0|            0|            0|  0.00%|    validators: Iterable[Decorator[RootValidatorDecoratorInfo]]
  2105|         0|            0|            0|  0.00%|    | Iterable[Decorator[ValidatorDecoratorInfo]]
  2106|         0|            0|            0|  0.00%|    | Iterable[Decorator[FieldValidatorDecoratorInfo]],
  2107|         0|            0|            0|  0.00%|    field_name: str | None,
  2108|         0|            0|            0|  0.00%|) -> core_schema.CoreSchema:
  2109|         0|            0|            0|  0.00%|    """Apply validators to a schema.
  2110|         0|            0|            0|  0.00%|
  2111|         0|            0|            0|  0.00%|    Args:
  2112|         0|            0|            0|  0.00%|        schema: The schema to apply validators on.
  2113|         0|            0|            0|  0.00%|        validators: An iterable of validators.
  2114|         0|            0|            0|  0.00%|        field_name: The name of the field if validators are being applied to a model field.
  2115|         0|            0|            0|  0.00%|
  2116|         0|            0|            0|  0.00%|    Returns:
  2117|         0|            0|            0|  0.00%|        The updated schema.
  2118|         0|            0|            0|  0.00%|    """
  2119|         0|            0|            0|  0.00%|    for validator in validators:
  2120|         0|            0|            0|  0.00%|        info_arg = inspect_validator(validator.func, validator.info.mode)
  2121|         0|            0|            0|  0.00%|        val_type = 'with-info' if info_arg else 'no-info'
  2122|         0|            0|            0|  0.00%|
  2123|         0|            0|            0|  0.00%|        schema = _VALIDATOR_F_MATCH[(validator.info.mode, val_type)](validator.func, schema, field_name)
  2124|         0|            0|            0|  0.00%|    return schema
  2125|         0|            0|            0|  0.00%|
  2126|         0|            0|            0|  0.00%|
  2127|         0|            0|            0|  0.00%|def _validators_require_validate_default(validators: Iterable[Decorator[ValidatorDecoratorInfo]]) -> bool:
  2128|         0|            0|            0|  0.00%|    """In v1, if any of the validators for a field had `always=True`, the default value would be validated.
  2129|         0|            0|            0|  0.00%|
  2130|         0|            0|            0|  0.00%|    This serves as an auxiliary function for re-implementing that logic, by looping over a provided
  2131|         0|            0|            0|  0.00%|    collection of (v1-style) ValidatorDecoratorInfo's and checking if any of them have `always=True`.
  2132|         0|            0|            0|  0.00%|
  2133|         0|            0|            0|  0.00%|    We should be able to drop this function and the associated logic calling it once we drop support
  2134|         0|            0|            0|  0.00%|    for v1-style validator decorators. (Or we can extend it and keep it if we add something equivalent
  2135|         0|            0|            0|  0.00%|    to the v1-validator `always` kwarg to `field_validator`.)
  2136|         0|            0|            0|  0.00%|    """
  2137|         0|            0|            0|  0.00%|    for validator in validators:
  2138|         0|            0|            0|  0.00%|        if validator.info.always:
  2139|         0|            0|            0|  0.00%|            return True
  2140|         0|            0|            0|  0.00%|    return False
  2141|         0|            0|            0|  0.00%|
  2142|         0|            0|            0|  0.00%|
  2143|         0|            0|            0|  0.00%|def apply_model_validators(
  2144|         0|            0|            0|  0.00%|    schema: core_schema.CoreSchema,
  2145|         0|            0|            0|  0.00%|    validators: Iterable[Decorator[ModelValidatorDecoratorInfo]],
  2146|         0|            0|            0|  0.00%|    mode: Literal['inner', 'outer', 'all'],
  2147|         0|            0|            0|  0.00%|) -> core_schema.CoreSchema:
  2148|         0|            0|            0|  0.00%|    """Apply model validators to a schema.
  2149|         0|            0|            0|  0.00%|
  2150|         0|            0|            0|  0.00%|    If mode == 'inner', only "before" validators are applied
  2151|         0|            0|            0|  0.00%|    If mode == 'outer', validators other than "before" are applied
  2152|         0|            0|            0|  0.00%|    If mode == 'all', all validators are applied
  2153|         0|            0|            0|  0.00%|
  2154|         0|            0|            0|  0.00%|    Args:
  2155|         0|            0|            0|  0.00%|        schema: The schema to apply validators on.
  2156|         0|            0|            0|  0.00%|        validators: An iterable of validators.
  2157|         0|            0|            0|  0.00%|        mode: The validator mode.
  2158|         0|            0|            0|  0.00%|
  2159|         0|            0|            0|  0.00%|    Returns:
  2160|         0|            0|            0|  0.00%|        The updated schema.
  2161|         0|            0|            0|  0.00%|    """
  2162|         0|            0|            0|  0.00%|    ref: str | None = schema.pop('ref', None)  # type: ignore
  2163|         0|            0|            0|  0.00%|    for validator in validators:
  2164|         0|            0|            0|  0.00%|        if mode == 'inner' and validator.info.mode != 'before':
  2165|         0|            0|            0|  0.00%|            continue
  2166|         0|            0|            0|  0.00%|        if mode == 'outer' and validator.info.mode == 'before':
  2167|         0|            0|            0|  0.00%|            continue
  2168|         0|            0|            0|  0.00%|        info_arg = inspect_validator(validator.func, validator.info.mode)
  2169|         0|            0|            0|  0.00%|        if validator.info.mode == 'wrap':
  2170|         0|            0|            0|  0.00%|            if info_arg:
  2171|         0|            0|            0|  0.00%|                schema = core_schema.with_info_wrap_validator_function(function=validator.func, schema=schema)
  2172|         0|            0|            0|  0.00%|            else:
  2173|         0|            0|            0|  0.00%|                schema = core_schema.no_info_wrap_validator_function(function=validator.func, schema=schema)
  2174|         0|            0|            0|  0.00%|        elif validator.info.mode == 'before':
  2175|         0|            0|            0|  0.00%|            if info_arg:
  2176|         0|            0|            0|  0.00%|                schema = core_schema.with_info_before_validator_function(function=validator.func, schema=schema)
  2177|         0|            0|            0|  0.00%|            else:
  2178|         0|            0|            0|  0.00%|                schema = core_schema.no_info_before_validator_function(function=validator.func, schema=schema)
  2179|         0|            0|            0|  0.00%|        else:
  2180|         0|            0|            0|  0.00%|            assert validator.info.mode == 'after'
  2181|         0|            0|            0|  0.00%|            if info_arg:
  2182|         0|            0|            0|  0.00%|                schema = core_schema.with_info_after_validator_function(function=validator.func, schema=schema)
  2183|         0|            0|            0|  0.00%|            else:
  2184|         0|            0|            0|  0.00%|                schema = core_schema.no_info_after_validator_function(function=validator.func, schema=schema)
  2185|         0|            0|            0|  0.00%|    if ref:
  2186|         0|            0|            0|  0.00%|        schema['ref'] = ref  # type: ignore
  2187|         0|            0|            0|  0.00%|    return schema
  2188|         0|            0|            0|  0.00%|
  2189|         0|            0|            0|  0.00%|
  2190|         2|  4.29153e-06|  2.14577e-06|  0.00%|def wrap_default(field_info: FieldInfo, schema: core_schema.CoreSchema) -> core_schema.CoreSchema:
  2191|         0|            0|            0|  0.00%|    """Wrap schema with default schema if default value or `default_factory` are available.
  2192|         0|            0|            0|  0.00%|
  2193|         0|            0|            0|  0.00%|    Args:
  2194|         0|            0|            0|  0.00%|        field_info: The field info object.
  2195|         0|            0|            0|  0.00%|        schema: The schema to apply default on.
  2196|         0|            0|            0|  0.00%|
  2197|         0|            0|            0|  0.00%|    Returns:
  2198|         0|            0|            0|  0.00%|        Updated schema by default value or `default_factory`.
  2199|         0|            0|            0|  0.00%|    """
  2200|         2|  4.05312e-06|  2.02656e-06|  0.00%|    if field_info.default_factory:
  2201|         0|            0|            0|  0.00%|        return core_schema.with_default_schema(
  2202|         0|            0|            0|  0.00%|            schema, default_factory=field_info.default_factory, validate_default=field_info.validate_default
  2203|         0|            0|            0|  0.00%|        )
  2204|         2|  3.57628e-06|  1.78814e-06|  0.00%|    elif field_info.default is not PydanticUndefined:
  2205|         0|            0|            0|  0.00%|        return core_schema.with_default_schema(
  2206|         0|            0|            0|  0.00%|            schema, default=field_info.default, validate_default=field_info.validate_default
  2207|         0|            0|            0|  0.00%|        )
  2208|         0|            0|            0|  0.00%|    else:
  2209|         2|  5.00679e-06|   2.5034e-06|  0.01%|        return schema
  2210|         0|            0|            0|  0.00%|
  2211|         0|            0|            0|  0.00%|
  2212|         6|  1.69277e-05|  2.82129e-06|  0.02%|def _extract_get_pydantic_json_schema(tp: Any, schema: CoreSchema) -> GetJsonSchemaFunction | None:
  2213|         0|            0|            0|  0.00%|    """Extract `__get_pydantic_json_schema__` from a type, handling the deprecated `__modify_schema__`."""
  2214|         6|  2.43187e-05|  4.05312e-06|  0.02%|    js_modify_function = getattr(tp, '__get_pydantic_json_schema__', None)
(call)|         2|  4.48227e-05|  2.24113e-05|  0.05%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:2025 __getattr__
  2215|         0|            0|            0|  0.00%|
  2216|         6|  2.14577e-05|  3.57628e-06|  0.02%|    if hasattr(tp, '__modify_schema__'):
(call)|         2|  4.05312e-05|  2.02656e-05|  0.04%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:2025 __getattr__
  2217|         0|            0|            0|  0.00%|        from pydantic import BaseModel  # circular reference
  2218|         0|            0|            0|  0.00%|
  2219|         0|            0|            0|  0.00%|        has_custom_v2_modify_js_func = (
  2220|         0|            0|            0|  0.00%|            js_modify_function is not None
  2221|         0|            0|            0|  0.00%|            and BaseModel.__get_pydantic_json_schema__.__func__  # type: ignore
  2222|         0|            0|            0|  0.00%|            not in (js_modify_function, getattr(js_modify_function, '__func__', None))
  2223|         0|            0|            0|  0.00%|        )
  2224|         0|            0|            0|  0.00%|
  2225|         0|            0|            0|  0.00%|        if not has_custom_v2_modify_js_func:
  2226|         0|            0|            0|  0.00%|            cls_name = getattr(tp, '__name__', None)
  2227|         0|            0|            0|  0.00%|            raise PydanticUserError(
  2228|         0|            0|            0|  0.00%|                f'The `__modify_schema__` method is not supported in Pydantic v2. '
  2229|         0|            0|            0|  0.00%|                f'Use `__get_pydantic_json_schema__` instead{f" in class `{cls_name}`" if cls_name else ""}.',
  2230|         0|            0|            0|  0.00%|                code='custom-json-schema',
  2231|         0|            0|            0|  0.00%|            )
  2232|         0|            0|            0|  0.00%|
  2233|         0|            0|            0|  0.00%|    # handle GenericAlias' but ignore Annotated which "lies" about its origin (in this case it would be `int`)
  2234|         6|  2.55108e-05|   4.2518e-06|  0.03%|    if hasattr(tp, '__origin__') and not isinstance(tp, type(Annotated[int, 'placeholder'])):
(call)|         2|  2.69413e-05|  1.34706e-05|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:2087 __class_getitem__
  2235|         0|            0|            0|  0.00%|        return _extract_get_pydantic_json_schema(tp.__origin__, schema)
  2236|         0|            0|            0|  0.00%|
  2237|         6|  1.16825e-05|  1.94709e-06|  0.01%|    if js_modify_function is None:
  2238|         6|  1.00136e-05|  1.66893e-06|  0.01%|        return None
  2239|         0|            0|            0|  0.00%|
  2240|         0|            0|            0|  0.00%|    return js_modify_function
  2241|         0|            0|            0|  0.00%|
  2242|         0|            0|            0|  0.00%|
  2243|         0|            0|            0|  0.00%|def get_json_schema_update_func(
  2244|         0|            0|            0|  0.00%|    json_schema_update: JsonSchemaValue, json_schema_extra: JsonDict | typing.Callable[[JsonDict], None] | None
  2245|         0|            0|            0|  0.00%|) -> GetJsonSchemaFunction:
  2246|         0|            0|            0|  0.00%|    def json_schema_update_func(
  2247|         0|            0|            0|  0.00%|        core_schema_or_field: CoreSchemaOrField, handler: GetJsonSchemaHandler
  2248|         0|            0|            0|  0.00%|    ) -> JsonSchemaValue:
  2249|         0|            0|            0|  0.00%|        json_schema = {**handler(core_schema_or_field), **json_schema_update}
  2250|         0|            0|            0|  0.00%|        add_json_schema_extra(json_schema, json_schema_extra)
  2251|         0|            0|            0|  0.00%|        return json_schema
  2252|         0|            0|            0|  0.00%|
  2253|         0|            0|            0|  0.00%|    return json_schema_update_func
  2254|         0|            0|            0|  0.00%|
  2255|         0|            0|            0|  0.00%|
  2256|         0|            0|            0|  0.00%|def add_json_schema_extra(
  2257|         0|            0|            0|  0.00%|    json_schema: JsonSchemaValue, json_schema_extra: JsonDict | typing.Callable[[JsonDict], None] | None
  2258|         0|            0|            0|  0.00%|):
  2259|         0|            0|            0|  0.00%|    if isinstance(json_schema_extra, dict):
  2260|         0|            0|            0|  0.00%|        json_schema.update(to_jsonable_python(json_schema_extra))
  2261|         0|            0|            0|  0.00%|    elif callable(json_schema_extra):
  2262|         0|            0|            0|  0.00%|        json_schema_extra(json_schema)
  2263|         0|            0|            0|  0.00%|
  2264|         0|            0|            0|  0.00%|
  2265|         0|            0|            0|  0.00%|class _CommonField(TypedDict):
  2266|         0|            0|            0|  0.00%|    schema: core_schema.CoreSchema
  2267|         0|            0|            0|  0.00%|    validation_alias: str | list[str | int] | list[list[str | int]] | None
  2268|         0|            0|            0|  0.00%|    serialization_alias: str | None
  2269|         0|            0|            0|  0.00%|    serialization_exclude: bool | None
  2270|         0|            0|            0|  0.00%|    frozen: bool | None
  2271|         0|            0|            0|  0.00%|    metadata: dict[str, Any]
  2272|         0|            0|            0|  0.00%|
  2273|         0|            0|            0|  0.00%|
  2274|         0|            0|            0|  0.00%|def _common_field(
  2275|         0|            0|            0|  0.00%|    schema: core_schema.CoreSchema,
  2276|         0|            0|            0|  0.00%|    *,
  2277|         0|            0|            0|  0.00%|    validation_alias: str | list[str | int] | list[list[str | int]] | None = None,
  2278|         0|            0|            0|  0.00%|    serialization_alias: str | None = None,
  2279|         0|            0|            0|  0.00%|    serialization_exclude: bool | None = None,
  2280|         0|            0|            0|  0.00%|    frozen: bool | None = None,
  2281|         0|            0|            0|  0.00%|    metadata: Any = None,
  2282|         0|            0|            0|  0.00%|) -> _CommonField:
  2283|         0|            0|            0|  0.00%|    return {
  2284|         0|            0|            0|  0.00%|        'schema': schema,
  2285|         0|            0|            0|  0.00%|        'validation_alias': validation_alias,
  2286|         0|            0|            0|  0.00%|        'serialization_alias': serialization_alias,
  2287|         0|            0|            0|  0.00%|        'serialization_exclude': serialization_exclude,
  2288|         0|            0|            0|  0.00%|        'frozen': frozen,
  2289|         0|            0|            0|  0.00%|        'metadata': metadata,
  2290|         0|            0|            0|  0.00%|    }
  2291|         0|            0|            0|  0.00%|
  2292|         0|            0|            0|  0.00%|
  2293|         0|            0|            0|  0.00%|class _Definitions:
  2294|         0|            0|            0|  0.00%|    """Keeps track of references and definitions."""
  2295|         0|            0|            0|  0.00%|
  2296|         2|  5.24521e-06|   2.6226e-06|  0.01%|    def __init__(self) -> None:
  2297|         2|   6.4373e-06|  3.21865e-06|  0.01%|        self.seen: set[str] = set()
  2298|         2|  5.72205e-06|  2.86102e-06|  0.01%|        self.definitions: dict[str, core_schema.CoreSchema] = {}
  2299|         0|            0|            0|  0.00%|
  2300|         4|  9.77516e-06|  2.44379e-06|  0.01%|    @contextmanager
  2301|         0|            0|            0|  0.00%|    def get_schema_or_ref(self, tp: Any) -> Iterator[tuple[str, None] | tuple[str, CoreSchema]]:
  2302|         0|            0|            0|  0.00%|        """Get a definition for `tp` if one exists.
  2303|         0|            0|            0|  0.00%|
  2304|         0|            0|            0|  0.00%|        If a definition exists, a tuple of `(ref_string, CoreSchema)` is returned.
  2305|         0|            0|            0|  0.00%|        If no definition exists yet, a tuple of `(ref_string, None)` is returned.
  2306|         0|            0|            0|  0.00%|
  2307|         0|            0|            0|  0.00%|        Note that the returned `CoreSchema` will always be a `DefinitionReferenceSchema`,
  2308|         0|            0|            0|  0.00%|        not the actual definition itself.
  2309|         0|            0|            0|  0.00%|
  2310|         0|            0|            0|  0.00%|        This should be called for any type that can be identified by reference.
  2311|         0|            0|            0|  0.00%|        This includes any recursive types.
  2312|         0|            0|            0|  0.00%|
  2313|         0|            0|            0|  0.00%|        At present the following types can be named/recursive:
  2314|         0|            0|            0|  0.00%|
  2315|         0|            0|            0|  0.00%|        - BaseModel
  2316|         0|            0|            0|  0.00%|        - Dataclasses
  2317|         0|            0|            0|  0.00%|        - TypedDict
  2318|         0|            0|            0|  0.00%|        - TypeAliasType
  2319|         0|            0|            0|  0.00%|        """
  2320|         4|  5.19753e-05|  1.29938e-05|  0.05%|        ref = get_type_ref(tp)
(call)|         4|  0.000758886|  0.000189722|  0.78%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:77 get_type_ref
  2321|         0|            0|            0|  0.00%|        # return the reference if we're either (1) in a cycle or (2) it was already defined
  2322|         4|  1.16825e-05|  2.92063e-06|  0.01%|        if ref in self.seen or ref in self.definitions:
  2323|         0|            0|            0|  0.00%|            yield (ref, core_schema.definition_reference_schema(ref))
  2324|         0|            0|            0|  0.00%|        else:
  2325|         4|  1.26362e-05|  3.15905e-06|  0.01%|            self.seen.add(ref)
  2326|         4|  7.15256e-06|  1.78814e-06|  0.01%|            try:
  2327|         8|  2.21729e-05|  2.77162e-06|  0.02%|                yield (ref, None)
  2328|         0|            0|            0|  0.00%|            finally:
  2329|         4|  1.04904e-05|   2.6226e-06|  0.01%|                self.seen.discard(ref)
  2330|         0|            0|            0|  0.00%|
  2331|         0|            0|            0|  0.00%|
  2332|         0|            0|            0|  0.00%|def resolve_original_schema(schema: CoreSchema, definitions: dict[str, CoreSchema]) -> CoreSchema | None:
  2333|         0|            0|            0|  0.00%|    if schema['type'] == 'definition-ref':
  2334|         0|            0|            0|  0.00%|        return definitions.get(schema['schema_ref'], None)
  2335|         0|            0|            0|  0.00%|    elif schema['type'] == 'definitions':
  2336|         0|            0|            0|  0.00%|        return schema['schema']
  2337|         0|            0|            0|  0.00%|    else:
  2338|         0|            0|            0|  0.00%|        return schema
  2339|         0|            0|            0|  0.00%|
  2340|         0|            0|            0|  0.00%|
  2341|         0|            0|            0|  0.00%|class _FieldNameStack:
  2342|         0|            0|            0|  0.00%|    __slots__ = ('_stack',)
  2343|         0|            0|            0|  0.00%|
  2344|         2|  7.15256e-06|  3.57628e-06|  0.01%|    def __init__(self) -> None:
  2345|         2|  4.52995e-06|  2.26498e-06|  0.00%|        self._stack: list[str] = []
  2346|         0|            0|            0|  0.00%|
  2347|         0|            0|            0|  0.00%|    @contextmanager
  2348|         0|            0|            0|  0.00%|    def push(self, field_name: str) -> Iterator[None]:
  2349|         0|            0|            0|  0.00%|        self._stack.append(field_name)
  2350|         0|            0|            0|  0.00%|        yield
  2351|         0|            0|            0|  0.00%|        self._stack.pop()
  2352|         0|            0|            0|  0.00%|
  2353|         0|            0|            0|  0.00%|    def get(self) -> str | None:
  2354|         0|            0|            0|  0.00%|        if self._stack:
  2355|         0|            0|            0|  0.00%|            return self._stack[-1]
  2356|         0|            0|            0|  0.00%|        else:
  2357|         0|            0|            0|  0.00%|            return None
  2358|         0|            0|            0|  0.00%|
  2359|         0|            0|            0|  0.00%|
  2360|         0|            0|            0|  0.00%|class _ModelTypeStack:
  2361|         0|            0|            0|  0.00%|    __slots__ = ('_stack',)
  2362|         0|            0|            0|  0.00%|
  2363|         2|  5.00679e-06|   2.5034e-06|  0.01%|    def __init__(self) -> None:
  2364|         2|  5.00679e-06|   2.5034e-06|  0.01%|        self._stack: list[type] = []
  2365|         0|            0|            0|  0.00%|
  2366|         0|            0|            0|  0.00%|    @contextmanager
  2367|         0|            0|            0|  0.00%|    def push(self, type_obj: type) -> Iterator[None]:
  2368|         0|            0|            0|  0.00%|        self._stack.append(type_obj)
  2369|         0|            0|            0|  0.00%|        yield
  2370|         0|            0|            0|  0.00%|        self._stack.pop()
  2371|         0|            0|            0|  0.00%|
  2372|         0|            0|            0|  0.00%|    def get(self) -> type | None:
  2373|         0|            0|            0|  0.00%|        if self._stack:
  2374|         0|            0|            0|  0.00%|            return self._stack[-1]
  2375|         0|            0|            0|  0.00%|        else:
  2376|         0|            0|            0|  0.00%|            return None
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/dependencies/utils.py
File duration: 0.00252652s (2.60%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|import inspect
     2|         0|            0|            0|  0.00%|from contextlib import AsyncExitStack, contextmanager
     3|         0|            0|            0|  0.00%|from copy import copy, deepcopy
     4|         0|            0|            0|  0.00%|from typing import (
     5|         0|            0|            0|  0.00%|    Any,
     6|         0|            0|            0|  0.00%|    Callable,
     7|         0|            0|            0|  0.00%|    Coroutine,
     8|         0|            0|            0|  0.00%|    Dict,
     9|         0|            0|            0|  0.00%|    ForwardRef,
    10|         0|            0|            0|  0.00%|    List,
    11|         0|            0|            0|  0.00%|    Mapping,
    12|         0|            0|            0|  0.00%|    Optional,
    13|         0|            0|            0|  0.00%|    Sequence,
    14|         0|            0|            0|  0.00%|    Tuple,
    15|         0|            0|            0|  0.00%|    Type,
    16|         0|            0|            0|  0.00%|    Union,
    17|         0|            0|            0|  0.00%|    cast,
    18|         0|            0|            0|  0.00%|)
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|import anyio
    21|         0|            0|            0|  0.00%|from fastapi import params
    22|         0|            0|            0|  0.00%|from fastapi._compat import (
    23|         0|            0|            0|  0.00%|    PYDANTIC_V2,
    24|         0|            0|            0|  0.00%|    ErrorWrapper,
    25|         0|            0|            0|  0.00%|    ModelField,
    26|         0|            0|            0|  0.00%|    Required,
    27|         0|            0|            0|  0.00%|    Undefined,
    28|         0|            0|            0|  0.00%|    _regenerate_error_with_loc,
    29|         0|            0|            0|  0.00%|    copy_field_info,
    30|         0|            0|            0|  0.00%|    create_body_model,
    31|         0|            0|            0|  0.00%|    evaluate_forwardref,
    32|         0|            0|            0|  0.00%|    field_annotation_is_scalar,
    33|         0|            0|            0|  0.00%|    get_annotation_from_field_info,
    34|         0|            0|            0|  0.00%|    get_missing_field_error,
    35|         0|            0|            0|  0.00%|    is_bytes_field,
    36|         0|            0|            0|  0.00%|    is_bytes_sequence_field,
    37|         0|            0|            0|  0.00%|    is_scalar_field,
    38|         0|            0|            0|  0.00%|    is_scalar_sequence_field,
    39|         0|            0|            0|  0.00%|    is_sequence_field,
    40|         0|            0|            0|  0.00%|    is_uploadfile_or_nonable_uploadfile_annotation,
    41|         0|            0|            0|  0.00%|    is_uploadfile_sequence_annotation,
    42|         0|            0|            0|  0.00%|    lenient_issubclass,
    43|         0|            0|            0|  0.00%|    sequence_types,
    44|         0|            0|            0|  0.00%|    serialize_sequence_value,
    45|         0|            0|            0|  0.00%|    value_is_sequence,
    46|         0|            0|            0|  0.00%|)
    47|         0|            0|            0|  0.00%|from fastapi.background import BackgroundTasks
    48|         0|            0|            0|  0.00%|from fastapi.concurrency import (
    49|         0|            0|            0|  0.00%|    asynccontextmanager,
    50|         0|            0|            0|  0.00%|    contextmanager_in_threadpool,
    51|         0|            0|            0|  0.00%|)
    52|         0|            0|            0|  0.00%|from fastapi.dependencies.models import Dependant, SecurityRequirement
    53|         0|            0|            0|  0.00%|from fastapi.logger import logger
    54|         0|            0|            0|  0.00%|from fastapi.security.base import SecurityBase
    55|         0|            0|            0|  0.00%|from fastapi.security.oauth2 import OAuth2, SecurityScopes
    56|         0|            0|            0|  0.00%|from fastapi.security.open_id_connect_url import OpenIdConnect
    57|         0|            0|            0|  0.00%|from fastapi.utils import create_response_field, get_path_param_names
    58|         0|            0|            0|  0.00%|from pydantic.fields import FieldInfo
    59|         0|            0|            0|  0.00%|from starlette.background import BackgroundTasks as StarletteBackgroundTasks
    60|         0|            0|            0|  0.00%|from starlette.concurrency import run_in_threadpool
    61|         0|            0|            0|  0.00%|from starlette.datastructures import FormData, Headers, QueryParams, UploadFile
    62|         0|            0|            0|  0.00%|from starlette.requests import HTTPConnection, Request
    63|         0|            0|            0|  0.00%|from starlette.responses import Response
    64|         0|            0|            0|  0.00%|from starlette.websockets import WebSocket
    65|         0|            0|            0|  0.00%|from typing_extensions import Annotated, get_args, get_origin
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|multipart_not_installed_error = (
    68|         0|            0|            0|  0.00%|    'Form data requires "python-multipart" to be installed. \n'
    69|         0|            0|            0|  0.00%|    'You can install "python-multipart" with: \n\n'
    70|         0|            0|            0|  0.00%|    "pip install python-multipart\n"
    71|         0|            0|            0|  0.00%|)
    72|         0|            0|            0|  0.00%|multipart_incorrect_install_error = (
    73|         0|            0|            0|  0.00%|    'Form data requires "python-multipart" to be installed. '
    74|         0|            0|            0|  0.00%|    'It seems you installed "multipart" instead. \n'
    75|         0|            0|            0|  0.00%|    'You can remove "multipart" with: \n\n'
    76|         0|            0|            0|  0.00%|    "pip uninstall multipart\n\n"
    77|         0|            0|            0|  0.00%|    'And then install "python-multipart" with: \n\n'
    78|         0|            0|            0|  0.00%|    "pip install python-multipart\n"
    79|         0|            0|            0|  0.00%|)
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|def check_file_field(field: ModelField) -> None:
    83|         0|            0|            0|  0.00%|    field_info = field.field_info
    84|         0|            0|            0|  0.00%|    if isinstance(field_info, params.Form):
    85|         0|            0|            0|  0.00%|        try:
    86|         0|            0|            0|  0.00%|            # __version__ is available in both multiparts, and can be mocked
    87|         0|            0|            0|  0.00%|            from multipart import __version__  # type: ignore
    88|         0|            0|            0|  0.00%|
    89|         0|            0|            0|  0.00%|            assert __version__
    90|         0|            0|            0|  0.00%|            try:
    91|         0|            0|            0|  0.00%|                # parse_options_header is only available in the right multipart
    92|         0|            0|            0|  0.00%|                from multipart.multipart import parse_options_header  # type: ignore
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|                assert parse_options_header
    95|         0|            0|            0|  0.00%|            except ImportError:
    96|         0|            0|            0|  0.00%|                logger.error(multipart_incorrect_install_error)
    97|         0|            0|            0|  0.00%|                raise RuntimeError(multipart_incorrect_install_error) from None
    98|         0|            0|            0|  0.00%|        except ImportError:
    99|         0|            0|            0|  0.00%|            logger.error(multipart_not_installed_error)
   100|         0|            0|            0|  0.00%|            raise RuntimeError(multipart_not_installed_error) from None
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|
   103|         0|            0|            0|  0.00%|def get_param_sub_dependant(
   104|         0|            0|            0|  0.00%|    *,
   105|         0|            0|            0|  0.00%|    param_name: str,
   106|         0|            0|            0|  0.00%|    depends: params.Depends,
   107|         0|            0|            0|  0.00%|    path: str,
   108|         0|            0|            0|  0.00%|    security_scopes: Optional[List[str]] = None,
   109|         0|            0|            0|  0.00%|) -> Dependant:
   110|         0|            0|            0|  0.00%|    assert depends.dependency
   111|         0|            0|            0|  0.00%|    return get_sub_dependant(
   112|         0|            0|            0|  0.00%|        depends=depends,
   113|         0|            0|            0|  0.00%|        dependency=depends.dependency,
   114|         0|            0|            0|  0.00%|        path=path,
   115|         0|            0|            0|  0.00%|        name=param_name,
   116|         0|            0|            0|  0.00%|        security_scopes=security_scopes,
   117|         0|            0|            0|  0.00%|    )
   118|         0|            0|            0|  0.00%|
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|def get_parameterless_sub_dependant(*, depends: params.Depends, path: str) -> Dependant:
   121|         0|            0|            0|  0.00%|    assert callable(
   122|         0|            0|            0|  0.00%|        depends.dependency
   123|         0|            0|            0|  0.00%|    ), "A parameter-less dependency must have a callable dependency"
   124|         0|            0|            0|  0.00%|    return get_sub_dependant(depends=depends, dependency=depends.dependency, path=path)
   125|         0|            0|            0|  0.00%|
   126|         0|            0|            0|  0.00%|
   127|         0|            0|            0|  0.00%|def get_sub_dependant(
   128|         0|            0|            0|  0.00%|    *,
   129|         0|            0|            0|  0.00%|    depends: params.Depends,
   130|         0|            0|            0|  0.00%|    dependency: Callable[..., Any],
   131|         0|            0|            0|  0.00%|    path: str,
   132|         0|            0|            0|  0.00%|    name: Optional[str] = None,
   133|         0|            0|            0|  0.00%|    security_scopes: Optional[List[str]] = None,
   134|         0|            0|            0|  0.00%|) -> Dependant:
   135|         0|            0|            0|  0.00%|    security_requirement = None
   136|         0|            0|            0|  0.00%|    security_scopes = security_scopes or []
   137|         0|            0|            0|  0.00%|    if isinstance(depends, params.Security):
   138|         0|            0|            0|  0.00%|        dependency_scopes = depends.scopes
   139|         0|            0|            0|  0.00%|        security_scopes.extend(dependency_scopes)
   140|         0|            0|            0|  0.00%|    if isinstance(dependency, SecurityBase):
   141|         0|            0|            0|  0.00%|        use_scopes: List[str] = []
   142|         0|            0|            0|  0.00%|        if isinstance(dependency, (OAuth2, OpenIdConnect)):
   143|         0|            0|            0|  0.00%|            use_scopes = security_scopes
   144|         0|            0|            0|  0.00%|        security_requirement = SecurityRequirement(
   145|         0|            0|            0|  0.00%|            security_scheme=dependency, scopes=use_scopes
   146|         0|            0|            0|  0.00%|        )
   147|         0|            0|            0|  0.00%|    sub_dependant = get_dependant(
   148|         0|            0|            0|  0.00%|        path=path,
   149|         0|            0|            0|  0.00%|        call=dependency,
   150|         0|            0|            0|  0.00%|        name=name,
   151|         0|            0|            0|  0.00%|        security_scopes=security_scopes,
   152|         0|            0|            0|  0.00%|        use_cache=depends.use_cache,
   153|         0|            0|            0|  0.00%|    )
   154|         0|            0|            0|  0.00%|    if security_requirement:
   155|         0|            0|            0|  0.00%|        sub_dependant.security_requirements.append(security_requirement)
   156|         0|            0|            0|  0.00%|    return sub_dependant
   157|         0|            0|            0|  0.00%|
   158|         0|            0|            0|  0.00%|
   159|         0|            0|            0|  0.00%|CacheKey = Tuple[Optional[Callable[..., Any]], Tuple[str, ...]]
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|def get_flat_dependant(
   163|         0|            0|            0|  0.00%|    dependant: Dependant,
   164|         0|            0|            0|  0.00%|    *,
   165|         0|            0|            0|  0.00%|    skip_repeats: bool = False,
   166|         0|            0|            0|  0.00%|    visited: Optional[List[CacheKey]] = None,
   167|         0|            0|            0|  0.00%|) -> Dependant:
   168|         0|            0|            0|  0.00%|    if visited is None:
   169|         0|            0|            0|  0.00%|        visited = []
   170|         0|            0|            0|  0.00%|    visited.append(dependant.cache_key)
   171|         0|            0|            0|  0.00%|
   172|         0|            0|            0|  0.00%|    flat_dependant = Dependant(
   173|         0|            0|            0|  0.00%|        path_params=dependant.path_params.copy(),
   174|         0|            0|            0|  0.00%|        query_params=dependant.query_params.copy(),
   175|         0|            0|            0|  0.00%|        header_params=dependant.header_params.copy(),
   176|         0|            0|            0|  0.00%|        cookie_params=dependant.cookie_params.copy(),
   177|         0|            0|            0|  0.00%|        body_params=dependant.body_params.copy(),
   178|         0|            0|            0|  0.00%|        security_schemes=dependant.security_requirements.copy(),
   179|         0|            0|            0|  0.00%|        use_cache=dependant.use_cache,
   180|         0|            0|            0|  0.00%|        path=dependant.path,
   181|         0|            0|            0|  0.00%|    )
   182|         0|            0|            0|  0.00%|    for sub_dependant in dependant.dependencies:
   183|         0|            0|            0|  0.00%|        if skip_repeats and sub_dependant.cache_key in visited:
   184|         0|            0|            0|  0.00%|            continue
   185|         0|            0|            0|  0.00%|        flat_sub = get_flat_dependant(
   186|         0|            0|            0|  0.00%|            sub_dependant, skip_repeats=skip_repeats, visited=visited
   187|         0|            0|            0|  0.00%|        )
   188|         0|            0|            0|  0.00%|        flat_dependant.path_params.extend(flat_sub.path_params)
   189|         0|            0|            0|  0.00%|        flat_dependant.query_params.extend(flat_sub.query_params)
   190|         0|            0|            0|  0.00%|        flat_dependant.header_params.extend(flat_sub.header_params)
   191|         0|            0|            0|  0.00%|        flat_dependant.cookie_params.extend(flat_sub.cookie_params)
   192|         0|            0|            0|  0.00%|        flat_dependant.body_params.extend(flat_sub.body_params)
   193|         0|            0|            0|  0.00%|        flat_dependant.security_requirements.extend(flat_sub.security_requirements)
   194|         0|            0|            0|  0.00%|    return flat_dependant
   195|         0|            0|            0|  0.00%|
   196|         0|            0|            0|  0.00%|
   197|         0|            0|            0|  0.00%|def get_flat_params(dependant: Dependant) -> List[ModelField]:
   198|         0|            0|            0|  0.00%|    flat_dependant = get_flat_dependant(dependant, skip_repeats=True)
   199|         0|            0|            0|  0.00%|    return (
   200|         0|            0|            0|  0.00%|        flat_dependant.path_params
   201|         0|            0|            0|  0.00%|        + flat_dependant.query_params
   202|         0|            0|            0|  0.00%|        + flat_dependant.header_params
   203|         0|            0|            0|  0.00%|        + flat_dependant.cookie_params
   204|         0|            0|            0|  0.00%|    )
   205|         0|            0|            0|  0.00%|
   206|         0|            0|            0|  0.00%|
   207|         1|  4.29153e-06|  4.29153e-06|  0.00%|def get_typed_signature(call: Callable[..., Any]) -> inspect.Signature:
   208|         1|  9.53674e-06|  9.53674e-06|  0.01%|    signature = inspect.signature(call)
(call)|         1|   0.00130177|   0.00130177|  1.34%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:3308 signature
   209|         1|  8.10623e-06|  8.10623e-06|  0.01%|    globalns = getattr(call, "__globals__", {})
   210|         4|  7.86781e-06|  1.96695e-06|  0.01%|    typed_params = [
   211|         6|  3.05176e-05|  5.08626e-06|  0.03%|        inspect.Parameter(
(call)|         3|  0.000146389|  4.87963e-05|  0.15%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:2712 __init__
   212|         3|  1.43051e-05|  4.76837e-06|  0.01%|            name=param.name,
(call)|         3|  1.28746e-05|  4.29153e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:2765 name
   213|         3|  2.74181e-05|  9.13938e-06|  0.03%|            kind=param.kind,
(call)|         3|  7.62939e-06|  2.54313e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:2777 kind
   214|         3|  1.83582e-05|  6.11941e-06|  0.02%|            default=param.default,
(call)|         3|  1.00136e-05|  3.33786e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:2769 default
   215|         3|  2.71797e-05|  9.05991e-06|  0.03%|            annotation=get_typed_annotation(param.annotation, globalns),
(call)|         3|  7.62939e-06|  2.54313e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:2773 annotation
(call)|         3|   1.4782e-05|  4.92732e-06|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/dependencies/utils.py:223 get_typed_annotation
   216|         0|            0|            0|  0.00%|        )
   217|         4|  1.38283e-05|  3.45707e-06|  0.01%|        for param in signature.parameters.values()
(call)|         1|  4.76837e-06|  4.76837e-06|  0.00%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:3058 parameters
   218|         0|            0|            0|  0.00%|    ]
   219|         1|  9.05991e-06|  9.05991e-06|  0.01%|    typed_signature = inspect.Signature(typed_params)
(call)|         1|  0.000158072|  0.000158072|  0.16%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:2998 __init__
   220|         1|  2.38419e-06|  2.38419e-06|  0.00%|    return typed_signature
   221|         0|            0|            0|  0.00%|
   222|         0|            0|            0|  0.00%|
   223|         3|  5.24521e-06|   1.7484e-06|  0.01%|def get_typed_annotation(annotation: Any, globalns: Dict[str, Any]) -> Any:
   224|         3|  5.72205e-06|  1.90735e-06|  0.01%|    if isinstance(annotation, str):
   225|         0|            0|            0|  0.00%|        annotation = ForwardRef(annotation)
   226|         0|            0|            0|  0.00%|        annotation = evaluate_forwardref(annotation, globalns, globalns)
   227|         3|   3.8147e-06|  1.27157e-06|  0.00%|    return annotation
   228|         0|            0|            0|  0.00%|
   229|         0|            0|            0|  0.00%|
   230|         0|            0|            0|  0.00%|def get_typed_return_annotation(call: Callable[..., Any]) -> Any:
   231|         0|            0|            0|  0.00%|    signature = inspect.signature(call)
   232|         0|            0|            0|  0.00%|    annotation = signature.return_annotation
   233|         0|            0|            0|  0.00%|
   234|         0|            0|            0|  0.00%|    if annotation is inspect.Signature.empty:
   235|         0|            0|            0|  0.00%|        return None
   236|         0|            0|            0|  0.00%|
   237|         0|            0|            0|  0.00%|    globalns = getattr(call, "__globals__", {})
   238|         0|            0|            0|  0.00%|    return get_typed_annotation(annotation, globalns)
   239|         0|            0|            0|  0.00%|
   240|         0|            0|            0|  0.00%|
   241|         1|   6.4373e-06|   6.4373e-06|  0.01%|def get_dependant(
   242|         0|            0|            0|  0.00%|    *,
   243|         0|            0|            0|  0.00%|    path: str,
   244|         0|            0|            0|  0.00%|    call: Callable[..., Any],
   245|         0|            0|            0|  0.00%|    name: Optional[str] = None,
   246|         0|            0|            0|  0.00%|    security_scopes: Optional[List[str]] = None,
   247|         0|            0|            0|  0.00%|    use_cache: bool = True,
   248|         0|            0|            0|  0.00%|) -> Dependant:
   249|         1|  1.62125e-05|  1.62125e-05|  0.02%|    path_param_names = get_path_param_names(path)
(call)|         1|  4.79221e-05|  4.79221e-05|  0.05%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/utils.py:59 get_path_param_names
   250|         1|  2.12193e-05|  2.12193e-05|  0.02%|    endpoint_signature = get_typed_signature(call)
(call)|         1|   0.00183678|   0.00183678|  1.89%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/dependencies/utils.py:207 get_typed_signature
   251|         1|  8.10623e-06|  8.10623e-06|  0.01%|    signature_params = endpoint_signature.parameters
(call)|         1|  4.05312e-06|  4.05312e-06|  0.00%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:3058 parameters
   252|         2|  2.40803e-05|  1.20401e-05|  0.02%|    dependant = Dependant(
(call)|         1|   7.4625e-05|   7.4625e-05|  0.08%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/dependencies/models.py:16 __init__
   253|         1|  3.09944e-06|  3.09944e-06|  0.00%|        call=call,
   254|         1|  4.52995e-06|  4.52995e-06|  0.00%|        name=name,
   255|         1|  3.33786e-06|  3.33786e-06|  0.00%|        path=path,
   256|         1|  2.86102e-06|  2.86102e-06|  0.00%|        security_scopes=security_scopes,
   257|         1|  2.86102e-06|  2.86102e-06|  0.00%|        use_cache=use_cache,
   258|         0|            0|            0|  0.00%|    )
   259|         4|  1.26362e-05|  3.15905e-06|  0.01%|    for param_name, param in signature_params.items():
   260|         3|  1.19209e-05|  3.97364e-06|  0.01%|        is_path_param = param_name in path_param_names
   261|         6|   9.9659e-05|  1.66098e-05|  0.10%|        type_annotation, depends, param_field = analyze_param(
(call)|         3|    0.0166602|    0.0055534| 17.13%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/dependencies/utils.py:317 analyze_param
   262|         3|  6.19888e-06|  2.06629e-06|  0.01%|            param_name=param_name,
   263|         3|  1.97887e-05|  6.59625e-06|  0.02%|            annotation=param.annotation,
(call)|         3|  1.23978e-05|  4.13259e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:2773 annotation
   264|         3|  1.83582e-05|  6.11941e-06|  0.02%|            value=param.default,
(call)|         3|  1.07288e-05|  3.57628e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:2769 default
   265|         3|  6.67572e-06|  2.22524e-06|  0.01%|            is_path_param=is_path_param,
   266|         0|            0|            0|  0.00%|        )
   267|         3|  9.77516e-06|  3.25839e-06|  0.01%|        if depends is not None:
   268|         0|            0|            0|  0.00%|            sub_dependant = get_param_sub_dependant(
   269|         0|            0|            0|  0.00%|                param_name=param_name,
   270|         0|            0|            0|  0.00%|                depends=depends,
   271|         0|            0|            0|  0.00%|                path=path,
   272|         0|            0|            0|  0.00%|                security_scopes=security_scopes,
   273|         0|            0|            0|  0.00%|            )
   274|         0|            0|            0|  0.00%|            dependant.dependencies.append(sub_dependant)
   275|         0|            0|            0|  0.00%|            continue
   276|         6|  5.10216e-05|   8.5036e-06|  0.05%|        if add_non_field_param_to_dependency(
(call)|         3|  0.000268221|   8.9407e-05|  0.28%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/dependencies/utils.py:293 add_non_field_param_to_dependency
   277|         3|  9.05991e-06|  3.01997e-06|  0.01%|            param_name=param_name,
   278|         3|  6.67572e-06|  2.22524e-06|  0.01%|            type_annotation=type_annotation,
   279|         3|  8.34465e-06|  2.78155e-06|  0.01%|            dependant=dependant,
   280|         0|            0|            0|  0.00%|        ):
   281|         0|            0|            0|  0.00%|            assert (
   282|         1|  1.90735e-06|  1.90735e-06|  0.00%|                param_field is None
   283|         0|            0|            0|  0.00%|            ), f"Cannot specify multiple FastAPI annotations for {param_name!r}"
   284|         1|  5.96046e-06|  5.96046e-06|  0.01%|            continue
   285|         2|  5.24521e-06|   2.6226e-06|  0.01%|        assert param_field is not None
   286|         2|  5.17368e-05|  2.58684e-05|  0.05%|        if is_body_param(param_field=param_field, is_path_param=is_path_param):
(call)|         2|   0.00193286|   0.00096643|  1.99%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/dependencies/utils.py:456 is_body_param
   287|         0|            0|            0|  0.00%|            dependant.body_params.append(param_field)
   288|         0|            0|            0|  0.00%|        else:
   289|         2|  2.55108e-05|  1.27554e-05|  0.03%|            add_param_to_fields(field=param_field, dependant=dependant)
(call)|         2|  3.67165e-05|  1.83582e-05|  0.04%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/dependencies/utils.py:475 add_param_to_fields
   290|         1|  2.14577e-06|  2.14577e-06|  0.00%|    return dependant
   291|         0|            0|            0|  0.00%|
   292|         0|            0|            0|  0.00%|
   293|         3|  1.09673e-05|  3.65575e-06|  0.01%|def add_non_field_param_to_dependency(
   294|         0|            0|            0|  0.00%|    *, param_name: str, type_annotation: Any, dependant: Dependant
   295|         0|            0|            0|  0.00%|) -> Optional[bool]:
   296|         3|  2.09808e-05|  6.99361e-06|  0.02%|    if lenient_issubclass(type_annotation, Request):
(call)|         3|  5.65052e-05|  1.88351e-05|  0.06%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_utils.py:75 lenient_issubclass
   297|         0|            0|            0|  0.00%|        dependant.request_param_name = param_name
   298|         0|            0|            0|  0.00%|        return True
   299|         3|  2.09808e-05|  6.99361e-06|  0.02%|    elif lenient_issubclass(type_annotation, WebSocket):
(call)|         3|  2.95639e-05|  9.85463e-06|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_utils.py:75 lenient_issubclass
   300|         1|  3.09944e-06|  3.09944e-06|  0.00%|        dependant.websocket_param_name = param_name
   301|         1|  2.38419e-06|  2.38419e-06|  0.00%|        return True
   302|         2|  1.62125e-05|  8.10623e-06|  0.02%|    elif lenient_issubclass(type_annotation, HTTPConnection):
(call)|         2|  1.97887e-05|  9.89437e-06|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_utils.py:75 lenient_issubclass
   303|         0|            0|            0|  0.00%|        dependant.http_connection_param_name = param_name
   304|         0|            0|            0|  0.00%|        return True
   305|         2|  2.40803e-05|  1.20401e-05|  0.02%|    elif lenient_issubclass(type_annotation, Response):
(call)|         2|  9.77516e-06|  4.88758e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_utils.py:75 lenient_issubclass
   306|         0|            0|            0|  0.00%|        dependant.response_param_name = param_name
   307|         0|            0|            0|  0.00%|        return True
   308|         2|  1.45435e-05|  7.27177e-06|  0.01%|    elif lenient_issubclass(type_annotation, StarletteBackgroundTasks):
(call)|         2|  7.62939e-06|   3.8147e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_utils.py:75 lenient_issubclass
   309|         0|            0|            0|  0.00%|        dependant.background_tasks_param_name = param_name
   310|         0|            0|            0|  0.00%|        return True
   311|         2|  1.57356e-05|  7.86781e-06|  0.02%|    elif lenient_issubclass(type_annotation, SecurityScopes):
(call)|         2|  9.77516e-06|  4.88758e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_utils.py:75 lenient_issubclass
   312|         0|            0|            0|  0.00%|        dependant.security_scopes_param_name = param_name
   313|         0|            0|            0|  0.00%|        return True
   314|         2|  6.19888e-06|  3.09944e-06|  0.01%|    return None
   315|         0|            0|            0|  0.00%|
   316|         0|            0|            0|  0.00%|
   317|         3|   2.3365e-05|  7.78834e-06|  0.02%|def analyze_param(
   318|         0|            0|            0|  0.00%|    *,
   319|         0|            0|            0|  0.00%|    param_name: str,
   320|         0|            0|            0|  0.00%|    annotation: Any,
   321|         0|            0|            0|  0.00%|    value: Any,
   322|         0|            0|            0|  0.00%|    is_path_param: bool,
   323|         0|            0|            0|  0.00%|) -> Tuple[Any, Optional[params.Depends], Optional[ModelField]]:
   324|         3|  1.64509e-05|  5.48363e-06|  0.02%|    field_info = None
   325|         3|  1.28746e-05|  4.29153e-06|  0.01%|    depends = None
   326|         3|  1.33514e-05|  4.45048e-06|  0.01%|    type_annotation: Any = Any
   327|         3|  1.28746e-05|  4.29153e-06|  0.01%|    use_annotation: Any = Any
   328|         3|  1.33514e-05|  4.45048e-06|  0.01%|    if annotation is not inspect.Signature.empty:
   329|         3|   1.4782e-05|  4.92732e-06|  0.02%|        use_annotation = annotation
   330|         3|   1.3113e-05|  4.37101e-06|  0.01%|        type_annotation = annotation
   331|         3|  4.50611e-05|  1.50204e-05|  0.05%|    if get_origin(use_annotation) is Annotated:
(call)|         3|  5.24521e-05|   1.7484e-05|  0.05%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:2310 get_origin
   332|         0|            0|            0|  0.00%|        annotated_args = get_args(annotation)
   333|         0|            0|            0|  0.00%|        type_annotation = annotated_args[0]
   334|         0|            0|            0|  0.00%|        fastapi_annotations = [
   335|         0|            0|            0|  0.00%|            arg
   336|         0|            0|            0|  0.00%|            for arg in annotated_args[1:]
   337|         0|            0|            0|  0.00%|            if isinstance(arg, (FieldInfo, params.Depends))
   338|         0|            0|            0|  0.00%|        ]
   339|         0|            0|            0|  0.00%|        fastapi_specific_annotations = [
   340|         0|            0|            0|  0.00%|            arg
   341|         0|            0|            0|  0.00%|            for arg in fastapi_annotations
   342|         0|            0|            0|  0.00%|            if isinstance(arg, (params.Param, params.Body, params.Depends))
   343|         0|            0|            0|  0.00%|        ]
   344|         0|            0|            0|  0.00%|        if fastapi_specific_annotations:
   345|         0|            0|            0|  0.00%|            fastapi_annotation: Union[FieldInfo, params.Depends, None] = (
   346|         0|            0|            0|  0.00%|                fastapi_specific_annotations[-1]
   347|         0|            0|            0|  0.00%|            )
   348|         0|            0|            0|  0.00%|        else:
   349|         0|            0|            0|  0.00%|            fastapi_annotation = None
   350|         0|            0|            0|  0.00%|        if isinstance(fastapi_annotation, FieldInfo):
   351|         0|            0|            0|  0.00%|            # Copy `field_info` because we mutate `field_info.default` below.
   352|         0|            0|            0|  0.00%|            field_info = copy_field_info(
   353|         0|            0|            0|  0.00%|                field_info=fastapi_annotation, annotation=use_annotation
   354|         0|            0|            0|  0.00%|            )
   355|         0|            0|            0|  0.00%|            assert field_info.default is Undefined or field_info.default is Required, (
   356|         0|            0|            0|  0.00%|                f"`{field_info.__class__.__name__}` default value cannot be set in"
   357|         0|            0|            0|  0.00%|                f" `Annotated` for {param_name!r}. Set the default value with `=` instead."
   358|         0|            0|            0|  0.00%|            )
   359|         0|            0|            0|  0.00%|            if value is not inspect.Signature.empty:
   360|         0|            0|            0|  0.00%|                assert not is_path_param, "Path parameters cannot have default values"
   361|         0|            0|            0|  0.00%|                field_info.default = value
   362|         0|            0|            0|  0.00%|            else:
   363|         0|            0|            0|  0.00%|                field_info.default = Required
   364|         0|            0|            0|  0.00%|        elif isinstance(fastapi_annotation, params.Depends):
   365|         0|            0|            0|  0.00%|            depends = fastapi_annotation
   366|         0|            0|            0|  0.00%|
   367|         3|  1.52588e-05|  5.08626e-06|  0.02%|    if isinstance(value, params.Depends):
   368|         0|            0|            0|  0.00%|        assert depends is None, (
   369|         0|            0|            0|  0.00%|            "Cannot specify `Depends` in `Annotated` and default value"
   370|         0|            0|            0|  0.00%|            f" together for {param_name!r}"
   371|         0|            0|            0|  0.00%|        )
   372|         0|            0|            0|  0.00%|        assert field_info is None, (
   373|         0|            0|            0|  0.00%|            "Cannot specify a FastAPI annotation in `Annotated` and `Depends` as a"
   374|         0|            0|            0|  0.00%|            f" default value together for {param_name!r}"
   375|         0|            0|            0|  0.00%|        )
   376|         0|            0|            0|  0.00%|        depends = value
   377|         3|  1.35899e-05|  4.52995e-06|  0.01%|    elif isinstance(value, FieldInfo):
   378|         0|            0|            0|  0.00%|        assert field_info is None, (
   379|         0|            0|            0|  0.00%|            "Cannot specify FastAPI annotations in `Annotated` and default value"
   380|         0|            0|            0|  0.00%|            f" together for {param_name!r}"
   381|         0|            0|            0|  0.00%|        )
   382|         0|            0|            0|  0.00%|        field_info = value
   383|         0|            0|            0|  0.00%|        if PYDANTIC_V2:
   384|         0|            0|            0|  0.00%|            field_info.annotation = type_annotation
   385|         0|            0|            0|  0.00%|
   386|         3|  1.62125e-05|  5.40415e-06|  0.02%|    if depends is not None and depends.dependency is None:
   387|         0|            0|            0|  0.00%|        # Copy `depends` before mutating it
   388|         0|            0|            0|  0.00%|        depends = copy(depends)
   389|         0|            0|            0|  0.00%|        depends.dependency = type_annotation
   390|         0|            0|            0|  0.00%|
   391|         6|  6.77109e-05|  1.12851e-05|  0.07%|    if lenient_issubclass(
(call)|         3|  0.000191212|  6.37372e-05|  0.20%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_utils.py:75 lenient_issubclass
   392|         3|  1.28746e-05|  4.29153e-06|  0.01%|        type_annotation,
   393|         3|  1.28746e-05|  4.29153e-06|  0.01%|        (
   394|         3|  1.45435e-05|  4.84784e-06|  0.01%|            Request,
   395|         3|  1.33514e-05|  4.45048e-06|  0.01%|            WebSocket,
   396|         3|  1.33514e-05|  4.45048e-06|  0.01%|            HTTPConnection,
   397|         3|  1.28746e-05|  4.29153e-06|  0.01%|            Response,
   398|         3|   1.3113e-05|  4.37101e-06|  0.01%|            StarletteBackgroundTasks,
   399|         3|  1.28746e-05|  4.29153e-06|  0.01%|            SecurityScopes,
   400|         0|            0|            0|  0.00%|        ),
   401|         0|            0|            0|  0.00%|    ):
   402|         1|  4.05312e-06|  4.05312e-06|  0.00%|        assert depends is None, f"Cannot specify `Depends` for type {type_annotation!r}"
   403|         0|            0|            0|  0.00%|        assert (
   404|         1|  7.39098e-06|  7.39098e-06|  0.01%|            field_info is None
   405|         0|            0|            0|  0.00%|        ), f"Cannot specify FastAPI annotation for type {type_annotation!r}"
   406|         2|  7.39098e-06|  3.69549e-06|  0.01%|    elif field_info is None and depends is None:
   407|         2|  1.21593e-05|  6.07967e-06|  0.01%|        default_value = value if value is not inspect.Signature.empty else Required
   408|         2|  1.00136e-05|  5.00679e-06|  0.01%|        if is_path_param:
   409|         0|            0|            0|  0.00%|            # We might check here that `default_value is Required`, but the fact is that the same
   410|         0|            0|            0|  0.00%|            # parameter might sometimes be a path parameter and sometimes not. See
   411|         0|            0|            0|  0.00%|            # `tests/test_infer_param_optionality.py` for an example.
   412|         1|  3.93391e-05|  3.93391e-05|  0.04%|            field_info = params.Path(annotation=use_annotation)
(call)|         1|   0.00105953|   0.00105953|  1.09%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/params.py:138 __init__
   413|         2|  2.67029e-05|  1.33514e-05|  0.03%|        elif is_uploadfile_or_nonable_uploadfile_annotation(
(call)|         1|  5.24521e-05|  5.24521e-05|  0.05%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/_compat.py:598 is_uploadfile_or_nonable_uploadfile_annotation
   414|         1|  6.67572e-06|  6.67572e-06|  0.01%|            type_annotation
   415|         1|  2.16961e-05|  2.16961e-05|  0.02%|        ) or is_uploadfile_sequence_annotation(type_annotation):
(call)|         1|  0.000101328|  0.000101328|  0.10%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/_compat.py:624 is_uploadfile_sequence_annotation
   416|         0|            0|            0|  0.00%|            field_info = params.File(annotation=use_annotation, default=default_value)
   417|         1|  1.95503e-05|  1.95503e-05|  0.02%|        elif not field_annotation_is_scalar(annotation=type_annotation):
(call)|         1|  0.000132799|  0.000132799|  0.14%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/_compat.py:565 field_annotation_is_scalar
   418|         0|            0|            0|  0.00%|            field_info = params.Body(annotation=use_annotation, default=default_value)
   419|         0|            0|            0|  0.00%|        else:
   420|         1|    4.673e-05|    4.673e-05|  0.05%|            field_info = params.Query(annotation=use_annotation, default=default_value)
(call)|         1|  0.000736475|  0.000736475|  0.76%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/params.py:224 __init__
   421|         0|            0|            0|  0.00%|
   422|         3|   0.00016284|    5.428e-05|  0.17%|    field = None
   423|         3|  2.67029e-05|  8.90096e-06|  0.03%|    if field_info is not None:
   424|         2|   1.0252e-05|    5.126e-06|  0.01%|        if is_path_param:
   425|         1|  7.15256e-06|  7.15256e-06|  0.01%|            assert isinstance(field_info, params.Path), (
   426|         0|            0|            0|  0.00%|                f"Cannot use `{field_info.__class__.__name__}` for path param"
   427|         0|            0|            0|  0.00%|                f" {param_name!r}"
   428|         0|            0|            0|  0.00%|            )
   429|         0|            0|            0|  0.00%|        elif (
   430|         1|  5.48363e-06|  5.48363e-06|  0.01%|            isinstance(field_info, params.Param)
   431|         1|  1.09673e-05|  1.09673e-05|  0.01%|            and getattr(field_info, "in_", None) is None
   432|         0|            0|            0|  0.00%|        ):
   433|         0|            0|            0|  0.00%|            field_info.in_ = params.ParamTypes.query
   434|         4|  5.57899e-05|  1.39475e-05|  0.06%|        use_annotation_from_field_info = get_annotation_from_field_info(
(call)|         2|  2.02656e-05|  1.01328e-05|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/_compat.py:165 get_annotation_from_field_info
   435|         2|  1.09673e-05|  5.48363e-06|  0.01%|            use_annotation,
   436|         2|  1.09673e-05|  5.48363e-06|  0.01%|            field_info,
   437|         2|  1.16825e-05|  5.84126e-06|  0.01%|            param_name,
   438|         0|            0|            0|  0.00%|        )
   439|         2|  8.58307e-06|  4.29153e-06|  0.01%|        if not field_info.alias and getattr(field_info, "convert_underscores", None):
   440|         0|            0|            0|  0.00%|            alias = param_name.replace("_", "-")
   441|         0|            0|            0|  0.00%|        else:
   442|         2|   1.0252e-05|    5.126e-06|  0.01%|            alias = field_info.alias or param_name
   443|         2|  1.16825e-05|  5.84126e-06|  0.01%|        field_info.alias = alias
   444|         4|  8.82149e-05|  2.20537e-05|  0.09%|        field = create_response_field(
(call)|         2|    0.0132005|   0.00660026| 13.57%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/utils.py:63 create_response_field
   445|         2|  1.50204e-05|  7.51019e-06|  0.02%|            name=param_name,
   446|         2|  1.19209e-05|  5.96046e-06|  0.01%|            type_=use_annotation_from_field_info,
   447|         2|   1.4782e-05|  7.39098e-06|  0.02%|            default=field_info.default,
   448|         2|   1.0252e-05|    5.126e-06|  0.01%|            alias=alias,
   449|         2|  9.77516e-06|  4.88758e-06|  0.01%|            required=field_info.default in (Required, Undefined),
   450|         2|  9.53674e-06|  4.76837e-06|  0.01%|            field_info=field_info,
   451|         0|            0|            0|  0.00%|        )
   452|         0|            0|            0|  0.00%|
   453|         3|  2.47955e-05|  8.26518e-06|  0.03%|    return type_annotation, depends, field
   454|         0|            0|            0|  0.00%|
   455|         0|            0|            0|  0.00%|
   456|         2|   1.4782e-05|  7.39098e-06|  0.02%|def is_body_param(*, param_field: ModelField, is_path_param: bool) -> bool:
   457|         2|  6.19888e-06|  3.09944e-06|  0.01%|    if is_path_param:
   458|         2|  0.000551462|  0.000275731|  0.57%|        assert is_scalar_field(
(call)|         1|   0.00115895|   0.00115895|  1.19%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/_compat.py:234 is_scalar_field
   459|         1|  2.26498e-05|  2.26498e-05|  0.02%|            field=param_field
   460|         0|            0|            0|  0.00%|        ), "Path params must be of one of the supported types"
   461|         1|  1.90735e-06|  1.90735e-06|  0.00%|        return False
   462|         1|  6.67572e-06|  6.67572e-06|  0.01%|    elif is_scalar_field(field=param_field):
(call)|         1|  0.000165462|  0.000165462|  0.17%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/_compat.py:234 is_scalar_field
   463|         1|  4.76837e-06|  4.76837e-06|  0.00%|        return False
   464|         0|            0|            0|  0.00%|    elif isinstance(
   465|         0|            0|            0|  0.00%|        param_field.field_info, (params.Query, params.Header)
   466|         0|            0|            0|  0.00%|    ) and is_scalar_sequence_field(param_field):
   467|         0|            0|            0|  0.00%|        return False
   468|         0|            0|            0|  0.00%|    else:
   469|         0|            0|            0|  0.00%|        assert isinstance(
   470|         0|            0|            0|  0.00%|            param_field.field_info, params.Body
   471|         0|            0|            0|  0.00%|        ), f"Param: {param_field.name} can only be a request body, using Body()"
   472|         0|            0|            0|  0.00%|        return True
   473|         0|            0|            0|  0.00%|
   474|         0|            0|            0|  0.00%|
   475|         2|  9.05991e-06|  4.52995e-06|  0.01%|def add_param_to_fields(*, field: ModelField, dependant: Dependant) -> None:
   476|         2|  5.48363e-06|  2.74181e-06|  0.01%|    field_info = field.field_info
   477|         2|  5.00679e-06|   2.5034e-06|  0.01%|    field_info_in = getattr(field_info, "in_", None)
   478|         2|  6.19888e-06|  3.09944e-06|  0.01%|    if field_info_in == params.ParamTypes.path:
   479|         1|  3.57628e-06|  3.57628e-06|  0.00%|        dependant.path_params.append(field)
   480|         1|  2.86102e-06|  2.86102e-06|  0.00%|    elif field_info_in == params.ParamTypes.query:
   481|         1|  4.52995e-06|  4.52995e-06|  0.00%|        dependant.query_params.append(field)
   482|         0|            0|            0|  0.00%|    elif field_info_in == params.ParamTypes.header:
   483|         0|            0|            0|  0.00%|        dependant.header_params.append(field)
   484|         0|            0|            0|  0.00%|    else:
   485|         0|            0|            0|  0.00%|        assert (
   486|         0|            0|            0|  0.00%|            field_info_in == params.ParamTypes.cookie
   487|         0|            0|            0|  0.00%|        ), f"non-body parameters must be in path, query, header or cookie: {field.name}"
   488|         0|            0|            0|  0.00%|        dependant.cookie_params.append(field)
   489|         0|            0|            0|  0.00%|
   490|         0|            0|            0|  0.00%|
   491|         0|            0|            0|  0.00%|def is_coroutine_callable(call: Callable[..., Any]) -> bool:
   492|         0|            0|            0|  0.00%|    if inspect.isroutine(call):
   493|         0|            0|            0|  0.00%|        return inspect.iscoroutinefunction(call)
   494|         0|            0|            0|  0.00%|    if inspect.isclass(call):
   495|         0|            0|            0|  0.00%|        return False
   496|         0|            0|            0|  0.00%|    dunder_call = getattr(call, "__call__", None)  # noqa: B004
   497|         0|            0|            0|  0.00%|    return inspect.iscoroutinefunction(dunder_call)
   498|         0|            0|            0|  0.00%|
   499|         0|            0|            0|  0.00%|
   500|         0|            0|            0|  0.00%|def is_async_gen_callable(call: Callable[..., Any]) -> bool:
   501|         0|            0|            0|  0.00%|    if inspect.isasyncgenfunction(call):
   502|         0|            0|            0|  0.00%|        return True
   503|         0|            0|            0|  0.00%|    dunder_call = getattr(call, "__call__", None)  # noqa: B004
   504|         0|            0|            0|  0.00%|    return inspect.isasyncgenfunction(dunder_call)
   505|         0|            0|            0|  0.00%|
   506|         0|            0|            0|  0.00%|
   507|         0|            0|            0|  0.00%|def is_gen_callable(call: Callable[..., Any]) -> bool:
   508|         0|            0|            0|  0.00%|    if inspect.isgeneratorfunction(call):
   509|         0|            0|            0|  0.00%|        return True
   510|         0|            0|            0|  0.00%|    dunder_call = getattr(call, "__call__", None)  # noqa: B004
   511|         0|            0|            0|  0.00%|    return inspect.isgeneratorfunction(dunder_call)
   512|         0|            0|            0|  0.00%|
   513|         0|            0|            0|  0.00%|
   514|         0|            0|            0|  0.00%|async def solve_generator(
   515|         0|            0|            0|  0.00%|    *, call: Callable[..., Any], stack: AsyncExitStack, sub_values: Dict[str, Any]
   516|         0|            0|            0|  0.00%|) -> Any:
   517|         0|            0|            0|  0.00%|    if is_gen_callable(call):
   518|         0|            0|            0|  0.00%|        cm = contextmanager_in_threadpool(contextmanager(call)(**sub_values))
   519|         0|            0|            0|  0.00%|    elif is_async_gen_callable(call):
   520|         0|            0|            0|  0.00%|        cm = asynccontextmanager(call)(**sub_values)
   521|         0|            0|            0|  0.00%|    return await stack.enter_async_context(cm)
   522|         0|            0|            0|  0.00%|
   523|         0|            0|            0|  0.00%|
   524|         0|            0|            0|  0.00%|async def solve_dependencies(
   525|         0|            0|            0|  0.00%|    *,
   526|         0|            0|            0|  0.00%|    request: Union[Request, WebSocket],
   527|         0|            0|            0|  0.00%|    dependant: Dependant,
   528|         0|            0|            0|  0.00%|    body: Optional[Union[Dict[str, Any], FormData]] = None,
   529|         0|            0|            0|  0.00%|    background_tasks: Optional[StarletteBackgroundTasks] = None,
   530|         0|            0|            0|  0.00%|    response: Optional[Response] = None,
   531|         0|            0|            0|  0.00%|    dependency_overrides_provider: Optional[Any] = None,
   532|         0|            0|            0|  0.00%|    dependency_cache: Optional[Dict[Tuple[Callable[..., Any], Tuple[str]], Any]] = None,
   533|         0|            0|            0|  0.00%|    async_exit_stack: AsyncExitStack,
   534|         0|            0|            0|  0.00%|) -> Tuple[
   535|         0|            0|            0|  0.00%|    Dict[str, Any],
   536|         0|            0|            0|  0.00%|    List[Any],
   537|         0|            0|            0|  0.00%|    Optional[StarletteBackgroundTasks],
   538|         0|            0|            0|  0.00%|    Response,
   539|         0|            0|            0|  0.00%|    Dict[Tuple[Callable[..., Any], Tuple[str]], Any],
   540|         0|            0|            0|  0.00%|]:
   541|         0|            0|            0|  0.00%|    values: Dict[str, Any] = {}
   542|         0|            0|            0|  0.00%|    errors: List[Any] = []
   543|         0|            0|            0|  0.00%|    if response is None:
   544|         0|            0|            0|  0.00%|        response = Response()
   545|         0|            0|            0|  0.00%|        del response.headers["content-length"]
   546|         0|            0|            0|  0.00%|        response.status_code = None  # type: ignore
   547|         0|            0|            0|  0.00%|    dependency_cache = dependency_cache or {}
   548|         0|            0|            0|  0.00%|    sub_dependant: Dependant
   549|         0|            0|            0|  0.00%|    for sub_dependant in dependant.dependencies:
   550|         0|            0|            0|  0.00%|        sub_dependant.call = cast(Callable[..., Any], sub_dependant.call)
   551|         0|            0|            0|  0.00%|        sub_dependant.cache_key = cast(
   552|         0|            0|            0|  0.00%|            Tuple[Callable[..., Any], Tuple[str]], sub_dependant.cache_key
   553|         0|            0|            0|  0.00%|        )
   554|         0|            0|            0|  0.00%|        call = sub_dependant.call
   555|         0|            0|            0|  0.00%|        use_sub_dependant = sub_dependant
   556|         0|            0|            0|  0.00%|        if (
   557|         0|            0|            0|  0.00%|            dependency_overrides_provider
   558|         0|            0|            0|  0.00%|            and dependency_overrides_provider.dependency_overrides
   559|         0|            0|            0|  0.00%|        ):
   560|         0|            0|            0|  0.00%|            original_call = sub_dependant.call
   561|         0|            0|            0|  0.00%|            call = getattr(
   562|         0|            0|            0|  0.00%|                dependency_overrides_provider, "dependency_overrides", {}
   563|         0|            0|            0|  0.00%|            ).get(original_call, original_call)
   564|         0|            0|            0|  0.00%|            use_path: str = sub_dependant.path  # type: ignore
   565|         0|            0|            0|  0.00%|            use_sub_dependant = get_dependant(
   566|         0|            0|            0|  0.00%|                path=use_path,
   567|         0|            0|            0|  0.00%|                call=call,
   568|         0|            0|            0|  0.00%|                name=sub_dependant.name,
   569|         0|            0|            0|  0.00%|                security_scopes=sub_dependant.security_scopes,
   570|         0|            0|            0|  0.00%|            )
   571|         0|            0|            0|  0.00%|
   572|         0|            0|            0|  0.00%|        solved_result = await solve_dependencies(
   573|         0|            0|            0|  0.00%|            request=request,
   574|         0|            0|            0|  0.00%|            dependant=use_sub_dependant,
   575|         0|            0|            0|  0.00%|            body=body,
   576|         0|            0|            0|  0.00%|            background_tasks=background_tasks,
   577|         0|            0|            0|  0.00%|            response=response,
   578|         0|            0|            0|  0.00%|            dependency_overrides_provider=dependency_overrides_provider,
   579|         0|            0|            0|  0.00%|            dependency_cache=dependency_cache,
   580|         0|            0|            0|  0.00%|            async_exit_stack=async_exit_stack,
   581|         0|            0|            0|  0.00%|        )
   582|         0|            0|            0|  0.00%|        (
   583|         0|            0|            0|  0.00%|            sub_values,
   584|         0|            0|            0|  0.00%|            sub_errors,
   585|         0|            0|            0|  0.00%|            background_tasks,
   586|         0|            0|            0|  0.00%|            _,  # the subdependency returns the same response we have
   587|         0|            0|            0|  0.00%|            sub_dependency_cache,
   588|         0|            0|            0|  0.00%|        ) = solved_result
   589|         0|            0|            0|  0.00%|        dependency_cache.update(sub_dependency_cache)
   590|         0|            0|            0|  0.00%|        if sub_errors:
   591|         0|            0|            0|  0.00%|            errors.extend(sub_errors)
   592|         0|            0|            0|  0.00%|            continue
   593|         0|            0|            0|  0.00%|        if sub_dependant.use_cache and sub_dependant.cache_key in dependency_cache:
   594|         0|            0|            0|  0.00%|            solved = dependency_cache[sub_dependant.cache_key]
   595|         0|            0|            0|  0.00%|        elif is_gen_callable(call) or is_async_gen_callable(call):
   596|         0|            0|            0|  0.00%|            solved = await solve_generator(
   597|         0|            0|            0|  0.00%|                call=call, stack=async_exit_stack, sub_values=sub_values
   598|         0|            0|            0|  0.00%|            )
   599|         0|            0|            0|  0.00%|        elif is_coroutine_callable(call):
   600|         0|            0|            0|  0.00%|            solved = await call(**sub_values)
   601|         0|            0|            0|  0.00%|        else:
   602|         0|            0|            0|  0.00%|            solved = await run_in_threadpool(call, **sub_values)
   603|         0|            0|            0|  0.00%|        if sub_dependant.name is not None:
   604|         0|            0|            0|  0.00%|            values[sub_dependant.name] = solved
   605|         0|            0|            0|  0.00%|        if sub_dependant.cache_key not in dependency_cache:
   606|         0|            0|            0|  0.00%|            dependency_cache[sub_dependant.cache_key] = solved
   607|         0|            0|            0|  0.00%|    path_values, path_errors = request_params_to_args(
   608|         0|            0|            0|  0.00%|        dependant.path_params, request.path_params
   609|         0|            0|            0|  0.00%|    )
   610|         0|            0|            0|  0.00%|    query_values, query_errors = request_params_to_args(
   611|         0|            0|            0|  0.00%|        dependant.query_params, request.query_params
   612|         0|            0|            0|  0.00%|    )
   613|         0|            0|            0|  0.00%|    header_values, header_errors = request_params_to_args(
   614|         0|            0|            0|  0.00%|        dependant.header_params, request.headers
   615|         0|            0|            0|  0.00%|    )
   616|         0|            0|            0|  0.00%|    cookie_values, cookie_errors = request_params_to_args(
   617|         0|            0|            0|  0.00%|        dependant.cookie_params, request.cookies
   618|         0|            0|            0|  0.00%|    )
   619|         0|            0|            0|  0.00%|    values.update(path_values)
   620|         0|            0|            0|  0.00%|    values.update(query_values)
   621|         0|            0|            0|  0.00%|    values.update(header_values)
   622|         0|            0|            0|  0.00%|    values.update(cookie_values)
   623|         0|            0|            0|  0.00%|    errors += path_errors + query_errors + header_errors + cookie_errors
   624|         0|            0|            0|  0.00%|    if dependant.body_params:
   625|         0|            0|            0|  0.00%|        (
   626|         0|            0|            0|  0.00%|            body_values,
   627|         0|            0|            0|  0.00%|            body_errors,
   628|         0|            0|            0|  0.00%|        ) = await request_body_to_args(  # body_params checked above
   629|         0|            0|            0|  0.00%|            required_params=dependant.body_params, received_body=body
   630|         0|            0|            0|  0.00%|        )
   631|         0|            0|            0|  0.00%|        values.update(body_values)
   632|         0|            0|            0|  0.00%|        errors.extend(body_errors)
   633|         0|            0|            0|  0.00%|    if dependant.http_connection_param_name:
   634|         0|            0|            0|  0.00%|        values[dependant.http_connection_param_name] = request
   635|         0|            0|            0|  0.00%|    if dependant.request_param_name and isinstance(request, Request):
   636|         0|            0|            0|  0.00%|        values[dependant.request_param_name] = request
   637|         0|            0|            0|  0.00%|    elif dependant.websocket_param_name and isinstance(request, WebSocket):
   638|         0|            0|            0|  0.00%|        values[dependant.websocket_param_name] = request
   639|         0|            0|            0|  0.00%|    if dependant.background_tasks_param_name:
   640|         0|            0|            0|  0.00%|        if background_tasks is None:
   641|         0|            0|            0|  0.00%|            background_tasks = BackgroundTasks()
   642|         0|            0|            0|  0.00%|        values[dependant.background_tasks_param_name] = background_tasks
   643|         0|            0|            0|  0.00%|    if dependant.response_param_name:
   644|         0|            0|            0|  0.00%|        values[dependant.response_param_name] = response
   645|         0|            0|            0|  0.00%|    if dependant.security_scopes_param_name:
   646|         0|            0|            0|  0.00%|        values[dependant.security_scopes_param_name] = SecurityScopes(
   647|         0|            0|            0|  0.00%|            scopes=dependant.security_scopes
   648|         0|            0|            0|  0.00%|        )
   649|         0|            0|            0|  0.00%|    return values, errors, background_tasks, response, dependency_cache
   650|         0|            0|            0|  0.00%|
   651|         0|            0|            0|  0.00%|
   652|         0|            0|            0|  0.00%|def request_params_to_args(
   653|         0|            0|            0|  0.00%|    required_params: Sequence[ModelField],
   654|         0|            0|            0|  0.00%|    received_params: Union[Mapping[str, Any], QueryParams, Headers],
   655|         0|            0|            0|  0.00%|) -> Tuple[Dict[str, Any], List[Any]]:
   656|         0|            0|            0|  0.00%|    values = {}
   657|         0|            0|            0|  0.00%|    errors = []
   658|         0|            0|            0|  0.00%|    for field in required_params:
   659|         0|            0|            0|  0.00%|        if is_scalar_sequence_field(field) and isinstance(
   660|         0|            0|            0|  0.00%|            received_params, (QueryParams, Headers)
   661|         0|            0|            0|  0.00%|        ):
   662|         0|            0|            0|  0.00%|            value = received_params.getlist(field.alias) or field.default
   663|         0|            0|            0|  0.00%|        else:
   664|         0|            0|            0|  0.00%|            value = received_params.get(field.alias)
   665|         0|            0|            0|  0.00%|        field_info = field.field_info
   666|         0|            0|            0|  0.00%|        assert isinstance(
   667|         0|            0|            0|  0.00%|            field_info, params.Param
   668|         0|            0|            0|  0.00%|        ), "Params must be subclasses of Param"
   669|         0|            0|            0|  0.00%|        loc = (field_info.in_.value, field.alias)
   670|         0|            0|            0|  0.00%|        if value is None:
   671|         0|            0|            0|  0.00%|            if field.required:
   672|         0|            0|            0|  0.00%|                errors.append(get_missing_field_error(loc=loc))
   673|         0|            0|            0|  0.00%|            else:
   674|         0|            0|            0|  0.00%|                values[field.name] = deepcopy(field.default)
   675|         0|            0|            0|  0.00%|            continue
   676|         0|            0|            0|  0.00%|        v_, errors_ = field.validate(value, values, loc=loc)
   677|         0|            0|            0|  0.00%|        if isinstance(errors_, ErrorWrapper):
   678|         0|            0|            0|  0.00%|            errors.append(errors_)
   679|         0|            0|            0|  0.00%|        elif isinstance(errors_, list):
   680|         0|            0|            0|  0.00%|            new_errors = _regenerate_error_with_loc(errors=errors_, loc_prefix=())
   681|         0|            0|            0|  0.00%|            errors.extend(new_errors)
   682|         0|            0|            0|  0.00%|        else:
   683|         0|            0|            0|  0.00%|            values[field.name] = v_
   684|         0|            0|            0|  0.00%|    return values, errors
   685|         0|            0|            0|  0.00%|
   686|         0|            0|            0|  0.00%|
   687|         0|            0|            0|  0.00%|async def request_body_to_args(
   688|         0|            0|            0|  0.00%|    required_params: List[ModelField],
   689|         0|            0|            0|  0.00%|    received_body: Optional[Union[Dict[str, Any], FormData]],
   690|         0|            0|            0|  0.00%|) -> Tuple[Dict[str, Any], List[Dict[str, Any]]]:
   691|         0|            0|            0|  0.00%|    values = {}
   692|         0|            0|            0|  0.00%|    errors: List[Dict[str, Any]] = []
   693|         0|            0|            0|  0.00%|    if required_params:
   694|         0|            0|            0|  0.00%|        field = required_params[0]
   695|         0|            0|            0|  0.00%|        field_info = field.field_info
   696|         0|            0|            0|  0.00%|        embed = getattr(field_info, "embed", None)
   697|         0|            0|            0|  0.00%|        field_alias_omitted = len(required_params) == 1 and not embed
   698|         0|            0|            0|  0.00%|        if field_alias_omitted:
   699|         0|            0|            0|  0.00%|            received_body = {field.alias: received_body}
   700|         0|            0|            0|  0.00%|
   701|         0|            0|            0|  0.00%|        for field in required_params:
   702|         0|            0|            0|  0.00%|            loc: Tuple[str, ...]
   703|         0|            0|            0|  0.00%|            if field_alias_omitted:
   704|         0|            0|            0|  0.00%|                loc = ("body",)
   705|         0|            0|            0|  0.00%|            else:
   706|         0|            0|            0|  0.00%|                loc = ("body", field.alias)
   707|         0|            0|            0|  0.00%|
   708|         0|            0|            0|  0.00%|            value: Optional[Any] = None
   709|         0|            0|            0|  0.00%|            if received_body is not None:
   710|         0|            0|            0|  0.00%|                if (is_sequence_field(field)) and isinstance(received_body, FormData):
   711|         0|            0|            0|  0.00%|                    value = received_body.getlist(field.alias)
   712|         0|            0|            0|  0.00%|                else:
   713|         0|            0|            0|  0.00%|                    try:
   714|         0|            0|            0|  0.00%|                        value = received_body.get(field.alias)
   715|         0|            0|            0|  0.00%|                    except AttributeError:
   716|         0|            0|            0|  0.00%|                        errors.append(get_missing_field_error(loc))
   717|         0|            0|            0|  0.00%|                        continue
   718|         0|            0|            0|  0.00%|            if (
   719|         0|            0|            0|  0.00%|                value is None
   720|         0|            0|            0|  0.00%|                or (isinstance(field_info, params.Form) and value == "")
   721|         0|            0|            0|  0.00%|                or (
   722|         0|            0|            0|  0.00%|                    isinstance(field_info, params.Form)
   723|         0|            0|            0|  0.00%|                    and is_sequence_field(field)
   724|         0|            0|            0|  0.00%|                    and len(value) == 0
   725|         0|            0|            0|  0.00%|                )
   726|         0|            0|            0|  0.00%|            ):
   727|         0|            0|            0|  0.00%|                if field.required:
   728|         0|            0|            0|  0.00%|                    errors.append(get_missing_field_error(loc))
   729|         0|            0|            0|  0.00%|                else:
   730|         0|            0|            0|  0.00%|                    values[field.name] = deepcopy(field.default)
   731|         0|            0|            0|  0.00%|                continue
   732|         0|            0|            0|  0.00%|            if (
   733|         0|            0|            0|  0.00%|                isinstance(field_info, params.File)
   734|         0|            0|            0|  0.00%|                and is_bytes_field(field)
   735|         0|            0|            0|  0.00%|                and isinstance(value, UploadFile)
   736|         0|            0|            0|  0.00%|            ):
   737|         0|            0|            0|  0.00%|                value = await value.read()
   738|         0|            0|            0|  0.00%|            elif (
   739|         0|            0|            0|  0.00%|                is_bytes_sequence_field(field)
   740|         0|            0|            0|  0.00%|                and isinstance(field_info, params.File)
   741|         0|            0|            0|  0.00%|                and value_is_sequence(value)
   742|         0|            0|            0|  0.00%|            ):
   743|         0|            0|            0|  0.00%|                # For types
   744|         0|            0|            0|  0.00%|                assert isinstance(value, sequence_types)  # type: ignore[arg-type]
   745|         0|            0|            0|  0.00%|                results: List[Union[bytes, str]] = []
   746|         0|            0|            0|  0.00%|
   747|         0|            0|            0|  0.00%|                async def process_fn(
   748|         0|            0|            0|  0.00%|                    fn: Callable[[], Coroutine[Any, Any, Any]],
   749|         0|            0|            0|  0.00%|                ) -> None:
   750|         0|            0|            0|  0.00%|                    result = await fn()
   751|         0|            0|            0|  0.00%|                    results.append(result)  # noqa: B023
   752|         0|            0|            0|  0.00%|
   753|         0|            0|            0|  0.00%|                async with anyio.create_task_group() as tg:
   754|         0|            0|            0|  0.00%|                    for sub_value in value:
   755|         0|            0|            0|  0.00%|                        tg.start_soon(process_fn, sub_value.read)
   756|         0|            0|            0|  0.00%|                value = serialize_sequence_value(field=field, value=results)
   757|         0|            0|            0|  0.00%|
   758|         0|            0|            0|  0.00%|            v_, errors_ = field.validate(value, values, loc=loc)
   759|         0|            0|            0|  0.00%|
   760|         0|            0|            0|  0.00%|            if isinstance(errors_, list):
   761|         0|            0|            0|  0.00%|                errors.extend(errors_)
   762|         0|            0|            0|  0.00%|            elif errors_:
   763|         0|            0|            0|  0.00%|                errors.append(errors_)
   764|         0|            0|            0|  0.00%|            else:
   765|         0|            0|            0|  0.00%|                values[field.name] = v_
   766|         0|            0|            0|  0.00%|    return values, errors
   767|         0|            0|            0|  0.00%|
   768|         0|            0|            0|  0.00%|
   769|         0|            0|            0|  0.00%|def get_body_field(*, dependant: Dependant, name: str) -> Optional[ModelField]:
   770|         0|            0|            0|  0.00%|    flat_dependant = get_flat_dependant(dependant)
   771|         0|            0|            0|  0.00%|    if not flat_dependant.body_params:
   772|         0|            0|            0|  0.00%|        return None
   773|         0|            0|            0|  0.00%|    first_param = flat_dependant.body_params[0]
   774|         0|            0|            0|  0.00%|    field_info = first_param.field_info
   775|         0|            0|            0|  0.00%|    embed = getattr(field_info, "embed", None)
   776|         0|            0|            0|  0.00%|    body_param_names_set = {param.name for param in flat_dependant.body_params}
   777|         0|            0|            0|  0.00%|    if len(body_param_names_set) == 1 and not embed:
   778|         0|            0|            0|  0.00%|        check_file_field(first_param)
   779|         0|            0|            0|  0.00%|        return first_param
   780|         0|            0|            0|  0.00%|    # If one field requires to embed, all have to be embedded
   781|         0|            0|            0|  0.00%|    # in case a sub-dependency is evaluated with a single unique body field
   782|         0|            0|            0|  0.00%|    # That is combined (embedded) with other body fields
   783|         0|            0|            0|  0.00%|    for param in flat_dependant.body_params:
   784|         0|            0|            0|  0.00%|        setattr(param.field_info, "embed", True)  # noqa: B010
   785|         0|            0|            0|  0.00%|    model_name = "Body_" + name
   786|         0|            0|            0|  0.00%|    BodyModel = create_body_model(
   787|         0|            0|            0|  0.00%|        fields=flat_dependant.body_params, model_name=model_name
   788|         0|            0|            0|  0.00%|    )
   789|         0|            0|            0|  0.00%|    required = any(True for f in flat_dependant.body_params if f.required)
   790|         0|            0|            0|  0.00%|    BodyFieldInfo_kwargs: Dict[str, Any] = {
   791|         0|            0|            0|  0.00%|        "annotation": BodyModel,
   792|         0|            0|            0|  0.00%|        "alias": "body",
   793|         0|            0|            0|  0.00%|    }
   794|         0|            0|            0|  0.00%|    if not required:
   795|         0|            0|            0|  0.00%|        BodyFieldInfo_kwargs["default"] = None
   796|         0|            0|            0|  0.00%|    if any(isinstance(f.field_info, params.File) for f in flat_dependant.body_params):
   797|         0|            0|            0|  0.00%|        BodyFieldInfo: Type[params.Body] = params.File
   798|         0|            0|            0|  0.00%|    elif any(isinstance(f.field_info, params.Form) for f in flat_dependant.body_params):
   799|         0|            0|            0|  0.00%|        BodyFieldInfo = params.Form
   800|         0|            0|            0|  0.00%|    else:
   801|         0|            0|            0|  0.00%|        BodyFieldInfo = params.Body
   802|         0|            0|            0|  0.00%|
   803|         0|            0|            0|  0.00%|        body_param_media_types = [
   804|         0|            0|            0|  0.00%|            f.field_info.media_type
   805|         0|            0|            0|  0.00%|            for f in flat_dependant.body_params
   806|         0|            0|            0|  0.00%|            if isinstance(f.field_info, params.Body)
   807|         0|            0|            0|  0.00%|        ]
   808|         0|            0|            0|  0.00%|        if len(set(body_param_media_types)) == 1:
   809|         0|            0|            0|  0.00%|            BodyFieldInfo_kwargs["media_type"] = body_param_media_types[0]
   810|         0|            0|            0|  0.00%|    final_field = create_response_field(
   811|         0|            0|            0|  0.00%|        name="body",
   812|         0|            0|            0|  0.00%|        type_=BodyModel,
   813|         0|            0|            0|  0.00%|        required=required,
   814|         0|            0|            0|  0.00%|        alias="body",
   815|         0|            0|            0|  0.00%|        field_info=BodyFieldInfo(**BodyFieldInfo_kwargs),
   816|         0|            0|            0|  0.00%|    )
   817|         0|            0|            0|  0.00%|    check_file_field(final_field)
   818|         0|            0|            0|  0.00%|    return final_field
File: <frozen abc>
File duration: 0.00228429s (2.35%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|
    44|         0|            0|            0|  0.00%|
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|
    48|         0|            0|            0|  0.00%|
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|
    54|         0|            0|            0|  0.00%|
    55|         0|            0|            0|  0.00%|
    56|         0|            0|            0|  0.00%|
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|
    69|         0|            0|            0|  0.00%|
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|
    72|         0|            0|            0|  0.00%|
    73|         0|            0|            0|  0.00%|
    74|         0|            0|            0|  0.00%|
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|
    83|         0|            0|            0|  0.00%|
    84|         0|            0|            0|  0.00%|
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|
    87|         0|            0|            0|  0.00%|
    88|         0|            0|            0|  0.00%|
    89|         0|            0|            0|  0.00%|
    90|         0|            0|            0|  0.00%|
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|
   106|         0|            0|            0|  0.00%|
   107|         0|            0|            0|  0.00%|
   108|         0|            0|            0|  0.00%|
   109|         0|            0|            0|  0.00%|
   110|         0|            0|            0|  0.00%|
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|
   113|         0|            0|            0|  0.00%|
   114|         0|            0|            0|  0.00%|
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|
   117|        14|  2.16961e-05|  1.54972e-06|  0.02%|
   118|         0|            0|            0|  0.00%|
   119|        14|  3.52859e-05|  2.52042e-06|  0.04%|
(call)|         2|  0.000548363|  0.000274181|  0.56%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:1846 __subclasscheck__
   120|         0|            0|            0|  0.00%|
   121|       335|  0.000297546|  8.88198e-07|  0.31%|
   122|         0|            0|            0|  0.00%|
   123|       335|   0.00192976|  5.76048e-06|  1.98%|
(call)|        43|  0.000233173|  5.42264e-06|  0.24%|# <frozen _collections_abc>:435 __subclasshook__
(call)|       295|   0.00202274|  6.85676e-06|  2.08%|# <frozen abc>:121 __subclasscheck__
(call)|        12|  0.000236511|  1.97093e-05|  0.24%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:1905 _proto_hook
(call)|        10|  0.000217676|  2.17676e-05|  0.22%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:1846 __subclasscheck__
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_compiler.py
File duration: 0.00225353s (2.32%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|#
     2|         0|            0|            0|  0.00%|# Secret Labs' Regular Expression Engine
     3|         0|            0|            0|  0.00%|#
     4|         0|            0|            0|  0.00%|# convert template to internal format
     5|         0|            0|            0|  0.00%|#
     6|         0|            0|            0|  0.00%|# Copyright (c) 1997-2001 by Secret Labs AB.  All rights reserved.
     7|         0|            0|            0|  0.00%|#
     8|         0|            0|            0|  0.00%|# See the __init__.py file for information on usage and redistribution.
     9|         0|            0|            0|  0.00%|#
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|"""Internal support module for sre"""
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|import _sre
    14|         0|            0|            0|  0.00%|from . import _parser
    15|         0|            0|            0|  0.00%|from ._constants import *
    16|         0|            0|            0|  0.00%|from ._casefix import _EXTRA_CASES
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|assert _sre.MAGIC == MAGIC, "SRE module mismatch"
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|_LITERAL_CODES = {LITERAL, NOT_LITERAL}
    21|         0|            0|            0|  0.00%|_SUCCESS_CODES = {SUCCESS, FAILURE}
    22|         0|            0|            0|  0.00%|_ASSERT_CODES = {ASSERT, ASSERT_NOT}
    23|         0|            0|            0|  0.00%|_UNIT_CODES = _LITERAL_CODES | {ANY, IN}
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|_REPEATING_CODES = {
    26|         0|            0|            0|  0.00%|    MIN_REPEAT: (REPEAT, MIN_UNTIL, MIN_REPEAT_ONE),
    27|         0|            0|            0|  0.00%|    MAX_REPEAT: (REPEAT, MAX_UNTIL, REPEAT_ONE),
    28|         0|            0|            0|  0.00%|    POSSESSIVE_REPEAT: (POSSESSIVE_REPEAT, SUCCESS, POSSESSIVE_REPEAT_ONE),
    29|         0|            0|            0|  0.00%|}
    30|         0|            0|            0|  0.00%|
    31|         1|  1.23978e-05|  1.23978e-05|  0.01%|def _combine_flags(flags, add_flags, del_flags,
    32|         0|            0|            0|  0.00%|                   TYPE_FLAGS=_parser.TYPE_FLAGS):
    33|         1|  2.14577e-06|  2.14577e-06|  0.00%|    if add_flags & TYPE_FLAGS:
    34|         0|            0|            0|  0.00%|        flags &= ~TYPE_FLAGS
    35|         1|  4.05312e-06|  4.05312e-06|  0.00%|    return (flags | add_flags) & ~del_flags
    36|         0|            0|            0|  0.00%|
    37|         3|  4.98295e-05|  1.66098e-05|  0.05%|def _compile(code, pattern, flags):
    38|         0|            0|            0|  0.00%|    # internal: compile a (sub)pattern
    39|         3|  2.57492e-05|  8.58307e-06|  0.03%|    emit = code.append
    40|         3|  2.45571e-05|   8.1857e-06|  0.03%|    _len = len
    41|         3|  2.45571e-05|   8.1857e-06|  0.03%|    LITERAL_CODES = _LITERAL_CODES
    42|         3|  2.45571e-05|   8.1857e-06|  0.03%|    REPEATING_CODES = _REPEATING_CODES
    43|         3|  2.38419e-05|  7.94729e-06|  0.02%|    SUCCESS_CODES = _SUCCESS_CODES
    44|         3|  2.43187e-05|  8.10623e-06|  0.02%|    ASSERT_CODES = _ASSERT_CODES
    45|         3|  2.67029e-05|  8.90096e-06|  0.03%|    iscased = None
    46|         3|  2.38419e-05|  7.94729e-06|  0.02%|    tolower = None
    47|         3|  2.38419e-05|  7.94729e-06|  0.02%|    fixes = None
    48|         3|  2.43187e-05|  8.10623e-06|  0.02%|    if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:
    49|         0|            0|            0|  0.00%|        if flags & SRE_FLAG_UNICODE:
    50|         0|            0|            0|  0.00%|            iscased = _sre.unicode_iscased
    51|         0|            0|            0|  0.00%|            tolower = _sre.unicode_tolower
    52|         0|            0|            0|  0.00%|            fixes = _EXTRA_CASES
    53|         0|            0|            0|  0.00%|        else:
    54|         0|            0|            0|  0.00%|            iscased = _sre.ascii_iscased
    55|         0|            0|            0|  0.00%|            tolower = _sre.ascii_tolower
    56|        14|   0.00033474|    2.391e-05|  0.34%|    for op, av in pattern:
(call)|         4|  6.48499e-05|  1.62125e-05|  0.07%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:168 __getitem__
    57|        11|  7.55787e-05|  6.87079e-06|  0.08%|        if op in LITERAL_CODES:
    58|         7|  4.98295e-05|   7.1185e-06|  0.05%|            if not flags & SRE_FLAG_IGNORECASE:
    59|         7|  5.45979e-05|  7.79969e-06|  0.06%|                emit(op)
    60|         7|  5.88894e-05|  8.41277e-06|  0.06%|                emit(av)
    61|         0|            0|            0|  0.00%|            elif flags & SRE_FLAG_LOCALE:
    62|         0|            0|            0|  0.00%|                emit(OP_LOCALE_IGNORE[op])
    63|         0|            0|            0|  0.00%|                emit(av)
    64|         0|            0|            0|  0.00%|            elif not iscased(av):
    65|         0|            0|            0|  0.00%|                emit(op)
    66|         0|            0|            0|  0.00%|                emit(av)
    67|         0|            0|            0|  0.00%|            else:
    68|         0|            0|            0|  0.00%|                lo = tolower(av)
    69|         0|            0|            0|  0.00%|                if not fixes:  # ascii
    70|         0|            0|            0|  0.00%|                    emit(OP_IGNORE[op])
    71|         0|            0|            0|  0.00%|                    emit(lo)
    72|         0|            0|            0|  0.00%|                elif lo not in fixes:
    73|         0|            0|            0|  0.00%|                    emit(OP_UNICODE_IGNORE[op])
    74|         0|            0|            0|  0.00%|                    emit(lo)
    75|         0|            0|            0|  0.00%|                else:
    76|         0|            0|            0|  0.00%|                    emit(IN_UNI_IGNORE)
    77|         0|            0|            0|  0.00%|                    skip = _len(code); emit(0)
    78|         0|            0|            0|  0.00%|                    if op is NOT_LITERAL:
    79|         0|            0|            0|  0.00%|                        emit(NEGATE)
    80|         0|            0|            0|  0.00%|                    for k in (lo,) + fixes[lo]:
    81|         0|            0|            0|  0.00%|                        emit(LITERAL)
    82|         0|            0|            0|  0.00%|                        emit(k)
    83|         0|            0|            0|  0.00%|                    emit(FAILURE)
    84|         0|            0|            0|  0.00%|                    code[skip] = _len(code) - skip
    85|         4|   3.0756e-05|    7.689e-06|  0.03%|        elif op is IN:
    86|         0|            0|            0|  0.00%|            charset, hascased = _optimize_charset(av, iscased, tolower, fixes)
    87|         0|            0|            0|  0.00%|            if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:
    88|         0|            0|            0|  0.00%|                emit(IN_LOC_IGNORE)
    89|         0|            0|            0|  0.00%|            elif not hascased:
    90|         0|            0|            0|  0.00%|                emit(IN)
    91|         0|            0|            0|  0.00%|            elif not fixes:  # ascii
    92|         0|            0|            0|  0.00%|                emit(IN_IGNORE)
    93|         0|            0|            0|  0.00%|            else:
    94|         0|            0|            0|  0.00%|                emit(IN_UNI_IGNORE)
    95|         0|            0|            0|  0.00%|            skip = _len(code); emit(0)
    96|         0|            0|            0|  0.00%|            _compile_charset(charset, flags, code)
    97|         0|            0|            0|  0.00%|            code[skip] = _len(code) - skip
    98|         4|  2.95639e-05|  7.39098e-06|  0.03%|        elif op is ANY:
    99|         0|            0|            0|  0.00%|            if flags & SRE_FLAG_DOTALL:
   100|         0|            0|            0|  0.00%|                emit(ANY_ALL)
   101|         0|            0|            0|  0.00%|            else:
   102|         0|            0|            0|  0.00%|                emit(ANY)
   103|         4|   3.0756e-05|    7.689e-06|  0.03%|        elif op in REPEATING_CODES:
   104|         1|  6.19888e-06|  6.19888e-06|  0.01%|            if flags & SRE_FLAG_TEMPLATE:
   105|         0|            0|            0|  0.00%|                raise error("internal: unsupported template operator %r" % (op,))
   106|         1|  3.60012e-05|  3.60012e-05|  0.04%|            if _simple(av[2]):
(call)|         1|  4.00543e-05|  4.00543e-05|  0.04%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_compiler.py:398 _simple
   107|         1|  1.23978e-05|  1.23978e-05|  0.01%|                emit(REPEATING_CODES[op][2])
   108|         1|  1.40667e-05|  1.40667e-05|  0.01%|                skip = _len(code); emit(0)
   109|         1|  1.21593e-05|  1.21593e-05|  0.01%|                emit(av[0])
   110|         1|  1.19209e-05|  1.19209e-05|  0.01%|                emit(av[1])
   111|         1|  6.48499e-05|  6.48499e-05|  0.07%|                _compile(code, av[2], flags)
(call)|         1|  0.000323296|  0.000323296|  0.33%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_compiler.py:37 _compile
   112|         1|  1.83582e-05|  1.83582e-05|  0.02%|                emit(SUCCESS)
   113|         1|  1.28746e-05|  1.28746e-05|  0.01%|                code[skip] = _len(code) - skip
   114|         0|            0|            0|  0.00%|            else:
   115|         0|            0|            0|  0.00%|                emit(REPEATING_CODES[op][0])
   116|         0|            0|            0|  0.00%|                skip = _len(code); emit(0)
   117|         0|            0|            0|  0.00%|                emit(av[0])
   118|         0|            0|            0|  0.00%|                emit(av[1])
   119|         0|            0|            0|  0.00%|                _compile(code, av[2], flags)
   120|         0|            0|            0|  0.00%|                code[skip] = _len(code) - skip
   121|         0|            0|            0|  0.00%|                emit(REPEATING_CODES[op][1])
   122|         3|  2.38419e-05|  7.94729e-06|  0.02%|        elif op is SUBPATTERN:
   123|         1|  6.19888e-06|  6.19888e-06|  0.01%|            group, add_flags, del_flags, p = av
   124|         1|  1.21593e-05|  1.21593e-05|  0.01%|            if group:
   125|         1|  1.40667e-05|  1.40667e-05|  0.01%|                emit(MARK)
   126|         1|  1.23978e-05|  1.23978e-05|  0.01%|                emit((group-1)*2)
   127|         0|            0|            0|  0.00%|            # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))
   128|         1|  0.000103712|  0.000103712|  0.11%|            _compile(code, p, _combine_flags(flags, add_flags, del_flags))
(call)|         1|  1.85966e-05|  1.85966e-05|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_compiler.py:31 _combine_flags
(call)|         1|  0.000434399|  0.000434399|  0.45%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_compiler.py:37 _compile
   129|         1|  5.05447e-05|  5.05447e-05|  0.05%|            if group:
   130|         1|  6.81877e-05|  6.81877e-05|  0.07%|                emit(MARK)
   131|         1|  1.85966e-05|  1.85966e-05|  0.02%|                emit((group-1)*2+1)
   132|         2|  1.81198e-05|  9.05991e-06|  0.02%|        elif op is ATOMIC_GROUP:
   133|         0|            0|            0|  0.00%|            # Atomic Groups are handled by starting with an Atomic
   134|         0|            0|            0|  0.00%|            # Group op code, then putting in the atomic group pattern
   135|         0|            0|            0|  0.00%|            # and finally a success op code to tell any repeat
   136|         0|            0|            0|  0.00%|            # operations within the Atomic Group to stop eating and
   137|         0|            0|            0|  0.00%|            # pop their stack if they reach it
   138|         0|            0|            0|  0.00%|            emit(ATOMIC_GROUP)
   139|         0|            0|            0|  0.00%|            skip = _len(code); emit(0)
   140|         0|            0|            0|  0.00%|            _compile(code, av, flags)
   141|         0|            0|            0|  0.00%|            emit(SUCCESS)
   142|         0|            0|            0|  0.00%|            code[skip] = _len(code) - skip
   143|         2|  1.83582e-05|  9.17912e-06|  0.02%|        elif op in SUCCESS_CODES:
   144|         0|            0|            0|  0.00%|            emit(op)
   145|         2|  2.00272e-05|  1.00136e-05|  0.02%|        elif op in ASSERT_CODES:
   146|         0|            0|            0|  0.00%|            emit(op)
   147|         0|            0|            0|  0.00%|            skip = _len(code); emit(0)
   148|         0|            0|            0|  0.00%|            if av[0] >= 0:
   149|         0|            0|            0|  0.00%|                emit(0) # look ahead
   150|         0|            0|            0|  0.00%|            else:
   151|         0|            0|            0|  0.00%|                lo, hi = av[1].getwidth()
   152|         0|            0|            0|  0.00%|                if lo > MAXCODE:
   153|         0|            0|            0|  0.00%|                    raise error("looks too much behind")
   154|         0|            0|            0|  0.00%|                if lo != hi:
   155|         0|            0|            0|  0.00%|                    raise error("look-behind requires fixed-width pattern")
   156|         0|            0|            0|  0.00%|                emit(lo) # look behind
   157|         0|            0|            0|  0.00%|            _compile(code, av[1], flags)
   158|         0|            0|            0|  0.00%|            emit(SUCCESS)
   159|         0|            0|            0|  0.00%|            code[skip] = _len(code) - skip
   160|         2|  1.78814e-05|   8.9407e-06|  0.02%|        elif op is AT:
   161|         2|  1.83582e-05|  9.17912e-06|  0.02%|            emit(op)
   162|         2|  1.81198e-05|  9.05991e-06|  0.02%|            if flags & SRE_FLAG_MULTILINE:
   163|         0|            0|            0|  0.00%|                av = AT_MULTILINE.get(av, av)
   164|         2|  1.83582e-05|  9.17912e-06|  0.02%|            if flags & SRE_FLAG_LOCALE:
   165|         0|            0|            0|  0.00%|                av = AT_LOCALE.get(av, av)
   166|         2|  1.78814e-05|   8.9407e-06|  0.02%|            elif flags & SRE_FLAG_UNICODE:
   167|         2|  1.85966e-05|  9.29832e-06|  0.02%|                av = AT_UNICODE.get(av, av)
   168|         2|  1.83582e-05|  9.17912e-06|  0.02%|            emit(av)
   169|         0|            0|            0|  0.00%|        elif op is BRANCH:
   170|         0|            0|            0|  0.00%|            emit(op)
   171|         0|            0|            0|  0.00%|            tail = []
   172|         0|            0|            0|  0.00%|            tailappend = tail.append
   173|         0|            0|            0|  0.00%|            for av in av[1]:
   174|         0|            0|            0|  0.00%|                skip = _len(code); emit(0)
   175|         0|            0|            0|  0.00%|                # _compile_info(code, av, flags)
   176|         0|            0|            0|  0.00%|                _compile(code, av, flags)
   177|         0|            0|            0|  0.00%|                emit(JUMP)
   178|         0|            0|            0|  0.00%|                tailappend(_len(code)); emit(0)
   179|         0|            0|            0|  0.00%|                code[skip] = _len(code) - skip
   180|         0|            0|            0|  0.00%|            emit(FAILURE) # end of branch
   181|         0|            0|            0|  0.00%|            for tail in tail:
   182|         0|            0|            0|  0.00%|                code[tail] = _len(code) - tail
   183|         0|            0|            0|  0.00%|        elif op is CATEGORY:
   184|         0|            0|            0|  0.00%|            emit(op)
   185|         0|            0|            0|  0.00%|            if flags & SRE_FLAG_LOCALE:
   186|         0|            0|            0|  0.00%|                av = CH_LOCALE[av]
   187|         0|            0|            0|  0.00%|            elif flags & SRE_FLAG_UNICODE:
   188|         0|            0|            0|  0.00%|                av = CH_UNICODE[av]
   189|         0|            0|            0|  0.00%|            emit(av)
   190|         0|            0|            0|  0.00%|        elif op is GROUPREF:
   191|         0|            0|            0|  0.00%|            if not flags & SRE_FLAG_IGNORECASE:
   192|         0|            0|            0|  0.00%|                emit(op)
   193|         0|            0|            0|  0.00%|            elif flags & SRE_FLAG_LOCALE:
   194|         0|            0|            0|  0.00%|                emit(GROUPREF_LOC_IGNORE)
   195|         0|            0|            0|  0.00%|            elif not fixes:  # ascii
   196|         0|            0|            0|  0.00%|                emit(GROUPREF_IGNORE)
   197|         0|            0|            0|  0.00%|            else:
   198|         0|            0|            0|  0.00%|                emit(GROUPREF_UNI_IGNORE)
   199|         0|            0|            0|  0.00%|            emit(av-1)
   200|         0|            0|            0|  0.00%|        elif op is GROUPREF_EXISTS:
   201|         0|            0|            0|  0.00%|            emit(op)
   202|         0|            0|            0|  0.00%|            emit(av[0]-1)
   203|         0|            0|            0|  0.00%|            skipyes = _len(code); emit(0)
   204|         0|            0|            0|  0.00%|            _compile(code, av[1], flags)
   205|         0|            0|            0|  0.00%|            if av[2]:
   206|         0|            0|            0|  0.00%|                emit(JUMP)
   207|         0|            0|            0|  0.00%|                skipno = _len(code); emit(0)
   208|         0|            0|            0|  0.00%|                code[skipyes] = _len(code) - skipyes + 1
   209|         0|            0|            0|  0.00%|                _compile(code, av[2], flags)
   210|         0|            0|            0|  0.00%|                code[skipno] = _len(code) - skipno
   211|         0|            0|            0|  0.00%|            else:
   212|         0|            0|            0|  0.00%|                code[skipyes] = _len(code) - skipyes + 1
   213|         0|            0|            0|  0.00%|        else:
   214|         0|            0|            0|  0.00%|            raise error("internal: unsupported operand type %r" % (op,))
   215|         0|            0|            0|  0.00%|
   216|         0|            0|            0|  0.00%|def _compile_charset(charset, flags, code):
   217|         0|            0|            0|  0.00%|    # compile charset subprogram
   218|         0|            0|            0|  0.00%|    emit = code.append
   219|         0|            0|            0|  0.00%|    for op, av in charset:
   220|         0|            0|            0|  0.00%|        emit(op)
   221|         0|            0|            0|  0.00%|        if op is NEGATE:
   222|         0|            0|            0|  0.00%|            pass
   223|         0|            0|            0|  0.00%|        elif op is LITERAL:
   224|         0|            0|            0|  0.00%|            emit(av)
   225|         0|            0|            0|  0.00%|        elif op is RANGE or op is RANGE_UNI_IGNORE:
   226|         0|            0|            0|  0.00%|            emit(av[0])
   227|         0|            0|            0|  0.00%|            emit(av[1])
   228|         0|            0|            0|  0.00%|        elif op is CHARSET:
   229|         0|            0|            0|  0.00%|            code.extend(av)
   230|         0|            0|            0|  0.00%|        elif op is BIGCHARSET:
   231|         0|            0|            0|  0.00%|            code.extend(av)
   232|         0|            0|            0|  0.00%|        elif op is CATEGORY:
   233|         0|            0|            0|  0.00%|            if flags & SRE_FLAG_LOCALE:
   234|         0|            0|            0|  0.00%|                emit(CH_LOCALE[av])
   235|         0|            0|            0|  0.00%|            elif flags & SRE_FLAG_UNICODE:
   236|         0|            0|            0|  0.00%|                emit(CH_UNICODE[av])
   237|         0|            0|            0|  0.00%|            else:
   238|         0|            0|            0|  0.00%|                emit(av)
   239|         0|            0|            0|  0.00%|        else:
   240|         0|            0|            0|  0.00%|            raise error("internal: unsupported set operator %r" % (op,))
   241|         0|            0|            0|  0.00%|    emit(FAILURE)
   242|         0|            0|            0|  0.00%|
   243|         0|            0|            0|  0.00%|def _optimize_charset(charset, iscased=None, fixup=None, fixes=None):
   244|         0|            0|            0|  0.00%|    # internal: optimize character set
   245|         0|            0|            0|  0.00%|    out = []
   246|         0|            0|            0|  0.00%|    tail = []
   247|         0|            0|            0|  0.00%|    charmap = bytearray(256)
   248|         0|            0|            0|  0.00%|    hascased = False
   249|         0|            0|            0|  0.00%|    for op, av in charset:
   250|         0|            0|            0|  0.00%|        while True:
   251|         0|            0|            0|  0.00%|            try:
   252|         0|            0|            0|  0.00%|                if op is LITERAL:
   253|         0|            0|            0|  0.00%|                    if fixup:
   254|         0|            0|            0|  0.00%|                        lo = fixup(av)
   255|         0|            0|            0|  0.00%|                        charmap[lo] = 1
   256|         0|            0|            0|  0.00%|                        if fixes and lo in fixes:
   257|         0|            0|            0|  0.00%|                            for k in fixes[lo]:
   258|         0|            0|            0|  0.00%|                                charmap[k] = 1
   259|         0|            0|            0|  0.00%|                        if not hascased and iscased(av):
   260|         0|            0|            0|  0.00%|                            hascased = True
   261|         0|            0|            0|  0.00%|                    else:
   262|         0|            0|            0|  0.00%|                        charmap[av] = 1
   263|         0|            0|            0|  0.00%|                elif op is RANGE:
   264|         0|            0|            0|  0.00%|                    r = range(av[0], av[1]+1)
   265|         0|            0|            0|  0.00%|                    if fixup:
   266|         0|            0|            0|  0.00%|                        if fixes:
   267|         0|            0|            0|  0.00%|                            for i in map(fixup, r):
   268|         0|            0|            0|  0.00%|                                charmap[i] = 1
   269|         0|            0|            0|  0.00%|                                if i in fixes:
   270|         0|            0|            0|  0.00%|                                    for k in fixes[i]:
   271|         0|            0|            0|  0.00%|                                        charmap[k] = 1
   272|         0|            0|            0|  0.00%|                        else:
   273|         0|            0|            0|  0.00%|                            for i in map(fixup, r):
   274|         0|            0|            0|  0.00%|                                charmap[i] = 1
   275|         0|            0|            0|  0.00%|                        if not hascased:
   276|         0|            0|            0|  0.00%|                            hascased = any(map(iscased, r))
   277|         0|            0|            0|  0.00%|                    else:
   278|         0|            0|            0|  0.00%|                        for i in r:
   279|         0|            0|            0|  0.00%|                            charmap[i] = 1
   280|         0|            0|            0|  0.00%|                elif op is NEGATE:
   281|         0|            0|            0|  0.00%|                    out.append((op, av))
   282|         0|            0|            0|  0.00%|                else:
   283|         0|            0|            0|  0.00%|                    tail.append((op, av))
   284|         0|            0|            0|  0.00%|            except IndexError:
   285|         0|            0|            0|  0.00%|                if len(charmap) == 256:
   286|         0|            0|            0|  0.00%|                    # character set contains non-UCS1 character codes
   287|         0|            0|            0|  0.00%|                    charmap += b'\0' * 0xff00
   288|         0|            0|            0|  0.00%|                    continue
   289|         0|            0|            0|  0.00%|                # Character set contains non-BMP character codes.
   290|         0|            0|            0|  0.00%|                # For range, all BMP characters in the range are already
   291|         0|            0|            0|  0.00%|                # proceeded.
   292|         0|            0|            0|  0.00%|                if fixup:
   293|         0|            0|            0|  0.00%|                    hascased = True
   294|         0|            0|            0|  0.00%|                    # For now, IN_UNI_IGNORE+LITERAL and
   295|         0|            0|            0|  0.00%|                    # IN_UNI_IGNORE+RANGE_UNI_IGNORE work for all non-BMP
   296|         0|            0|            0|  0.00%|                    # characters, because two characters (at least one of
   297|         0|            0|            0|  0.00%|                    # which is not in the BMP) match case-insensitively
   298|         0|            0|            0|  0.00%|                    # if and only if:
   299|         0|            0|            0|  0.00%|                    # 1) c1.lower() == c2.lower()
   300|         0|            0|            0|  0.00%|                    # 2) c1.lower() == c2 or c1.lower().upper() == c2
   301|         0|            0|            0|  0.00%|                    # Also, both c.lower() and c.lower().upper() are single
   302|         0|            0|            0|  0.00%|                    # characters for every non-BMP character.
   303|         0|            0|            0|  0.00%|                    if op is RANGE:
   304|         0|            0|            0|  0.00%|                        op = RANGE_UNI_IGNORE
   305|         0|            0|            0|  0.00%|                tail.append((op, av))
   306|         0|            0|            0|  0.00%|            break
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|    # compress character map
   309|         0|            0|            0|  0.00%|    runs = []
   310|         0|            0|            0|  0.00%|    q = 0
   311|         0|            0|            0|  0.00%|    while True:
   312|         0|            0|            0|  0.00%|        p = charmap.find(1, q)
   313|         0|            0|            0|  0.00%|        if p < 0:
   314|         0|            0|            0|  0.00%|            break
   315|         0|            0|            0|  0.00%|        if len(runs) >= 2:
   316|         0|            0|            0|  0.00%|            runs = None
   317|         0|            0|            0|  0.00%|            break
   318|         0|            0|            0|  0.00%|        q = charmap.find(0, p)
   319|         0|            0|            0|  0.00%|        if q < 0:
   320|         0|            0|            0|  0.00%|            runs.append((p, len(charmap)))
   321|         0|            0|            0|  0.00%|            break
   322|         0|            0|            0|  0.00%|        runs.append((p, q))
   323|         0|            0|            0|  0.00%|    if runs is not None:
   324|         0|            0|            0|  0.00%|        # use literal/range
   325|         0|            0|            0|  0.00%|        for p, q in runs:
   326|         0|            0|            0|  0.00%|            if q - p == 1:
   327|         0|            0|            0|  0.00%|                out.append((LITERAL, p))
   328|         0|            0|            0|  0.00%|            else:
   329|         0|            0|            0|  0.00%|                out.append((RANGE, (p, q - 1)))
   330|         0|            0|            0|  0.00%|        out += tail
   331|         0|            0|            0|  0.00%|        # if the case was changed or new representation is more compact
   332|         0|            0|            0|  0.00%|        if hascased or len(out) < len(charset):
   333|         0|            0|            0|  0.00%|            return out, hascased
   334|         0|            0|            0|  0.00%|        # else original character set is good enough
   335|         0|            0|            0|  0.00%|        return charset, hascased
   336|         0|            0|            0|  0.00%|
   337|         0|            0|            0|  0.00%|    # use bitmap
   338|         0|            0|            0|  0.00%|    if len(charmap) == 256:
   339|         0|            0|            0|  0.00%|        data = _mk_bitmap(charmap)
   340|         0|            0|            0|  0.00%|        out.append((CHARSET, data))
   341|         0|            0|            0|  0.00%|        out += tail
   342|         0|            0|            0|  0.00%|        return out, hascased
   343|         0|            0|            0|  0.00%|
   344|         0|            0|            0|  0.00%|    # To represent a big charset, first a bitmap of all characters in the
   345|         0|            0|            0|  0.00%|    # set is constructed. Then, this bitmap is sliced into chunks of 256
   346|         0|            0|            0|  0.00%|    # characters, duplicate chunks are eliminated, and each chunk is
   347|         0|            0|            0|  0.00%|    # given a number. In the compiled expression, the charset is
   348|         0|            0|            0|  0.00%|    # represented by a 32-bit word sequence, consisting of one word for
   349|         0|            0|            0|  0.00%|    # the number of different chunks, a sequence of 256 bytes (64 words)
   350|         0|            0|            0|  0.00%|    # of chunk numbers indexed by their original chunk position, and a
   351|         0|            0|            0|  0.00%|    # sequence of 256-bit chunks (8 words each).
   352|         0|            0|            0|  0.00%|
   353|         0|            0|            0|  0.00%|    # Compression is normally good: in a typical charset, large ranges of
   354|         0|            0|            0|  0.00%|    # Unicode will be either completely excluded (e.g. if only cyrillic
   355|         0|            0|            0|  0.00%|    # letters are to be matched), or completely included (e.g. if large
   356|         0|            0|            0|  0.00%|    # subranges of Kanji match). These ranges will be represented by
   357|         0|            0|            0|  0.00%|    # chunks of all one-bits or all zero-bits.
   358|         0|            0|            0|  0.00%|
   359|         0|            0|            0|  0.00%|    # Matching can be also done efficiently: the more significant byte of
   360|         0|            0|            0|  0.00%|    # the Unicode character is an index into the chunk number, and the
   361|         0|            0|            0|  0.00%|    # less significant byte is a bit index in the chunk (just like the
   362|         0|            0|            0|  0.00%|    # CHARSET matching).
   363|         0|            0|            0|  0.00%|
   364|         0|            0|            0|  0.00%|    charmap = bytes(charmap) # should be hashable
   365|         0|            0|            0|  0.00%|    comps = {}
   366|         0|            0|            0|  0.00%|    mapping = bytearray(256)
   367|         0|            0|            0|  0.00%|    block = 0
   368|         0|            0|            0|  0.00%|    data = bytearray()
   369|         0|            0|            0|  0.00%|    for i in range(0, 65536, 256):
   370|         0|            0|            0|  0.00%|        chunk = charmap[i: i + 256]
   371|         0|            0|            0|  0.00%|        if chunk in comps:
   372|         0|            0|            0|  0.00%|            mapping[i // 256] = comps[chunk]
   373|         0|            0|            0|  0.00%|        else:
   374|         0|            0|            0|  0.00%|            mapping[i // 256] = comps[chunk] = block
   375|         0|            0|            0|  0.00%|            block += 1
   376|         0|            0|            0|  0.00%|            data += chunk
   377|         0|            0|            0|  0.00%|    data = _mk_bitmap(data)
   378|         0|            0|            0|  0.00%|    data[0:0] = [block] + _bytes_to_codes(mapping)
   379|         0|            0|            0|  0.00%|    out.append((BIGCHARSET, data))
   380|         0|            0|            0|  0.00%|    out += tail
   381|         0|            0|            0|  0.00%|    return out, hascased
   382|         0|            0|            0|  0.00%|
   383|         0|            0|            0|  0.00%|_CODEBITS = _sre.CODESIZE * 8
   384|         0|            0|            0|  0.00%|MAXCODE = (1 << _CODEBITS) - 1
   385|         0|            0|            0|  0.00%|_BITS_TRANS = b'0' + b'1' * 255
   386|         0|            0|            0|  0.00%|def _mk_bitmap(bits, _CODEBITS=_CODEBITS, _int=int):
   387|         0|            0|            0|  0.00%|    s = bits.translate(_BITS_TRANS)[::-1]
   388|         0|            0|            0|  0.00%|    return [_int(s[i - _CODEBITS: i], 2)
   389|         0|            0|            0|  0.00%|            for i in range(len(s), 0, -_CODEBITS)]
   390|         0|            0|            0|  0.00%|
   391|         0|            0|            0|  0.00%|def _bytes_to_codes(b):
   392|         0|            0|            0|  0.00%|    # Convert block indices to word array
   393|         0|            0|            0|  0.00%|    a = memoryview(b).cast('I')
   394|         0|            0|            0|  0.00%|    assert a.itemsize == _sre.CODESIZE
   395|         0|            0|            0|  0.00%|    assert len(a) * a.itemsize == len(b)
   396|         0|            0|            0|  0.00%|    return a.tolist()
   397|         0|            0|            0|  0.00%|
   398|         1|  1.28746e-05|  1.28746e-05|  0.01%|def _simple(p):
   399|         0|            0|            0|  0.00%|    # check if this subpattern is a "simple" operator
   400|         1|  6.91414e-06|  6.91414e-06|  0.01%|    if len(p) != 1:
(call)|         1|  5.72205e-06|  5.72205e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:164 __len__
   401|         0|            0|            0|  0.00%|        return False
   402|         1|  6.19888e-06|  6.19888e-06|  0.01%|    op, av = p[0]
(call)|         1|  4.29153e-06|  4.29153e-06|  0.00%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:168 __getitem__
   403|         1|  1.90735e-06|  1.90735e-06|  0.00%|    if op is SUBPATTERN:
   404|         0|            0|            0|  0.00%|        return av[0] is None and _simple(av[-1])
   405|         1|  2.14577e-06|  2.14577e-06|  0.00%|    return op in _UNIT_CODES
   406|         0|            0|            0|  0.00%|
   407|         0|            0|            0|  0.00%|def _generate_overlap_table(prefix):
   408|         0|            0|            0|  0.00%|    """
   409|         0|            0|            0|  0.00%|    Generate an overlap table for the following prefix.
   410|         0|            0|            0|  0.00%|    An overlap table is a table of the same size as the prefix which
   411|         0|            0|            0|  0.00%|    informs about the potential self-overlap for each index in the prefix:
   412|         0|            0|            0|  0.00%|    - if overlap[i] == 0, prefix[i:] can't overlap prefix[0:...]
   413|         0|            0|            0|  0.00%|    - if overlap[i] == k with 0 < k <= i, prefix[i-k+1:i+1] overlaps with
   414|         0|            0|            0|  0.00%|      prefix[0:k]
   415|         0|            0|            0|  0.00%|    """
   416|         0|            0|            0|  0.00%|    table = [0] * len(prefix)
   417|         0|            0|            0|  0.00%|    for i in range(1, len(prefix)):
   418|         0|            0|            0|  0.00%|        idx = table[i - 1]
   419|         0|            0|            0|  0.00%|        while prefix[i] != prefix[idx]:
   420|         0|            0|            0|  0.00%|            if idx == 0:
   421|         0|            0|            0|  0.00%|                table[i] = 0
   422|         0|            0|            0|  0.00%|                break
   423|         0|            0|            0|  0.00%|            idx = table[idx - 1]
   424|         0|            0|            0|  0.00%|        else:
   425|         0|            0|            0|  0.00%|            table[i] = idx + 1
   426|         0|            0|            0|  0.00%|    return table
   427|         0|            0|            0|  0.00%|
   428|         2|  6.67572e-06|  3.33786e-06|  0.01%|def _get_iscased(flags):
   429|         2|  3.57628e-06|  1.78814e-06|  0.00%|    if not flags & SRE_FLAG_IGNORECASE:
   430|         2|  2.86102e-06|  1.43051e-06|  0.00%|        return None
   431|         0|            0|            0|  0.00%|    elif flags & SRE_FLAG_UNICODE:
   432|         0|            0|            0|  0.00%|        return _sre.unicode_iscased
   433|         0|            0|            0|  0.00%|    else:
   434|         0|            0|            0|  0.00%|        return _sre.ascii_iscased
   435|         0|            0|            0|  0.00%|
   436|         1|  6.19888e-06|  6.19888e-06|  0.01%|def _get_literal_prefix(pattern, flags):
   437|         0|            0|            0|  0.00%|    # look for literal prefix
   438|         1|  3.09944e-06|  3.09944e-06|  0.00%|    prefix = []
   439|         1|  5.72205e-06|  5.72205e-06|  0.01%|    prefixappend = prefix.append
   440|         1|  2.86102e-06|  2.86102e-06|  0.00%|    prefix_skip = None
   441|         1|  1.12057e-05|  1.12057e-05|  0.01%|    iscased = _get_iscased(flags)
(call)|         1|  6.67572e-06|  6.67572e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_compiler.py:428 _get_iscased
   442|         1|  3.09944e-06|  3.09944e-06|  0.00%|    for op, av in pattern.data:
   443|         1|  4.52995e-06|  4.52995e-06|  0.00%|        if op is LITERAL:
   444|         0|            0|            0|  0.00%|            if iscased and iscased(av):
   445|         0|            0|            0|  0.00%|                break
   446|         0|            0|            0|  0.00%|            prefixappend(av)
   447|         1|  3.09944e-06|  3.09944e-06|  0.00%|        elif op is SUBPATTERN:
   448|         0|            0|            0|  0.00%|            group, add_flags, del_flags, p = av
   449|         0|            0|            0|  0.00%|            flags1 = _combine_flags(flags, add_flags, del_flags)
   450|         0|            0|            0|  0.00%|            if flags1 & SRE_FLAG_IGNORECASE and flags1 & SRE_FLAG_LOCALE:
   451|         0|            0|            0|  0.00%|                break
   452|         0|            0|            0|  0.00%|            prefix1, prefix_skip1, got_all = _get_literal_prefix(p, flags1)
   453|         0|            0|            0|  0.00%|            if prefix_skip is None:
   454|         0|            0|            0|  0.00%|                if group is not None:
   455|         0|            0|            0|  0.00%|                    prefix_skip = len(prefix)
   456|         0|            0|            0|  0.00%|                elif prefix_skip1 is not None:
   457|         0|            0|            0|  0.00%|                    prefix_skip = len(prefix) + prefix_skip1
   458|         0|            0|            0|  0.00%|            prefix.extend(prefix1)
   459|         0|            0|            0|  0.00%|            if not got_all:
   460|         0|            0|            0|  0.00%|                break
   461|         0|            0|            0|  0.00%|        else:
   462|         1|  3.09944e-06|  3.09944e-06|  0.00%|            break
   463|         0|            0|            0|  0.00%|    else:
   464|         0|            0|            0|  0.00%|        return prefix, prefix_skip, True
   465|         1|  2.86102e-06|  2.86102e-06|  0.00%|    return prefix, prefix_skip, False
   466|         0|            0|            0|  0.00%|
   467|         1|  8.82149e-06|  8.82149e-06|  0.01%|def _get_charset_prefix(pattern, flags):
   468|         1|  3.57628e-06|  3.57628e-06|  0.00%|    while True:
   469|         1|  3.57628e-06|  3.57628e-06|  0.00%|        if not pattern.data:
   470|         0|            0|            0|  0.00%|            return None
   471|         1|  3.33786e-06|  3.33786e-06|  0.00%|        op, av = pattern.data[0]
   472|         1|  3.33786e-06|  3.33786e-06|  0.00%|        if op is not SUBPATTERN:
   473|         1|  5.48363e-06|  5.48363e-06|  0.01%|            break
   474|         0|            0|            0|  0.00%|        group, add_flags, del_flags, pattern = av
   475|         0|            0|            0|  0.00%|        flags = _combine_flags(flags, add_flags, del_flags)
   476|         0|            0|            0|  0.00%|        if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:
   477|         0|            0|            0|  0.00%|            return None
   478|         0|            0|            0|  0.00%|
   479|         1|  1.26362e-05|  1.26362e-05|  0.01%|    iscased = _get_iscased(flags)
(call)|         1|   6.4373e-06|   6.4373e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_compiler.py:428 _get_iscased
   480|         1|  3.57628e-06|  3.57628e-06|  0.00%|    if op is LITERAL:
   481|         0|            0|            0|  0.00%|        if iscased and iscased(av):
   482|         0|            0|            0|  0.00%|            return None
   483|         0|            0|            0|  0.00%|        return [(op, av)]
   484|         1|  3.33786e-06|  3.33786e-06|  0.00%|    elif op is BRANCH:
   485|         0|            0|            0|  0.00%|        charset = []
   486|         0|            0|            0|  0.00%|        charsetappend = charset.append
   487|         0|            0|            0|  0.00%|        for p in av[1]:
   488|         0|            0|            0|  0.00%|            if not p:
   489|         0|            0|            0|  0.00%|                return None
   490|         0|            0|            0|  0.00%|            op, av = p[0]
   491|         0|            0|            0|  0.00%|            if op is LITERAL and not (iscased and iscased(av)):
   492|         0|            0|            0|  0.00%|                charsetappend((op, av))
   493|         0|            0|            0|  0.00%|            else:
   494|         0|            0|            0|  0.00%|                return None
   495|         0|            0|            0|  0.00%|        return charset
   496|         1|  3.57628e-06|  3.57628e-06|  0.00%|    elif op is IN:
   497|         0|            0|            0|  0.00%|        charset = av
   498|         0|            0|            0|  0.00%|        if iscased:
   499|         0|            0|            0|  0.00%|            for op, av in charset:
   500|         0|            0|            0|  0.00%|                if op is LITERAL:
   501|         0|            0|            0|  0.00%|                    if iscased(av):
   502|         0|            0|            0|  0.00%|                        return None
   503|         0|            0|            0|  0.00%|                elif op is RANGE:
   504|         0|            0|            0|  0.00%|                    if av[1] > 0xffff:
   505|         0|            0|            0|  0.00%|                        return None
   506|         0|            0|            0|  0.00%|                    if any(map(iscased, range(av[0], av[1]+1))):
   507|         0|            0|            0|  0.00%|                        return None
   508|         0|            0|            0|  0.00%|        return charset
   509|         1|  4.05312e-06|  4.05312e-06|  0.00%|    return None
   510|         0|            0|            0|  0.00%|
   511|         1|  9.53674e-06|  9.53674e-06|  0.01%|def _compile_info(code, pattern, flags):
   512|         0|            0|            0|  0.00%|    # internal: compile an info block.  in the current version,
   513|         0|            0|            0|  0.00%|    # this contains min/max pattern width, and an optional literal
   514|         0|            0|            0|  0.00%|    # prefix or a character map
   515|         1|  2.12193e-05|  2.12193e-05|  0.02%|    lo, hi = pattern.getwidth()
(call)|         1|  0.000323057|  0.000323057|  0.33%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:178 getwidth
   516|         1|  5.24521e-06|  5.24521e-06|  0.01%|    if hi > MAXCODE:
   517|         1|   3.8147e-06|   3.8147e-06|  0.00%|        hi = MAXCODE
   518|         1|   3.8147e-06|   3.8147e-06|  0.00%|    if lo == 0:
   519|         0|            0|            0|  0.00%|        code.extend([INFO, 4, 0, lo, hi])
   520|         0|            0|            0|  0.00%|        return
   521|         0|            0|            0|  0.00%|    # look for a literal prefix
   522|         1|  6.91414e-06|  6.91414e-06|  0.01%|    prefix = []
   523|         1|   3.8147e-06|   3.8147e-06|  0.00%|    prefix_skip = 0
   524|         1|  3.57628e-06|  3.57628e-06|  0.00%|    charset = [] # not used
   525|         1|  3.57628e-06|  3.57628e-06|  0.00%|    if not (flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE):
   526|         0|            0|            0|  0.00%|        # look for literal prefix
   527|         1|  2.26498e-05|  2.26498e-05|  0.02%|        prefix, prefix_skip, got_all = _get_literal_prefix(pattern, flags)
(call)|         1|  5.24521e-05|  5.24521e-05|  0.05%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_compiler.py:436 _get_literal_prefix
   528|         0|            0|            0|  0.00%|        # if no prefix, look for charset prefix
   529|         1|  4.05312e-06|  4.05312e-06|  0.00%|        if not prefix:
   530|         1|  2.38419e-05|  2.38419e-05|  0.02%|            charset = _get_charset_prefix(pattern, flags)
(call)|         1|  6.17504e-05|  6.17504e-05|  0.06%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_compiler.py:467 _get_charset_prefix
   531|         0|            0|            0|  0.00%|##     if prefix:
   532|         0|            0|            0|  0.00%|##         print("*** PREFIX", prefix, prefix_skip)
   533|         0|            0|            0|  0.00%|##     if charset:
   534|         0|            0|            0|  0.00%|##         print("*** CHARSET", charset)
   535|         0|            0|            0|  0.00%|    # add an info block
   536|         1|  3.57628e-06|  3.57628e-06|  0.00%|    emit = code.append
   537|         1|   3.8147e-06|   3.8147e-06|  0.00%|    emit(INFO)
   538|         1|  3.57628e-06|  3.57628e-06|  0.00%|    skip = len(code); emit(0)
   539|         0|            0|            0|  0.00%|    # literal flag
   540|         1|  3.57628e-06|  3.57628e-06|  0.00%|    mask = 0
   541|         1|   3.8147e-06|   3.8147e-06|  0.00%|    if prefix:
   542|         0|            0|            0|  0.00%|        mask = SRE_INFO_PREFIX
   543|         0|            0|            0|  0.00%|        if prefix_skip is None and got_all:
   544|         0|            0|            0|  0.00%|            mask = mask | SRE_INFO_LITERAL
   545|         1|  3.57628e-06|  3.57628e-06|  0.00%|    elif charset:
   546|         0|            0|            0|  0.00%|        mask = mask | SRE_INFO_CHARSET
   547|         1|  3.33786e-06|  3.33786e-06|  0.00%|    emit(mask)
   548|         0|            0|            0|  0.00%|    # pattern length
   549|         1|   3.8147e-06|   3.8147e-06|  0.00%|    if lo < MAXCODE:
   550|         1|  5.24521e-06|  5.24521e-06|  0.01%|        emit(lo)
   551|         0|            0|            0|  0.00%|    else:
   552|         0|            0|            0|  0.00%|        emit(MAXCODE)
   553|         0|            0|            0|  0.00%|        prefix = prefix[:MAXCODE]
   554|         1|  4.05312e-06|  4.05312e-06|  0.00%|    emit(hi)
   555|         0|            0|            0|  0.00%|    # add literal prefix
   556|         1|  3.33786e-06|  3.33786e-06|  0.00%|    if prefix:
   557|         0|            0|            0|  0.00%|        emit(len(prefix)) # length
   558|         0|            0|            0|  0.00%|        if prefix_skip is None:
   559|         0|            0|            0|  0.00%|            prefix_skip =  len(prefix)
   560|         0|            0|            0|  0.00%|        emit(prefix_skip) # skip
   561|         0|            0|            0|  0.00%|        code.extend(prefix)
   562|         0|            0|            0|  0.00%|        # generate overlap table
   563|         0|            0|            0|  0.00%|        code.extend(_generate_overlap_table(prefix))
   564|         1|  4.91142e-05|  4.91142e-05|  0.05%|    elif charset:
   565|         0|            0|            0|  0.00%|        charset, hascased = _optimize_charset(charset)
   566|         0|            0|            0|  0.00%|        assert not hascased
   567|         0|            0|            0|  0.00%|        _compile_charset(charset, flags, code)
   568|         1|  4.05312e-06|  4.05312e-06|  0.00%|    code[skip] = len(code) - skip
   569|         0|            0|            0|  0.00%|
   570|         2|  5.96046e-06|  2.98023e-06|  0.01%|def isstring(obj):
   571|         2|  9.29832e-06|  4.64916e-06|  0.01%|    return isinstance(obj, (str, bytes))
   572|         0|            0|            0|  0.00%|
   573|         1|  8.58307e-06|  8.58307e-06|  0.01%|def _code(p, flags):
   574|         0|            0|            0|  0.00%|
   575|         1|  5.24521e-06|  5.24521e-06|  0.01%|    flags = p.state.flags | flags
   576|         1|  4.52995e-06|  4.52995e-06|  0.00%|    code = []
   577|         0|            0|            0|  0.00%|
   578|         0|            0|            0|  0.00%|    # compile info block
   579|         1|  3.05176e-05|  3.05176e-05|  0.03%|    _compile_info(code, p, flags)
(call)|         1|  0.000644207|  0.000644207|  0.66%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_compiler.py:511 _compile_info
   580|         0|            0|            0|  0.00%|
   581|         0|            0|            0|  0.00%|    # compile the pattern
   582|         1|  6.96182e-05|  6.96182e-05|  0.07%|    _compile(code, p.data, flags)
(call)|         1|   0.00176692|   0.00176692|  1.82%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_compiler.py:37 _compile
   583|         0|            0|            0|  0.00%|
   584|         1|   2.6226e-06|   2.6226e-06|  0.00%|    code.append(SUCCESS)
   585|         0|            0|            0|  0.00%|
   586|         1|  2.14577e-06|  2.14577e-06|  0.00%|    return code
   587|         0|            0|            0|  0.00%|
   588|         0|            0|            0|  0.00%|def _hex_code(code):
   589|         0|            0|            0|  0.00%|    return '[%s]' % ', '.join('%#0*x' % (_sre.CODESIZE*2+2, x) for x in code)
   590|         0|            0|            0|  0.00%|
   591|         0|            0|            0|  0.00%|def dis(code):
   592|         0|            0|            0|  0.00%|    import sys
   593|         0|            0|            0|  0.00%|
   594|         0|            0|            0|  0.00%|    labels = set()
   595|         0|            0|            0|  0.00%|    level = 0
   596|         0|            0|            0|  0.00%|    offset_width = len(str(len(code) - 1))
   597|         0|            0|            0|  0.00%|
   598|         0|            0|            0|  0.00%|    def dis_(start, end):
   599|         0|            0|            0|  0.00%|        def print_(*args, to=None):
   600|         0|            0|            0|  0.00%|            if to is not None:
   601|         0|            0|            0|  0.00%|                labels.add(to)
   602|         0|            0|            0|  0.00%|                args += ('(to %d)' % (to,),)
   603|         0|            0|            0|  0.00%|            print('%*d%s ' % (offset_width, start, ':' if start in labels else '.'),
   604|         0|            0|            0|  0.00%|                  end='  '*(level-1))
   605|         0|            0|            0|  0.00%|            print(*args)
   606|         0|            0|            0|  0.00%|
   607|         0|            0|            0|  0.00%|        def print_2(*args):
   608|         0|            0|            0|  0.00%|            print(end=' '*(offset_width + 2*level))
   609|         0|            0|            0|  0.00%|            print(*args)
   610|         0|            0|            0|  0.00%|
   611|         0|            0|            0|  0.00%|        nonlocal level
   612|         0|            0|            0|  0.00%|        level += 1
   613|         0|            0|            0|  0.00%|        i = start
   614|         0|            0|            0|  0.00%|        while i < end:
   615|         0|            0|            0|  0.00%|            start = i
   616|         0|            0|            0|  0.00%|            op = code[i]
   617|         0|            0|            0|  0.00%|            i += 1
   618|         0|            0|            0|  0.00%|            op = OPCODES[op]
   619|         0|            0|            0|  0.00%|            if op in (SUCCESS, FAILURE, ANY, ANY_ALL,
   620|         0|            0|            0|  0.00%|                      MAX_UNTIL, MIN_UNTIL, NEGATE):
   621|         0|            0|            0|  0.00%|                print_(op)
   622|         0|            0|            0|  0.00%|            elif op in (LITERAL, NOT_LITERAL,
   623|         0|            0|            0|  0.00%|                        LITERAL_IGNORE, NOT_LITERAL_IGNORE,
   624|         0|            0|            0|  0.00%|                        LITERAL_UNI_IGNORE, NOT_LITERAL_UNI_IGNORE,
   625|         0|            0|            0|  0.00%|                        LITERAL_LOC_IGNORE, NOT_LITERAL_LOC_IGNORE):
   626|         0|            0|            0|  0.00%|                arg = code[i]
   627|         0|            0|            0|  0.00%|                i += 1
   628|         0|            0|            0|  0.00%|                print_(op, '%#02x (%r)' % (arg, chr(arg)))
   629|         0|            0|            0|  0.00%|            elif op is AT:
   630|         0|            0|            0|  0.00%|                arg = code[i]
   631|         0|            0|            0|  0.00%|                i += 1
   632|         0|            0|            0|  0.00%|                arg = str(ATCODES[arg])
   633|         0|            0|            0|  0.00%|                assert arg[:3] == 'AT_'
   634|         0|            0|            0|  0.00%|                print_(op, arg[3:])
   635|         0|            0|            0|  0.00%|            elif op is CATEGORY:
   636|         0|            0|            0|  0.00%|                arg = code[i]
   637|         0|            0|            0|  0.00%|                i += 1
   638|         0|            0|            0|  0.00%|                arg = str(CHCODES[arg])
   639|         0|            0|            0|  0.00%|                assert arg[:9] == 'CATEGORY_'
   640|         0|            0|            0|  0.00%|                print_(op, arg[9:])
   641|         0|            0|            0|  0.00%|            elif op in (IN, IN_IGNORE, IN_UNI_IGNORE, IN_LOC_IGNORE):
   642|         0|            0|            0|  0.00%|                skip = code[i]
   643|         0|            0|            0|  0.00%|                print_(op, skip, to=i+skip)
   644|         0|            0|            0|  0.00%|                dis_(i+1, i+skip)
   645|         0|            0|            0|  0.00%|                i += skip
   646|         0|            0|            0|  0.00%|            elif op in (RANGE, RANGE_UNI_IGNORE):
   647|         0|            0|            0|  0.00%|                lo, hi = code[i: i+2]
   648|         0|            0|            0|  0.00%|                i += 2
   649|         0|            0|            0|  0.00%|                print_(op, '%#02x %#02x (%r-%r)' % (lo, hi, chr(lo), chr(hi)))
   650|         0|            0|            0|  0.00%|            elif op is CHARSET:
   651|         0|            0|            0|  0.00%|                print_(op, _hex_code(code[i: i + 256//_CODEBITS]))
   652|         0|            0|            0|  0.00%|                i += 256//_CODEBITS
   653|         0|            0|            0|  0.00%|            elif op is BIGCHARSET:
   654|         0|            0|            0|  0.00%|                arg = code[i]
   655|         0|            0|            0|  0.00%|                i += 1
   656|         0|            0|            0|  0.00%|                mapping = list(b''.join(x.to_bytes(_sre.CODESIZE, sys.byteorder)
   657|         0|            0|            0|  0.00%|                                        for x in code[i: i + 256//_sre.CODESIZE]))
   658|         0|            0|            0|  0.00%|                print_(op, arg, mapping)
   659|         0|            0|            0|  0.00%|                i += 256//_sre.CODESIZE
   660|         0|            0|            0|  0.00%|                level += 1
   661|         0|            0|            0|  0.00%|                for j in range(arg):
   662|         0|            0|            0|  0.00%|                    print_2(_hex_code(code[i: i + 256//_CODEBITS]))
   663|         0|            0|            0|  0.00%|                    i += 256//_CODEBITS
   664|         0|            0|            0|  0.00%|                level -= 1
   665|         0|            0|            0|  0.00%|            elif op in (MARK, GROUPREF, GROUPREF_IGNORE, GROUPREF_UNI_IGNORE,
   666|         0|            0|            0|  0.00%|                        GROUPREF_LOC_IGNORE):
   667|         0|            0|            0|  0.00%|                arg = code[i]
   668|         0|            0|            0|  0.00%|                i += 1
   669|         0|            0|            0|  0.00%|                print_(op, arg)
   670|         0|            0|            0|  0.00%|            elif op is JUMP:
   671|         0|            0|            0|  0.00%|                skip = code[i]
   672|         0|            0|            0|  0.00%|                print_(op, skip, to=i+skip)
   673|         0|            0|            0|  0.00%|                i += 1
   674|         0|            0|            0|  0.00%|            elif op is BRANCH:
   675|         0|            0|            0|  0.00%|                skip = code[i]
   676|         0|            0|            0|  0.00%|                print_(op, skip, to=i+skip)
   677|         0|            0|            0|  0.00%|                while skip:
   678|         0|            0|            0|  0.00%|                    dis_(i+1, i+skip)
   679|         0|            0|            0|  0.00%|                    i += skip
   680|         0|            0|            0|  0.00%|                    start = i
   681|         0|            0|            0|  0.00%|                    skip = code[i]
   682|         0|            0|            0|  0.00%|                    if skip:
   683|         0|            0|            0|  0.00%|                        print_('branch', skip, to=i+skip)
   684|         0|            0|            0|  0.00%|                    else:
   685|         0|            0|            0|  0.00%|                        print_(FAILURE)
   686|         0|            0|            0|  0.00%|                i += 1
   687|         0|            0|            0|  0.00%|            elif op in (REPEAT, REPEAT_ONE, MIN_REPEAT_ONE,
   688|         0|            0|            0|  0.00%|                        POSSESSIVE_REPEAT, POSSESSIVE_REPEAT_ONE):
   689|         0|            0|            0|  0.00%|                skip, min, max = code[i: i+3]
   690|         0|            0|            0|  0.00%|                if max == MAXREPEAT:
   691|         0|            0|            0|  0.00%|                    max = 'MAXREPEAT'
   692|         0|            0|            0|  0.00%|                print_(op, skip, min, max, to=i+skip)
   693|         0|            0|            0|  0.00%|                dis_(i+3, i+skip)
   694|         0|            0|            0|  0.00%|                i += skip
   695|         0|            0|            0|  0.00%|            elif op is GROUPREF_EXISTS:
   696|         0|            0|            0|  0.00%|                arg, skip = code[i: i+2]
   697|         0|            0|            0|  0.00%|                print_(op, arg, skip, to=i+skip)
   698|         0|            0|            0|  0.00%|                i += 2
   699|         0|            0|            0|  0.00%|            elif op in (ASSERT, ASSERT_NOT):
   700|         0|            0|            0|  0.00%|                skip, arg = code[i: i+2]
   701|         0|            0|            0|  0.00%|                print_(op, skip, arg, to=i+skip)
   702|         0|            0|            0|  0.00%|                dis_(i+2, i+skip)
   703|         0|            0|            0|  0.00%|                i += skip
   704|         0|            0|            0|  0.00%|            elif op is ATOMIC_GROUP:
   705|         0|            0|            0|  0.00%|                skip = code[i]
   706|         0|            0|            0|  0.00%|                print_(op, skip, to=i+skip)
   707|         0|            0|            0|  0.00%|                dis_(i+1, i+skip)
   708|         0|            0|            0|  0.00%|                i += skip
   709|         0|            0|            0|  0.00%|            elif op is INFO:
   710|         0|            0|            0|  0.00%|                skip, flags, min, max = code[i: i+4]
   711|         0|            0|            0|  0.00%|                if max == MAXREPEAT:
   712|         0|            0|            0|  0.00%|                    max = 'MAXREPEAT'
   713|         0|            0|            0|  0.00%|                print_(op, skip, bin(flags), min, max, to=i+skip)
   714|         0|            0|            0|  0.00%|                start = i+4
   715|         0|            0|            0|  0.00%|                if flags & SRE_INFO_PREFIX:
   716|         0|            0|            0|  0.00%|                    prefix_len, prefix_skip = code[i+4: i+6]
   717|         0|            0|            0|  0.00%|                    print_2('  prefix_skip', prefix_skip)
   718|         0|            0|            0|  0.00%|                    start = i + 6
   719|         0|            0|            0|  0.00%|                    prefix = code[start: start+prefix_len]
   720|         0|            0|            0|  0.00%|                    print_2('  prefix',
   721|         0|            0|            0|  0.00%|                            '[%s]' % ', '.join('%#02x' % x for x in prefix),
   722|         0|            0|            0|  0.00%|                            '(%r)' % ''.join(map(chr, prefix)))
   723|         0|            0|            0|  0.00%|                    start += prefix_len
   724|         0|            0|            0|  0.00%|                    print_2('  overlap', code[start: start+prefix_len])
   725|         0|            0|            0|  0.00%|                    start += prefix_len
   726|         0|            0|            0|  0.00%|                if flags & SRE_INFO_CHARSET:
   727|         0|            0|            0|  0.00%|                    level += 1
   728|         0|            0|            0|  0.00%|                    print_2('in')
   729|         0|            0|            0|  0.00%|                    dis_(start, i+skip)
   730|         0|            0|            0|  0.00%|                    level -= 1
   731|         0|            0|            0|  0.00%|                i += skip
   732|         0|            0|            0|  0.00%|            else:
   733|         0|            0|            0|  0.00%|                raise ValueError(op)
   734|         0|            0|            0|  0.00%|
   735|         0|            0|            0|  0.00%|        level -= 1
   736|         0|            0|            0|  0.00%|
   737|         0|            0|            0|  0.00%|    dis_(0, len(code))
   738|         0|            0|            0|  0.00%|
   739|         0|            0|            0|  0.00%|
   740|         1|  4.76837e-06|  4.76837e-06|  0.00%|def compile(p, flags=0):
   741|         0|            0|            0|  0.00%|    # internal: convert pattern list to internal format
   742|         0|            0|            0|  0.00%|
   743|         1|  9.05991e-06|  9.05991e-06|  0.01%|    if isstring(p):
(call)|         1|   3.8147e-06|   3.8147e-06|  0.00%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_compiler.py:570 isstring
   744|         1|  2.38419e-06|  2.38419e-06|  0.00%|        pattern = p
   745|         1|  2.43187e-05|  2.43187e-05|  0.02%|        p = _parser.parse(p, flags)
(call)|         1|    0.0721841|    0.0721841| 74.21%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:969 parse
   746|         0|            0|            0|  0.00%|    else:
   747|         0|            0|            0|  0.00%|        pattern = None
   748|         0|            0|            0|  0.00%|
   749|         1|  2.12193e-05|  2.12193e-05|  0.02%|    code = _code(p, flags)
(call)|         1|   0.00253439|   0.00253439|  2.61%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_compiler.py:573 _code
   750|         0|            0|            0|  0.00%|
   751|         1|  2.86102e-06|  2.86102e-06|  0.00%|    if flags & SRE_FLAG_DEBUG:
   752|         0|            0|            0|  0.00%|        print()
   753|         0|            0|            0|  0.00%|        dis(code)
   754|         0|            0|            0|  0.00%|
   755|         0|            0|            0|  0.00%|    # map in either direction
   756|         1|   2.6226e-06|   2.6226e-06|  0.00%|    groupindex = p.state.groupdict
   757|         1|  7.86781e-06|  7.86781e-06|  0.01%|    indexgroup = [None] * p.state.groups
(call)|         1|  5.00679e-06|  5.00679e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:83 groups
   758|         2|  5.72205e-06|  2.86102e-06|  0.01%|    for k, i in groupindex.items():
   759|         1|  2.86102e-06|  2.86102e-06|  0.00%|        indexgroup[i] = k
   760|         0|            0|            0|  0.00%|
   761|         2|  6.19888e-06|  3.09944e-06|  0.01%|    return _sre.compile(
   762|         1|  2.14577e-06|  2.14577e-06|  0.00%|        pattern, flags | p.state.flags, code,
   763|         1|  7.15256e-06|  7.15256e-06|  0.01%|        p.state.groups-1,
(call)|         1|   2.6226e-06|   2.6226e-06|  0.00%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_parser.py:83 groups
   764|         1|   2.6226e-06|   2.6226e-06|  0.00%|        groupindex, tuple(indexgroup)
   765|         0|            0|            0|  0.00%|        )
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py
File duration: 0.00202346s (2.08%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Get useful information from live Python objects.
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|This module encapsulates the interface provided by the internal special
     4|         0|            0|            0|  0.00%|attributes (co_*, im_*, tb_*, etc.) in a friendlier fashion.
     5|         0|            0|            0|  0.00%|It also provides some help for examining source code and class layout.
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|Here are some of the useful functions provided by this module:
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|    ismodule(), isclass(), ismethod(), isfunction(), isgeneratorfunction(),
    10|         0|            0|            0|  0.00%|        isgenerator(), istraceback(), isframe(), iscode(), isbuiltin(),
    11|         0|            0|            0|  0.00%|        isroutine() - check object types
    12|         0|            0|            0|  0.00%|    getmembers() - get members of an object that satisfy a given condition
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|    getfile(), getsourcefile(), getsource() - find an object's source code
    15|         0|            0|            0|  0.00%|    getdoc(), getcomments() - get documentation on an object
    16|         0|            0|            0|  0.00%|    getmodule() - determine the module that an object came from
    17|         0|            0|            0|  0.00%|    getclasstree() - arrange classes so as to represent their hierarchy
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|    getargvalues(), getcallargs() - get info about function arguments
    20|         0|            0|            0|  0.00%|    getfullargspec() - same, with support for Python 3 features
    21|         0|            0|            0|  0.00%|    formatargvalues() - format an argument spec
    22|         0|            0|            0|  0.00%|    getouterframes(), getinnerframes() - get info about frames
    23|         0|            0|            0|  0.00%|    currentframe() - get the current stack frame
    24|         0|            0|            0|  0.00%|    stack(), trace() - get info about frames on the stack or in a traceback
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|    signature() - get a Signature object for the callable
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|    get_annotations() - safely compute an object's annotations
    29|         0|            0|            0|  0.00%|"""
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|# This module is in the public domain.  No warranties.
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|__author__ = ('Ka-Ping Yee <ping@lfw.org>',
    34|         0|            0|            0|  0.00%|              'Yury Selivanov <yselivanov@sprymix.com>')
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|__all__ = [
    37|         0|            0|            0|  0.00%|    "AGEN_CLOSED",
    38|         0|            0|            0|  0.00%|    "AGEN_CREATED",
    39|         0|            0|            0|  0.00%|    "AGEN_RUNNING",
    40|         0|            0|            0|  0.00%|    "AGEN_SUSPENDED",
    41|         0|            0|            0|  0.00%|    "ArgInfo",
    42|         0|            0|            0|  0.00%|    "Arguments",
    43|         0|            0|            0|  0.00%|    "Attribute",
    44|         0|            0|            0|  0.00%|    "BlockFinder",
    45|         0|            0|            0|  0.00%|    "BoundArguments",
    46|         0|            0|            0|  0.00%|    "BufferFlags",
    47|         0|            0|            0|  0.00%|    "CORO_CLOSED",
    48|         0|            0|            0|  0.00%|    "CORO_CREATED",
    49|         0|            0|            0|  0.00%|    "CORO_RUNNING",
    50|         0|            0|            0|  0.00%|    "CORO_SUSPENDED",
    51|         0|            0|            0|  0.00%|    "CO_ASYNC_GENERATOR",
    52|         0|            0|            0|  0.00%|    "CO_COROUTINE",
    53|         0|            0|            0|  0.00%|    "CO_GENERATOR",
    54|         0|            0|            0|  0.00%|    "CO_ITERABLE_COROUTINE",
    55|         0|            0|            0|  0.00%|    "CO_NESTED",
    56|         0|            0|            0|  0.00%|    "CO_NEWLOCALS",
    57|         0|            0|            0|  0.00%|    "CO_NOFREE",
    58|         0|            0|            0|  0.00%|    "CO_OPTIMIZED",
    59|         0|            0|            0|  0.00%|    "CO_VARARGS",
    60|         0|            0|            0|  0.00%|    "CO_VARKEYWORDS",
    61|         0|            0|            0|  0.00%|    "ClassFoundException",
    62|         0|            0|            0|  0.00%|    "ClosureVars",
    63|         0|            0|            0|  0.00%|    "EndOfBlock",
    64|         0|            0|            0|  0.00%|    "FrameInfo",
    65|         0|            0|            0|  0.00%|    "FullArgSpec",
    66|         0|            0|            0|  0.00%|    "GEN_CLOSED",
    67|         0|            0|            0|  0.00%|    "GEN_CREATED",
    68|         0|            0|            0|  0.00%|    "GEN_RUNNING",
    69|         0|            0|            0|  0.00%|    "GEN_SUSPENDED",
    70|         0|            0|            0|  0.00%|    "Parameter",
    71|         0|            0|            0|  0.00%|    "Signature",
    72|         0|            0|            0|  0.00%|    "TPFLAGS_IS_ABSTRACT",
    73|         0|            0|            0|  0.00%|    "Traceback",
    74|         0|            0|            0|  0.00%|    "classify_class_attrs",
    75|         0|            0|            0|  0.00%|    "cleandoc",
    76|         0|            0|            0|  0.00%|    "currentframe",
    77|         0|            0|            0|  0.00%|    "findsource",
    78|         0|            0|            0|  0.00%|    "formatannotation",
    79|         0|            0|            0|  0.00%|    "formatannotationrelativeto",
    80|         0|            0|            0|  0.00%|    "formatargvalues",
    81|         0|            0|            0|  0.00%|    "get_annotations",
    82|         0|            0|            0|  0.00%|    "getabsfile",
    83|         0|            0|            0|  0.00%|    "getargs",
    84|         0|            0|            0|  0.00%|    "getargvalues",
    85|         0|            0|            0|  0.00%|    "getasyncgenlocals",
    86|         0|            0|            0|  0.00%|    "getasyncgenstate",
    87|         0|            0|            0|  0.00%|    "getattr_static",
    88|         0|            0|            0|  0.00%|    "getblock",
    89|         0|            0|            0|  0.00%|    "getcallargs",
    90|         0|            0|            0|  0.00%|    "getclasstree",
    91|         0|            0|            0|  0.00%|    "getclosurevars",
    92|         0|            0|            0|  0.00%|    "getcomments",
    93|         0|            0|            0|  0.00%|    "getcoroutinelocals",
    94|         0|            0|            0|  0.00%|    "getcoroutinestate",
    95|         0|            0|            0|  0.00%|    "getdoc",
    96|         0|            0|            0|  0.00%|    "getfile",
    97|         0|            0|            0|  0.00%|    "getframeinfo",
    98|         0|            0|            0|  0.00%|    "getfullargspec",
    99|         0|            0|            0|  0.00%|    "getgeneratorlocals",
   100|         0|            0|            0|  0.00%|    "getgeneratorstate",
   101|         0|            0|            0|  0.00%|    "getinnerframes",
   102|         0|            0|            0|  0.00%|    "getlineno",
   103|         0|            0|            0|  0.00%|    "getmembers",
   104|         0|            0|            0|  0.00%|    "getmembers_static",
   105|         0|            0|            0|  0.00%|    "getmodule",
   106|         0|            0|            0|  0.00%|    "getmodulename",
   107|         0|            0|            0|  0.00%|    "getmro",
   108|         0|            0|            0|  0.00%|    "getouterframes",
   109|         0|            0|            0|  0.00%|    "getsource",
   110|         0|            0|            0|  0.00%|    "getsourcefile",
   111|         0|            0|            0|  0.00%|    "getsourcelines",
   112|         0|            0|            0|  0.00%|    "indentsize",
   113|         0|            0|            0|  0.00%|    "isabstract",
   114|         0|            0|            0|  0.00%|    "isasyncgen",
   115|         0|            0|            0|  0.00%|    "isasyncgenfunction",
   116|         0|            0|            0|  0.00%|    "isawaitable",
   117|         0|            0|            0|  0.00%|    "isbuiltin",
   118|         0|            0|            0|  0.00%|    "isclass",
   119|         0|            0|            0|  0.00%|    "iscode",
   120|         0|            0|            0|  0.00%|    "iscoroutine",
   121|         0|            0|            0|  0.00%|    "iscoroutinefunction",
   122|         0|            0|            0|  0.00%|    "isdatadescriptor",
   123|         0|            0|            0|  0.00%|    "isframe",
   124|         0|            0|            0|  0.00%|    "isfunction",
   125|         0|            0|            0|  0.00%|    "isgenerator",
   126|         0|            0|            0|  0.00%|    "isgeneratorfunction",
   127|         0|            0|            0|  0.00%|    "isgetsetdescriptor",
   128|         0|            0|            0|  0.00%|    "ismemberdescriptor",
   129|         0|            0|            0|  0.00%|    "ismethod",
   130|         0|            0|            0|  0.00%|    "ismethoddescriptor",
   131|         0|            0|            0|  0.00%|    "ismethodwrapper",
   132|         0|            0|            0|  0.00%|    "ismodule",
   133|         0|            0|            0|  0.00%|    "isroutine",
   134|         0|            0|            0|  0.00%|    "istraceback",
   135|         0|            0|            0|  0.00%|    "markcoroutinefunction",
   136|         0|            0|            0|  0.00%|    "signature",
   137|         0|            0|            0|  0.00%|    "stack",
   138|         0|            0|            0|  0.00%|    "trace",
   139|         0|            0|            0|  0.00%|    "unwrap",
   140|         0|            0|            0|  0.00%|    "walktree",
   141|         0|            0|            0|  0.00%|]
   142|         0|            0|            0|  0.00%|
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|import abc
   145|         0|            0|            0|  0.00%|import ast
   146|         0|            0|            0|  0.00%|import dis
   147|         0|            0|            0|  0.00%|import collections.abc
   148|         0|            0|            0|  0.00%|import enum
   149|         0|            0|            0|  0.00%|import importlib.machinery
   150|         0|            0|            0|  0.00%|import itertools
   151|         0|            0|            0|  0.00%|import linecache
   152|         0|            0|            0|  0.00%|import os
   153|         0|            0|            0|  0.00%|import re
   154|         0|            0|            0|  0.00%|import sys
   155|         0|            0|            0|  0.00%|import tokenize
   156|         0|            0|            0|  0.00%|import token
   157|         0|            0|            0|  0.00%|import types
   158|         0|            0|            0|  0.00%|import functools
   159|         0|            0|            0|  0.00%|import builtins
   160|         0|            0|            0|  0.00%|from keyword import iskeyword
   161|         0|            0|            0|  0.00%|from operator import attrgetter
   162|         0|            0|            0|  0.00%|from collections import namedtuple, OrderedDict
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|# Create constants for the compiler flags in Include/code.h
   165|         0|            0|            0|  0.00%|# We try to get them from dis to avoid duplication
   166|         0|            0|            0|  0.00%|mod_dict = globals()
   167|         0|            0|            0|  0.00%|for k, v in dis.COMPILER_FLAG_NAMES.items():
   168|         0|            0|            0|  0.00%|    mod_dict["CO_" + v] = k
   169|         0|            0|            0|  0.00%|del k, v, mod_dict
   170|         0|            0|            0|  0.00%|
   171|         0|            0|            0|  0.00%|# See Include/object.h
   172|         0|            0|            0|  0.00%|TPFLAGS_IS_ABSTRACT = 1 << 20
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|
   175|         1|  1.04904e-05|  1.04904e-05|  0.01%|def get_annotations(obj, *, globals=None, locals=None, eval_str=False):
   176|         0|            0|            0|  0.00%|    """Compute the annotations dict for an object.
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|    obj may be a callable, class, or module.
   179|         0|            0|            0|  0.00%|    Passing in an object of any other type raises TypeError.
   180|         0|            0|            0|  0.00%|
   181|         0|            0|            0|  0.00%|    Returns a dict.  get_annotations() returns a new dict every time
   182|         0|            0|            0|  0.00%|    it's called; calling it twice on the same object will return two
   183|         0|            0|            0|  0.00%|    different but equivalent dicts.
   184|         0|            0|            0|  0.00%|
   185|         0|            0|            0|  0.00%|    This function handles several details for you:
   186|         0|            0|            0|  0.00%|
   187|         0|            0|            0|  0.00%|      * If eval_str is true, values of type str will
   188|         0|            0|            0|  0.00%|        be un-stringized using eval().  This is intended
   189|         0|            0|            0|  0.00%|        for use with stringized annotations
   190|         0|            0|            0|  0.00%|        ("from __future__ import annotations").
   191|         0|            0|            0|  0.00%|      * If obj doesn't have an annotations dict, returns an
   192|         0|            0|            0|  0.00%|        empty dict.  (Functions and methods always have an
   193|         0|            0|            0|  0.00%|        annotations dict; classes, modules, and other types of
   194|         0|            0|            0|  0.00%|        callables may not.)
   195|         0|            0|            0|  0.00%|      * Ignores inherited annotations on classes.  If a class
   196|         0|            0|            0|  0.00%|        doesn't have its own annotations dict, returns an empty dict.
   197|         0|            0|            0|  0.00%|      * All accesses to object members and dict values are done
   198|         0|            0|            0|  0.00%|        using getattr() and dict.get() for safety.
   199|         0|            0|            0|  0.00%|      * Always, always, always returns a freshly-created dict.
   200|         0|            0|            0|  0.00%|
   201|         0|            0|            0|  0.00%|    eval_str controls whether or not values of type str are replaced
   202|         0|            0|            0|  0.00%|    with the result of calling eval() on those values:
   203|         0|            0|            0|  0.00%|
   204|         0|            0|            0|  0.00%|      * If eval_str is true, eval() is called on values of type str.
   205|         0|            0|            0|  0.00%|      * If eval_str is false (the default), values of type str are unchanged.
   206|         0|            0|            0|  0.00%|
   207|         0|            0|            0|  0.00%|    globals and locals are passed in to eval(); see the documentation
   208|         0|            0|            0|  0.00%|    for eval() for more information.  If either globals or locals is
   209|         0|            0|            0|  0.00%|    None, this function may replace that value with a context-specific
   210|         0|            0|            0|  0.00%|    default, contingent on type(obj):
   211|         0|            0|            0|  0.00%|
   212|         0|            0|            0|  0.00%|      * If obj is a module, globals defaults to obj.__dict__.
   213|         0|            0|            0|  0.00%|      * If obj is a class, globals defaults to
   214|         0|            0|            0|  0.00%|        sys.modules[obj.__module__].__dict__ and locals
   215|         0|            0|            0|  0.00%|        defaults to the obj class namespace.
   216|         0|            0|            0|  0.00%|      * If obj is a callable, globals defaults to obj.__globals__,
   217|         0|            0|            0|  0.00%|        although if obj is a wrapped function (using
   218|         0|            0|            0|  0.00%|        functools.update_wrapper()) it is first unwrapped.
   219|         0|            0|            0|  0.00%|    """
   220|         1|  5.00679e-06|  5.00679e-06|  0.01%|    if isinstance(obj, type):
   221|         0|            0|            0|  0.00%|        # class
   222|         0|            0|            0|  0.00%|        obj_dict = getattr(obj, '__dict__', None)
   223|         0|            0|            0|  0.00%|        if obj_dict and hasattr(obj_dict, 'get'):
   224|         0|            0|            0|  0.00%|            ann = obj_dict.get('__annotations__', None)
   225|         0|            0|            0|  0.00%|            if isinstance(ann, types.GetSetDescriptorType):
   226|         0|            0|            0|  0.00%|                ann = None
   227|         0|            0|            0|  0.00%|        else:
   228|         0|            0|            0|  0.00%|            ann = None
   229|         0|            0|            0|  0.00%|
   230|         0|            0|            0|  0.00%|        obj_globals = None
   231|         0|            0|            0|  0.00%|        module_name = getattr(obj, '__module__', None)
   232|         0|            0|            0|  0.00%|        if module_name:
   233|         0|            0|            0|  0.00%|            module = sys.modules.get(module_name, None)
   234|         0|            0|            0|  0.00%|            if module:
   235|         0|            0|            0|  0.00%|                obj_globals = getattr(module, '__dict__', None)
   236|         0|            0|            0|  0.00%|        obj_locals = dict(vars(obj))
   237|         0|            0|            0|  0.00%|        unwrap = obj
   238|         1|  4.29153e-06|  4.29153e-06|  0.00%|    elif isinstance(obj, types.ModuleType):
   239|         0|            0|            0|  0.00%|        # module
   240|         0|            0|            0|  0.00%|        ann = getattr(obj, '__annotations__', None)
   241|         0|            0|            0|  0.00%|        obj_globals = getattr(obj, '__dict__')
   242|         0|            0|            0|  0.00%|        obj_locals = None
   243|         0|            0|            0|  0.00%|        unwrap = None
   244|         1|  4.52995e-06|  4.52995e-06|  0.00%|    elif callable(obj):
   245|         0|            0|            0|  0.00%|        # this includes types.Function, types.BuiltinFunctionType,
   246|         0|            0|            0|  0.00%|        # types.BuiltinMethodType, functools.partial, functools.singledispatch,
   247|         0|            0|            0|  0.00%|        # "class funclike" from Lib/test/test_inspect... on and on it goes.
   248|         1|  8.10623e-06|  8.10623e-06|  0.01%|        ann = getattr(obj, '__annotations__', None)
   249|         1|  5.48363e-06|  5.48363e-06|  0.01%|        obj_globals = getattr(obj, '__globals__', None)
   250|         1|   3.8147e-06|   3.8147e-06|  0.00%|        obj_locals = None
   251|         1|  5.48363e-06|  5.48363e-06|  0.01%|        unwrap = obj
   252|         0|            0|            0|  0.00%|    else:
   253|         0|            0|            0|  0.00%|        raise TypeError(f"{obj!r} is not a module, class, or callable.")
   254|         0|            0|            0|  0.00%|
   255|         1|  4.52995e-06|  4.52995e-06|  0.00%|    if ann is None:
   256|         0|            0|            0|  0.00%|        return {}
   257|         0|            0|            0|  0.00%|
   258|         1|  4.29153e-06|  4.29153e-06|  0.00%|    if not isinstance(ann, dict):
   259|         0|            0|            0|  0.00%|        raise ValueError(f"{obj!r}.__annotations__ is neither a dict nor None")
   260|         0|            0|            0|  0.00%|
   261|         1|  4.05312e-06|  4.05312e-06|  0.00%|    if not ann:
   262|         0|            0|            0|  0.00%|        return {}
   263|         0|            0|            0|  0.00%|
   264|         1|  4.52995e-06|  4.52995e-06|  0.00%|    if not eval_str:
   265|         1|   6.4373e-06|   6.4373e-06|  0.01%|        return dict(ann)
   266|         0|            0|            0|  0.00%|
   267|         0|            0|            0|  0.00%|    if unwrap is not None:
   268|         0|            0|            0|  0.00%|        while True:
   269|         0|            0|            0|  0.00%|            if hasattr(unwrap, '__wrapped__'):
   270|         0|            0|            0|  0.00%|                unwrap = unwrap.__wrapped__
   271|         0|            0|            0|  0.00%|                continue
   272|         0|            0|            0|  0.00%|            if isinstance(unwrap, functools.partial):
   273|         0|            0|            0|  0.00%|                unwrap = unwrap.func
   274|         0|            0|            0|  0.00%|                continue
   275|         0|            0|            0|  0.00%|            break
   276|         0|            0|            0|  0.00%|        if hasattr(unwrap, "__globals__"):
   277|         0|            0|            0|  0.00%|            obj_globals = unwrap.__globals__
   278|         0|            0|            0|  0.00%|
   279|         0|            0|            0|  0.00%|    if globals is None:
   280|         0|            0|            0|  0.00%|        globals = obj_globals
   281|         0|            0|            0|  0.00%|    if locals is None:
   282|         0|            0|            0|  0.00%|        locals = obj_locals
   283|         0|            0|            0|  0.00%|
   284|         0|            0|            0|  0.00%|    return_value = {key:
   285|         0|            0|            0|  0.00%|        value if not isinstance(value, str) else eval(value, globals, locals)
   286|         0|            0|            0|  0.00%|        for key, value in ann.items() }
   287|         0|            0|            0|  0.00%|    return return_value
   288|         0|            0|            0|  0.00%|
   289|         0|            0|            0|  0.00%|
   290|         0|            0|            0|  0.00%|# ----------------------------------------------------------- type-checking
   291|         0|            0|            0|  0.00%|def ismodule(object):
   292|         0|            0|            0|  0.00%|    """Return true if the object is a module."""
   293|         0|            0|            0|  0.00%|    return isinstance(object, types.ModuleType)
   294|         0|            0|            0|  0.00%|
   295|         0|            0|            0|  0.00%|def isclass(object):
   296|         0|            0|            0|  0.00%|    """Return true if the object is a class."""
   297|         0|            0|            0|  0.00%|    return isinstance(object, type)
   298|         0|            0|            0|  0.00%|
   299|         0|            0|            0|  0.00%|def ismethod(object):
   300|         0|            0|            0|  0.00%|    """Return true if the object is an instance method."""
   301|         0|            0|            0|  0.00%|    return isinstance(object, types.MethodType)
   302|         0|            0|            0|  0.00%|
   303|         0|            0|            0|  0.00%|def ismethoddescriptor(object):
   304|         0|            0|            0|  0.00%|    """Return true if the object is a method descriptor.
   305|         0|            0|            0|  0.00%|
   306|         0|            0|            0|  0.00%|    But not if ismethod() or isclass() or isfunction() are true.
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|    This is new in Python 2.2, and, for example, is true of int.__add__.
   309|         0|            0|            0|  0.00%|    An object passing this test has a __get__ attribute but not a __set__
   310|         0|            0|            0|  0.00%|    attribute, but beyond that the set of attributes varies.  __name__ is
   311|         0|            0|            0|  0.00%|    usually sensible, and __doc__ often is.
   312|         0|            0|            0|  0.00%|
   313|         0|            0|            0|  0.00%|    Methods implemented via descriptors that also pass one of the other
   314|         0|            0|            0|  0.00%|    tests return false from the ismethoddescriptor() test, simply because
   315|         0|            0|            0|  0.00%|    the other tests promise more -- you can, e.g., count on having the
   316|         0|            0|            0|  0.00%|    __func__ attribute (etc) when an object passes ismethod()."""
   317|         0|            0|            0|  0.00%|    if isclass(object) or ismethod(object) or isfunction(object):
   318|         0|            0|            0|  0.00%|        # mutual exclusion
   319|         0|            0|            0|  0.00%|        return False
   320|         0|            0|            0|  0.00%|    tp = type(object)
   321|         0|            0|            0|  0.00%|    return hasattr(tp, "__get__") and not hasattr(tp, "__set__")
   322|         0|            0|            0|  0.00%|
   323|         0|            0|            0|  0.00%|def isdatadescriptor(object):
   324|         0|            0|            0|  0.00%|    """Return true if the object is a data descriptor.
   325|         0|            0|            0|  0.00%|
   326|         0|            0|            0|  0.00%|    Data descriptors have a __set__ or a __delete__ attribute.  Examples are
   327|         0|            0|            0|  0.00%|    properties (defined in Python) and getsets and members (defined in C).
   328|         0|            0|            0|  0.00%|    Typically, data descriptors will also have __name__ and __doc__ attributes
   329|         0|            0|            0|  0.00%|    (properties, getsets, and members have both of these attributes), but this
   330|         0|            0|            0|  0.00%|    is not guaranteed."""
   331|         0|            0|            0|  0.00%|    if isclass(object) or ismethod(object) or isfunction(object):
   332|         0|            0|            0|  0.00%|        # mutual exclusion
   333|         0|            0|            0|  0.00%|        return False
   334|         0|            0|            0|  0.00%|    tp = type(object)
   335|         0|            0|            0|  0.00%|    return hasattr(tp, "__set__") or hasattr(tp, "__delete__")
   336|         0|            0|            0|  0.00%|
   337|         0|            0|            0|  0.00%|if hasattr(types, 'MemberDescriptorType'):
   338|         0|            0|            0|  0.00%|    # CPython and equivalent
   339|         0|            0|            0|  0.00%|    def ismemberdescriptor(object):
   340|         0|            0|            0|  0.00%|        """Return true if the object is a member descriptor.
   341|         0|            0|            0|  0.00%|
   342|         0|            0|            0|  0.00%|        Member descriptors are specialized descriptors defined in extension
   343|         0|            0|            0|  0.00%|        modules."""
   344|         0|            0|            0|  0.00%|        return isinstance(object, types.MemberDescriptorType)
   345|         0|            0|            0|  0.00%|else:
   346|         0|            0|            0|  0.00%|    # Other implementations
   347|         0|            0|            0|  0.00%|    def ismemberdescriptor(object):
   348|         0|            0|            0|  0.00%|        """Return true if the object is a member descriptor.
   349|         0|            0|            0|  0.00%|
   350|         0|            0|            0|  0.00%|        Member descriptors are specialized descriptors defined in extension
   351|         0|            0|            0|  0.00%|        modules."""
   352|         0|            0|            0|  0.00%|        return False
   353|         0|            0|            0|  0.00%|
   354|         0|            0|            0|  0.00%|if hasattr(types, 'GetSetDescriptorType'):
   355|         0|            0|            0|  0.00%|    # CPython and equivalent
   356|         0|            0|            0|  0.00%|    def isgetsetdescriptor(object):
   357|         0|            0|            0|  0.00%|        """Return true if the object is a getset descriptor.
   358|         0|            0|            0|  0.00%|
   359|         0|            0|            0|  0.00%|        getset descriptors are specialized descriptors defined in extension
   360|         0|            0|            0|  0.00%|        modules."""
   361|         0|            0|            0|  0.00%|        return isinstance(object, types.GetSetDescriptorType)
   362|         0|            0|            0|  0.00%|else:
   363|         0|            0|            0|  0.00%|    # Other implementations
   364|         0|            0|            0|  0.00%|    def isgetsetdescriptor(object):
   365|         0|            0|            0|  0.00%|        """Return true if the object is a getset descriptor.
   366|         0|            0|            0|  0.00%|
   367|         0|            0|            0|  0.00%|        getset descriptors are specialized descriptors defined in extension
   368|         0|            0|            0|  0.00%|        modules."""
   369|         0|            0|            0|  0.00%|        return False
   370|         0|            0|            0|  0.00%|
   371|         2|  2.21729e-05|  1.10865e-05|  0.02%|def isfunction(object):
   372|         0|            0|            0|  0.00%|    """Return true if the object is a user-defined function.
   373|         0|            0|            0|  0.00%|
   374|         0|            0|            0|  0.00%|    Function objects provide these attributes:
   375|         0|            0|            0|  0.00%|        __doc__         documentation string
   376|         0|            0|            0|  0.00%|        __name__        name with which this function was defined
   377|         0|            0|            0|  0.00%|        __code__        code object containing compiled function bytecode
   378|         0|            0|            0|  0.00%|        __defaults__    tuple of any default values for arguments
   379|         0|            0|            0|  0.00%|        __globals__     global namespace in which this function was defined
   380|         0|            0|            0|  0.00%|        __annotations__ dict of parameter annotations
   381|         0|            0|            0|  0.00%|        __kwdefaults__  dict of keyword only parameters with defaults"""
   382|         2|  4.29153e-06|  2.14577e-06|  0.00%|    return isinstance(object, types.FunctionType)
   383|         0|            0|            0|  0.00%|
   384|         0|            0|            0|  0.00%|def _has_code_flag(f, flag):
   385|         0|            0|            0|  0.00%|    """Return true if ``f`` is a function (or a method or functools.partial
   386|         0|            0|            0|  0.00%|    wrapper wrapping a function) whose code object has the given ``flag``
   387|         0|            0|            0|  0.00%|    set in its flags."""
   388|         0|            0|            0|  0.00%|    while ismethod(f):
   389|         0|            0|            0|  0.00%|        f = f.__func__
   390|         0|            0|            0|  0.00%|    f = functools._unwrap_partial(f)
   391|         0|            0|            0|  0.00%|    if not (isfunction(f) or _signature_is_functionlike(f)):
   392|         0|            0|            0|  0.00%|        return False
   393|         0|            0|            0|  0.00%|    return bool(f.__code__.co_flags & flag)
   394|         0|            0|            0|  0.00%|
   395|         0|            0|            0|  0.00%|def isgeneratorfunction(obj):
   396|         0|            0|            0|  0.00%|    """Return true if the object is a user-defined generator function.
   397|         0|            0|            0|  0.00%|
   398|         0|            0|            0|  0.00%|    Generator function objects provide the same attributes as functions.
   399|         0|            0|            0|  0.00%|    See help(isfunction) for a list of attributes."""
   400|         0|            0|            0|  0.00%|    return _has_code_flag(obj, CO_GENERATOR)
   401|         0|            0|            0|  0.00%|
   402|         0|            0|            0|  0.00%|# A marker for markcoroutinefunction and iscoroutinefunction.
   403|         0|            0|            0|  0.00%|_is_coroutine_marker = object()
   404|         0|            0|            0|  0.00%|
   405|         0|            0|            0|  0.00%|def _has_coroutine_mark(f):
   406|         0|            0|            0|  0.00%|    while ismethod(f):
   407|         0|            0|            0|  0.00%|        f = f.__func__
   408|         0|            0|            0|  0.00%|    f = functools._unwrap_partial(f)
   409|         0|            0|            0|  0.00%|    return getattr(f, "_is_coroutine_marker", None) is _is_coroutine_marker
   410|         0|            0|            0|  0.00%|
   411|         0|            0|            0|  0.00%|def markcoroutinefunction(func):
   412|         0|            0|            0|  0.00%|    """
   413|         0|            0|            0|  0.00%|    Decorator to ensure callable is recognised as a coroutine function.
   414|         0|            0|            0|  0.00%|    """
   415|         0|            0|            0|  0.00%|    if hasattr(func, '__func__'):
   416|         0|            0|            0|  0.00%|        func = func.__func__
   417|         0|            0|            0|  0.00%|    func._is_coroutine_marker = _is_coroutine_marker
   418|         0|            0|            0|  0.00%|    return func
   419|         0|            0|            0|  0.00%|
   420|         0|            0|            0|  0.00%|def iscoroutinefunction(obj):
   421|         0|            0|            0|  0.00%|    """Return true if the object is a coroutine function.
   422|         0|            0|            0|  0.00%|
   423|         0|            0|            0|  0.00%|    Coroutine functions are normally defined with "async def" syntax, but may
   424|         0|            0|            0|  0.00%|    be marked via markcoroutinefunction.
   425|         0|            0|            0|  0.00%|    """
   426|         0|            0|            0|  0.00%|    return _has_code_flag(obj, CO_COROUTINE) or _has_coroutine_mark(obj)
   427|         0|            0|            0|  0.00%|
   428|         0|            0|            0|  0.00%|def isasyncgenfunction(obj):
   429|         0|            0|            0|  0.00%|    """Return true if the object is an asynchronous generator function.
   430|         0|            0|            0|  0.00%|
   431|         0|            0|            0|  0.00%|    Asynchronous generator functions are defined with "async def"
   432|         0|            0|            0|  0.00%|    syntax and have "yield" expressions in their body.
   433|         0|            0|            0|  0.00%|    """
   434|         0|            0|            0|  0.00%|    return _has_code_flag(obj, CO_ASYNC_GENERATOR)
   435|         0|            0|            0|  0.00%|
   436|         0|            0|            0|  0.00%|def isasyncgen(object):
   437|         0|            0|            0|  0.00%|    """Return true if the object is an asynchronous generator."""
   438|         0|            0|            0|  0.00%|    return isinstance(object, types.AsyncGeneratorType)
   439|         0|            0|            0|  0.00%|
   440|         0|            0|            0|  0.00%|def isgenerator(object):
   441|         0|            0|            0|  0.00%|    """Return true if the object is a generator.
   442|         0|            0|            0|  0.00%|
   443|         0|            0|            0|  0.00%|    Generator objects provide these attributes:
   444|         0|            0|            0|  0.00%|        __iter__        defined to support iteration over container
   445|         0|            0|            0|  0.00%|        close           raises a new GeneratorExit exception inside the
   446|         0|            0|            0|  0.00%|                        generator to terminate the iteration
   447|         0|            0|            0|  0.00%|        gi_code         code object
   448|         0|            0|            0|  0.00%|        gi_frame        frame object or possibly None once the generator has
   449|         0|            0|            0|  0.00%|                        been exhausted
   450|         0|            0|            0|  0.00%|        gi_running      set to 1 when generator is executing, 0 otherwise
   451|         0|            0|            0|  0.00%|        next            return the next item from the container
   452|         0|            0|            0|  0.00%|        send            resumes the generator and "sends" a value that becomes
   453|         0|            0|            0|  0.00%|                        the result of the current yield-expression
   454|         0|            0|            0|  0.00%|        throw           used to raise an exception inside the generator"""
   455|         0|            0|            0|  0.00%|    return isinstance(object, types.GeneratorType)
   456|         0|            0|            0|  0.00%|
   457|         0|            0|            0|  0.00%|def iscoroutine(object):
   458|         0|            0|            0|  0.00%|    """Return true if the object is a coroutine."""
   459|         0|            0|            0|  0.00%|    return isinstance(object, types.CoroutineType)
   460|         0|            0|            0|  0.00%|
   461|         0|            0|            0|  0.00%|def isawaitable(object):
   462|         0|            0|            0|  0.00%|    """Return true if object can be passed to an ``await`` expression."""
   463|         0|            0|            0|  0.00%|    return (isinstance(object, types.CoroutineType) or
   464|         0|            0|            0|  0.00%|            isinstance(object, types.GeneratorType) and
   465|         0|            0|            0|  0.00%|                bool(object.gi_code.co_flags & CO_ITERABLE_COROUTINE) or
   466|         0|            0|            0|  0.00%|            isinstance(object, collections.abc.Awaitable))
   467|         0|            0|            0|  0.00%|
   468|         0|            0|            0|  0.00%|def istraceback(object):
   469|         0|            0|            0|  0.00%|    """Return true if the object is a traceback.
   470|         0|            0|            0|  0.00%|
   471|         0|            0|            0|  0.00%|    Traceback objects provide these attributes:
   472|         0|            0|            0|  0.00%|        tb_frame        frame object at this level
   473|         0|            0|            0|  0.00%|        tb_lasti        index of last attempted instruction in bytecode
   474|         0|            0|            0|  0.00%|        tb_lineno       current line number in Python source code
   475|         0|            0|            0|  0.00%|        tb_next         next inner traceback object (called by this level)"""
   476|         0|            0|            0|  0.00%|    return isinstance(object, types.TracebackType)
   477|         0|            0|            0|  0.00%|
   478|         0|            0|            0|  0.00%|def isframe(object):
   479|         0|            0|            0|  0.00%|    """Return true if the object is a frame object.
   480|         0|            0|            0|  0.00%|
   481|         0|            0|            0|  0.00%|    Frame objects provide these attributes:
   482|         0|            0|            0|  0.00%|        f_back          next outer frame object (this frame's caller)
   483|         0|            0|            0|  0.00%|        f_builtins      built-in namespace seen by this frame
   484|         0|            0|            0|  0.00%|        f_code          code object being executed in this frame
   485|         0|            0|            0|  0.00%|        f_globals       global namespace seen by this frame
   486|         0|            0|            0|  0.00%|        f_lasti         index of last attempted instruction in bytecode
   487|         0|            0|            0|  0.00%|        f_lineno        current line number in Python source code
   488|         0|            0|            0|  0.00%|        f_locals        local namespace seen by this frame
   489|         0|            0|            0|  0.00%|        f_trace         tracing function for this frame, or None"""
   490|         0|            0|            0|  0.00%|    return isinstance(object, types.FrameType)
   491|         0|            0|            0|  0.00%|
   492|         0|            0|            0|  0.00%|def iscode(object):
   493|         0|            0|            0|  0.00%|    """Return true if the object is a code object.
   494|         0|            0|            0|  0.00%|
   495|         0|            0|            0|  0.00%|    Code objects provide these attributes:
   496|         0|            0|            0|  0.00%|        co_argcount         number of arguments (not including *, ** args
   497|         0|            0|            0|  0.00%|                            or keyword only arguments)
   498|         0|            0|            0|  0.00%|        co_code             string of raw compiled bytecode
   499|         0|            0|            0|  0.00%|        co_cellvars         tuple of names of cell variables
   500|         0|            0|            0|  0.00%|        co_consts           tuple of constants used in the bytecode
   501|         0|            0|            0|  0.00%|        co_filename         name of file in which this code object was created
   502|         0|            0|            0|  0.00%|        co_firstlineno      number of first line in Python source code
   503|         0|            0|            0|  0.00%|        co_flags            bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg
   504|         0|            0|            0|  0.00%|                            | 16=nested | 32=generator | 64=nofree | 128=coroutine
   505|         0|            0|            0|  0.00%|                            | 256=iterable_coroutine | 512=async_generator
   506|         0|            0|            0|  0.00%|        co_freevars         tuple of names of free variables
   507|         0|            0|            0|  0.00%|        co_posonlyargcount  number of positional only arguments
   508|         0|            0|            0|  0.00%|        co_kwonlyargcount   number of keyword only arguments (not including ** arg)
   509|         0|            0|            0|  0.00%|        co_lnotab           encoded mapping of line numbers to bytecode indices
   510|         0|            0|            0|  0.00%|        co_name             name with which this code object was defined
   511|         0|            0|            0|  0.00%|        co_names            tuple of names other than arguments and function locals
   512|         0|            0|            0|  0.00%|        co_nlocals          number of local variables
   513|         0|            0|            0|  0.00%|        co_stacksize        virtual machine stack space required
   514|         0|            0|            0|  0.00%|        co_varnames         tuple of names of arguments and local variables"""
   515|         0|            0|            0|  0.00%|    return isinstance(object, types.CodeType)
   516|         0|            0|            0|  0.00%|
   517|         0|            0|            0|  0.00%|def isbuiltin(object):
   518|         0|            0|            0|  0.00%|    """Return true if the object is a built-in function or method.
   519|         0|            0|            0|  0.00%|
   520|         0|            0|            0|  0.00%|    Built-in functions and methods provide these attributes:
   521|         0|            0|            0|  0.00%|        __doc__         documentation string
   522|         0|            0|            0|  0.00%|        __name__        original name of this function or method
   523|         0|            0|            0|  0.00%|        __self__        instance to which a method is bound, or None"""
   524|         0|            0|            0|  0.00%|    return isinstance(object, types.BuiltinFunctionType)
   525|         0|            0|            0|  0.00%|
   526|         0|            0|            0|  0.00%|def ismethodwrapper(object):
   527|         0|            0|            0|  0.00%|    """Return true if the object is a method wrapper."""
   528|         0|            0|            0|  0.00%|    return isinstance(object, types.MethodWrapperType)
   529|         0|            0|            0|  0.00%|
   530|         0|            0|            0|  0.00%|def isroutine(object):
   531|         0|            0|            0|  0.00%|    """Return true if the object is any kind of function or method."""
   532|         0|            0|            0|  0.00%|    return (isbuiltin(object)
   533|         0|            0|            0|  0.00%|            or isfunction(object)
   534|         0|            0|            0|  0.00%|            or ismethod(object)
   535|         0|            0|            0|  0.00%|            or ismethoddescriptor(object)
   536|         0|            0|            0|  0.00%|            or ismethodwrapper(object))
   537|         0|            0|            0|  0.00%|
   538|         0|            0|            0|  0.00%|def isabstract(object):
   539|         0|            0|            0|  0.00%|    """Return true if the object is an abstract base class (ABC)."""
   540|         0|            0|            0|  0.00%|    if not isinstance(object, type):
   541|         0|            0|            0|  0.00%|        return False
   542|         0|            0|            0|  0.00%|    if object.__flags__ & TPFLAGS_IS_ABSTRACT:
   543|         0|            0|            0|  0.00%|        return True
   544|         0|            0|            0|  0.00%|    if not issubclass(type(object), abc.ABCMeta):
   545|         0|            0|            0|  0.00%|        return False
   546|         0|            0|            0|  0.00%|    if hasattr(object, '__abstractmethods__'):
   547|         0|            0|            0|  0.00%|        # It looks like ABCMeta.__new__ has finished running;
   548|         0|            0|            0|  0.00%|        # TPFLAGS_IS_ABSTRACT should have been accurate.
   549|         0|            0|            0|  0.00%|        return False
   550|         0|            0|            0|  0.00%|    # It looks like ABCMeta.__new__ has not finished running yet; we're
   551|         0|            0|            0|  0.00%|    # probably in __init_subclass__. We'll look for abstractmethods manually.
   552|         0|            0|            0|  0.00%|    for name, value in object.__dict__.items():
   553|         0|            0|            0|  0.00%|        if getattr(value, "__isabstractmethod__", False):
   554|         0|            0|            0|  0.00%|            return True
   555|         0|            0|            0|  0.00%|    for base in object.__bases__:
   556|         0|            0|            0|  0.00%|        for name in getattr(base, "__abstractmethods__", ()):
   557|         0|            0|            0|  0.00%|            value = getattr(object, name, None)
   558|         0|            0|            0|  0.00%|            if getattr(value, "__isabstractmethod__", False):
   559|         0|            0|            0|  0.00%|                return True
   560|         0|            0|            0|  0.00%|    return False
   561|         0|            0|            0|  0.00%|
   562|         0|            0|            0|  0.00%|def _getmembers(object, predicate, getter):
   563|         0|            0|            0|  0.00%|    results = []
   564|         0|            0|            0|  0.00%|    processed = set()
   565|         0|            0|            0|  0.00%|    names = dir(object)
   566|         0|            0|            0|  0.00%|    if isclass(object):
   567|         0|            0|            0|  0.00%|        mro = getmro(object)
   568|         0|            0|            0|  0.00%|        # add any DynamicClassAttributes to the list of names if object is a class;
   569|         0|            0|            0|  0.00%|        # this may result in duplicate entries if, for example, a virtual
   570|         0|            0|            0|  0.00%|        # attribute with the same name as a DynamicClassAttribute exists
   571|         0|            0|            0|  0.00%|        try:
   572|         0|            0|            0|  0.00%|            for base in object.__bases__:
   573|         0|            0|            0|  0.00%|                for k, v in base.__dict__.items():
   574|         0|            0|            0|  0.00%|                    if isinstance(v, types.DynamicClassAttribute):
   575|         0|            0|            0|  0.00%|                        names.append(k)
   576|         0|            0|            0|  0.00%|        except AttributeError:
   577|         0|            0|            0|  0.00%|            pass
   578|         0|            0|            0|  0.00%|    else:
   579|         0|            0|            0|  0.00%|        mro = ()
   580|         0|            0|            0|  0.00%|    for key in names:
   581|         0|            0|            0|  0.00%|        # First try to get the value via getattr.  Some descriptors don't
   582|         0|            0|            0|  0.00%|        # like calling their __get__ (see bug #1785), so fall back to
   583|         0|            0|            0|  0.00%|        # looking in the __dict__.
   584|         0|            0|            0|  0.00%|        try:
   585|         0|            0|            0|  0.00%|            value = getter(object, key)
   586|         0|            0|            0|  0.00%|            # handle the duplicate key
   587|         0|            0|            0|  0.00%|            if key in processed:
   588|         0|            0|            0|  0.00%|                raise AttributeError
   589|         0|            0|            0|  0.00%|        except AttributeError:
   590|         0|            0|            0|  0.00%|            for base in mro:
   591|         0|            0|            0|  0.00%|                if key in base.__dict__:
   592|         0|            0|            0|  0.00%|                    value = base.__dict__[key]
   593|         0|            0|            0|  0.00%|                    break
   594|         0|            0|            0|  0.00%|            else:
   595|         0|            0|            0|  0.00%|                # could be a (currently) missing slot member, or a buggy
   596|         0|            0|            0|  0.00%|                # __dir__; discard and move on
   597|         0|            0|            0|  0.00%|                continue
   598|         0|            0|            0|  0.00%|        if not predicate or predicate(value):
   599|         0|            0|            0|  0.00%|            results.append((key, value))
   600|         0|            0|            0|  0.00%|        processed.add(key)
   601|         0|            0|            0|  0.00%|    results.sort(key=lambda pair: pair[0])
   602|         0|            0|            0|  0.00%|    return results
   603|         0|            0|            0|  0.00%|
   604|         0|            0|            0|  0.00%|def getmembers(object, predicate=None):
   605|         0|            0|            0|  0.00%|    """Return all members of an object as (name, value) pairs sorted by name.
   606|         0|            0|            0|  0.00%|    Optionally, only return members that satisfy a given predicate."""
   607|         0|            0|            0|  0.00%|    return _getmembers(object, predicate, getattr)
   608|         0|            0|            0|  0.00%|
   609|         0|            0|            0|  0.00%|def getmembers_static(object, predicate=None):
   610|         0|            0|            0|  0.00%|    """Return all members of an object as (name, value) pairs sorted by name
   611|         0|            0|            0|  0.00%|    without triggering dynamic lookup via the descriptor protocol,
   612|         0|            0|            0|  0.00%|    __getattr__ or __getattribute__. Optionally, only return members that
   613|         0|            0|            0|  0.00%|    satisfy a given predicate.
   614|         0|            0|            0|  0.00%|
   615|         0|            0|            0|  0.00%|    Note: this function may not be able to retrieve all members
   616|         0|            0|            0|  0.00%|       that getmembers can fetch (like dynamically created attributes)
   617|         0|            0|            0|  0.00%|       and may find members that getmembers can't (like descriptors
   618|         0|            0|            0|  0.00%|       that raise AttributeError). It can also return descriptor objects
   619|         0|            0|            0|  0.00%|       instead of instance members in some cases.
   620|         0|            0|            0|  0.00%|    """
   621|         0|            0|            0|  0.00%|    return _getmembers(object, predicate, getattr_static)
   622|         0|            0|            0|  0.00%|
   623|         0|            0|            0|  0.00%|Attribute = namedtuple('Attribute', 'name kind defining_class object')
   624|         0|            0|            0|  0.00%|
   625|         0|            0|            0|  0.00%|def classify_class_attrs(cls):
   626|         0|            0|            0|  0.00%|    """Return list of attribute-descriptor tuples.
   627|         0|            0|            0|  0.00%|
   628|         0|            0|            0|  0.00%|    For each name in dir(cls), the return list contains a 4-tuple
   629|         0|            0|            0|  0.00%|    with these elements:
   630|         0|            0|            0|  0.00%|
   631|         0|            0|            0|  0.00%|        0. The name (a string).
   632|         0|            0|            0|  0.00%|
   633|         0|            0|            0|  0.00%|        1. The kind of attribute this is, one of these strings:
   634|         0|            0|            0|  0.00%|               'class method'    created via classmethod()
   635|         0|            0|            0|  0.00%|               'static method'   created via staticmethod()
   636|         0|            0|            0|  0.00%|               'property'        created via property()
   637|         0|            0|            0|  0.00%|               'method'          any other flavor of method or descriptor
   638|         0|            0|            0|  0.00%|               'data'            not a method
   639|         0|            0|            0|  0.00%|
   640|         0|            0|            0|  0.00%|        2. The class which defined this attribute (a class).
   641|         0|            0|            0|  0.00%|
   642|         0|            0|            0|  0.00%|        3. The object as obtained by calling getattr; if this fails, or if the
   643|         0|            0|            0|  0.00%|           resulting object does not live anywhere in the class' mro (including
   644|         0|            0|            0|  0.00%|           metaclasses) then the object is looked up in the defining class's
   645|         0|            0|            0|  0.00%|           dict (found by walking the mro).
   646|         0|            0|            0|  0.00%|
   647|         0|            0|            0|  0.00%|    If one of the items in dir(cls) is stored in the metaclass it will now
   648|         0|            0|            0|  0.00%|    be discovered and not have None be listed as the class in which it was
   649|         0|            0|            0|  0.00%|    defined.  Any items whose home class cannot be discovered are skipped.
   650|         0|            0|            0|  0.00%|    """
   651|         0|            0|            0|  0.00%|
   652|         0|            0|            0|  0.00%|    mro = getmro(cls)
   653|         0|            0|            0|  0.00%|    metamro = getmro(type(cls)) # for attributes stored in the metaclass
   654|         0|            0|            0|  0.00%|    metamro = tuple(cls for cls in metamro if cls not in (type, object))
   655|         0|            0|            0|  0.00%|    class_bases = (cls,) + mro
   656|         0|            0|            0|  0.00%|    all_bases = class_bases + metamro
   657|         0|            0|            0|  0.00%|    names = dir(cls)
   658|         0|            0|            0|  0.00%|    # :dd any DynamicClassAttributes to the list of names;
   659|         0|            0|            0|  0.00%|    # this may result in duplicate entries if, for example, a virtual
   660|         0|            0|            0|  0.00%|    # attribute with the same name as a DynamicClassAttribute exists.
   661|         0|            0|            0|  0.00%|    for base in mro:
   662|         0|            0|            0|  0.00%|        for k, v in base.__dict__.items():
   663|         0|            0|            0|  0.00%|            if isinstance(v, types.DynamicClassAttribute) and v.fget is not None:
   664|         0|            0|            0|  0.00%|                names.append(k)
   665|         0|            0|            0|  0.00%|    result = []
   666|         0|            0|            0|  0.00%|    processed = set()
   667|         0|            0|            0|  0.00%|
   668|         0|            0|            0|  0.00%|    for name in names:
   669|         0|            0|            0|  0.00%|        # Get the object associated with the name, and where it was defined.
   670|         0|            0|            0|  0.00%|        # Normal objects will be looked up with both getattr and directly in
   671|         0|            0|            0|  0.00%|        # its class' dict (in case getattr fails [bug #1785], and also to look
   672|         0|            0|            0|  0.00%|        # for a docstring).
   673|         0|            0|            0|  0.00%|        # For DynamicClassAttributes on the second pass we only look in the
   674|         0|            0|            0|  0.00%|        # class's dict.
   675|         0|            0|            0|  0.00%|        #
   676|         0|            0|            0|  0.00%|        # Getting an obj from the __dict__ sometimes reveals more than
   677|         0|            0|            0|  0.00%|        # using getattr.  Static and class methods are dramatic examples.
   678|         0|            0|            0|  0.00%|        homecls = None
   679|         0|            0|            0|  0.00%|        get_obj = None
   680|         0|            0|            0|  0.00%|        dict_obj = None
   681|         0|            0|            0|  0.00%|        if name not in processed:
   682|         0|            0|            0|  0.00%|            try:
   683|         0|            0|            0|  0.00%|                if name == '__dict__':
   684|         0|            0|            0|  0.00%|                    raise Exception("__dict__ is special, don't want the proxy")
   685|         0|            0|            0|  0.00%|                get_obj = getattr(cls, name)
   686|         0|            0|            0|  0.00%|            except Exception:
   687|         0|            0|            0|  0.00%|                pass
   688|         0|            0|            0|  0.00%|            else:
   689|         0|            0|            0|  0.00%|                homecls = getattr(get_obj, "__objclass__", homecls)
   690|         0|            0|            0|  0.00%|                if homecls not in class_bases:
   691|         0|            0|            0|  0.00%|                    # if the resulting object does not live somewhere in the
   692|         0|            0|            0|  0.00%|                    # mro, drop it and search the mro manually
   693|         0|            0|            0|  0.00%|                    homecls = None
   694|         0|            0|            0|  0.00%|                    last_cls = None
   695|         0|            0|            0|  0.00%|                    # first look in the classes
   696|         0|            0|            0|  0.00%|                    for srch_cls in class_bases:
   697|         0|            0|            0|  0.00%|                        srch_obj = getattr(srch_cls, name, None)
   698|         0|            0|            0|  0.00%|                        if srch_obj is get_obj:
   699|         0|            0|            0|  0.00%|                            last_cls = srch_cls
   700|         0|            0|            0|  0.00%|                    # then check the metaclasses
   701|         0|            0|            0|  0.00%|                    for srch_cls in metamro:
   702|         0|            0|            0|  0.00%|                        try:
   703|         0|            0|            0|  0.00%|                            srch_obj = srch_cls.__getattr__(cls, name)
   704|         0|            0|            0|  0.00%|                        except AttributeError:
   705|         0|            0|            0|  0.00%|                            continue
   706|         0|            0|            0|  0.00%|                        if srch_obj is get_obj:
   707|         0|            0|            0|  0.00%|                            last_cls = srch_cls
   708|         0|            0|            0|  0.00%|                    if last_cls is not None:
   709|         0|            0|            0|  0.00%|                        homecls = last_cls
   710|         0|            0|            0|  0.00%|        for base in all_bases:
   711|         0|            0|            0|  0.00%|            if name in base.__dict__:
   712|         0|            0|            0|  0.00%|                dict_obj = base.__dict__[name]
   713|         0|            0|            0|  0.00%|                if homecls not in metamro:
   714|         0|            0|            0|  0.00%|                    homecls = base
   715|         0|            0|            0|  0.00%|                break
   716|         0|            0|            0|  0.00%|        if homecls is None:
   717|         0|            0|            0|  0.00%|            # unable to locate the attribute anywhere, most likely due to
   718|         0|            0|            0|  0.00%|            # buggy custom __dir__; discard and move on
   719|         0|            0|            0|  0.00%|            continue
   720|         0|            0|            0|  0.00%|        obj = get_obj if get_obj is not None else dict_obj
   721|         0|            0|            0|  0.00%|        # Classify the object or its descriptor.
   722|         0|            0|            0|  0.00%|        if isinstance(dict_obj, (staticmethod, types.BuiltinMethodType)):
   723|         0|            0|            0|  0.00%|            kind = "static method"
   724|         0|            0|            0|  0.00%|            obj = dict_obj
   725|         0|            0|            0|  0.00%|        elif isinstance(dict_obj, (classmethod, types.ClassMethodDescriptorType)):
   726|         0|            0|            0|  0.00%|            kind = "class method"
   727|         0|            0|            0|  0.00%|            obj = dict_obj
   728|         0|            0|            0|  0.00%|        elif isinstance(dict_obj, property):
   729|         0|            0|            0|  0.00%|            kind = "property"
   730|         0|            0|            0|  0.00%|            obj = dict_obj
   731|         0|            0|            0|  0.00%|        elif isroutine(obj):
   732|         0|            0|            0|  0.00%|            kind = "method"
   733|         0|            0|            0|  0.00%|        else:
   734|         0|            0|            0|  0.00%|            kind = "data"
   735|         0|            0|            0|  0.00%|        result.append(Attribute(name, kind, homecls, obj))
   736|         0|            0|            0|  0.00%|        processed.add(name)
   737|         0|            0|            0|  0.00%|    return result
   738|         0|            0|            0|  0.00%|
   739|         0|            0|            0|  0.00%|# ----------------------------------------------------------- class helpers
   740|         0|            0|            0|  0.00%|
   741|         0|            0|            0|  0.00%|def getmro(cls):
   742|         0|            0|            0|  0.00%|    "Return tuple of base classes (including cls) in method resolution order."
   743|         0|            0|            0|  0.00%|    return cls.__mro__
   744|         0|            0|            0|  0.00%|
   745|         0|            0|            0|  0.00%|# -------------------------------------------------------- function helpers
   746|         0|            0|            0|  0.00%|
   747|         1|  8.58307e-06|  8.58307e-06|  0.01%|def unwrap(func, *, stop=None):
   748|         0|            0|            0|  0.00%|    """Get the object wrapped by *func*.
   749|         0|            0|            0|  0.00%|
   750|         0|            0|            0|  0.00%|   Follows the chain of :attr:`__wrapped__` attributes returning the last
   751|         0|            0|            0|  0.00%|   object in the chain.
   752|         0|            0|            0|  0.00%|
   753|         0|            0|            0|  0.00%|   *stop* is an optional callback accepting an object in the wrapper chain
   754|         0|            0|            0|  0.00%|   as its sole argument that allows the unwrapping to be terminated early if
   755|         0|            0|            0|  0.00%|   the callback returns a true value. If the callback never returns a true
   756|         0|            0|            0|  0.00%|   value, the last object in the chain is returned as usual. For example,
   757|         0|            0|            0|  0.00%|   :func:`signature` uses this to stop unwrapping if any object in the
   758|         0|            0|            0|  0.00%|   chain has a ``__signature__`` attribute defined.
   759|         0|            0|            0|  0.00%|
   760|         0|            0|            0|  0.00%|   :exc:`ValueError` is raised if a cycle is encountered.
   761|         0|            0|            0|  0.00%|
   762|         0|            0|            0|  0.00%|    """
   763|         1|  4.52995e-06|  4.52995e-06|  0.00%|    f = func  # remember the original func for error reporting
   764|         0|            0|            0|  0.00%|    # Memoise by id to tolerate non-hashable objects, but store objects to
   765|         0|            0|            0|  0.00%|    # ensure they aren't destroyed, which would allow their IDs to be reused.
   766|         1|  2.86102e-06|  2.86102e-06|  0.00%|    memo = {id(f): f}
   767|         1|  2.86102e-06|  2.86102e-06|  0.00%|    recursion_limit = sys.getrecursionlimit()
   768|         1|  5.72205e-06|  5.72205e-06|  0.01%|    while not isinstance(func, type) and hasattr(func, '__wrapped__'):
   769|         0|            0|            0|  0.00%|        if stop is not None and stop(func):
   770|         0|            0|            0|  0.00%|            break
   771|         0|            0|            0|  0.00%|        func = func.__wrapped__
   772|         0|            0|            0|  0.00%|        id_func = id(func)
   773|         0|            0|            0|  0.00%|        if (id_func in memo) or (len(memo) >= recursion_limit):
   774|         0|            0|            0|  0.00%|            raise ValueError('wrapper loop when unwrapping {!r}'.format(f))
   775|         0|            0|            0|  0.00%|        memo[id_func] = func
   776|         1|   2.6226e-06|   2.6226e-06|  0.00%|    return func
   777|         0|            0|            0|  0.00%|
   778|         0|            0|            0|  0.00%|# -------------------------------------------------- source code extraction
   779|         0|            0|            0|  0.00%|def indentsize(line):
   780|         0|            0|            0|  0.00%|    """Return the indent size, in spaces, at the start of a line of text."""
   781|         0|            0|            0|  0.00%|    expline = line.expandtabs()
   782|         0|            0|            0|  0.00%|    return len(expline) - len(expline.lstrip())
   783|         0|            0|            0|  0.00%|
   784|         0|            0|            0|  0.00%|def _findclass(func):
   785|         0|            0|            0|  0.00%|    cls = sys.modules.get(func.__module__)
   786|         0|            0|            0|  0.00%|    if cls is None:
   787|         0|            0|            0|  0.00%|        return None
   788|         0|            0|            0|  0.00%|    for name in func.__qualname__.split('.')[:-1]:
   789|         0|            0|            0|  0.00%|        cls = getattr(cls, name)
   790|         0|            0|            0|  0.00%|    if not isclass(cls):
   791|         0|            0|            0|  0.00%|        return None
   792|         0|            0|            0|  0.00%|    return cls
   793|         0|            0|            0|  0.00%|
   794|         0|            0|            0|  0.00%|def _finddoc(obj):
   795|         0|            0|            0|  0.00%|    if isclass(obj):
   796|         0|            0|            0|  0.00%|        for base in obj.__mro__:
   797|         0|            0|            0|  0.00%|            if base is not object:
   798|         0|            0|            0|  0.00%|                try:
   799|         0|            0|            0|  0.00%|                    doc = base.__doc__
   800|         0|            0|            0|  0.00%|                except AttributeError:
   801|         0|            0|            0|  0.00%|                    continue
   802|         0|            0|            0|  0.00%|                if doc is not None:
   803|         0|            0|            0|  0.00%|                    return doc
   804|         0|            0|            0|  0.00%|        return None
   805|         0|            0|            0|  0.00%|
   806|         0|            0|            0|  0.00%|    if ismethod(obj):
   807|         0|            0|            0|  0.00%|        name = obj.__func__.__name__
   808|         0|            0|            0|  0.00%|        self = obj.__self__
   809|         0|            0|            0|  0.00%|        if (isclass(self) and
   810|         0|            0|            0|  0.00%|            getattr(getattr(self, name, None), '__func__') is obj.__func__):
   811|         0|            0|            0|  0.00%|            # classmethod
   812|         0|            0|            0|  0.00%|            cls = self
   813|         0|            0|            0|  0.00%|        else:
   814|         0|            0|            0|  0.00%|            cls = self.__class__
   815|         0|            0|            0|  0.00%|    elif isfunction(obj):
   816|         0|            0|            0|  0.00%|        name = obj.__name__
   817|         0|            0|            0|  0.00%|        cls = _findclass(obj)
   818|         0|            0|            0|  0.00%|        if cls is None or getattr(cls, name) is not obj:
   819|         0|            0|            0|  0.00%|            return None
   820|         0|            0|            0|  0.00%|    elif isbuiltin(obj):
   821|         0|            0|            0|  0.00%|        name = obj.__name__
   822|         0|            0|            0|  0.00%|        self = obj.__self__
   823|         0|            0|            0|  0.00%|        if (isclass(self) and
   824|         0|            0|            0|  0.00%|            self.__qualname__ + '.' + name == obj.__qualname__):
   825|         0|            0|            0|  0.00%|            # classmethod
   826|         0|            0|            0|  0.00%|            cls = self
   827|         0|            0|            0|  0.00%|        else:
   828|         0|            0|            0|  0.00%|            cls = self.__class__
   829|         0|            0|            0|  0.00%|    # Should be tested before isdatadescriptor().
   830|         0|            0|            0|  0.00%|    elif isinstance(obj, property):
   831|         0|            0|            0|  0.00%|        func = obj.fget
   832|         0|            0|            0|  0.00%|        name = func.__name__
   833|         0|            0|            0|  0.00%|        cls = _findclass(func)
   834|         0|            0|            0|  0.00%|        if cls is None or getattr(cls, name) is not obj:
   835|         0|            0|            0|  0.00%|            return None
   836|         0|            0|            0|  0.00%|    elif ismethoddescriptor(obj) or isdatadescriptor(obj):
   837|         0|            0|            0|  0.00%|        name = obj.__name__
   838|         0|            0|            0|  0.00%|        cls = obj.__objclass__
   839|         0|            0|            0|  0.00%|        if getattr(cls, name) is not obj:
   840|         0|            0|            0|  0.00%|            return None
   841|         0|            0|            0|  0.00%|        if ismemberdescriptor(obj):
   842|         0|            0|            0|  0.00%|            slots = getattr(cls, '__slots__', None)
   843|         0|            0|            0|  0.00%|            if isinstance(slots, dict) and name in slots:
   844|         0|            0|            0|  0.00%|                return slots[name]
   845|         0|            0|            0|  0.00%|    else:
   846|         0|            0|            0|  0.00%|        return None
   847|         0|            0|            0|  0.00%|    for base in cls.__mro__:
   848|         0|            0|            0|  0.00%|        try:
   849|         0|            0|            0|  0.00%|            doc = getattr(base, name).__doc__
   850|         0|            0|            0|  0.00%|        except AttributeError:
   851|         0|            0|            0|  0.00%|            continue
   852|         0|            0|            0|  0.00%|        if doc is not None:
   853|         0|            0|            0|  0.00%|            return doc
   854|         0|            0|            0|  0.00%|    return None
   855|         0|            0|            0|  0.00%|
   856|         0|            0|            0|  0.00%|def getdoc(object):
   857|         0|            0|            0|  0.00%|    """Get the documentation string for an object.
   858|         0|            0|            0|  0.00%|
   859|         0|            0|            0|  0.00%|    All tabs are expanded to spaces.  To clean up docstrings that are
   860|         0|            0|            0|  0.00%|    indented to line up with blocks of code, any whitespace than can be
   861|         0|            0|            0|  0.00%|    uniformly removed from the second line onwards is removed."""
   862|         0|            0|            0|  0.00%|    try:
   863|         0|            0|            0|  0.00%|        doc = object.__doc__
   864|         0|            0|            0|  0.00%|    except AttributeError:
   865|         0|            0|            0|  0.00%|        return None
   866|         0|            0|            0|  0.00%|    if doc is None:
   867|         0|            0|            0|  0.00%|        try:
   868|         0|            0|            0|  0.00%|            doc = _finddoc(object)
   869|         0|            0|            0|  0.00%|        except (AttributeError, TypeError):
   870|         0|            0|            0|  0.00%|            return None
   871|         0|            0|            0|  0.00%|    if not isinstance(doc, str):
   872|         0|            0|            0|  0.00%|        return None
   873|         0|            0|            0|  0.00%|    return cleandoc(doc)
   874|         0|            0|            0|  0.00%|
   875|         0|            0|            0|  0.00%|def cleandoc(doc):
   876|         0|            0|            0|  0.00%|    """Clean up indentation from docstrings.
   877|         0|            0|            0|  0.00%|
   878|         0|            0|            0|  0.00%|    Any whitespace that can be uniformly removed from the second line
   879|         0|            0|            0|  0.00%|    onwards is removed."""
   880|         0|            0|            0|  0.00%|    try:
   881|         0|            0|            0|  0.00%|        lines = doc.expandtabs().split('\n')
   882|         0|            0|            0|  0.00%|    except UnicodeError:
   883|         0|            0|            0|  0.00%|        return None
   884|         0|            0|            0|  0.00%|    else:
   885|         0|            0|            0|  0.00%|        # Find minimum indentation of any non-blank lines after first line.
   886|         0|            0|            0|  0.00%|        margin = sys.maxsize
   887|         0|            0|            0|  0.00%|        for line in lines[1:]:
   888|         0|            0|            0|  0.00%|            content = len(line.lstrip())
   889|         0|            0|            0|  0.00%|            if content:
   890|         0|            0|            0|  0.00%|                indent = len(line) - content
   891|         0|            0|            0|  0.00%|                margin = min(margin, indent)
   892|         0|            0|            0|  0.00%|        # Remove indentation.
   893|         0|            0|            0|  0.00%|        if lines:
   894|         0|            0|            0|  0.00%|            lines[0] = lines[0].lstrip()
   895|         0|            0|            0|  0.00%|        if margin < sys.maxsize:
   896|         0|            0|            0|  0.00%|            for i in range(1, len(lines)): lines[i] = lines[i][margin:]
   897|         0|            0|            0|  0.00%|        # Remove any trailing or leading blank lines.
   898|         0|            0|            0|  0.00%|        while lines and not lines[-1]:
   899|         0|            0|            0|  0.00%|            lines.pop()
   900|         0|            0|            0|  0.00%|        while lines and not lines[0]:
   901|         0|            0|            0|  0.00%|            lines.pop(0)
   902|         0|            0|            0|  0.00%|        return '\n'.join(lines)
   903|         0|            0|            0|  0.00%|
   904|         0|            0|            0|  0.00%|def getfile(object):
   905|         0|            0|            0|  0.00%|    """Work out which source or compiled file an object was defined in."""
   906|         0|            0|            0|  0.00%|    if ismodule(object):
   907|         0|            0|            0|  0.00%|        if getattr(object, '__file__', None):
   908|         0|            0|            0|  0.00%|            return object.__file__
   909|         0|            0|            0|  0.00%|        raise TypeError('{!r} is a built-in module'.format(object))
   910|         0|            0|            0|  0.00%|    if isclass(object):
   911|         0|            0|            0|  0.00%|        if hasattr(object, '__module__'):
   912|         0|            0|            0|  0.00%|            module = sys.modules.get(object.__module__)
   913|         0|            0|            0|  0.00%|            if getattr(module, '__file__', None):
   914|         0|            0|            0|  0.00%|                return module.__file__
   915|         0|            0|            0|  0.00%|            if object.__module__ == '__main__':
   916|         0|            0|            0|  0.00%|                raise OSError('source code not available')
   917|         0|            0|            0|  0.00%|        raise TypeError('{!r} is a built-in class'.format(object))
   918|         0|            0|            0|  0.00%|    if ismethod(object):
   919|         0|            0|            0|  0.00%|        object = object.__func__
   920|         0|            0|            0|  0.00%|    if isfunction(object):
   921|         0|            0|            0|  0.00%|        object = object.__code__
   922|         0|            0|            0|  0.00%|    if istraceback(object):
   923|         0|            0|            0|  0.00%|        object = object.tb_frame
   924|         0|            0|            0|  0.00%|    if isframe(object):
   925|         0|            0|            0|  0.00%|        object = object.f_code
   926|         0|            0|            0|  0.00%|    if iscode(object):
   927|         0|            0|            0|  0.00%|        return object.co_filename
   928|         0|            0|            0|  0.00%|    raise TypeError('module, class, method, function, traceback, frame, or '
   929|         0|            0|            0|  0.00%|                    'code object was expected, got {}'.format(
   930|         0|            0|            0|  0.00%|                    type(object).__name__))
   931|         0|            0|            0|  0.00%|
   932|         0|            0|            0|  0.00%|def getmodulename(path):
   933|         0|            0|            0|  0.00%|    """Return the module name for a given file, or None."""
   934|         0|            0|            0|  0.00%|    fname = os.path.basename(path)
   935|         0|            0|            0|  0.00%|    # Check for paths that look like an actual module file
   936|         0|            0|            0|  0.00%|    suffixes = [(-len(suffix), suffix)
   937|         0|            0|            0|  0.00%|                    for suffix in importlib.machinery.all_suffixes()]
   938|         0|            0|            0|  0.00%|    suffixes.sort() # try longest suffixes first, in case they overlap
   939|         0|            0|            0|  0.00%|    for neglen, suffix in suffixes:
   940|         0|            0|            0|  0.00%|        if fname.endswith(suffix):
   941|         0|            0|            0|  0.00%|            return fname[:neglen]
   942|         0|            0|            0|  0.00%|    return None
   943|         0|            0|            0|  0.00%|
   944|         0|            0|            0|  0.00%|def getsourcefile(object):
   945|         0|            0|            0|  0.00%|    """Return the filename that can be used to locate an object's source.
   946|         0|            0|            0|  0.00%|    Return None if no way can be identified to get the source.
   947|         0|            0|            0|  0.00%|    """
   948|         0|            0|            0|  0.00%|    filename = getfile(object)
   949|         0|            0|            0|  0.00%|    all_bytecode_suffixes = importlib.machinery.DEBUG_BYTECODE_SUFFIXES[:]
   950|         0|            0|            0|  0.00%|    all_bytecode_suffixes += importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES[:]
   951|         0|            0|            0|  0.00%|    if any(filename.endswith(s) for s in all_bytecode_suffixes):
   952|         0|            0|            0|  0.00%|        filename = (os.path.splitext(filename)[0] +
   953|         0|            0|            0|  0.00%|                    importlib.machinery.SOURCE_SUFFIXES[0])
   954|         0|            0|            0|  0.00%|    elif any(filename.endswith(s) for s in
   955|         0|            0|            0|  0.00%|                 importlib.machinery.EXTENSION_SUFFIXES):
   956|         0|            0|            0|  0.00%|        return None
   957|         0|            0|            0|  0.00%|    # return a filename found in the linecache even if it doesn't exist on disk
   958|         0|            0|            0|  0.00%|    if filename in linecache.cache:
   959|         0|            0|            0|  0.00%|        return filename
   960|         0|            0|            0|  0.00%|    if os.path.exists(filename):
   961|         0|            0|            0|  0.00%|        return filename
   962|         0|            0|            0|  0.00%|    # only return a non-existent filename if the module has a PEP 302 loader
   963|         0|            0|            0|  0.00%|    module = getmodule(object, filename)
   964|         0|            0|            0|  0.00%|    if getattr(module, '__loader__', None) is not None:
   965|         0|            0|            0|  0.00%|        return filename
   966|         0|            0|            0|  0.00%|    elif getattr(getattr(module, "__spec__", None), "loader", None) is not None:
   967|         0|            0|            0|  0.00%|        return filename
   968|         0|            0|            0|  0.00%|
   969|         0|            0|            0|  0.00%|def getabsfile(object, _filename=None):
   970|         0|            0|            0|  0.00%|    """Return an absolute path to the source or compiled file for an object.
   971|         0|            0|            0|  0.00%|
   972|         0|            0|            0|  0.00%|    The idea is for each object to have a unique origin, so this routine
   973|         0|            0|            0|  0.00%|    normalizes the result as much as possible."""
   974|         0|            0|            0|  0.00%|    if _filename is None:
   975|         0|            0|            0|  0.00%|        _filename = getsourcefile(object) or getfile(object)
   976|         0|            0|            0|  0.00%|    return os.path.normcase(os.path.abspath(_filename))
   977|         0|            0|            0|  0.00%|
   978|         0|            0|            0|  0.00%|modulesbyfile = {}
   979|         0|            0|            0|  0.00%|_filesbymodname = {}
   980|         0|            0|            0|  0.00%|
   981|         0|            0|            0|  0.00%|def getmodule(object, _filename=None):
   982|         0|            0|            0|  0.00%|    """Return the module an object was defined in, or None if not found."""
   983|         0|            0|            0|  0.00%|    if ismodule(object):
   984|         0|            0|            0|  0.00%|        return object
   985|         0|            0|            0|  0.00%|    if hasattr(object, '__module__'):
   986|         0|            0|            0|  0.00%|        return sys.modules.get(object.__module__)
   987|         0|            0|            0|  0.00%|    # Try the filename to modulename cache
   988|         0|            0|            0|  0.00%|    if _filename is not None and _filename in modulesbyfile:
   989|         0|            0|            0|  0.00%|        return sys.modules.get(modulesbyfile[_filename])
   990|         0|            0|            0|  0.00%|    # Try the cache again with the absolute file name
   991|         0|            0|            0|  0.00%|    try:
   992|         0|            0|            0|  0.00%|        file = getabsfile(object, _filename)
   993|         0|            0|            0|  0.00%|    except (TypeError, FileNotFoundError):
   994|         0|            0|            0|  0.00%|        return None
   995|         0|            0|            0|  0.00%|    if file in modulesbyfile:
   996|         0|            0|            0|  0.00%|        return sys.modules.get(modulesbyfile[file])
   997|         0|            0|            0|  0.00%|    # Update the filename to module name cache and check yet again
   998|         0|            0|            0|  0.00%|    # Copy sys.modules in order to cope with changes while iterating
   999|         0|            0|            0|  0.00%|    for modname, module in sys.modules.copy().items():
  1000|         0|            0|            0|  0.00%|        if ismodule(module) and hasattr(module, '__file__'):
  1001|         0|            0|            0|  0.00%|            f = module.__file__
  1002|         0|            0|            0|  0.00%|            if f == _filesbymodname.get(modname, None):
  1003|         0|            0|            0|  0.00%|                # Have already mapped this module, so skip it
  1004|         0|            0|            0|  0.00%|                continue
  1005|         0|            0|            0|  0.00%|            _filesbymodname[modname] = f
  1006|         0|            0|            0|  0.00%|            f = getabsfile(module)
  1007|         0|            0|            0|  0.00%|            # Always map to the name the module knows itself by
  1008|         0|            0|            0|  0.00%|            modulesbyfile[f] = modulesbyfile[
  1009|         0|            0|            0|  0.00%|                os.path.realpath(f)] = module.__name__
  1010|         0|            0|            0|  0.00%|    if file in modulesbyfile:
  1011|         0|            0|            0|  0.00%|        return sys.modules.get(modulesbyfile[file])
  1012|         0|            0|            0|  0.00%|    # Check the main module
  1013|         0|            0|            0|  0.00%|    main = sys.modules['__main__']
  1014|         0|            0|            0|  0.00%|    if not hasattr(object, '__name__'):
  1015|         0|            0|            0|  0.00%|        return None
  1016|         0|            0|            0|  0.00%|    if hasattr(main, object.__name__):
  1017|         0|            0|            0|  0.00%|        mainobject = getattr(main, object.__name__)
  1018|         0|            0|            0|  0.00%|        if mainobject is object:
  1019|         0|            0|            0|  0.00%|            return main
  1020|         0|            0|            0|  0.00%|    # Check builtins
  1021|         0|            0|            0|  0.00%|    builtin = sys.modules['builtins']
  1022|         0|            0|            0|  0.00%|    if hasattr(builtin, object.__name__):
  1023|         0|            0|            0|  0.00%|        builtinobject = getattr(builtin, object.__name__)
  1024|         0|            0|            0|  0.00%|        if builtinobject is object:
  1025|         0|            0|            0|  0.00%|            return builtin
  1026|         0|            0|            0|  0.00%|
  1027|         0|            0|            0|  0.00%|
  1028|         0|            0|            0|  0.00%|class ClassFoundException(Exception):
  1029|         0|            0|            0|  0.00%|    pass
  1030|         0|            0|            0|  0.00%|
  1031|         0|            0|            0|  0.00%|
  1032|         0|            0|            0|  0.00%|class _ClassFinder(ast.NodeVisitor):
  1033|         0|            0|            0|  0.00%|
  1034|         0|            0|            0|  0.00%|    def __init__(self, qualname):
  1035|         0|            0|            0|  0.00%|        self.stack = []
  1036|         0|            0|            0|  0.00%|        self.qualname = qualname
  1037|         0|            0|            0|  0.00%|
  1038|         0|            0|            0|  0.00%|    def visit_FunctionDef(self, node):
  1039|         0|            0|            0|  0.00%|        self.stack.append(node.name)
  1040|         0|            0|            0|  0.00%|        self.stack.append('<locals>')
  1041|         0|            0|            0|  0.00%|        self.generic_visit(node)
  1042|         0|            0|            0|  0.00%|        self.stack.pop()
  1043|         0|            0|            0|  0.00%|        self.stack.pop()
  1044|         0|            0|            0|  0.00%|
  1045|         0|            0|            0|  0.00%|    visit_AsyncFunctionDef = visit_FunctionDef
  1046|         0|            0|            0|  0.00%|
  1047|         0|            0|            0|  0.00%|    def visit_ClassDef(self, node):
  1048|         0|            0|            0|  0.00%|        self.stack.append(node.name)
  1049|         0|            0|            0|  0.00%|        if self.qualname == '.'.join(self.stack):
  1050|         0|            0|            0|  0.00%|            # Return the decorator for the class if present
  1051|         0|            0|            0|  0.00%|            if node.decorator_list:
  1052|         0|            0|            0|  0.00%|                line_number = node.decorator_list[0].lineno
  1053|         0|            0|            0|  0.00%|            else:
  1054|         0|            0|            0|  0.00%|                line_number = node.lineno
  1055|         0|            0|            0|  0.00%|
  1056|         0|            0|            0|  0.00%|            # decrement by one since lines starts with indexing by zero
  1057|         0|            0|            0|  0.00%|            line_number -= 1
  1058|         0|            0|            0|  0.00%|            raise ClassFoundException(line_number)
  1059|         0|            0|            0|  0.00%|        self.generic_visit(node)
  1060|         0|            0|            0|  0.00%|        self.stack.pop()
  1061|         0|            0|            0|  0.00%|
  1062|         0|            0|            0|  0.00%|
  1063|         0|            0|            0|  0.00%|def findsource(object):
  1064|         0|            0|            0|  0.00%|    """Return the entire source file and starting line number for an object.
  1065|         0|            0|            0|  0.00%|
  1066|         0|            0|            0|  0.00%|    The argument may be a module, class, method, function, traceback, frame,
  1067|         0|            0|            0|  0.00%|    or code object.  The source code is returned as a list of all the lines
  1068|         0|            0|            0|  0.00%|    in the file and the line number indexes a line in that list.  An OSError
  1069|         0|            0|            0|  0.00%|    is raised if the source code cannot be retrieved."""
  1070|         0|            0|            0|  0.00%|
  1071|         0|            0|            0|  0.00%|    file = getsourcefile(object)
  1072|         0|            0|            0|  0.00%|    if file:
  1073|         0|            0|            0|  0.00%|        # Invalidate cache if needed.
  1074|         0|            0|            0|  0.00%|        linecache.checkcache(file)
  1075|         0|            0|            0|  0.00%|    else:
  1076|         0|            0|            0|  0.00%|        file = getfile(object)
  1077|         0|            0|            0|  0.00%|        # Allow filenames in form of "<something>" to pass through.
  1078|         0|            0|            0|  0.00%|        # `doctest` monkeypatches `linecache` module to enable
  1079|         0|            0|            0|  0.00%|        # inspection, so let `linecache.getlines` to be called.
  1080|         0|            0|            0|  0.00%|        if not (file.startswith('<') and file.endswith('>')):
  1081|         0|            0|            0|  0.00%|            raise OSError('source code not available')
  1082|         0|            0|            0|  0.00%|
  1083|         0|            0|            0|  0.00%|    module = getmodule(object, file)
  1084|         0|            0|            0|  0.00%|    if module:
  1085|         0|            0|            0|  0.00%|        lines = linecache.getlines(file, module.__dict__)
  1086|         0|            0|            0|  0.00%|    else:
  1087|         0|            0|            0|  0.00%|        lines = linecache.getlines(file)
  1088|         0|            0|            0|  0.00%|    if not lines:
  1089|         0|            0|            0|  0.00%|        raise OSError('could not get source code')
  1090|         0|            0|            0|  0.00%|
  1091|         0|            0|            0|  0.00%|    if ismodule(object):
  1092|         0|            0|            0|  0.00%|        return lines, 0
  1093|         0|            0|            0|  0.00%|
  1094|         0|            0|            0|  0.00%|    if isclass(object):
  1095|         0|            0|            0|  0.00%|        qualname = object.__qualname__
  1096|         0|            0|            0|  0.00%|        source = ''.join(lines)
  1097|         0|            0|            0|  0.00%|        tree = ast.parse(source)
  1098|         0|            0|            0|  0.00%|        class_finder = _ClassFinder(qualname)
  1099|         0|            0|            0|  0.00%|        try:
  1100|         0|            0|            0|  0.00%|            class_finder.visit(tree)
  1101|         0|            0|            0|  0.00%|        except ClassFoundException as e:
  1102|         0|            0|            0|  0.00%|            line_number = e.args[0]
  1103|         0|            0|            0|  0.00%|            return lines, line_number
  1104|         0|            0|            0|  0.00%|        else:
  1105|         0|            0|            0|  0.00%|            raise OSError('could not find class definition')
  1106|         0|            0|            0|  0.00%|
  1107|         0|            0|            0|  0.00%|    if ismethod(object):
  1108|         0|            0|            0|  0.00%|        object = object.__func__
  1109|         0|            0|            0|  0.00%|    if isfunction(object):
  1110|         0|            0|            0|  0.00%|        object = object.__code__
  1111|         0|            0|            0|  0.00%|    if istraceback(object):
  1112|         0|            0|            0|  0.00%|        object = object.tb_frame
  1113|         0|            0|            0|  0.00%|    if isframe(object):
  1114|         0|            0|            0|  0.00%|        object = object.f_code
  1115|         0|            0|            0|  0.00%|    if iscode(object):
  1116|         0|            0|            0|  0.00%|        if not hasattr(object, 'co_firstlineno'):
  1117|         0|            0|            0|  0.00%|            raise OSError('could not find function definition')
  1118|         0|            0|            0|  0.00%|        lnum = object.co_firstlineno - 1
  1119|         0|            0|            0|  0.00%|        pat = re.compile(r'^(\s*def\s)|(\s*async\s+def\s)|(.*(?<!\w)lambda(:|\s))|^(\s*@)')
  1120|         0|            0|            0|  0.00%|        while lnum > 0:
  1121|         0|            0|            0|  0.00%|            try:
  1122|         0|            0|            0|  0.00%|                line = lines[lnum]
  1123|         0|            0|            0|  0.00%|            except IndexError:
  1124|         0|            0|            0|  0.00%|                raise OSError('lineno is out of bounds')
  1125|         0|            0|            0|  0.00%|            if pat.match(line):
  1126|         0|            0|            0|  0.00%|                break
  1127|         0|            0|            0|  0.00%|            lnum = lnum - 1
  1128|         0|            0|            0|  0.00%|        return lines, lnum
  1129|         0|            0|            0|  0.00%|    raise OSError('could not find code object')
  1130|         0|            0|            0|  0.00%|
  1131|         0|            0|            0|  0.00%|def getcomments(object):
  1132|         0|            0|            0|  0.00%|    """Get lines of comments immediately preceding an object's source code.
  1133|         0|            0|            0|  0.00%|
  1134|         0|            0|            0|  0.00%|    Returns None when source can't be found.
  1135|         0|            0|            0|  0.00%|    """
  1136|         0|            0|            0|  0.00%|    try:
  1137|         0|            0|            0|  0.00%|        lines, lnum = findsource(object)
  1138|         0|            0|            0|  0.00%|    except (OSError, TypeError):
  1139|         0|            0|            0|  0.00%|        return None
  1140|         0|            0|            0|  0.00%|
  1141|         0|            0|            0|  0.00%|    if ismodule(object):
  1142|         0|            0|            0|  0.00%|        # Look for a comment block at the top of the file.
  1143|         0|            0|            0|  0.00%|        start = 0
  1144|         0|            0|            0|  0.00%|        if lines and lines[0][:2] == '#!': start = 1
  1145|         0|            0|            0|  0.00%|        while start < len(lines) and lines[start].strip() in ('', '#'):
  1146|         0|            0|            0|  0.00%|            start = start + 1
  1147|         0|            0|            0|  0.00%|        if start < len(lines) and lines[start][:1] == '#':
  1148|         0|            0|            0|  0.00%|            comments = []
  1149|         0|            0|            0|  0.00%|            end = start
  1150|         0|            0|            0|  0.00%|            while end < len(lines) and lines[end][:1] == '#':
  1151|         0|            0|            0|  0.00%|                comments.append(lines[end].expandtabs())
  1152|         0|            0|            0|  0.00%|                end = end + 1
  1153|         0|            0|            0|  0.00%|            return ''.join(comments)
  1154|         0|            0|            0|  0.00%|
  1155|         0|            0|            0|  0.00%|    # Look for a preceding block of comments at the same indentation.
  1156|         0|            0|            0|  0.00%|    elif lnum > 0:
  1157|         0|            0|            0|  0.00%|        indent = indentsize(lines[lnum])
  1158|         0|            0|            0|  0.00%|        end = lnum - 1
  1159|         0|            0|            0|  0.00%|        if end >= 0 and lines[end].lstrip()[:1] == '#' and \
  1160|         0|            0|            0|  0.00%|            indentsize(lines[end]) == indent:
  1161|         0|            0|            0|  0.00%|            comments = [lines[end].expandtabs().lstrip()]
  1162|         0|            0|            0|  0.00%|            if end > 0:
  1163|         0|            0|            0|  0.00%|                end = end - 1
  1164|         0|            0|            0|  0.00%|                comment = lines[end].expandtabs().lstrip()
  1165|         0|            0|            0|  0.00%|                while comment[:1] == '#' and indentsize(lines[end]) == indent:
  1166|         0|            0|            0|  0.00%|                    comments[:0] = [comment]
  1167|         0|            0|            0|  0.00%|                    end = end - 1
  1168|         0|            0|            0|  0.00%|                    if end < 0: break
  1169|         0|            0|            0|  0.00%|                    comment = lines[end].expandtabs().lstrip()
  1170|         0|            0|            0|  0.00%|            while comments and comments[0].strip() == '#':
  1171|         0|            0|            0|  0.00%|                comments[:1] = []
  1172|         0|            0|            0|  0.00%|            while comments and comments[-1].strip() == '#':
  1173|         0|            0|            0|  0.00%|                comments[-1:] = []
  1174|         0|            0|            0|  0.00%|            return ''.join(comments)
  1175|         0|            0|            0|  0.00%|
  1176|         0|            0|            0|  0.00%|class EndOfBlock(Exception): pass
  1177|         0|            0|            0|  0.00%|
  1178|         0|            0|            0|  0.00%|class BlockFinder:
  1179|         0|            0|            0|  0.00%|    """Provide a tokeneater() method to detect the end of a code block."""
  1180|         0|            0|            0|  0.00%|    def __init__(self):
  1181|         0|            0|            0|  0.00%|        self.indent = 0
  1182|         0|            0|            0|  0.00%|        self.islambda = False
  1183|         0|            0|            0|  0.00%|        self.started = False
  1184|         0|            0|            0|  0.00%|        self.passline = False
  1185|         0|            0|            0|  0.00%|        self.indecorator = False
  1186|         0|            0|            0|  0.00%|        self.last = 1
  1187|         0|            0|            0|  0.00%|        self.body_col0 = None
  1188|         0|            0|            0|  0.00%|
  1189|         0|            0|            0|  0.00%|    def tokeneater(self, type, token, srowcol, erowcol, line):
  1190|         0|            0|            0|  0.00%|        if not self.started and not self.indecorator:
  1191|         0|            0|            0|  0.00%|            # skip any decorators
  1192|         0|            0|            0|  0.00%|            if token == "@":
  1193|         0|            0|            0|  0.00%|                self.indecorator = True
  1194|         0|            0|            0|  0.00%|            # look for the first "def", "class" or "lambda"
  1195|         0|            0|            0|  0.00%|            elif token in ("def", "class", "lambda"):
  1196|         0|            0|            0|  0.00%|                if token == "lambda":
  1197|         0|            0|            0|  0.00%|                    self.islambda = True
  1198|         0|            0|            0|  0.00%|                self.started = True
  1199|         0|            0|            0|  0.00%|            self.passline = True    # skip to the end of the line
  1200|         0|            0|            0|  0.00%|        elif type == tokenize.NEWLINE:
  1201|         0|            0|            0|  0.00%|            self.passline = False   # stop skipping when a NEWLINE is seen
  1202|         0|            0|            0|  0.00%|            self.last = srowcol[0]
  1203|         0|            0|            0|  0.00%|            if self.islambda:       # lambdas always end at the first NEWLINE
  1204|         0|            0|            0|  0.00%|                raise EndOfBlock
  1205|         0|            0|            0|  0.00%|            # hitting a NEWLINE when in a decorator without args
  1206|         0|            0|            0|  0.00%|            # ends the decorator
  1207|         0|            0|            0|  0.00%|            if self.indecorator:
  1208|         0|            0|            0|  0.00%|                self.indecorator = False
  1209|         0|            0|            0|  0.00%|        elif self.passline:
  1210|         0|            0|            0|  0.00%|            pass
  1211|         0|            0|            0|  0.00%|        elif type == tokenize.INDENT:
  1212|         0|            0|            0|  0.00%|            if self.body_col0 is None and self.started:
  1213|         0|            0|            0|  0.00%|                self.body_col0 = erowcol[1]
  1214|         0|            0|            0|  0.00%|            self.indent = self.indent + 1
  1215|         0|            0|            0|  0.00%|            self.passline = True
  1216|         0|            0|            0|  0.00%|        elif type == tokenize.DEDENT:
  1217|         0|            0|            0|  0.00%|            self.indent = self.indent - 1
  1218|         0|            0|            0|  0.00%|            # the end of matching indent/dedent pairs end a block
  1219|         0|            0|            0|  0.00%|            # (note that this only works for "def"/"class" blocks,
  1220|         0|            0|            0|  0.00%|            #  not e.g. for "if: else:" or "try: finally:" blocks)
  1221|         0|            0|            0|  0.00%|            if self.indent <= 0:
  1222|         0|            0|            0|  0.00%|                raise EndOfBlock
  1223|         0|            0|            0|  0.00%|        elif type == tokenize.COMMENT:
  1224|         0|            0|            0|  0.00%|            if self.body_col0 is not None and srowcol[1] >= self.body_col0:
  1225|         0|            0|            0|  0.00%|                # Include comments if indented at least as much as the block
  1226|         0|            0|            0|  0.00%|                self.last = srowcol[0]
  1227|         0|            0|            0|  0.00%|        elif self.indent == 0 and type not in (tokenize.COMMENT, tokenize.NL):
  1228|         0|            0|            0|  0.00%|            # any other token on the same indentation level end the previous
  1229|         0|            0|            0|  0.00%|            # block as well, except the pseudo-tokens COMMENT and NL.
  1230|         0|            0|            0|  0.00%|            raise EndOfBlock
  1231|         0|            0|            0|  0.00%|
  1232|         0|            0|            0|  0.00%|def getblock(lines):
  1233|         0|            0|            0|  0.00%|    """Extract the block of code at the top of the given list of lines."""
  1234|         0|            0|            0|  0.00%|    blockfinder = BlockFinder()
  1235|         0|            0|            0|  0.00%|    try:
  1236|         0|            0|            0|  0.00%|        tokens = tokenize.generate_tokens(iter(lines).__next__)
  1237|         0|            0|            0|  0.00%|        for _token in tokens:
  1238|         0|            0|            0|  0.00%|            blockfinder.tokeneater(*_token)
  1239|         0|            0|            0|  0.00%|    except (EndOfBlock, IndentationError):
  1240|         0|            0|            0|  0.00%|        pass
  1241|         0|            0|            0|  0.00%|    except SyntaxError as e:
  1242|         0|            0|            0|  0.00%|        if "unmatched" not in e.msg:
  1243|         0|            0|            0|  0.00%|            raise e from None
  1244|         0|            0|            0|  0.00%|        _, *_token_info = _token
  1245|         0|            0|            0|  0.00%|        try:
  1246|         0|            0|            0|  0.00%|            blockfinder.tokeneater(tokenize.NEWLINE, *_token_info)
  1247|         0|            0|            0|  0.00%|        except (EndOfBlock, IndentationError):
  1248|         0|            0|            0|  0.00%|            pass
  1249|         0|            0|            0|  0.00%|    return lines[:blockfinder.last]
  1250|         0|            0|            0|  0.00%|
  1251|         0|            0|            0|  0.00%|def getsourcelines(object):
  1252|         0|            0|            0|  0.00%|    """Return a list of source lines and starting line number for an object.
  1253|         0|            0|            0|  0.00%|
  1254|         0|            0|            0|  0.00%|    The argument may be a module, class, method, function, traceback, frame,
  1255|         0|            0|            0|  0.00%|    or code object.  The source code is returned as a list of the lines
  1256|         0|            0|            0|  0.00%|    corresponding to the object and the line number indicates where in the
  1257|         0|            0|            0|  0.00%|    original source file the first line of code was found.  An OSError is
  1258|         0|            0|            0|  0.00%|    raised if the source code cannot be retrieved."""
  1259|         0|            0|            0|  0.00%|    object = unwrap(object)
  1260|         0|            0|            0|  0.00%|    lines, lnum = findsource(object)
  1261|         0|            0|            0|  0.00%|
  1262|         0|            0|            0|  0.00%|    if istraceback(object):
  1263|         0|            0|            0|  0.00%|        object = object.tb_frame
  1264|         0|            0|            0|  0.00%|
  1265|         0|            0|            0|  0.00%|    # for module or frame that corresponds to module, return all source lines
  1266|         0|            0|            0|  0.00%|    if (ismodule(object) or
  1267|         0|            0|            0|  0.00%|        (isframe(object) and object.f_code.co_name == "<module>")):
  1268|         0|            0|            0|  0.00%|        return lines, 0
  1269|         0|            0|            0|  0.00%|    else:
  1270|         0|            0|            0|  0.00%|        return getblock(lines[lnum:]), lnum + 1
  1271|         0|            0|            0|  0.00%|
  1272|         0|            0|            0|  0.00%|def getsource(object):
  1273|         0|            0|            0|  0.00%|    """Return the text of the source code for an object.
  1274|         0|            0|            0|  0.00%|
  1275|         0|            0|            0|  0.00%|    The argument may be a module, class, method, function, traceback, frame,
  1276|         0|            0|            0|  0.00%|    or code object.  The source code is returned as a single string.  An
  1277|         0|            0|            0|  0.00%|    OSError is raised if the source code cannot be retrieved."""
  1278|         0|            0|            0|  0.00%|    lines, lnum = getsourcelines(object)
  1279|         0|            0|            0|  0.00%|    return ''.join(lines)
  1280|         0|            0|            0|  0.00%|
  1281|         0|            0|            0|  0.00%|# --------------------------------------------------- class tree extraction
  1282|         0|            0|            0|  0.00%|def walktree(classes, children, parent):
  1283|         0|            0|            0|  0.00%|    """Recursive helper function for getclasstree()."""
  1284|         0|            0|            0|  0.00%|    results = []
  1285|         0|            0|            0|  0.00%|    classes.sort(key=attrgetter('__module__', '__name__'))
  1286|         0|            0|            0|  0.00%|    for c in classes:
  1287|         0|            0|            0|  0.00%|        results.append((c, c.__bases__))
  1288|         0|            0|            0|  0.00%|        if c in children:
  1289|         0|            0|            0|  0.00%|            results.append(walktree(children[c], children, c))
  1290|         0|            0|            0|  0.00%|    return results
  1291|         0|            0|            0|  0.00%|
  1292|         0|            0|            0|  0.00%|def getclasstree(classes, unique=False):
  1293|         0|            0|            0|  0.00%|    """Arrange the given list of classes into a hierarchy of nested lists.
  1294|         0|            0|            0|  0.00%|
  1295|         0|            0|            0|  0.00%|    Where a nested list appears, it contains classes derived from the class
  1296|         0|            0|            0|  0.00%|    whose entry immediately precedes the list.  Each entry is a 2-tuple
  1297|         0|            0|            0|  0.00%|    containing a class and a tuple of its base classes.  If the 'unique'
  1298|         0|            0|            0|  0.00%|    argument is true, exactly one entry appears in the returned structure
  1299|         0|            0|            0|  0.00%|    for each class in the given list.  Otherwise, classes using multiple
  1300|         0|            0|            0|  0.00%|    inheritance and their descendants will appear multiple times."""
  1301|         0|            0|            0|  0.00%|    children = {}
  1302|         0|            0|            0|  0.00%|    roots = []
  1303|         0|            0|            0|  0.00%|    for c in classes:
  1304|         0|            0|            0|  0.00%|        if c.__bases__:
  1305|         0|            0|            0|  0.00%|            for parent in c.__bases__:
  1306|         0|            0|            0|  0.00%|                if parent not in children:
  1307|         0|            0|            0|  0.00%|                    children[parent] = []
  1308|         0|            0|            0|  0.00%|                if c not in children[parent]:
  1309|         0|            0|            0|  0.00%|                    children[parent].append(c)
  1310|         0|            0|            0|  0.00%|                if unique and parent in classes: break
  1311|         0|            0|            0|  0.00%|        elif c not in roots:
  1312|         0|            0|            0|  0.00%|            roots.append(c)
  1313|         0|            0|            0|  0.00%|    for parent in children:
  1314|         0|            0|            0|  0.00%|        if parent not in classes:
  1315|         0|            0|            0|  0.00%|            roots.append(parent)
  1316|         0|            0|            0|  0.00%|    return walktree(roots, children, None)
  1317|         0|            0|            0|  0.00%|
  1318|         0|            0|            0|  0.00%|# ------------------------------------------------ argument list extraction
  1319|         0|            0|            0|  0.00%|Arguments = namedtuple('Arguments', 'args, varargs, varkw')
  1320|         0|            0|            0|  0.00%|
  1321|         0|            0|            0|  0.00%|def getargs(co):
  1322|         0|            0|            0|  0.00%|    """Get information about the arguments accepted by a code object.
  1323|         0|            0|            0|  0.00%|
  1324|         0|            0|            0|  0.00%|    Three things are returned: (args, varargs, varkw), where
  1325|         0|            0|            0|  0.00%|    'args' is the list of argument names. Keyword-only arguments are
  1326|         0|            0|            0|  0.00%|    appended. 'varargs' and 'varkw' are the names of the * and **
  1327|         0|            0|            0|  0.00%|    arguments or None."""
  1328|         0|            0|            0|  0.00%|    if not iscode(co):
  1329|         0|            0|            0|  0.00%|        raise TypeError('{!r} is not a code object'.format(co))
  1330|         0|            0|            0|  0.00%|
  1331|         0|            0|            0|  0.00%|    names = co.co_varnames
  1332|         0|            0|            0|  0.00%|    nargs = co.co_argcount
  1333|         0|            0|            0|  0.00%|    nkwargs = co.co_kwonlyargcount
  1334|         0|            0|            0|  0.00%|    args = list(names[:nargs])
  1335|         0|            0|            0|  0.00%|    kwonlyargs = list(names[nargs:nargs+nkwargs])
  1336|         0|            0|            0|  0.00%|
  1337|         0|            0|            0|  0.00%|    nargs += nkwargs
  1338|         0|            0|            0|  0.00%|    varargs = None
  1339|         0|            0|            0|  0.00%|    if co.co_flags & CO_VARARGS:
  1340|         0|            0|            0|  0.00%|        varargs = co.co_varnames[nargs]
  1341|         0|            0|            0|  0.00%|        nargs = nargs + 1
  1342|         0|            0|            0|  0.00%|    varkw = None
  1343|         0|            0|            0|  0.00%|    if co.co_flags & CO_VARKEYWORDS:
  1344|         0|            0|            0|  0.00%|        varkw = co.co_varnames[nargs]
  1345|         0|            0|            0|  0.00%|    return Arguments(args + kwonlyargs, varargs, varkw)
  1346|         0|            0|            0|  0.00%|
  1347|         0|            0|            0|  0.00%|
  1348|         0|            0|            0|  0.00%|FullArgSpec = namedtuple('FullArgSpec',
  1349|         0|            0|            0|  0.00%|    'args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations')
  1350|         0|            0|            0|  0.00%|
  1351|         0|            0|            0|  0.00%|def getfullargspec(func):
  1352|         0|            0|            0|  0.00%|    """Get the names and default values of a callable object's parameters.
  1353|         0|            0|            0|  0.00%|
  1354|         0|            0|            0|  0.00%|    A tuple of seven things is returned:
  1355|         0|            0|            0|  0.00%|    (args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations).
  1356|         0|            0|            0|  0.00%|    'args' is a list of the parameter names.
  1357|         0|            0|            0|  0.00%|    'varargs' and 'varkw' are the names of the * and ** parameters or None.
  1358|         0|            0|            0|  0.00%|    'defaults' is an n-tuple of the default values of the last n parameters.
  1359|         0|            0|            0|  0.00%|    'kwonlyargs' is a list of keyword-only parameter names.
  1360|         0|            0|            0|  0.00%|    'kwonlydefaults' is a dictionary mapping names from kwonlyargs to defaults.
  1361|         0|            0|            0|  0.00%|    'annotations' is a dictionary mapping parameter names to annotations.
  1362|         0|            0|            0|  0.00%|
  1363|         0|            0|            0|  0.00%|    Notable differences from inspect.signature():
  1364|         0|            0|            0|  0.00%|      - the "self" parameter is always reported, even for bound methods
  1365|         0|            0|            0|  0.00%|      - wrapper chains defined by __wrapped__ *not* unwrapped automatically
  1366|         0|            0|            0|  0.00%|    """
  1367|         0|            0|            0|  0.00%|    try:
  1368|         0|            0|            0|  0.00%|        # Re: `skip_bound_arg=False`
  1369|         0|            0|            0|  0.00%|        #
  1370|         0|            0|            0|  0.00%|        # There is a notable difference in behaviour between getfullargspec
  1371|         0|            0|            0|  0.00%|        # and Signature: the former always returns 'self' parameter for bound
  1372|         0|            0|            0|  0.00%|        # methods, whereas the Signature always shows the actual calling
  1373|         0|            0|            0|  0.00%|        # signature of the passed object.
  1374|         0|            0|            0|  0.00%|        #
  1375|         0|            0|            0|  0.00%|        # To simulate this behaviour, we "unbind" bound methods, to trick
  1376|         0|            0|            0|  0.00%|        # inspect.signature to always return their first parameter ("self",
  1377|         0|            0|            0|  0.00%|        # usually)
  1378|         0|            0|            0|  0.00%|
  1379|         0|            0|            0|  0.00%|        # Re: `follow_wrapper_chains=False`
  1380|         0|            0|            0|  0.00%|        #
  1381|         0|            0|            0|  0.00%|        # getfullargspec() historically ignored __wrapped__ attributes,
  1382|         0|            0|            0|  0.00%|        # so we ensure that remains the case in 3.3+
  1383|         0|            0|            0|  0.00%|
  1384|         0|            0|            0|  0.00%|        sig = _signature_from_callable(func,
  1385|         0|            0|            0|  0.00%|                                       follow_wrapper_chains=False,
  1386|         0|            0|            0|  0.00%|                                       skip_bound_arg=False,
  1387|         0|            0|            0|  0.00%|                                       sigcls=Signature,
  1388|         0|            0|            0|  0.00%|                                       eval_str=False)
  1389|         0|            0|            0|  0.00%|    except Exception as ex:
  1390|         0|            0|            0|  0.00%|        # Most of the times 'signature' will raise ValueError.
  1391|         0|            0|            0|  0.00%|        # But, it can also raise AttributeError, and, maybe something
  1392|         0|            0|            0|  0.00%|        # else. So to be fully backwards compatible, we catch all
  1393|         0|            0|            0|  0.00%|        # possible exceptions here, and reraise a TypeError.
  1394|         0|            0|            0|  0.00%|        raise TypeError('unsupported callable') from ex
  1395|         0|            0|            0|  0.00%|
  1396|         0|            0|            0|  0.00%|    args = []
  1397|         0|            0|            0|  0.00%|    varargs = None
  1398|         0|            0|            0|  0.00%|    varkw = None
  1399|         0|            0|            0|  0.00%|    posonlyargs = []
  1400|         0|            0|            0|  0.00%|    kwonlyargs = []
  1401|         0|            0|            0|  0.00%|    annotations = {}
  1402|         0|            0|            0|  0.00%|    defaults = ()
  1403|         0|            0|            0|  0.00%|    kwdefaults = {}
  1404|         0|            0|            0|  0.00%|
  1405|         0|            0|            0|  0.00%|    if sig.return_annotation is not sig.empty:
  1406|         0|            0|            0|  0.00%|        annotations['return'] = sig.return_annotation
  1407|         0|            0|            0|  0.00%|
  1408|         0|            0|            0|  0.00%|    for param in sig.parameters.values():
  1409|         0|            0|            0|  0.00%|        kind = param.kind
  1410|         0|            0|            0|  0.00%|        name = param.name
  1411|         0|            0|            0|  0.00%|
  1412|         0|            0|            0|  0.00%|        if kind is _POSITIONAL_ONLY:
  1413|         0|            0|            0|  0.00%|            posonlyargs.append(name)
  1414|         0|            0|            0|  0.00%|            if param.default is not param.empty:
  1415|         0|            0|            0|  0.00%|                defaults += (param.default,)
  1416|         0|            0|            0|  0.00%|        elif kind is _POSITIONAL_OR_KEYWORD:
  1417|         0|            0|            0|  0.00%|            args.append(name)
  1418|         0|            0|            0|  0.00%|            if param.default is not param.empty:
  1419|         0|            0|            0|  0.00%|                defaults += (param.default,)
  1420|         0|            0|            0|  0.00%|        elif kind is _VAR_POSITIONAL:
  1421|         0|            0|            0|  0.00%|            varargs = name
  1422|         0|            0|            0|  0.00%|        elif kind is _KEYWORD_ONLY:
  1423|         0|            0|            0|  0.00%|            kwonlyargs.append(name)
  1424|         0|            0|            0|  0.00%|            if param.default is not param.empty:
  1425|         0|            0|            0|  0.00%|                kwdefaults[name] = param.default
  1426|         0|            0|            0|  0.00%|        elif kind is _VAR_KEYWORD:
  1427|         0|            0|            0|  0.00%|            varkw = name
  1428|         0|            0|            0|  0.00%|
  1429|         0|            0|            0|  0.00%|        if param.annotation is not param.empty:
  1430|         0|            0|            0|  0.00%|            annotations[name] = param.annotation
  1431|         0|            0|            0|  0.00%|
  1432|         0|            0|            0|  0.00%|    if not kwdefaults:
  1433|         0|            0|            0|  0.00%|        # compatibility with 'func.__kwdefaults__'
  1434|         0|            0|            0|  0.00%|        kwdefaults = None
  1435|         0|            0|            0|  0.00%|
  1436|         0|            0|            0|  0.00%|    if not defaults:
  1437|         0|            0|            0|  0.00%|        # compatibility with 'func.__defaults__'
  1438|         0|            0|            0|  0.00%|        defaults = None
  1439|         0|            0|            0|  0.00%|
  1440|         0|            0|            0|  0.00%|    return FullArgSpec(posonlyargs + args, varargs, varkw, defaults,
  1441|         0|            0|            0|  0.00%|                       kwonlyargs, kwdefaults, annotations)
  1442|         0|            0|            0|  0.00%|
  1443|         0|            0|            0|  0.00%|
  1444|         0|            0|            0|  0.00%|ArgInfo = namedtuple('ArgInfo', 'args varargs keywords locals')
  1445|         0|            0|            0|  0.00%|
  1446|         0|            0|            0|  0.00%|def getargvalues(frame):
  1447|         0|            0|            0|  0.00%|    """Get information about arguments passed into a particular frame.
  1448|         0|            0|            0|  0.00%|
  1449|         0|            0|            0|  0.00%|    A tuple of four things is returned: (args, varargs, varkw, locals).
  1450|         0|            0|            0|  0.00%|    'args' is a list of the argument names.
  1451|         0|            0|            0|  0.00%|    'varargs' and 'varkw' are the names of the * and ** arguments or None.
  1452|         0|            0|            0|  0.00%|    'locals' is the locals dictionary of the given frame."""
  1453|         0|            0|            0|  0.00%|    args, varargs, varkw = getargs(frame.f_code)
  1454|         0|            0|            0|  0.00%|    return ArgInfo(args, varargs, varkw, frame.f_locals)
  1455|         0|            0|            0|  0.00%|
  1456|         0|            0|            0|  0.00%|def formatannotation(annotation, base_module=None):
  1457|         0|            0|            0|  0.00%|    if getattr(annotation, '__module__', None) == 'typing':
  1458|         0|            0|            0|  0.00%|        def repl(match):
  1459|         0|            0|            0|  0.00%|            text = match.group()
  1460|         0|            0|            0|  0.00%|            return text.removeprefix('typing.')
  1461|         0|            0|            0|  0.00%|        return re.sub(r'[\w\.]+', repl, repr(annotation))
  1462|         0|            0|            0|  0.00%|    if isinstance(annotation, types.GenericAlias):
  1463|         0|            0|            0|  0.00%|        return str(annotation)
  1464|         0|            0|            0|  0.00%|    if isinstance(annotation, type):
  1465|         0|            0|            0|  0.00%|        if annotation.__module__ in ('builtins', base_module):
  1466|         0|            0|            0|  0.00%|            return annotation.__qualname__
  1467|         0|            0|            0|  0.00%|        return annotation.__module__+'.'+annotation.__qualname__
  1468|         0|            0|            0|  0.00%|    return repr(annotation)
  1469|         0|            0|            0|  0.00%|
  1470|         0|            0|            0|  0.00%|def formatannotationrelativeto(object):
  1471|         0|            0|            0|  0.00%|    module = getattr(object, '__module__', None)
  1472|         0|            0|            0|  0.00%|    def _formatannotation(annotation):
  1473|         0|            0|            0|  0.00%|        return formatannotation(annotation, module)
  1474|         0|            0|            0|  0.00%|    return _formatannotation
  1475|         0|            0|            0|  0.00%|
  1476|         0|            0|            0|  0.00%|
  1477|         0|            0|            0|  0.00%|def formatargvalues(args, varargs, varkw, locals,
  1478|         0|            0|            0|  0.00%|                    formatarg=str,
  1479|         0|            0|            0|  0.00%|                    formatvarargs=lambda name: '*' + name,
  1480|         0|            0|            0|  0.00%|                    formatvarkw=lambda name: '**' + name,
  1481|         0|            0|            0|  0.00%|                    formatvalue=lambda value: '=' + repr(value)):
  1482|         0|            0|            0|  0.00%|    """Format an argument spec from the 4 values returned by getargvalues.
  1483|         0|            0|            0|  0.00%|
  1484|         0|            0|            0|  0.00%|    The first four arguments are (args, varargs, varkw, locals).  The
  1485|         0|            0|            0|  0.00%|    next four arguments are the corresponding optional formatting functions
  1486|         0|            0|            0|  0.00%|    that are called to turn names and values into strings.  The ninth
  1487|         0|            0|            0|  0.00%|    argument is an optional function to format the sequence of arguments."""
  1488|         0|            0|            0|  0.00%|    def convert(name, locals=locals,
  1489|         0|            0|            0|  0.00%|                formatarg=formatarg, formatvalue=formatvalue):
  1490|         0|            0|            0|  0.00%|        return formatarg(name) + formatvalue(locals[name])
  1491|         0|            0|            0|  0.00%|    specs = []
  1492|         0|            0|            0|  0.00%|    for i in range(len(args)):
  1493|         0|            0|            0|  0.00%|        specs.append(convert(args[i]))
  1494|         0|            0|            0|  0.00%|    if varargs:
  1495|         0|            0|            0|  0.00%|        specs.append(formatvarargs(varargs) + formatvalue(locals[varargs]))
  1496|         0|            0|            0|  0.00%|    if varkw:
  1497|         0|            0|            0|  0.00%|        specs.append(formatvarkw(varkw) + formatvalue(locals[varkw]))
  1498|         0|            0|            0|  0.00%|    return '(' + ', '.join(specs) + ')'
  1499|         0|            0|            0|  0.00%|
  1500|         0|            0|            0|  0.00%|def _missing_arguments(f_name, argnames, pos, values):
  1501|         0|            0|            0|  0.00%|    names = [repr(name) for name in argnames if name not in values]
  1502|         0|            0|            0|  0.00%|    missing = len(names)
  1503|         0|            0|            0|  0.00%|    if missing == 1:
  1504|         0|            0|            0|  0.00%|        s = names[0]
  1505|         0|            0|            0|  0.00%|    elif missing == 2:
  1506|         0|            0|            0|  0.00%|        s = "{} and {}".format(*names)
  1507|         0|            0|            0|  0.00%|    else:
  1508|         0|            0|            0|  0.00%|        tail = ", {} and {}".format(*names[-2:])
  1509|         0|            0|            0|  0.00%|        del names[-2:]
  1510|         0|            0|            0|  0.00%|        s = ", ".join(names) + tail
  1511|         0|            0|            0|  0.00%|    raise TypeError("%s() missing %i required %s argument%s: %s" %
  1512|         0|            0|            0|  0.00%|                    (f_name, missing,
  1513|         0|            0|            0|  0.00%|                      "positional" if pos else "keyword-only",
  1514|         0|            0|            0|  0.00%|                      "" if missing == 1 else "s", s))
  1515|         0|            0|            0|  0.00%|
  1516|         0|            0|            0|  0.00%|def _too_many(f_name, args, kwonly, varargs, defcount, given, values):
  1517|         0|            0|            0|  0.00%|    atleast = len(args) - defcount
  1518|         0|            0|            0|  0.00%|    kwonly_given = len([arg for arg in kwonly if arg in values])
  1519|         0|            0|            0|  0.00%|    if varargs:
  1520|         0|            0|            0|  0.00%|        plural = atleast != 1
  1521|         0|            0|            0|  0.00%|        sig = "at least %d" % (atleast,)
  1522|         0|            0|            0|  0.00%|    elif defcount:
  1523|         0|            0|            0|  0.00%|        plural = True
  1524|         0|            0|            0|  0.00%|        sig = "from %d to %d" % (atleast, len(args))
  1525|         0|            0|            0|  0.00%|    else:
  1526|         0|            0|            0|  0.00%|        plural = len(args) != 1
  1527|         0|            0|            0|  0.00%|        sig = str(len(args))
  1528|         0|            0|            0|  0.00%|    kwonly_sig = ""
  1529|         0|            0|            0|  0.00%|    if kwonly_given:
  1530|         0|            0|            0|  0.00%|        msg = " positional argument%s (and %d keyword-only argument%s)"
  1531|         0|            0|            0|  0.00%|        kwonly_sig = (msg % ("s" if given != 1 else "", kwonly_given,
  1532|         0|            0|            0|  0.00%|                             "s" if kwonly_given != 1 else ""))
  1533|         0|            0|            0|  0.00%|    raise TypeError("%s() takes %s positional argument%s but %d%s %s given" %
  1534|         0|            0|            0|  0.00%|            (f_name, sig, "s" if plural else "", given, kwonly_sig,
  1535|         0|            0|            0|  0.00%|             "was" if given == 1 and not kwonly_given else "were"))
  1536|         0|            0|            0|  0.00%|
  1537|         0|            0|            0|  0.00%|def getcallargs(func, /, *positional, **named):
  1538|         0|            0|            0|  0.00%|    """Get the mapping of arguments to values.
  1539|         0|            0|            0|  0.00%|
  1540|         0|            0|            0|  0.00%|    A dict is returned, with keys the function argument names (including the
  1541|         0|            0|            0|  0.00%|    names of the * and ** arguments, if any), and values the respective bound
  1542|         0|            0|            0|  0.00%|    values from 'positional' and 'named'."""
  1543|         0|            0|            0|  0.00%|    spec = getfullargspec(func)
  1544|         0|            0|            0|  0.00%|    args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, ann = spec
  1545|         0|            0|            0|  0.00%|    f_name = func.__name__
  1546|         0|            0|            0|  0.00%|    arg2value = {}
  1547|         0|            0|            0|  0.00%|
  1548|         0|            0|            0|  0.00%|
  1549|         0|            0|            0|  0.00%|    if ismethod(func) and func.__self__ is not None:
  1550|         0|            0|            0|  0.00%|        # implicit 'self' (or 'cls' for classmethods) argument
  1551|         0|            0|            0|  0.00%|        positional = (func.__self__,) + positional
  1552|         0|            0|            0|  0.00%|    num_pos = len(positional)
  1553|         0|            0|            0|  0.00%|    num_args = len(args)
  1554|         0|            0|            0|  0.00%|    num_defaults = len(defaults) if defaults else 0
  1555|         0|            0|            0|  0.00%|
  1556|         0|            0|            0|  0.00%|    n = min(num_pos, num_args)
  1557|         0|            0|            0|  0.00%|    for i in range(n):
  1558|         0|            0|            0|  0.00%|        arg2value[args[i]] = positional[i]
  1559|         0|            0|            0|  0.00%|    if varargs:
  1560|         0|            0|            0|  0.00%|        arg2value[varargs] = tuple(positional[n:])
  1561|         0|            0|            0|  0.00%|    possible_kwargs = set(args + kwonlyargs)
  1562|         0|            0|            0|  0.00%|    if varkw:
  1563|         0|            0|            0|  0.00%|        arg2value[varkw] = {}
  1564|         0|            0|            0|  0.00%|    for kw, value in named.items():
  1565|         0|            0|            0|  0.00%|        if kw not in possible_kwargs:
  1566|         0|            0|            0|  0.00%|            if not varkw:
  1567|         0|            0|            0|  0.00%|                raise TypeError("%s() got an unexpected keyword argument %r" %
  1568|         0|            0|            0|  0.00%|                                (f_name, kw))
  1569|         0|            0|            0|  0.00%|            arg2value[varkw][kw] = value
  1570|         0|            0|            0|  0.00%|            continue
  1571|         0|            0|            0|  0.00%|        if kw in arg2value:
  1572|         0|            0|            0|  0.00%|            raise TypeError("%s() got multiple values for argument %r" %
  1573|         0|            0|            0|  0.00%|                            (f_name, kw))
  1574|         0|            0|            0|  0.00%|        arg2value[kw] = value
  1575|         0|            0|            0|  0.00%|    if num_pos > num_args and not varargs:
  1576|         0|            0|            0|  0.00%|        _too_many(f_name, args, kwonlyargs, varargs, num_defaults,
  1577|         0|            0|            0|  0.00%|                   num_pos, arg2value)
  1578|         0|            0|            0|  0.00%|    if num_pos < num_args:
  1579|         0|            0|            0|  0.00%|        req = args[:num_args - num_defaults]
  1580|         0|            0|            0|  0.00%|        for arg in req:
  1581|         0|            0|            0|  0.00%|            if arg not in arg2value:
  1582|         0|            0|            0|  0.00%|                _missing_arguments(f_name, req, True, arg2value)
  1583|         0|            0|            0|  0.00%|        for i, arg in enumerate(args[num_args - num_defaults:]):
  1584|         0|            0|            0|  0.00%|            if arg not in arg2value:
  1585|         0|            0|            0|  0.00%|                arg2value[arg] = defaults[i]
  1586|         0|            0|            0|  0.00%|    missing = 0
  1587|         0|            0|            0|  0.00%|    for kwarg in kwonlyargs:
  1588|         0|            0|            0|  0.00%|        if kwarg not in arg2value:
  1589|         0|            0|            0|  0.00%|            if kwonlydefaults and kwarg in kwonlydefaults:
  1590|         0|            0|            0|  0.00%|                arg2value[kwarg] = kwonlydefaults[kwarg]
  1591|         0|            0|            0|  0.00%|            else:
  1592|         0|            0|            0|  0.00%|                missing += 1
  1593|         0|            0|            0|  0.00%|    if missing:
  1594|         0|            0|            0|  0.00%|        _missing_arguments(f_name, kwonlyargs, False, arg2value)
  1595|         0|            0|            0|  0.00%|    return arg2value
  1596|         0|            0|            0|  0.00%|
  1597|         0|            0|            0|  0.00%|ClosureVars = namedtuple('ClosureVars', 'nonlocals globals builtins unbound')
  1598|         0|            0|            0|  0.00%|
  1599|         0|            0|            0|  0.00%|def getclosurevars(func):
  1600|         0|            0|            0|  0.00%|    """
  1601|         0|            0|            0|  0.00%|    Get the mapping of free variables to their current values.
  1602|         0|            0|            0|  0.00%|
  1603|         0|            0|            0|  0.00%|    Returns a named tuple of dicts mapping the current nonlocal, global
  1604|         0|            0|            0|  0.00%|    and builtin references as seen by the body of the function. A final
  1605|         0|            0|            0|  0.00%|    set of unbound names that could not be resolved is also provided.
  1606|         0|            0|            0|  0.00%|    """
  1607|         0|            0|            0|  0.00%|
  1608|         0|            0|            0|  0.00%|    if ismethod(func):
  1609|         0|            0|            0|  0.00%|        func = func.__func__
  1610|         0|            0|            0|  0.00%|
  1611|         0|            0|            0|  0.00%|    if not isfunction(func):
  1612|         0|            0|            0|  0.00%|        raise TypeError("{!r} is not a Python function".format(func))
  1613|         0|            0|            0|  0.00%|
  1614|         0|            0|            0|  0.00%|    code = func.__code__
  1615|         0|            0|            0|  0.00%|    # Nonlocal references are named in co_freevars and resolved
  1616|         0|            0|            0|  0.00%|    # by looking them up in __closure__ by positional index
  1617|         0|            0|            0|  0.00%|    if func.__closure__ is None:
  1618|         0|            0|            0|  0.00%|        nonlocal_vars = {}
  1619|         0|            0|            0|  0.00%|    else:
  1620|         0|            0|            0|  0.00%|        nonlocal_vars = {
  1621|         0|            0|            0|  0.00%|            var : cell.cell_contents
  1622|         0|            0|            0|  0.00%|            for var, cell in zip(code.co_freevars, func.__closure__)
  1623|         0|            0|            0|  0.00%|       }
  1624|         0|            0|            0|  0.00%|
  1625|         0|            0|            0|  0.00%|    # Global and builtin references are named in co_names and resolved
  1626|         0|            0|            0|  0.00%|    # by looking them up in __globals__ or __builtins__
  1627|         0|            0|            0|  0.00%|    global_ns = func.__globals__
  1628|         0|            0|            0|  0.00%|    builtin_ns = global_ns.get("__builtins__", builtins.__dict__)
  1629|         0|            0|            0|  0.00%|    if ismodule(builtin_ns):
  1630|         0|            0|            0|  0.00%|        builtin_ns = builtin_ns.__dict__
  1631|         0|            0|            0|  0.00%|    global_vars = {}
  1632|         0|            0|            0|  0.00%|    builtin_vars = {}
  1633|         0|            0|            0|  0.00%|    unbound_names = set()
  1634|         0|            0|            0|  0.00%|    for name in code.co_names:
  1635|         0|            0|            0|  0.00%|        if name in ("None", "True", "False"):
  1636|         0|            0|            0|  0.00%|            # Because these used to be builtins instead of keywords, they
  1637|         0|            0|            0|  0.00%|            # may still show up as name references. We ignore them.
  1638|         0|            0|            0|  0.00%|            continue
  1639|         0|            0|            0|  0.00%|        try:
  1640|         0|            0|            0|  0.00%|            global_vars[name] = global_ns[name]
  1641|         0|            0|            0|  0.00%|        except KeyError:
  1642|         0|            0|            0|  0.00%|            try:
  1643|         0|            0|            0|  0.00%|                builtin_vars[name] = builtin_ns[name]
  1644|         0|            0|            0|  0.00%|            except KeyError:
  1645|         0|            0|            0|  0.00%|                unbound_names.add(name)
  1646|         0|            0|            0|  0.00%|
  1647|         0|            0|            0|  0.00%|    return ClosureVars(nonlocal_vars, global_vars,
  1648|         0|            0|            0|  0.00%|                       builtin_vars, unbound_names)
  1649|         0|            0|            0|  0.00%|
  1650|         0|            0|            0|  0.00%|# -------------------------------------------------- stack frame extraction
  1651|         0|            0|            0|  0.00%|
  1652|         0|            0|            0|  0.00%|_Traceback = namedtuple('_Traceback', 'filename lineno function code_context index')
  1653|         0|            0|            0|  0.00%|
  1654|         0|            0|            0|  0.00%|class Traceback(_Traceback):
  1655|         0|            0|            0|  0.00%|    def __new__(cls, filename, lineno, function, code_context, index, *, positions=None):
  1656|         0|            0|            0|  0.00%|        instance = super().__new__(cls, filename, lineno, function, code_context, index)
  1657|         0|            0|            0|  0.00%|        instance.positions = positions
  1658|         0|            0|            0|  0.00%|        return instance
  1659|         0|            0|            0|  0.00%|
  1660|         0|            0|            0|  0.00%|    def __repr__(self):
  1661|         0|            0|            0|  0.00%|        return ('Traceback(filename={!r}, lineno={!r}, function={!r}, '
  1662|         0|            0|            0|  0.00%|               'code_context={!r}, index={!r}, positions={!r})'.format(
  1663|         0|            0|            0|  0.00%|                self.filename, self.lineno, self.function, self.code_context,
  1664|         0|            0|            0|  0.00%|                self.index, self.positions))
  1665|         0|            0|            0|  0.00%|
  1666|         0|            0|            0|  0.00%|def _get_code_position_from_tb(tb):
  1667|         0|            0|            0|  0.00%|    code, instruction_index = tb.tb_frame.f_code, tb.tb_lasti
  1668|         0|            0|            0|  0.00%|    return _get_code_position(code, instruction_index)
  1669|         0|            0|            0|  0.00%|
  1670|         0|            0|            0|  0.00%|def _get_code_position(code, instruction_index):
  1671|         0|            0|            0|  0.00%|    if instruction_index < 0:
  1672|         0|            0|            0|  0.00%|        return (None, None, None, None)
  1673|         0|            0|            0|  0.00%|    positions_gen = code.co_positions()
  1674|         0|            0|            0|  0.00%|    # The nth entry in code.co_positions() corresponds to instruction (2*n)th since Python 3.10+
  1675|         0|            0|            0|  0.00%|    return next(itertools.islice(positions_gen, instruction_index // 2, None))
  1676|         0|            0|            0|  0.00%|
  1677|         0|            0|            0|  0.00%|def getframeinfo(frame, context=1):
  1678|         0|            0|            0|  0.00%|    """Get information about a frame or traceback object.
  1679|         0|            0|            0|  0.00%|
  1680|         0|            0|            0|  0.00%|    A tuple of five things is returned: the filename, the line number of
  1681|         0|            0|            0|  0.00%|    the current line, the function name, a list of lines of context from
  1682|         0|            0|            0|  0.00%|    the source code, and the index of the current line within that list.
  1683|         0|            0|            0|  0.00%|    The optional second argument specifies the number of lines of context
  1684|         0|            0|            0|  0.00%|    to return, which are centered around the current line."""
  1685|         0|            0|            0|  0.00%|    if istraceback(frame):
  1686|         0|            0|            0|  0.00%|        positions = _get_code_position_from_tb(frame)
  1687|         0|            0|            0|  0.00%|        lineno = frame.tb_lineno
  1688|         0|            0|            0|  0.00%|        frame = frame.tb_frame
  1689|         0|            0|            0|  0.00%|    else:
  1690|         0|            0|            0|  0.00%|        lineno = frame.f_lineno
  1691|         0|            0|            0|  0.00%|        positions = _get_code_position(frame.f_code, frame.f_lasti)
  1692|         0|            0|            0|  0.00%|
  1693|         0|            0|            0|  0.00%|    if positions[0] is None:
  1694|         0|            0|            0|  0.00%|        frame, *positions = (frame, lineno, *positions[1:])
  1695|         0|            0|            0|  0.00%|    else:
  1696|         0|            0|            0|  0.00%|        frame, *positions = (frame, *positions)
  1697|         0|            0|            0|  0.00%|
  1698|         0|            0|            0|  0.00%|    lineno = positions[0]
  1699|         0|            0|            0|  0.00%|
  1700|         0|            0|            0|  0.00%|    if not isframe(frame):
  1701|         0|            0|            0|  0.00%|        raise TypeError('{!r} is not a frame or traceback object'.format(frame))
  1702|         0|            0|            0|  0.00%|
  1703|         0|            0|            0|  0.00%|    filename = getsourcefile(frame) or getfile(frame)
  1704|         0|            0|            0|  0.00%|    if context > 0:
  1705|         0|            0|            0|  0.00%|        start = lineno - 1 - context//2
  1706|         0|            0|            0|  0.00%|        try:
  1707|         0|            0|            0|  0.00%|            lines, lnum = findsource(frame)
  1708|         0|            0|            0|  0.00%|        except OSError:
  1709|         0|            0|            0|  0.00%|            lines = index = None
  1710|         0|            0|            0|  0.00%|        else:
  1711|         0|            0|            0|  0.00%|            start = max(0, min(start, len(lines) - context))
  1712|         0|            0|            0|  0.00%|            lines = lines[start:start+context]
  1713|         0|            0|            0|  0.00%|            index = lineno - 1 - start
  1714|         0|            0|            0|  0.00%|    else:
  1715|         0|            0|            0|  0.00%|        lines = index = None
  1716|         0|            0|            0|  0.00%|
  1717|         0|            0|            0|  0.00%|    return Traceback(filename, lineno, frame.f_code.co_name, lines,
  1718|         0|            0|            0|  0.00%|                     index, positions=dis.Positions(*positions))
  1719|         0|            0|            0|  0.00%|
  1720|         0|            0|            0|  0.00%|def getlineno(frame):
  1721|         0|            0|            0|  0.00%|    """Get the line number from a frame object, allowing for optimization."""
  1722|         0|            0|            0|  0.00%|    # FrameType.f_lineno is now a descriptor that grovels co_lnotab
  1723|         0|            0|            0|  0.00%|    return frame.f_lineno
  1724|         0|            0|            0|  0.00%|
  1725|         0|            0|            0|  0.00%|_FrameInfo = namedtuple('_FrameInfo', ('frame',) + Traceback._fields)
  1726|         0|            0|            0|  0.00%|class FrameInfo(_FrameInfo):
  1727|         0|            0|            0|  0.00%|    def __new__(cls, frame, filename, lineno, function, code_context, index, *, positions=None):
  1728|         0|            0|            0|  0.00%|        instance = super().__new__(cls, frame, filename, lineno, function, code_context, index)
  1729|         0|            0|            0|  0.00%|        instance.positions = positions
  1730|         0|            0|            0|  0.00%|        return instance
  1731|         0|            0|            0|  0.00%|
  1732|         0|            0|            0|  0.00%|    def __repr__(self):
  1733|         0|            0|            0|  0.00%|        return ('FrameInfo(frame={!r}, filename={!r}, lineno={!r}, function={!r}, '
  1734|         0|            0|            0|  0.00%|               'code_context={!r}, index={!r}, positions={!r})'.format(
  1735|         0|            0|            0|  0.00%|                self.frame, self.filename, self.lineno, self.function,
  1736|         0|            0|            0|  0.00%|                self.code_context, self.index, self.positions))
  1737|         0|            0|            0|  0.00%|
  1738|         0|            0|            0|  0.00%|def getouterframes(frame, context=1):
  1739|         0|            0|            0|  0.00%|    """Get a list of records for a frame and all higher (calling) frames.
  1740|         0|            0|            0|  0.00%|
  1741|         0|            0|            0|  0.00%|    Each record contains a frame object, filename, line number, function
  1742|         0|            0|            0|  0.00%|    name, a list of lines of context, and index within the context."""
  1743|         0|            0|            0|  0.00%|    framelist = []
  1744|         0|            0|            0|  0.00%|    while frame:
  1745|         0|            0|            0|  0.00%|        traceback_info = getframeinfo(frame, context)
  1746|         0|            0|            0|  0.00%|        frameinfo = (frame,) + traceback_info
  1747|         0|            0|            0|  0.00%|        framelist.append(FrameInfo(*frameinfo, positions=traceback_info.positions))
  1748|         0|            0|            0|  0.00%|        frame = frame.f_back
  1749|         0|            0|            0|  0.00%|    return framelist
  1750|         0|            0|            0|  0.00%|
  1751|         0|            0|            0|  0.00%|def getinnerframes(tb, context=1):
  1752|         0|            0|            0|  0.00%|    """Get a list of records for a traceback's frame and all lower frames.
  1753|         0|            0|            0|  0.00%|
  1754|         0|            0|            0|  0.00%|    Each record contains a frame object, filename, line number, function
  1755|         0|            0|            0|  0.00%|    name, a list of lines of context, and index within the context."""
  1756|         0|            0|            0|  0.00%|    framelist = []
  1757|         0|            0|            0|  0.00%|    while tb:
  1758|         0|            0|            0|  0.00%|        traceback_info = getframeinfo(tb, context)
  1759|         0|            0|            0|  0.00%|        frameinfo = (tb.tb_frame,) + traceback_info
  1760|         0|            0|            0|  0.00%|        framelist.append(FrameInfo(*frameinfo, positions=traceback_info.positions))
  1761|         0|            0|            0|  0.00%|        tb = tb.tb_next
  1762|         0|            0|            0|  0.00%|    return framelist
  1763|         0|            0|            0|  0.00%|
  1764|         0|            0|            0|  0.00%|def currentframe():
  1765|         0|            0|            0|  0.00%|    """Return the frame of the caller or None if this is not possible."""
  1766|         0|            0|            0|  0.00%|    return sys._getframe(1) if hasattr(sys, "_getframe") else None
  1767|         0|            0|            0|  0.00%|
  1768|         0|            0|            0|  0.00%|def stack(context=1):
  1769|         0|            0|            0|  0.00%|    """Return a list of records for the stack above the caller's frame."""
  1770|         0|            0|            0|  0.00%|    return getouterframes(sys._getframe(1), context)
  1771|         0|            0|            0|  0.00%|
  1772|         0|            0|            0|  0.00%|def trace(context=1):
  1773|         0|            0|            0|  0.00%|    """Return a list of records for the stack below the current exception."""
  1774|         0|            0|            0|  0.00%|    exc = sys.exception()
  1775|         0|            0|            0|  0.00%|    tb = None if exc is None else exc.__traceback__
  1776|         0|            0|            0|  0.00%|    return getinnerframes(tb, context)
  1777|         0|            0|            0|  0.00%|
  1778|         0|            0|            0|  0.00%|
  1779|         0|            0|            0|  0.00%|# ------------------------------------------------ static version of getattr
  1780|         0|            0|            0|  0.00%|
  1781|         0|            0|            0|  0.00%|_sentinel = object()
  1782|         0|            0|            0|  0.00%|_static_getmro = type.__dict__['__mro__'].__get__
  1783|         0|            0|            0|  0.00%|_get_dunder_dict_of_class = type.__dict__["__dict__"].__get__
  1784|         0|            0|            0|  0.00%|
  1785|         0|            0|            0|  0.00%|
  1786|         4|  9.53674e-06|  2.38419e-06|  0.01%|def _check_instance(obj, attr):
  1787|         4|   6.4373e-06|  1.60933e-06|  0.01%|    instance_dict = {}
  1788|         4|  5.48363e-06|  1.37091e-06|  0.01%|    try:
  1789|         4|  8.82149e-06|  2.20537e-06|  0.01%|        instance_dict = object.__getattribute__(obj, "__dict__")
  1790|         0|            0|            0|  0.00%|    except AttributeError:
  1791|         0|            0|            0|  0.00%|        pass
  1792|         4|  5.96046e-06|  1.49012e-06|  0.01%|    return dict.get(instance_dict, attr, _sentinel)
  1793|         0|            0|            0|  0.00%|
  1794|         0|            0|            0|  0.00%|
  1795|         4|  9.29832e-06|  2.32458e-06|  0.01%|def _check_class(klass, attr):
  1796|        24|  2.98023e-05|  1.24176e-06|  0.03%|    for entry in _static_getmro(klass):
  1797|        20|  7.55787e-05|  3.77893e-06|  0.08%|        if _shadowed_dict(type(entry)) is _sentinel and attr in entry.__dict__:
(call)|        20|   4.3869e-05|  2.19345e-06|  0.05%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:1813 _shadowed_dict
  1798|         0|            0|            0|  0.00%|            return entry.__dict__[attr]
  1799|         4|   3.8147e-06|  9.53674e-07|  0.00%|    return _sentinel
  1800|         0|            0|            0|  0.00%|
  1801|         1|  4.29153e-06|  4.29153e-06|  0.00%|@functools.lru_cache()
  1802|         0|            0|            0|  0.00%|def _shadowed_dict_from_mro_tuple(mro):
  1803|         6|  1.62125e-05|  2.70208e-06|  0.02%|    for entry in mro:
  1804|         5|  8.10623e-06|  1.62125e-06|  0.01%|        dunder_dict = _get_dunder_dict_of_class(entry)
  1805|         5|  6.91414e-06|  1.38283e-06|  0.01%|        if '__dict__' in dunder_dict:
  1806|         1|  1.43051e-06|  1.43051e-06|  0.00%|            class_dict = dunder_dict['__dict__']
  1807|         1|   2.6226e-06|   2.6226e-06|  0.00%|            if not (type(class_dict) is types.GetSetDescriptorType and
  1808|         1|   2.6226e-06|   2.6226e-06|  0.00%|                    class_dict.__name__ == "__dict__" and
  1809|         1|   2.6226e-06|   2.6226e-06|  0.00%|                    class_dict.__objclass__ is entry):
  1810|         0|            0|            0|  0.00%|                return class_dict
  1811|         1|  9.53674e-07|  9.53674e-07|  0.00%|    return _sentinel
  1812|         0|            0|            0|  0.00%|
  1813|        24|  2.93255e-05|   1.2219e-06|  0.03%|def _shadowed_dict(klass):
  1814|        24|  4.14848e-05|  1.72853e-06|  0.04%|    return _shadowed_dict_from_mro_tuple(_static_getmro(klass))
(call)|         1|  4.57764e-05|  4.57764e-05|  0.05%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:1801 _shadowed_dict_from_mro_tuple
  1815|         0|            0|            0|  0.00%|
  1816|         4|  1.43051e-05|  3.57628e-06|  0.01%|def getattr_static(obj, attr, default=_sentinel):
  1817|         0|            0|            0|  0.00%|    """Retrieve attributes without triggering dynamic lookup via the
  1818|         0|            0|            0|  0.00%|       descriptor protocol,  __getattr__ or __getattribute__.
  1819|         0|            0|            0|  0.00%|
  1820|         0|            0|            0|  0.00%|       Note: this function may not be able to retrieve all attributes
  1821|         0|            0|            0|  0.00%|       that getattr can fetch (like dynamically created attributes)
  1822|         0|            0|            0|  0.00%|       and may find attributes that getattr can't (like descriptors
  1823|         0|            0|            0|  0.00%|       that raise AttributeError). It can also return descriptor objects
  1824|         0|            0|            0|  0.00%|       instead of instance members in some cases. See the
  1825|         0|            0|            0|  0.00%|       documentation for details.
  1826|         0|            0|            0|  0.00%|    """
  1827|         4|  1.04904e-05|   2.6226e-06|  0.01%|    instance_result = _sentinel
  1828|         0|            0|            0|  0.00%|
  1829|         4|  9.05991e-06|  2.26498e-06|  0.01%|    objtype = type(obj)
  1830|         4|  1.26362e-05|  3.15905e-06|  0.01%|    if type not in _static_getmro(objtype):
  1831|         4|  9.05991e-06|  2.26498e-06|  0.01%|        klass = objtype
  1832|         4|  3.05176e-05|  7.62939e-06|  0.03%|        dict_attr = _shadowed_dict(klass)
(call)|         4|  7.27177e-05|  1.81794e-05|  0.07%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:1813 _shadowed_dict
  1833|         4|  9.05991e-06|  2.26498e-06|  0.01%|        if (dict_attr is _sentinel or
  1834|         0|            0|            0|  0.00%|            type(dict_attr) is types.MemberDescriptorType):
  1835|         4|  3.19481e-05|  7.98702e-06|  0.03%|            instance_result = _check_instance(obj, attr)
(call)|         4|  3.62396e-05|  9.05991e-06|  0.04%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:1786 _check_instance
  1836|         0|            0|            0|  0.00%|    else:
  1837|         0|            0|            0|  0.00%|        klass = obj
  1838|         0|            0|            0|  0.00%|
  1839|         4|  3.21865e-05|  8.04663e-06|  0.03%|    klass_result = _check_class(klass, attr)
(call)|         4|  0.000162363|  4.05908e-05|  0.17%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:1795 _check_class
  1840|         0|            0|            0|  0.00%|
  1841|         4|  9.05991e-06|  2.26498e-06|  0.01%|    if instance_result is not _sentinel and klass_result is not _sentinel:
  1842|         0|            0|            0|  0.00%|        if _check_class(type(klass_result), "__get__") is not _sentinel and (
  1843|         0|            0|            0|  0.00%|            _check_class(type(klass_result), "__set__") is not _sentinel
  1844|         0|            0|            0|  0.00%|            or _check_class(type(klass_result), "__delete__") is not _sentinel
  1845|         0|            0|            0|  0.00%|        ):
  1846|         0|            0|            0|  0.00%|            return klass_result
  1847|         0|            0|            0|  0.00%|
  1848|         4|  8.58307e-06|  2.14577e-06|  0.01%|    if instance_result is not _sentinel:
  1849|         0|            0|            0|  0.00%|        return instance_result
  1850|         4|  8.34465e-06|  2.08616e-06|  0.01%|    if klass_result is not _sentinel:
  1851|         0|            0|            0|  0.00%|        return klass_result
  1852|         0|            0|            0|  0.00%|
  1853|         4|  8.10623e-06|  2.02656e-06|  0.01%|    if obj is klass:
  1854|         0|            0|            0|  0.00%|        # for types we check the metaclass too
  1855|         0|            0|            0|  0.00%|        for entry in _static_getmro(type(klass)):
  1856|         0|            0|            0|  0.00%|            if (
  1857|         0|            0|            0|  0.00%|                _shadowed_dict(type(entry)) is _sentinel
  1858|         0|            0|            0|  0.00%|                and attr in entry.__dict__
  1859|         0|            0|            0|  0.00%|            ):
  1860|         0|            0|            0|  0.00%|                return entry.__dict__[attr]
  1861|         4|  8.10623e-06|  2.02656e-06|  0.01%|    if default is not _sentinel:
  1862|         0|            0|            0|  0.00%|        return default
  1863|         4|  1.21593e-05|  3.03984e-06|  0.01%|    raise AttributeError(attr)
  1864|         0|            0|            0|  0.00%|
  1865|         0|            0|            0|  0.00%|
  1866|         0|            0|            0|  0.00%|# ------------------------------------------------ generator introspection
  1867|         0|            0|            0|  0.00%|
  1868|         0|            0|            0|  0.00%|GEN_CREATED = 'GEN_CREATED'
  1869|         0|            0|            0|  0.00%|GEN_RUNNING = 'GEN_RUNNING'
  1870|         0|            0|            0|  0.00%|GEN_SUSPENDED = 'GEN_SUSPENDED'
  1871|         0|            0|            0|  0.00%|GEN_CLOSED = 'GEN_CLOSED'
  1872|         0|            0|            0|  0.00%|
  1873|         0|            0|            0|  0.00%|def getgeneratorstate(generator):
  1874|         0|            0|            0|  0.00%|    """Get current state of a generator-iterator.
  1875|         0|            0|            0|  0.00%|
  1876|         0|            0|            0|  0.00%|    Possible states are:
  1877|         0|            0|            0|  0.00%|      GEN_CREATED: Waiting to start execution.
  1878|         0|            0|            0|  0.00%|      GEN_RUNNING: Currently being executed by the interpreter.
  1879|         0|            0|            0|  0.00%|      GEN_SUSPENDED: Currently suspended at a yield expression.
  1880|         0|            0|            0|  0.00%|      GEN_CLOSED: Execution has completed.
  1881|         0|            0|            0|  0.00%|    """
  1882|         0|            0|            0|  0.00%|    if generator.gi_running:
  1883|         0|            0|            0|  0.00%|        return GEN_RUNNING
  1884|         0|            0|            0|  0.00%|    if generator.gi_suspended:
  1885|         0|            0|            0|  0.00%|        return GEN_SUSPENDED
  1886|         0|            0|            0|  0.00%|    if generator.gi_frame is None:
  1887|         0|            0|            0|  0.00%|        return GEN_CLOSED
  1888|         0|            0|            0|  0.00%|    return GEN_CREATED
  1889|         0|            0|            0|  0.00%|
  1890|         0|            0|            0|  0.00%|
  1891|         0|            0|            0|  0.00%|def getgeneratorlocals(generator):
  1892|         0|            0|            0|  0.00%|    """
  1893|         0|            0|            0|  0.00%|    Get the mapping of generator local variables to their current values.
  1894|         0|            0|            0|  0.00%|
  1895|         0|            0|            0|  0.00%|    A dict is returned, with the keys the local variable names and values the
  1896|         0|            0|            0|  0.00%|    bound values."""
  1897|         0|            0|            0|  0.00%|
  1898|         0|            0|            0|  0.00%|    if not isgenerator(generator):
  1899|         0|            0|            0|  0.00%|        raise TypeError("{!r} is not a Python generator".format(generator))
  1900|         0|            0|            0|  0.00%|
  1901|         0|            0|            0|  0.00%|    frame = getattr(generator, "gi_frame", None)
  1902|         0|            0|            0|  0.00%|    if frame is not None:
  1903|         0|            0|            0|  0.00%|        return generator.gi_frame.f_locals
  1904|         0|            0|            0|  0.00%|    else:
  1905|         0|            0|            0|  0.00%|        return {}
  1906|         0|            0|            0|  0.00%|
  1907|         0|            0|            0|  0.00%|
  1908|         0|            0|            0|  0.00%|# ------------------------------------------------ coroutine introspection
  1909|         0|            0|            0|  0.00%|
  1910|         0|            0|            0|  0.00%|CORO_CREATED = 'CORO_CREATED'
  1911|         0|            0|            0|  0.00%|CORO_RUNNING = 'CORO_RUNNING'
  1912|         0|            0|            0|  0.00%|CORO_SUSPENDED = 'CORO_SUSPENDED'
  1913|         0|            0|            0|  0.00%|CORO_CLOSED = 'CORO_CLOSED'
  1914|         0|            0|            0|  0.00%|
  1915|         0|            0|            0|  0.00%|def getcoroutinestate(coroutine):
  1916|         0|            0|            0|  0.00%|    """Get current state of a coroutine object.
  1917|         0|            0|            0|  0.00%|
  1918|         0|            0|            0|  0.00%|    Possible states are:
  1919|         0|            0|            0|  0.00%|      CORO_CREATED: Waiting to start execution.
  1920|         0|            0|            0|  0.00%|      CORO_RUNNING: Currently being executed by the interpreter.
  1921|         0|            0|            0|  0.00%|      CORO_SUSPENDED: Currently suspended at an await expression.
  1922|         0|            0|            0|  0.00%|      CORO_CLOSED: Execution has completed.
  1923|         0|            0|            0|  0.00%|    """
  1924|         0|            0|            0|  0.00%|    if coroutine.cr_running:
  1925|         0|            0|            0|  0.00%|        return CORO_RUNNING
  1926|         0|            0|            0|  0.00%|    if coroutine.cr_suspended:
  1927|         0|            0|            0|  0.00%|        return CORO_SUSPENDED
  1928|         0|            0|            0|  0.00%|    if coroutine.cr_frame is None:
  1929|         0|            0|            0|  0.00%|        return CORO_CLOSED
  1930|         0|            0|            0|  0.00%|    return CORO_CREATED
  1931|         0|            0|            0|  0.00%|
  1932|         0|            0|            0|  0.00%|
  1933|         0|            0|            0|  0.00%|def getcoroutinelocals(coroutine):
  1934|         0|            0|            0|  0.00%|    """
  1935|         0|            0|            0|  0.00%|    Get the mapping of coroutine local variables to their current values.
  1936|         0|            0|            0|  0.00%|
  1937|         0|            0|            0|  0.00%|    A dict is returned, with the keys the local variable names and values the
  1938|         0|            0|            0|  0.00%|    bound values."""
  1939|         0|            0|            0|  0.00%|    frame = getattr(coroutine, "cr_frame", None)
  1940|         0|            0|            0|  0.00%|    if frame is not None:
  1941|         0|            0|            0|  0.00%|        return frame.f_locals
  1942|         0|            0|            0|  0.00%|    else:
  1943|         0|            0|            0|  0.00%|        return {}
  1944|         0|            0|            0|  0.00%|
  1945|         0|            0|            0|  0.00%|
  1946|         0|            0|            0|  0.00%|# ----------------------------------- asynchronous generator introspection
  1947|         0|            0|            0|  0.00%|
  1948|         0|            0|            0|  0.00%|AGEN_CREATED = 'AGEN_CREATED'
  1949|         0|            0|            0|  0.00%|AGEN_RUNNING = 'AGEN_RUNNING'
  1950|         0|            0|            0|  0.00%|AGEN_SUSPENDED = 'AGEN_SUSPENDED'
  1951|         0|            0|            0|  0.00%|AGEN_CLOSED = 'AGEN_CLOSED'
  1952|         0|            0|            0|  0.00%|
  1953|         0|            0|            0|  0.00%|
  1954|         0|            0|            0|  0.00%|def getasyncgenstate(agen):
  1955|         0|            0|            0|  0.00%|    """Get current state of an asynchronous generator object.
  1956|         0|            0|            0|  0.00%|
  1957|         0|            0|            0|  0.00%|    Possible states are:
  1958|         0|            0|            0|  0.00%|      AGEN_CREATED: Waiting to start execution.
  1959|         0|            0|            0|  0.00%|      AGEN_RUNNING: Currently being executed by the interpreter.
  1960|         0|            0|            0|  0.00%|      AGEN_SUSPENDED: Currently suspended at a yield expression.
  1961|         0|            0|            0|  0.00%|      AGEN_CLOSED: Execution has completed.
  1962|         0|            0|            0|  0.00%|    """
  1963|         0|            0|            0|  0.00%|    if agen.ag_running:
  1964|         0|            0|            0|  0.00%|        return AGEN_RUNNING
  1965|         0|            0|            0|  0.00%|    if agen.ag_suspended:
  1966|         0|            0|            0|  0.00%|        return AGEN_SUSPENDED
  1967|         0|            0|            0|  0.00%|    if agen.ag_frame is None:
  1968|         0|            0|            0|  0.00%|        return AGEN_CLOSED
  1969|         0|            0|            0|  0.00%|    return AGEN_CREATED
  1970|         0|            0|            0|  0.00%|
  1971|         0|            0|            0|  0.00%|
  1972|         0|            0|            0|  0.00%|def getasyncgenlocals(agen):
  1973|         0|            0|            0|  0.00%|    """
  1974|         0|            0|            0|  0.00%|    Get the mapping of asynchronous generator local variables to their current
  1975|         0|            0|            0|  0.00%|    values.
  1976|         0|            0|            0|  0.00%|
  1977|         0|            0|            0|  0.00%|    A dict is returned, with the keys the local variable names and values the
  1978|         0|            0|            0|  0.00%|    bound values."""
  1979|         0|            0|            0|  0.00%|
  1980|         0|            0|            0|  0.00%|    if not isasyncgen(agen):
  1981|         0|            0|            0|  0.00%|        raise TypeError(f"{agen!r} is not a Python async generator")
  1982|         0|            0|            0|  0.00%|
  1983|         0|            0|            0|  0.00%|    frame = getattr(agen, "ag_frame", None)
  1984|         0|            0|            0|  0.00%|    if frame is not None:
  1985|         0|            0|            0|  0.00%|        return agen.ag_frame.f_locals
  1986|         0|            0|            0|  0.00%|    else:
  1987|         0|            0|            0|  0.00%|        return {}
  1988|         0|            0|            0|  0.00%|
  1989|         0|            0|            0|  0.00%|
  1990|         0|            0|            0|  0.00%|###############################################################################
  1991|         0|            0|            0|  0.00%|### Function Signature Object (PEP 362)
  1992|         0|            0|            0|  0.00%|###############################################################################
  1993|         0|            0|            0|  0.00%|
  1994|         0|            0|            0|  0.00%|
  1995|         0|            0|            0|  0.00%|_NonUserDefinedCallables = (types.WrapperDescriptorType,
  1996|         0|            0|            0|  0.00%|                            types.MethodWrapperType,
  1997|         0|            0|            0|  0.00%|                            types.ClassMethodDescriptorType,
  1998|         0|            0|            0|  0.00%|                            types.BuiltinFunctionType)
  1999|         0|            0|            0|  0.00%|
  2000|         0|            0|            0|  0.00%|
  2001|         0|            0|            0|  0.00%|def _signature_get_user_defined_method(cls, method_name):
  2002|         0|            0|            0|  0.00%|    """Private helper. Checks if ``cls`` has an attribute
  2003|         0|            0|            0|  0.00%|    named ``method_name`` and returns it only if it is a
  2004|         0|            0|            0|  0.00%|    pure python function.
  2005|         0|            0|            0|  0.00%|    """
  2006|         0|            0|            0|  0.00%|    if method_name == '__new__':
  2007|         0|            0|            0|  0.00%|        meth = getattr(cls, method_name, None)
  2008|         0|            0|            0|  0.00%|    else:
  2009|         0|            0|            0|  0.00%|        meth = getattr_static(cls, method_name, None)
  2010|         0|            0|            0|  0.00%|    if meth is None or isinstance(meth, _NonUserDefinedCallables):
  2011|         0|            0|            0|  0.00%|        # Once '__signature__' will be added to 'C'-level
  2012|         0|            0|            0|  0.00%|        # callables, this check won't be necessary
  2013|         0|            0|            0|  0.00%|        return None
  2014|         0|            0|            0|  0.00%|    if method_name != '__new__':
  2015|         0|            0|            0|  0.00%|        meth = _descriptor_get(meth, cls)
  2016|         0|            0|            0|  0.00%|    return meth
  2017|         0|            0|            0|  0.00%|
  2018|         0|            0|            0|  0.00%|
  2019|         0|            0|            0|  0.00%|def _signature_get_partial(wrapped_sig, partial, extra_args=()):
  2020|         0|            0|            0|  0.00%|    """Private helper to calculate how 'wrapped_sig' signature will
  2021|         0|            0|            0|  0.00%|    look like after applying a 'functools.partial' object (or alike)
  2022|         0|            0|            0|  0.00%|    on it.
  2023|         0|            0|            0|  0.00%|    """
  2024|         0|            0|            0|  0.00%|
  2025|         0|            0|            0|  0.00%|    old_params = wrapped_sig.parameters
  2026|         0|            0|            0|  0.00%|    new_params = OrderedDict(old_params.items())
  2027|         0|            0|            0|  0.00%|
  2028|         0|            0|            0|  0.00%|    partial_args = partial.args or ()
  2029|         0|            0|            0|  0.00%|    partial_keywords = partial.keywords or {}
  2030|         0|            0|            0|  0.00%|
  2031|         0|            0|            0|  0.00%|    if extra_args:
  2032|         0|            0|            0|  0.00%|        partial_args = extra_args + partial_args
  2033|         0|            0|            0|  0.00%|
  2034|         0|            0|            0|  0.00%|    try:
  2035|         0|            0|            0|  0.00%|        ba = wrapped_sig.bind_partial(*partial_args, **partial_keywords)
  2036|         0|            0|            0|  0.00%|    except TypeError as ex:
  2037|         0|            0|            0|  0.00%|        msg = 'partial object {!r} has incorrect arguments'.format(partial)
  2038|         0|            0|            0|  0.00%|        raise ValueError(msg) from ex
  2039|         0|            0|            0|  0.00%|
  2040|         0|            0|            0|  0.00%|
  2041|         0|            0|            0|  0.00%|    transform_to_kwonly = False
  2042|         0|            0|            0|  0.00%|    for param_name, param in old_params.items():
  2043|         0|            0|            0|  0.00%|        try:
  2044|         0|            0|            0|  0.00%|            arg_value = ba.arguments[param_name]
  2045|         0|            0|            0|  0.00%|        except KeyError:
  2046|         0|            0|            0|  0.00%|            pass
  2047|         0|            0|            0|  0.00%|        else:
  2048|         0|            0|            0|  0.00%|            if param.kind is _POSITIONAL_ONLY:
  2049|         0|            0|            0|  0.00%|                # If positional-only parameter is bound by partial,
  2050|         0|            0|            0|  0.00%|                # it effectively disappears from the signature
  2051|         0|            0|            0|  0.00%|                new_params.pop(param_name)
  2052|         0|            0|            0|  0.00%|                continue
  2053|         0|            0|            0|  0.00%|
  2054|         0|            0|            0|  0.00%|            if param.kind is _POSITIONAL_OR_KEYWORD:
  2055|         0|            0|            0|  0.00%|                if param_name in partial_keywords:
  2056|         0|            0|            0|  0.00%|                    # This means that this parameter, and all parameters
  2057|         0|            0|            0|  0.00%|                    # after it should be keyword-only (and var-positional
  2058|         0|            0|            0|  0.00%|                    # should be removed). Here's why. Consider the following
  2059|         0|            0|            0|  0.00%|                    # function:
  2060|         0|            0|            0|  0.00%|                    #     foo(a, b, *args, c):
  2061|         0|            0|            0|  0.00%|                    #         pass
  2062|         0|            0|            0|  0.00%|                    #
  2063|         0|            0|            0|  0.00%|                    # "partial(foo, a='spam')" will have the following
  2064|         0|            0|            0|  0.00%|                    # signature: "(*, a='spam', b, c)". Because attempting
  2065|         0|            0|            0|  0.00%|                    # to call that partial with "(10, 20)" arguments will
  2066|         0|            0|            0|  0.00%|                    # raise a TypeError, saying that "a" argument received
  2067|         0|            0|            0|  0.00%|                    # multiple values.
  2068|         0|            0|            0|  0.00%|                    transform_to_kwonly = True
  2069|         0|            0|            0|  0.00%|                    # Set the new default value
  2070|         0|            0|            0|  0.00%|                    new_params[param_name] = param.replace(default=arg_value)
  2071|         0|            0|            0|  0.00%|                else:
  2072|         0|            0|            0|  0.00%|                    # was passed as a positional argument
  2073|         0|            0|            0|  0.00%|                    new_params.pop(param.name)
  2074|         0|            0|            0|  0.00%|                    continue
  2075|         0|            0|            0|  0.00%|
  2076|         0|            0|            0|  0.00%|            if param.kind is _KEYWORD_ONLY:
  2077|         0|            0|            0|  0.00%|                # Set the new default value
  2078|         0|            0|            0|  0.00%|                new_params[param_name] = param.replace(default=arg_value)
  2079|         0|            0|            0|  0.00%|
  2080|         0|            0|            0|  0.00%|        if transform_to_kwonly:
  2081|         0|            0|            0|  0.00%|            assert param.kind is not _POSITIONAL_ONLY
  2082|         0|            0|            0|  0.00%|
  2083|         0|            0|            0|  0.00%|            if param.kind is _POSITIONAL_OR_KEYWORD:
  2084|         0|            0|            0|  0.00%|                new_param = new_params[param_name].replace(kind=_KEYWORD_ONLY)
  2085|         0|            0|            0|  0.00%|                new_params[param_name] = new_param
  2086|         0|            0|            0|  0.00%|                new_params.move_to_end(param_name)
  2087|         0|            0|            0|  0.00%|            elif param.kind in (_KEYWORD_ONLY, _VAR_KEYWORD):
  2088|         0|            0|            0|  0.00%|                new_params.move_to_end(param_name)
  2089|         0|            0|            0|  0.00%|            elif param.kind is _VAR_POSITIONAL:
  2090|         0|            0|            0|  0.00%|                new_params.pop(param.name)
  2091|         0|            0|            0|  0.00%|
  2092|         0|            0|            0|  0.00%|    return wrapped_sig.replace(parameters=new_params.values())
  2093|         0|            0|            0|  0.00%|
  2094|         0|            0|            0|  0.00%|
  2095|         0|            0|            0|  0.00%|def _signature_bound_method(sig):
  2096|         0|            0|            0|  0.00%|    """Private helper to transform signatures for unbound
  2097|         0|            0|            0|  0.00%|    functions to bound methods.
  2098|         0|            0|            0|  0.00%|    """
  2099|         0|            0|            0|  0.00%|
  2100|         0|            0|            0|  0.00%|    params = tuple(sig.parameters.values())
  2101|         0|            0|            0|  0.00%|
  2102|         0|            0|            0|  0.00%|    if not params or params[0].kind in (_VAR_KEYWORD, _KEYWORD_ONLY):
  2103|         0|            0|            0|  0.00%|        raise ValueError('invalid method signature')
  2104|         0|            0|            0|  0.00%|
  2105|         0|            0|            0|  0.00%|    kind = params[0].kind
  2106|         0|            0|            0|  0.00%|    if kind in (_POSITIONAL_OR_KEYWORD, _POSITIONAL_ONLY):
  2107|         0|            0|            0|  0.00%|        # Drop first parameter:
  2108|         0|            0|            0|  0.00%|        # '(p1, p2[, ...])' -> '(p2[, ...])'
  2109|         0|            0|            0|  0.00%|        params = params[1:]
  2110|         0|            0|            0|  0.00%|    else:
  2111|         0|            0|            0|  0.00%|        if kind is not _VAR_POSITIONAL:
  2112|         0|            0|            0|  0.00%|            # Unless we add a new parameter type we never
  2113|         0|            0|            0|  0.00%|            # get here
  2114|         0|            0|            0|  0.00%|            raise ValueError('invalid argument type')
  2115|         0|            0|            0|  0.00%|        # It's a var-positional parameter.
  2116|         0|            0|            0|  0.00%|        # Do nothing. '(*args[, ...])' -> '(*args[, ...])'
  2117|         0|            0|            0|  0.00%|
  2118|         0|            0|            0|  0.00%|    return sig.replace(parameters=params)
  2119|         0|            0|            0|  0.00%|
  2120|         0|            0|            0|  0.00%|
  2121|         0|            0|            0|  0.00%|def _signature_is_builtin(obj):
  2122|         0|            0|            0|  0.00%|    """Private helper to test if `obj` is a callable that might
  2123|         0|            0|            0|  0.00%|    support Argument Clinic's __text_signature__ protocol.
  2124|         0|            0|            0|  0.00%|    """
  2125|         0|            0|            0|  0.00%|    return (isbuiltin(obj) or
  2126|         0|            0|            0|  0.00%|            ismethoddescriptor(obj) or
  2127|         0|            0|            0|  0.00%|            isinstance(obj, _NonUserDefinedCallables) or
  2128|         0|            0|            0|  0.00%|            # Can't test 'isinstance(type)' here, as it would
  2129|         0|            0|            0|  0.00%|            # also be True for regular python classes
  2130|         0|            0|            0|  0.00%|            obj in (type, object))
  2131|         0|            0|            0|  0.00%|
  2132|         0|            0|            0|  0.00%|
  2133|         0|            0|            0|  0.00%|def _signature_is_functionlike(obj):
  2134|         0|            0|            0|  0.00%|    """Private helper to test if `obj` is a duck type of FunctionType.
  2135|         0|            0|            0|  0.00%|    A good example of such objects are functions compiled with
  2136|         0|            0|            0|  0.00%|    Cython, which have all attributes that a pure Python function
  2137|         0|            0|            0|  0.00%|    would have, but have their code statically compiled.
  2138|         0|            0|            0|  0.00%|    """
  2139|         0|            0|            0|  0.00%|
  2140|         0|            0|            0|  0.00%|    if not callable(obj) or isclass(obj):
  2141|         0|            0|            0|  0.00%|        # All function-like objects are obviously callables,
  2142|         0|            0|            0|  0.00%|        # and not classes.
  2143|         0|            0|            0|  0.00%|        return False
  2144|         0|            0|            0|  0.00%|
  2145|         0|            0|            0|  0.00%|    name = getattr(obj, '__name__', None)
  2146|         0|            0|            0|  0.00%|    code = getattr(obj, '__code__', None)
  2147|         0|            0|            0|  0.00%|    defaults = getattr(obj, '__defaults__', _void) # Important to use _void ...
  2148|         0|            0|            0|  0.00%|    kwdefaults = getattr(obj, '__kwdefaults__', _void) # ... and not None here
  2149|         0|            0|            0|  0.00%|    annotations = getattr(obj, '__annotations__', None)
  2150|         0|            0|            0|  0.00%|
  2151|         0|            0|            0|  0.00%|    return (isinstance(code, types.CodeType) and
  2152|         0|            0|            0|  0.00%|            isinstance(name, str) and
  2153|         0|            0|            0|  0.00%|            (defaults is None or isinstance(defaults, tuple)) and
  2154|         0|            0|            0|  0.00%|            (kwdefaults is None or isinstance(kwdefaults, dict)) and
  2155|         0|            0|            0|  0.00%|            (isinstance(annotations, (dict)) or annotations is None) )
  2156|         0|            0|            0|  0.00%|
  2157|         0|            0|            0|  0.00%|
  2158|         0|            0|            0|  0.00%|def _signature_strip_non_python_syntax(signature):
  2159|         0|            0|            0|  0.00%|    """
  2160|         0|            0|            0|  0.00%|    Private helper function. Takes a signature in Argument Clinic's
  2161|         0|            0|            0|  0.00%|    extended signature format.
  2162|         0|            0|            0|  0.00%|
  2163|         0|            0|            0|  0.00%|    Returns a tuple of two things:
  2164|         0|            0|            0|  0.00%|      * that signature re-rendered in standard Python syntax, and
  2165|         0|            0|            0|  0.00%|      * the index of the "self" parameter (generally 0), or None if
  2166|         0|            0|            0|  0.00%|        the function does not have a "self" parameter.
  2167|         0|            0|            0|  0.00%|    """
  2168|         0|            0|            0|  0.00%|
  2169|         0|            0|            0|  0.00%|    if not signature:
  2170|         0|            0|            0|  0.00%|        return signature, None
  2171|         0|            0|            0|  0.00%|
  2172|         0|            0|            0|  0.00%|    self_parameter = None
  2173|         0|            0|            0|  0.00%|
  2174|         0|            0|            0|  0.00%|    lines = [l.encode('ascii') for l in signature.split('\n') if l]
  2175|         0|            0|            0|  0.00%|    generator = iter(lines).__next__
  2176|         0|            0|            0|  0.00%|    token_stream = tokenize.tokenize(generator)
  2177|         0|            0|            0|  0.00%|
  2178|         0|            0|            0|  0.00%|    text = []
  2179|         0|            0|            0|  0.00%|    add = text.append
  2180|         0|            0|            0|  0.00%|
  2181|         0|            0|            0|  0.00%|    current_parameter = 0
  2182|         0|            0|            0|  0.00%|    OP = token.OP
  2183|         0|            0|            0|  0.00%|    ERRORTOKEN = token.ERRORTOKEN
  2184|         0|            0|            0|  0.00%|
  2185|         0|            0|            0|  0.00%|    # token stream always starts with ENCODING token, skip it
  2186|         0|            0|            0|  0.00%|    t = next(token_stream)
  2187|         0|            0|            0|  0.00%|    assert t.type == tokenize.ENCODING
  2188|         0|            0|            0|  0.00%|
  2189|         0|            0|            0|  0.00%|    for t in token_stream:
  2190|         0|            0|            0|  0.00%|        type, string = t.type, t.string
  2191|         0|            0|            0|  0.00%|
  2192|         0|            0|            0|  0.00%|        if type == OP:
  2193|         0|            0|            0|  0.00%|            if string == ',':
  2194|         0|            0|            0|  0.00%|                current_parameter += 1
  2195|         0|            0|            0|  0.00%|
  2196|         0|            0|            0|  0.00%|        if (type == OP) and (string == '$'):
  2197|         0|            0|            0|  0.00%|            assert self_parameter is None
  2198|         0|            0|            0|  0.00%|            self_parameter = current_parameter
  2199|         0|            0|            0|  0.00%|            continue
  2200|         0|            0|            0|  0.00%|
  2201|         0|            0|            0|  0.00%|        add(string)
  2202|         0|            0|            0|  0.00%|        if (string == ','):
  2203|         0|            0|            0|  0.00%|            add(' ')
  2204|         0|            0|            0|  0.00%|    clean_signature = ''.join(text).strip().replace("\n", "")
  2205|         0|            0|            0|  0.00%|    return clean_signature, self_parameter
  2206|         0|            0|            0|  0.00%|
  2207|         0|            0|            0|  0.00%|
  2208|         0|            0|            0|  0.00%|def _signature_fromstr(cls, obj, s, skip_bound_arg=True):
  2209|         0|            0|            0|  0.00%|    """Private helper to parse content of '__text_signature__'
  2210|         0|            0|            0|  0.00%|    and return a Signature based on it.
  2211|         0|            0|            0|  0.00%|    """
  2212|         0|            0|            0|  0.00%|    Parameter = cls._parameter_cls
  2213|         0|            0|            0|  0.00%|
  2214|         0|            0|            0|  0.00%|    clean_signature, self_parameter = _signature_strip_non_python_syntax(s)
  2215|         0|            0|            0|  0.00%|
  2216|         0|            0|            0|  0.00%|    program = "def foo" + clean_signature + ": pass"
  2217|         0|            0|            0|  0.00%|
  2218|         0|            0|            0|  0.00%|    try:
  2219|         0|            0|            0|  0.00%|        module = ast.parse(program)
  2220|         0|            0|            0|  0.00%|    except SyntaxError:
  2221|         0|            0|            0|  0.00%|        module = None
  2222|         0|            0|            0|  0.00%|
  2223|         0|            0|            0|  0.00%|    if not isinstance(module, ast.Module):
  2224|         0|            0|            0|  0.00%|        raise ValueError("{!r} builtin has invalid signature".format(obj))
  2225|         0|            0|            0|  0.00%|
  2226|         0|            0|            0|  0.00%|    f = module.body[0]
  2227|         0|            0|            0|  0.00%|
  2228|         0|            0|            0|  0.00%|    parameters = []
  2229|         0|            0|            0|  0.00%|    empty = Parameter.empty
  2230|         0|            0|            0|  0.00%|
  2231|         0|            0|            0|  0.00%|    module = None
  2232|         0|            0|            0|  0.00%|    module_dict = {}
  2233|         0|            0|            0|  0.00%|    module_name = getattr(obj, '__module__', None)
  2234|         0|            0|            0|  0.00%|    if module_name:
  2235|         0|            0|            0|  0.00%|        module = sys.modules.get(module_name, None)
  2236|         0|            0|            0|  0.00%|        if module:
  2237|         0|            0|            0|  0.00%|            module_dict = module.__dict__
  2238|         0|            0|            0|  0.00%|    sys_module_dict = sys.modules.copy()
  2239|         0|            0|            0|  0.00%|
  2240|         0|            0|            0|  0.00%|    def parse_name(node):
  2241|         0|            0|            0|  0.00%|        assert isinstance(node, ast.arg)
  2242|         0|            0|            0|  0.00%|        if node.annotation is not None:
  2243|         0|            0|            0|  0.00%|            raise ValueError("Annotations are not currently supported")
  2244|         0|            0|            0|  0.00%|        return node.arg
  2245|         0|            0|            0|  0.00%|
  2246|         0|            0|            0|  0.00%|    def wrap_value(s):
  2247|         0|            0|            0|  0.00%|        try:
  2248|         0|            0|            0|  0.00%|            value = eval(s, module_dict)
  2249|         0|            0|            0|  0.00%|        except NameError:
  2250|         0|            0|            0|  0.00%|            try:
  2251|         0|            0|            0|  0.00%|                value = eval(s, sys_module_dict)
  2252|         0|            0|            0|  0.00%|            except NameError:
  2253|         0|            0|            0|  0.00%|                raise ValueError
  2254|         0|            0|            0|  0.00%|
  2255|         0|            0|            0|  0.00%|        if isinstance(value, (str, int, float, bytes, bool, type(None))):
  2256|         0|            0|            0|  0.00%|            return ast.Constant(value)
  2257|         0|            0|            0|  0.00%|        raise ValueError
  2258|         0|            0|            0|  0.00%|
  2259|         0|            0|            0|  0.00%|    class RewriteSymbolics(ast.NodeTransformer):
  2260|         0|            0|            0|  0.00%|        def visit_Attribute(self, node):
  2261|         0|            0|            0|  0.00%|            a = []
  2262|         0|            0|            0|  0.00%|            n = node
  2263|         0|            0|            0|  0.00%|            while isinstance(n, ast.Attribute):
  2264|         0|            0|            0|  0.00%|                a.append(n.attr)
  2265|         0|            0|            0|  0.00%|                n = n.value
  2266|         0|            0|            0|  0.00%|            if not isinstance(n, ast.Name):
  2267|         0|            0|            0|  0.00%|                raise ValueError
  2268|         0|            0|            0|  0.00%|            a.append(n.id)
  2269|         0|            0|            0|  0.00%|            value = ".".join(reversed(a))
  2270|         0|            0|            0|  0.00%|            return wrap_value(value)
  2271|         0|            0|            0|  0.00%|
  2272|         0|            0|            0|  0.00%|        def visit_Name(self, node):
  2273|         0|            0|            0|  0.00%|            if not isinstance(node.ctx, ast.Load):
  2274|         0|            0|            0|  0.00%|                raise ValueError()
  2275|         0|            0|            0|  0.00%|            return wrap_value(node.id)
  2276|         0|            0|            0|  0.00%|
  2277|         0|            0|            0|  0.00%|        def visit_BinOp(self, node):
  2278|         0|            0|            0|  0.00%|            # Support constant folding of a couple simple binary operations
  2279|         0|            0|            0|  0.00%|            # commonly used to define default values in text signatures
  2280|         0|            0|            0|  0.00%|            left = self.visit(node.left)
  2281|         0|            0|            0|  0.00%|            right = self.visit(node.right)
  2282|         0|            0|            0|  0.00%|            if not isinstance(left, ast.Constant) or not isinstance(right, ast.Constant):
  2283|         0|            0|            0|  0.00%|                raise ValueError
  2284|         0|            0|            0|  0.00%|            if isinstance(node.op, ast.Add):
  2285|         0|            0|            0|  0.00%|                return ast.Constant(left.value + right.value)
  2286|         0|            0|            0|  0.00%|            elif isinstance(node.op, ast.Sub):
  2287|         0|            0|            0|  0.00%|                return ast.Constant(left.value - right.value)
  2288|         0|            0|            0|  0.00%|            elif isinstance(node.op, ast.BitOr):
  2289|         0|            0|            0|  0.00%|                return ast.Constant(left.value | right.value)
  2290|         0|            0|            0|  0.00%|            raise ValueError
  2291|         0|            0|            0|  0.00%|
  2292|         0|            0|            0|  0.00%|    def p(name_node, default_node, default=empty):
  2293|         0|            0|            0|  0.00%|        name = parse_name(name_node)
  2294|         0|            0|            0|  0.00%|        if default_node and default_node is not _empty:
  2295|         0|            0|            0|  0.00%|            try:
  2296|         0|            0|            0|  0.00%|                default_node = RewriteSymbolics().visit(default_node)
  2297|         0|            0|            0|  0.00%|                default = ast.literal_eval(default_node)
  2298|         0|            0|            0|  0.00%|            except ValueError:
  2299|         0|            0|            0|  0.00%|                raise ValueError("{!r} builtin has invalid signature".format(obj)) from None
  2300|         0|            0|            0|  0.00%|        parameters.append(Parameter(name, kind, default=default, annotation=empty))
  2301|         0|            0|            0|  0.00%|
  2302|         0|            0|            0|  0.00%|    # non-keyword-only parameters
  2303|         0|            0|            0|  0.00%|    total_non_kw_args = len(f.args.posonlyargs) + len(f.args.args)
  2304|         0|            0|            0|  0.00%|    required_non_kw_args = total_non_kw_args - len(f.args.defaults)
  2305|         0|            0|            0|  0.00%|    defaults = itertools.chain(itertools.repeat(None, required_non_kw_args), f.args.defaults)
  2306|         0|            0|            0|  0.00%|
  2307|         0|            0|            0|  0.00%|    kind = Parameter.POSITIONAL_ONLY
  2308|         0|            0|            0|  0.00%|    for (name, default) in zip(f.args.posonlyargs, defaults):
  2309|         0|            0|            0|  0.00%|        p(name, default)
  2310|         0|            0|            0|  0.00%|
  2311|         0|            0|            0|  0.00%|    kind = Parameter.POSITIONAL_OR_KEYWORD
  2312|         0|            0|            0|  0.00%|    for (name, default) in zip(f.args.args, defaults):
  2313|         0|            0|            0|  0.00%|        p(name, default)
  2314|         0|            0|            0|  0.00%|
  2315|         0|            0|            0|  0.00%|    # *args
  2316|         0|            0|            0|  0.00%|    if f.args.vararg:
  2317|         0|            0|            0|  0.00%|        kind = Parameter.VAR_POSITIONAL
  2318|         0|            0|            0|  0.00%|        p(f.args.vararg, empty)
  2319|         0|            0|            0|  0.00%|
  2320|         0|            0|            0|  0.00%|    # keyword-only arguments
  2321|         0|            0|            0|  0.00%|    kind = Parameter.KEYWORD_ONLY
  2322|         0|            0|            0|  0.00%|    for name, default in zip(f.args.kwonlyargs, f.args.kw_defaults):
  2323|         0|            0|            0|  0.00%|        p(name, default)
  2324|         0|            0|            0|  0.00%|
  2325|         0|            0|            0|  0.00%|    # **kwargs
  2326|         0|            0|            0|  0.00%|    if f.args.kwarg:
  2327|         0|            0|            0|  0.00%|        kind = Parameter.VAR_KEYWORD
  2328|         0|            0|            0|  0.00%|        p(f.args.kwarg, empty)
  2329|         0|            0|            0|  0.00%|
  2330|         0|            0|            0|  0.00%|    if self_parameter is not None:
  2331|         0|            0|            0|  0.00%|        # Possibly strip the bound argument:
  2332|         0|            0|            0|  0.00%|        #    - We *always* strip first bound argument if
  2333|         0|            0|            0|  0.00%|        #      it is a module.
  2334|         0|            0|            0|  0.00%|        #    - We don't strip first bound argument if
  2335|         0|            0|            0|  0.00%|        #      skip_bound_arg is False.
  2336|         0|            0|            0|  0.00%|        assert parameters
  2337|         0|            0|            0|  0.00%|        _self = getattr(obj, '__self__', None)
  2338|         0|            0|            0|  0.00%|        self_isbound = _self is not None
  2339|         0|            0|            0|  0.00%|        self_ismodule = ismodule(_self)
  2340|         0|            0|            0|  0.00%|        if self_isbound and (self_ismodule or skip_bound_arg):
  2341|         0|            0|            0|  0.00%|            parameters.pop(0)
  2342|         0|            0|            0|  0.00%|        else:
  2343|         0|            0|            0|  0.00%|            # for builtins, self parameter is always positional-only!
  2344|         0|            0|            0|  0.00%|            p = parameters[0].replace(kind=Parameter.POSITIONAL_ONLY)
  2345|         0|            0|            0|  0.00%|            parameters[0] = p
  2346|         0|            0|            0|  0.00%|
  2347|         0|            0|            0|  0.00%|    return cls(parameters, return_annotation=cls.empty)
  2348|         0|            0|            0|  0.00%|
  2349|         0|            0|            0|  0.00%|
  2350|         0|            0|            0|  0.00%|def _signature_from_builtin(cls, func, skip_bound_arg=True):
  2351|         0|            0|            0|  0.00%|    """Private helper function to get signature for
  2352|         0|            0|            0|  0.00%|    builtin callables.
  2353|         0|            0|            0|  0.00%|    """
  2354|         0|            0|            0|  0.00%|
  2355|         0|            0|            0|  0.00%|    if not _signature_is_builtin(func):
  2356|         0|            0|            0|  0.00%|        raise TypeError("{!r} is not a Python builtin "
  2357|         0|            0|            0|  0.00%|                        "function".format(func))
  2358|         0|            0|            0|  0.00%|
  2359|         0|            0|            0|  0.00%|    s = getattr(func, "__text_signature__", None)
  2360|         0|            0|            0|  0.00%|    if not s:
  2361|         0|            0|            0|  0.00%|        raise ValueError("no signature found for builtin {!r}".format(func))
  2362|         0|            0|            0|  0.00%|
  2363|         0|            0|            0|  0.00%|    return _signature_fromstr(cls, func, s, skip_bound_arg)
  2364|         0|            0|            0|  0.00%|
  2365|         0|            0|            0|  0.00%|
  2366|         1|  1.26362e-05|  1.26362e-05|  0.01%|def _signature_from_function(cls, func, skip_bound_arg=True,
  2367|         0|            0|            0|  0.00%|                             globals=None, locals=None, eval_str=False):
  2368|         0|            0|            0|  0.00%|    """Private helper: constructs Signature for the given python function."""
  2369|         0|            0|            0|  0.00%|
  2370|         1|  5.48363e-06|  5.48363e-06|  0.01%|    is_duck_function = False
  2371|         1|  1.33514e-05|  1.33514e-05|  0.01%|    if not isfunction(func):
(call)|         1|  1.64509e-05|  1.64509e-05|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:371 isfunction
  2372|         0|            0|            0|  0.00%|        if _signature_is_functionlike(func):
  2373|         0|            0|            0|  0.00%|            is_duck_function = True
  2374|         0|            0|            0|  0.00%|        else:
  2375|         0|            0|            0|  0.00%|            # If it's not a pure Python function, and not a duck type
  2376|         0|            0|            0|  0.00%|            # of pure function:
  2377|         0|            0|            0|  0.00%|            raise TypeError('{!r} is not a Python function'.format(func))
  2378|         0|            0|            0|  0.00%|
  2379|         1|  6.67572e-06|  6.67572e-06|  0.01%|    s = getattr(func, "__text_signature__", None)
  2380|         1|  7.15256e-06|  7.15256e-06|  0.01%|    if s:
  2381|         0|            0|            0|  0.00%|        return _signature_fromstr(cls, func, s, skip_bound_arg)
  2382|         0|            0|            0|  0.00%|
  2383|         1|  5.24521e-06|  5.24521e-06|  0.01%|    Parameter = cls._parameter_cls
  2384|         0|            0|            0|  0.00%|
  2385|         0|            0|            0|  0.00%|    # Parameter information.
  2386|         1|  5.72205e-06|  5.72205e-06|  0.01%|    func_code = func.__code__
  2387|         1|  5.24521e-06|  5.24521e-06|  0.01%|    pos_count = func_code.co_argcount
  2388|         1|  6.19888e-06|  6.19888e-06|  0.01%|    arg_names = func_code.co_varnames
  2389|         1|  4.76837e-06|  4.76837e-06|  0.00%|    posonly_count = func_code.co_posonlyargcount
  2390|         1|  5.48363e-06|  5.48363e-06|  0.01%|    positional = arg_names[:pos_count]
  2391|         1|  5.00679e-06|  5.00679e-06|  0.01%|    keyword_only_count = func_code.co_kwonlyargcount
  2392|         1|  5.24521e-06|  5.24521e-06|  0.01%|    keyword_only = arg_names[pos_count:pos_count + keyword_only_count]
  2393|         1|  3.45707e-05|  3.45707e-05|  0.04%|    annotations = get_annotations(func, globals=globals, locals=locals, eval_str=eval_str)
(call)|         1|  7.10487e-05|  7.10487e-05|  0.07%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:175 get_annotations
  2394|         1|  5.48363e-06|  5.48363e-06|  0.01%|    defaults = func.__defaults__
  2395|         1|  5.00679e-06|  5.00679e-06|  0.01%|    kwdefaults = func.__kwdefaults__
  2396|         0|            0|            0|  0.00%|
  2397|         1|  5.24521e-06|  5.24521e-06|  0.01%|    if defaults:
  2398|         0|            0|            0|  0.00%|        pos_default_count = len(defaults)
  2399|         0|            0|            0|  0.00%|    else:
  2400|         1|  6.67572e-06|  6.67572e-06|  0.01%|        pos_default_count = 0
  2401|         0|            0|            0|  0.00%|
  2402|         1|  5.00679e-06|  5.00679e-06|  0.01%|    parameters = []
  2403|         0|            0|            0|  0.00%|
  2404|         1|  5.24521e-06|  5.24521e-06|  0.01%|    non_default_count = pos_count - pos_default_count
  2405|         1|  4.76837e-06|  4.76837e-06|  0.00%|    posonly_left = posonly_count
  2406|         0|            0|            0|  0.00%|
  2407|         0|            0|            0|  0.00%|    # Non-keyword-only parameters w/o defaults.
  2408|         4|  1.83582e-05|  4.58956e-06|  0.02%|    for name in positional[:non_default_count]:
  2409|         3|  1.16825e-05|  3.89417e-06|  0.01%|        kind = _POSITIONAL_ONLY if posonly_left else _POSITIONAL_OR_KEYWORD
  2410|         3|   1.3113e-05|  4.37101e-06|  0.01%|        annotation = annotations.get(name, _empty)
  2411|         6|  7.36713e-05|  1.22786e-05|  0.08%|        parameters.append(Parameter(name, annotation=annotation,
(call)|         3|  0.000254154|  8.47181e-05|  0.26%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:2712 __init__
  2412|         3|  1.16825e-05|  3.89417e-06|  0.01%|                                    kind=kind))
  2413|         3|  1.09673e-05|  3.65575e-06|  0.01%|        if posonly_left:
  2414|         0|            0|            0|  0.00%|            posonly_left -= 1
  2415|         0|            0|            0|  0.00%|
  2416|         0|            0|            0|  0.00%|    # ... w/ defaults.
  2417|         1|  5.24521e-06|  5.24521e-06|  0.01%|    for offset, name in enumerate(positional[non_default_count:]):
  2418|         0|            0|            0|  0.00%|        kind = _POSITIONAL_ONLY if posonly_left else _POSITIONAL_OR_KEYWORD
  2419|         0|            0|            0|  0.00%|        annotation = annotations.get(name, _empty)
  2420|         0|            0|            0|  0.00%|        parameters.append(Parameter(name, annotation=annotation,
  2421|         0|            0|            0|  0.00%|                                    kind=kind,
  2422|         0|            0|            0|  0.00%|                                    default=defaults[offset]))
  2423|         0|            0|            0|  0.00%|        if posonly_left:
  2424|         0|            0|            0|  0.00%|            posonly_left -= 1
  2425|         0|            0|            0|  0.00%|
  2426|         0|            0|            0|  0.00%|    # *args
  2427|         1|  9.29832e-06|  9.29832e-06|  0.01%|    if func_code.co_flags & CO_VARARGS:
  2428|         0|            0|            0|  0.00%|        name = arg_names[pos_count + keyword_only_count]
  2429|         0|            0|            0|  0.00%|        annotation = annotations.get(name, _empty)
  2430|         0|            0|            0|  0.00%|        parameters.append(Parameter(name, annotation=annotation,
  2431|         0|            0|            0|  0.00%|                                    kind=_VAR_POSITIONAL))
  2432|         0|            0|            0|  0.00%|
  2433|         0|            0|            0|  0.00%|    # Keyword-only parameters.
  2434|         1|  6.19888e-06|  6.19888e-06|  0.01%|    for name in keyword_only:
  2435|         0|            0|            0|  0.00%|        default = _empty
  2436|         0|            0|            0|  0.00%|        if kwdefaults is not None:
  2437|         0|            0|            0|  0.00%|            default = kwdefaults.get(name, _empty)
  2438|         0|            0|            0|  0.00%|
  2439|         0|            0|            0|  0.00%|        annotation = annotations.get(name, _empty)
  2440|         0|            0|            0|  0.00%|        parameters.append(Parameter(name, annotation=annotation,
  2441|         0|            0|            0|  0.00%|                                    kind=_KEYWORD_ONLY,
  2442|         0|            0|            0|  0.00%|                                    default=default))
  2443|         0|            0|            0|  0.00%|    # **kwargs
  2444|         1|  1.16825e-05|  1.16825e-05|  0.01%|    if func_code.co_flags & CO_VARKEYWORDS:
  2445|         0|            0|            0|  0.00%|        index = pos_count + keyword_only_count
  2446|         0|            0|            0|  0.00%|        if func_code.co_flags & CO_VARARGS:
  2447|         0|            0|            0|  0.00%|            index += 1
  2448|         0|            0|            0|  0.00%|
  2449|         0|            0|            0|  0.00%|        name = arg_names[index]
  2450|         0|            0|            0|  0.00%|        annotation = annotations.get(name, _empty)
  2451|         0|            0|            0|  0.00%|        parameters.append(Parameter(name, annotation=annotation,
  2452|         0|            0|            0|  0.00%|                                    kind=_VAR_KEYWORD))
  2453|         0|            0|            0|  0.00%|
  2454|         0|            0|            0|  0.00%|    # Is 'func' is a pure Python function - don't validate the
  2455|         0|            0|            0|  0.00%|    # parameters list (for correct order and defaults), it should be OK.
  2456|         2|  4.00543e-05|  2.00272e-05|  0.04%|    return cls(parameters,
(call)|         1|  0.000194788|  0.000194788|  0.20%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:2998 __init__
  2457|         1|  9.53674e-06|  9.53674e-06|  0.01%|               return_annotation=annotations.get('return', _empty),
  2458|         1|   6.4373e-06|   6.4373e-06|  0.01%|               __validate_parameters__=is_duck_function)
  2459|         0|            0|            0|  0.00%|
  2460|         0|            0|            0|  0.00%|
  2461|         0|            0|            0|  0.00%|def _descriptor_get(descriptor, obj):
  2462|         0|            0|            0|  0.00%|    if isclass(descriptor):
  2463|         0|            0|            0|  0.00%|        return descriptor
  2464|         0|            0|            0|  0.00%|    get = getattr(type(descriptor), '__get__', _sentinel)
  2465|         0|            0|            0|  0.00%|    if get is _sentinel:
  2466|         0|            0|            0|  0.00%|        return descriptor
  2467|         0|            0|            0|  0.00%|    return get(descriptor, obj, type(obj))
  2468|         0|            0|            0|  0.00%|
  2469|         0|            0|            0|  0.00%|
  2470|         1|  1.07288e-05|  1.07288e-05|  0.01%|def _signature_from_callable(obj, *,
  2471|         0|            0|            0|  0.00%|                             follow_wrapper_chains=True,
  2472|         0|            0|            0|  0.00%|                             skip_bound_arg=True,
  2473|         0|            0|            0|  0.00%|                             globals=None,
  2474|         0|            0|            0|  0.00%|                             locals=None,
  2475|         0|            0|            0|  0.00%|                             eval_str=False,
  2476|         0|            0|            0|  0.00%|                             sigcls):
  2477|         0|            0|            0|  0.00%|
  2478|         0|            0|            0|  0.00%|    """Private helper function to get signature for arbitrary
  2479|         0|            0|            0|  0.00%|    callable objects.
  2480|         0|            0|            0|  0.00%|    """
  2481|         0|            0|            0|  0.00%|
  2482|         2|  1.57356e-05|  7.86781e-06|  0.02%|    _get_signature_of = functools.partial(_signature_from_callable,
  2483|         1|   6.4373e-06|   6.4373e-06|  0.01%|                                follow_wrapper_chains=follow_wrapper_chains,
  2484|         1|   6.4373e-06|   6.4373e-06|  0.01%|                                skip_bound_arg=skip_bound_arg,
  2485|         1|  6.67572e-06|  6.67572e-06|  0.01%|                                globals=globals,
  2486|         1|  6.19888e-06|  6.19888e-06|  0.01%|                                locals=locals,
  2487|         1|   6.4373e-06|   6.4373e-06|  0.01%|                                sigcls=sigcls,
  2488|         1|   6.4373e-06|   6.4373e-06|  0.01%|                                eval_str=eval_str)
  2489|         0|            0|            0|  0.00%|
  2490|         1|  4.29153e-06|  4.29153e-06|  0.00%|    if not callable(obj):
  2491|         0|            0|            0|  0.00%|        raise TypeError('{!r} is not a callable object'.format(obj))
  2492|         0|            0|            0|  0.00%|
  2493|         1|  7.39098e-06|  7.39098e-06|  0.01%|    if isinstance(obj, types.MethodType):
  2494|         0|            0|            0|  0.00%|        # In this case we skip the first parameter of the underlying
  2495|         0|            0|            0|  0.00%|        # function (usually `self` or `cls`).
  2496|         0|            0|            0|  0.00%|        sig = _get_signature_of(obj.__func__)
  2497|         0|            0|            0|  0.00%|
  2498|         0|            0|            0|  0.00%|        if skip_bound_arg:
  2499|         0|            0|            0|  0.00%|            return _signature_bound_method(sig)
  2500|         0|            0|            0|  0.00%|        else:
  2501|         0|            0|            0|  0.00%|            return sig
  2502|         0|            0|            0|  0.00%|
  2503|         0|            0|            0|  0.00%|    # Was this function wrapped by a decorator?
  2504|         1|   6.4373e-06|   6.4373e-06|  0.01%|    if follow_wrapper_chains:
  2505|         0|            0|            0|  0.00%|        # Unwrap until we find an explicit signature or a MethodType (which will be
  2506|         0|            0|            0|  0.00%|        # handled explicitly below).
  2507|         1|  2.64645e-05|  2.64645e-05|  0.03%|        obj = unwrap(obj, stop=(lambda f: hasattr(f, "__signature__")
(call)|         1|  2.71797e-05|  2.71797e-05|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:747 unwrap
  2508|         0|            0|            0|  0.00%|                                or isinstance(f, types.MethodType)))
  2509|         1|  7.39098e-06|  7.39098e-06|  0.01%|        if isinstance(obj, types.MethodType):
  2510|         0|            0|            0|  0.00%|            # If the unwrapped object is a *method*, we might want to
  2511|         0|            0|            0|  0.00%|            # skip its first parameter (self).
  2512|         0|            0|            0|  0.00%|            # See test_signature_wrapped_bound_method for details.
  2513|         0|            0|            0|  0.00%|            return _get_signature_of(obj)
  2514|         0|            0|            0|  0.00%|
  2515|         1|  6.67572e-06|  6.67572e-06|  0.01%|    try:
  2516|         1|  1.09673e-05|  1.09673e-05|  0.01%|        sig = obj.__signature__
  2517|         1|  8.82149e-06|  8.82149e-06|  0.01%|    except AttributeError:
  2518|         1|  6.91414e-06|  6.91414e-06|  0.01%|        pass
  2519|         0|            0|            0|  0.00%|    else:
  2520|         0|            0|            0|  0.00%|        if sig is not None:
  2521|         0|            0|            0|  0.00%|            # since __text_signature__ is not writable on classes, __signature__
  2522|         0|            0|            0|  0.00%|            # may contain text (or be a callable that returns text);
  2523|         0|            0|            0|  0.00%|            # if so, convert it
  2524|         0|            0|            0|  0.00%|            o_sig = sig
  2525|         0|            0|            0|  0.00%|            if not isinstance(sig, (Signature, str)) and callable(sig):
  2526|         0|            0|            0|  0.00%|                sig = sig()
  2527|         0|            0|            0|  0.00%|            if isinstance(sig, str):
  2528|         0|            0|            0|  0.00%|                sig = _signature_fromstr(sigcls, obj, sig)
  2529|         0|            0|            0|  0.00%|            if not isinstance(sig, Signature):
  2530|         0|            0|            0|  0.00%|                raise TypeError(
  2531|         0|            0|            0|  0.00%|                    'unexpected object {!r} in __signature__ '
  2532|         0|            0|            0|  0.00%|                    'attribute'.format(o_sig))
  2533|         0|            0|            0|  0.00%|            return sig
  2534|         0|            0|            0|  0.00%|
  2535|         1|  7.15256e-06|  7.15256e-06|  0.01%|    try:
  2536|         1|  1.00136e-05|  1.00136e-05|  0.01%|        partialmethod = obj._partialmethod
  2537|         1|  6.91414e-06|  6.91414e-06|  0.01%|    except AttributeError:
  2538|         1|  6.67572e-06|  6.67572e-06|  0.01%|        pass
  2539|         0|            0|            0|  0.00%|    else:
  2540|         0|            0|            0|  0.00%|        if isinstance(partialmethod, functools.partialmethod):
  2541|         0|            0|            0|  0.00%|            # Unbound partialmethod (see functools.partialmethod)
  2542|         0|            0|            0|  0.00%|            # This means, that we need to calculate the signature
  2543|         0|            0|            0|  0.00%|            # as if it's a regular partial object, but taking into
  2544|         0|            0|            0|  0.00%|            # account that the first positional argument
  2545|         0|            0|            0|  0.00%|            # (usually `self`, or `cls`) will not be passed
  2546|         0|            0|            0|  0.00%|            # automatically (as for boundmethods)
  2547|         0|            0|            0|  0.00%|
  2548|         0|            0|            0|  0.00%|            wrapped_sig = _get_signature_of(partialmethod.func)
  2549|         0|            0|            0|  0.00%|
  2550|         0|            0|            0|  0.00%|            sig = _signature_get_partial(wrapped_sig, partialmethod, (None,))
  2551|         0|            0|            0|  0.00%|            first_wrapped_param = tuple(wrapped_sig.parameters.values())[0]
  2552|         0|            0|            0|  0.00%|            if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:
  2553|         0|            0|            0|  0.00%|                # First argument of the wrapped callable is `*args`, as in
  2554|         0|            0|            0|  0.00%|                # `partialmethod(lambda *args)`.
  2555|         0|            0|            0|  0.00%|                return sig
  2556|         0|            0|            0|  0.00%|            else:
  2557|         0|            0|            0|  0.00%|                sig_params = tuple(sig.parameters.values())
  2558|         0|            0|            0|  0.00%|                assert (not sig_params or
  2559|         0|            0|            0|  0.00%|                        first_wrapped_param is not sig_params[0])
  2560|         0|            0|            0|  0.00%|                new_params = (first_wrapped_param,) + sig_params
  2561|         0|            0|            0|  0.00%|                return sig.replace(parameters=new_params)
  2562|         0|            0|            0|  0.00%|
  2563|         1|   2.3365e-05|   2.3365e-05|  0.02%|    if isfunction(obj) or _signature_is_functionlike(obj):
(call)|         1|  1.00136e-05|  1.00136e-05|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:371 isfunction
  2564|         0|            0|            0|  0.00%|        # If it's a pure Python function, or an object that is duck type
  2565|         0|            0|            0|  0.00%|        # of a Python function (Cython functions, for instance), then:
  2566|         2|  5.19753e-05|  2.59876e-05|  0.05%|        return _signature_from_function(sigcls, obj,
(call)|         1|  0.000924587|  0.000924587|  0.95%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:2366 _signature_from_function
  2567|         1|  6.67572e-06|  6.67572e-06|  0.01%|                                        skip_bound_arg=skip_bound_arg,
  2568|         1|  6.67572e-06|  6.67572e-06|  0.01%|                                        globals=globals, locals=locals, eval_str=eval_str)
  2569|         0|            0|            0|  0.00%|
  2570|         0|            0|            0|  0.00%|    if _signature_is_builtin(obj):
  2571|         0|            0|            0|  0.00%|        return _signature_from_builtin(sigcls, obj,
  2572|         0|            0|            0|  0.00%|                                       skip_bound_arg=skip_bound_arg)
  2573|         0|            0|            0|  0.00%|
  2574|         0|            0|            0|  0.00%|    if isinstance(obj, functools.partial):
  2575|         0|            0|            0|  0.00%|        wrapped_sig = _get_signature_of(obj.func)
  2576|         0|            0|            0|  0.00%|        return _signature_get_partial(wrapped_sig, obj)
  2577|         0|            0|            0|  0.00%|
  2578|         0|            0|            0|  0.00%|    if isinstance(obj, type):
  2579|         0|            0|            0|  0.00%|        # obj is a class or a metaclass
  2580|         0|            0|            0|  0.00%|
  2581|         0|            0|            0|  0.00%|        # First, let's see if it has an overloaded __call__ defined
  2582|         0|            0|            0|  0.00%|        # in its metaclass
  2583|         0|            0|            0|  0.00%|        call = _signature_get_user_defined_method(type(obj), '__call__')
  2584|         0|            0|            0|  0.00%|        if call is not None:
  2585|         0|            0|            0|  0.00%|            return _get_signature_of(call)
  2586|         0|            0|            0|  0.00%|
  2587|         0|            0|            0|  0.00%|        new = _signature_get_user_defined_method(obj, '__new__')
  2588|         0|            0|            0|  0.00%|        init = _signature_get_user_defined_method(obj, '__init__')
  2589|         0|            0|            0|  0.00%|
  2590|         0|            0|            0|  0.00%|        # Go through the MRO and see if any class has user-defined
  2591|         0|            0|            0|  0.00%|        # pure Python __new__ or __init__ method
  2592|         0|            0|            0|  0.00%|        for base in obj.__mro__:
  2593|         0|            0|            0|  0.00%|            # Now we check if the 'obj' class has an own '__new__' method
  2594|         0|            0|            0|  0.00%|            if new is not None and '__new__' in base.__dict__:
  2595|         0|            0|            0|  0.00%|                sig = _get_signature_of(new)
  2596|         0|            0|            0|  0.00%|                if skip_bound_arg:
  2597|         0|            0|            0|  0.00%|                    sig = _signature_bound_method(sig)
  2598|         0|            0|            0|  0.00%|                return sig
  2599|         0|            0|            0|  0.00%|            # or an own '__init__' method
  2600|         0|            0|            0|  0.00%|            elif init is not None and '__init__' in base.__dict__:
  2601|         0|            0|            0|  0.00%|                return _get_signature_of(init)
  2602|         0|            0|            0|  0.00%|
  2603|         0|            0|            0|  0.00%|        # At this point we know, that `obj` is a class, with no user-
  2604|         0|            0|            0|  0.00%|        # defined '__init__', '__new__', or class-level '__call__'
  2605|         0|            0|            0|  0.00%|
  2606|         0|            0|            0|  0.00%|        for base in obj.__mro__[:-1]:
  2607|         0|            0|            0|  0.00%|            # Since '__text_signature__' is implemented as a
  2608|         0|            0|            0|  0.00%|            # descriptor that extracts text signature from the
  2609|         0|            0|            0|  0.00%|            # class docstring, if 'obj' is derived from a builtin
  2610|         0|            0|            0|  0.00%|            # class, its own '__text_signature__' may be 'None'.
  2611|         0|            0|            0|  0.00%|            # Therefore, we go through the MRO (except the last
  2612|         0|            0|            0|  0.00%|            # class in there, which is 'object') to find the first
  2613|         0|            0|            0|  0.00%|            # class with non-empty text signature.
  2614|         0|            0|            0|  0.00%|            try:
  2615|         0|            0|            0|  0.00%|                text_sig = base.__text_signature__
  2616|         0|            0|            0|  0.00%|            except AttributeError:
  2617|         0|            0|            0|  0.00%|                pass
  2618|         0|            0|            0|  0.00%|            else:
  2619|         0|            0|            0|  0.00%|                if text_sig:
  2620|         0|            0|            0|  0.00%|                    # If 'base' class has a __text_signature__ attribute:
  2621|         0|            0|            0|  0.00%|                    # return a signature based on it
  2622|         0|            0|            0|  0.00%|                    return _signature_fromstr(sigcls, base, text_sig)
  2623|         0|            0|            0|  0.00%|
  2624|         0|            0|            0|  0.00%|        # No '__text_signature__' was found for the 'obj' class.
  2625|         0|            0|            0|  0.00%|        # Last option is to check if its '__init__' is
  2626|         0|            0|            0|  0.00%|        # object.__init__ or type.__init__.
  2627|         0|            0|            0|  0.00%|        if type not in obj.__mro__:
  2628|         0|            0|            0|  0.00%|            # We have a class (not metaclass), but no user-defined
  2629|         0|            0|            0|  0.00%|            # __init__ or __new__ for it
  2630|         0|            0|            0|  0.00%|            if (obj.__init__ is object.__init__ and
  2631|         0|            0|            0|  0.00%|                obj.__new__ is object.__new__):
  2632|         0|            0|            0|  0.00%|                # Return a signature of 'object' builtin.
  2633|         0|            0|            0|  0.00%|                return sigcls.from_callable(object)
  2634|         0|            0|            0|  0.00%|            else:
  2635|         0|            0|            0|  0.00%|                raise ValueError(
  2636|         0|            0|            0|  0.00%|                    'no signature found for builtin type {!r}'.format(obj))
  2637|         0|            0|            0|  0.00%|
  2638|         0|            0|            0|  0.00%|    else:
  2639|         0|            0|            0|  0.00%|        # An object with __call__
  2640|         0|            0|            0|  0.00%|        call = getattr_static(type(obj), '__call__', None)
  2641|         0|            0|            0|  0.00%|        if call is not None:
  2642|         0|            0|            0|  0.00%|            call = _descriptor_get(call, obj)
  2643|         0|            0|            0|  0.00%|            return _get_signature_of(call)
  2644|         0|            0|            0|  0.00%|
  2645|         0|            0|            0|  0.00%|    raise ValueError('callable {!r} is not supported by signature'.format(obj))
  2646|         0|            0|            0|  0.00%|
  2647|         0|            0|            0|  0.00%|
  2648|         0|            0|            0|  0.00%|class _void:
  2649|         0|            0|            0|  0.00%|    """A private marker - used in Parameter & Signature."""
  2650|         0|            0|            0|  0.00%|
  2651|         0|            0|            0|  0.00%|
  2652|         0|            0|            0|  0.00%|class _empty:
  2653|         0|            0|            0|  0.00%|    """Marker object for Signature.empty and Parameter.empty."""
  2654|         0|            0|            0|  0.00%|
  2655|         0|            0|            0|  0.00%|
  2656|         0|            0|            0|  0.00%|class _ParameterKind(enum.IntEnum):
  2657|         0|            0|            0|  0.00%|    POSITIONAL_ONLY = 'positional-only'
  2658|         0|            0|            0|  0.00%|    POSITIONAL_OR_KEYWORD = 'positional or keyword'
  2659|         0|            0|            0|  0.00%|    VAR_POSITIONAL = 'variadic positional'
  2660|         0|            0|            0|  0.00%|    KEYWORD_ONLY = 'keyword-only'
  2661|         0|            0|            0|  0.00%|    VAR_KEYWORD = 'variadic keyword'
  2662|         0|            0|            0|  0.00%|
  2663|         0|            0|            0|  0.00%|    def __new__(cls, description):
  2664|         0|            0|            0|  0.00%|        value = len(cls.__members__)
  2665|         0|            0|            0|  0.00%|        member = int.__new__(cls, value)
  2666|         0|            0|            0|  0.00%|        member._value_ = value
  2667|         0|            0|            0|  0.00%|        member.description = description
  2668|         0|            0|            0|  0.00%|        return member
  2669|         0|            0|            0|  0.00%|
  2670|         0|            0|            0|  0.00%|    def __str__(self):
  2671|         0|            0|            0|  0.00%|        return self.name
  2672|         0|            0|            0|  0.00%|
  2673|         0|            0|            0|  0.00%|_POSITIONAL_ONLY         = _ParameterKind.POSITIONAL_ONLY
  2674|         0|            0|            0|  0.00%|_POSITIONAL_OR_KEYWORD   = _ParameterKind.POSITIONAL_OR_KEYWORD
  2675|         0|            0|            0|  0.00%|_VAR_POSITIONAL          = _ParameterKind.VAR_POSITIONAL
  2676|         0|            0|            0|  0.00%|_KEYWORD_ONLY            = _ParameterKind.KEYWORD_ONLY
  2677|         0|            0|            0|  0.00%|_VAR_KEYWORD             = _ParameterKind.VAR_KEYWORD
  2678|         0|            0|            0|  0.00%|
  2679|         0|            0|            0|  0.00%|
  2680|         0|            0|            0|  0.00%|class Parameter:
  2681|         0|            0|            0|  0.00%|    """Represents a parameter in a function signature.
  2682|         0|            0|            0|  0.00%|
  2683|         0|            0|            0|  0.00%|    Has the following public attributes:
  2684|         0|            0|            0|  0.00%|
  2685|         0|            0|            0|  0.00%|    * name : str
  2686|         0|            0|            0|  0.00%|        The name of the parameter as a string.
  2687|         0|            0|            0|  0.00%|    * default : object
  2688|         0|            0|            0|  0.00%|        The default value for the parameter if specified.  If the
  2689|         0|            0|            0|  0.00%|        parameter has no default value, this attribute is set to
  2690|         0|            0|            0|  0.00%|        `Parameter.empty`.
  2691|         0|            0|            0|  0.00%|    * annotation
  2692|         0|            0|            0|  0.00%|        The annotation for the parameter if specified.  If the
  2693|         0|            0|            0|  0.00%|        parameter has no annotation, this attribute is set to
  2694|         0|            0|            0|  0.00%|        `Parameter.empty`.
  2695|         0|            0|            0|  0.00%|    * kind : str
  2696|         0|            0|            0|  0.00%|        Describes how argument values are bound to the parameter.
  2697|         0|            0|            0|  0.00%|        Possible values: `Parameter.POSITIONAL_ONLY`,
  2698|         0|            0|            0|  0.00%|        `Parameter.POSITIONAL_OR_KEYWORD`, `Parameter.VAR_POSITIONAL`,
  2699|         0|            0|            0|  0.00%|        `Parameter.KEYWORD_ONLY`, `Parameter.VAR_KEYWORD`.
  2700|         0|            0|            0|  0.00%|    """
  2701|         0|            0|            0|  0.00%|
  2702|         0|            0|            0|  0.00%|    __slots__ = ('_name', '_kind', '_default', '_annotation')
  2703|         0|            0|            0|  0.00%|
  2704|         0|            0|            0|  0.00%|    POSITIONAL_ONLY         = _POSITIONAL_ONLY
  2705|         0|            0|            0|  0.00%|    POSITIONAL_OR_KEYWORD   = _POSITIONAL_OR_KEYWORD
  2706|         0|            0|            0|  0.00%|    VAR_POSITIONAL          = _VAR_POSITIONAL
  2707|         0|            0|            0|  0.00%|    KEYWORD_ONLY            = _KEYWORD_ONLY
  2708|         0|            0|            0|  0.00%|    VAR_KEYWORD             = _VAR_KEYWORD
  2709|         0|            0|            0|  0.00%|
  2710|         0|            0|            0|  0.00%|    empty = _empty
  2711|         0|            0|            0|  0.00%|
  2712|         6|  2.93255e-05|  4.88758e-06|  0.03%|    def __init__(self, name, kind, *, default=_empty, annotation=_empty):
  2713|         6|  1.45435e-05|  2.42392e-06|  0.01%|        try:
  2714|         6|  5.38826e-05|  8.98043e-06|  0.06%|            self._kind = _ParameterKind(kind)
(call)|         6|  0.000137806|  2.29677e-05|  0.14%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/enum.py:726 __call__
  2715|         0|            0|            0|  0.00%|        except ValueError:
  2716|         0|            0|            0|  0.00%|            raise ValueError(f'value {kind!r} is not a valid Parameter.kind')
  2717|         6|  1.50204e-05|   2.5034e-06|  0.02%|        if default is not _empty:
  2718|         0|            0|            0|  0.00%|            if self._kind in (_VAR_POSITIONAL, _VAR_KEYWORD):
  2719|         0|            0|            0|  0.00%|                msg = '{} parameters cannot have default values'
  2720|         0|            0|            0|  0.00%|                msg = msg.format(self._kind.description)
  2721|         0|            0|            0|  0.00%|                raise ValueError(msg)
  2722|         6|   1.3113e-05|   2.1855e-06|  0.01%|        self._default = default
  2723|         6|   1.3113e-05|   2.1855e-06|  0.01%|        self._annotation = annotation
  2724|         0|            0|            0|  0.00%|
  2725|         6|  1.33514e-05|  2.22524e-06|  0.01%|        if name is _empty:
  2726|         0|            0|            0|  0.00%|            raise ValueError('name is a required attribute for Parameter')
  2727|         0|            0|            0|  0.00%|
  2728|         6|  3.43323e-05|  5.72205e-06|  0.04%|        if not isinstance(name, str):
  2729|         0|            0|            0|  0.00%|            msg = 'name must be a str, not a {}'.format(type(name).__name__)
  2730|         0|            0|            0|  0.00%|            raise TypeError(msg)
  2731|         0|            0|            0|  0.00%|
  2732|         6|  1.43051e-05|  2.38419e-06|  0.01%|        if name[0] == '.' and name[1:].isdigit():
  2733|         0|            0|            0|  0.00%|            # These are implicit arguments generated by comprehensions. In
  2734|         0|            0|            0|  0.00%|            # order to provide a friendlier interface to users, we recast
  2735|         0|            0|            0|  0.00%|            # their name as "implicitN" and treat them as positional-only.
  2736|         0|            0|            0|  0.00%|            # See issue 19611.
  2737|         0|            0|            0|  0.00%|            if self._kind != _POSITIONAL_OR_KEYWORD:
  2738|         0|            0|            0|  0.00%|                msg = (
  2739|         0|            0|            0|  0.00%|                    'implicit arguments must be passed as '
  2740|         0|            0|            0|  0.00%|                    'positional or keyword arguments, not {}'
  2741|         0|            0|            0|  0.00%|                )
  2742|         0|            0|            0|  0.00%|                msg = msg.format(self._kind.description)
  2743|         0|            0|            0|  0.00%|                raise ValueError(msg)
  2744|         0|            0|            0|  0.00%|            self._kind = _POSITIONAL_ONLY
  2745|         0|            0|            0|  0.00%|            name = 'implicit{}'.format(name[1:])
  2746|         0|            0|            0|  0.00%|
  2747|         0|            0|            0|  0.00%|        # It's possible for C functions to have a positional-only parameter
  2748|         0|            0|            0|  0.00%|        # where the name is a keyword, so for compatibility we'll allow it.
  2749|         6|  1.66893e-05|  2.78155e-06|  0.02%|        is_keyword = iskeyword(name) and self._kind is not _POSITIONAL_ONLY
  2750|         6|  3.19481e-05|  5.32468e-06|  0.03%|        if is_keyword or not name.isidentifier():
  2751|         0|            0|            0|  0.00%|            raise ValueError('{!r} is not a valid parameter name'.format(name))
  2752|         0|            0|            0|  0.00%|
  2753|         6|   1.3113e-05|   2.1855e-06|  0.01%|        self._name = name
  2754|         0|            0|            0|  0.00%|
  2755|         0|            0|            0|  0.00%|    def __reduce__(self):
  2756|         0|            0|            0|  0.00%|        return (type(self),
  2757|         0|            0|            0|  0.00%|                (self._name, self._kind),
  2758|         0|            0|            0|  0.00%|                {'_default': self._default,
  2759|         0|            0|            0|  0.00%|                 '_annotation': self._annotation})
  2760|         0|            0|            0|  0.00%|
  2761|         0|            0|            0|  0.00%|    def __setstate__(self, state):
  2762|         0|            0|            0|  0.00%|        self._default = state['_default']
  2763|         0|            0|            0|  0.00%|        self._annotation = state['_annotation']
  2764|         0|            0|            0|  0.00%|
  2765|         9|  2.00272e-05|  2.22524e-06|  0.02%|    @property
  2766|         0|            0|            0|  0.00%|    def name(self):
  2767|         9|  9.44138e-05|  1.04904e-05|  0.10%|        return self._name
  2768|         0|            0|            0|  0.00%|
  2769|         9|  1.62125e-05|  1.80138e-06|  0.02%|    @property
  2770|         0|            0|            0|  0.00%|    def default(self):
  2771|         9|  1.26362e-05|  1.40402e-06|  0.01%|        return self._default
  2772|         0|            0|            0|  0.00%|
  2773|         6|  1.16825e-05|  1.94709e-06|  0.01%|    @property
  2774|         0|            0|            0|  0.00%|    def annotation(self):
  2775|         6|  8.34465e-06|  1.39078e-06|  0.01%|        return self._annotation
  2776|         0|            0|            0|  0.00%|
  2777|         6|  9.77516e-06|  1.62919e-06|  0.01%|    @property
  2778|         0|            0|            0|  0.00%|    def kind(self):
  2779|         6|  6.91414e-06|  1.15236e-06|  0.01%|        return self._kind
  2780|         0|            0|            0|  0.00%|
  2781|         0|            0|            0|  0.00%|    def replace(self, *, name=_void, kind=_void,
  2782|         0|            0|            0|  0.00%|                annotation=_void, default=_void):
  2783|         0|            0|            0|  0.00%|        """Creates a customized copy of the Parameter."""
  2784|         0|            0|            0|  0.00%|
  2785|         0|            0|            0|  0.00%|        if name is _void:
  2786|         0|            0|            0|  0.00%|            name = self._name
  2787|         0|            0|            0|  0.00%|
  2788|         0|            0|            0|  0.00%|        if kind is _void:
  2789|         0|            0|            0|  0.00%|            kind = self._kind
  2790|         0|            0|            0|  0.00%|
  2791|         0|            0|            0|  0.00%|        if annotation is _void:
  2792|         0|            0|            0|  0.00%|            annotation = self._annotation
  2793|         0|            0|            0|  0.00%|
  2794|         0|            0|            0|  0.00%|        if default is _void:
  2795|         0|            0|            0|  0.00%|            default = self._default
  2796|         0|            0|            0|  0.00%|
  2797|         0|            0|            0|  0.00%|        return type(self)(name, kind, default=default, annotation=annotation)
  2798|         0|            0|            0|  0.00%|
  2799|         0|            0|            0|  0.00%|    def __str__(self):
  2800|         0|            0|            0|  0.00%|        kind = self.kind
  2801|         0|            0|            0|  0.00%|        formatted = self._name
  2802|         0|            0|            0|  0.00%|
  2803|         0|            0|            0|  0.00%|        # Add annotation and default value
  2804|         0|            0|            0|  0.00%|        if self._annotation is not _empty:
  2805|         0|            0|            0|  0.00%|            formatted = '{}: {}'.format(formatted,
  2806|         0|            0|            0|  0.00%|                                       formatannotation(self._annotation))
  2807|         0|            0|            0|  0.00%|
  2808|         0|            0|            0|  0.00%|        if self._default is not _empty:
  2809|         0|            0|            0|  0.00%|            if self._annotation is not _empty:
  2810|         0|            0|            0|  0.00%|                formatted = '{} = {}'.format(formatted, repr(self._default))
  2811|         0|            0|            0|  0.00%|            else:
  2812|         0|            0|            0|  0.00%|                formatted = '{}={}'.format(formatted, repr(self._default))
  2813|         0|            0|            0|  0.00%|
  2814|         0|            0|            0|  0.00%|        if kind == _VAR_POSITIONAL:
  2815|         0|            0|            0|  0.00%|            formatted = '*' + formatted
  2816|         0|            0|            0|  0.00%|        elif kind == _VAR_KEYWORD:
  2817|         0|            0|            0|  0.00%|            formatted = '**' + formatted
  2818|         0|            0|            0|  0.00%|
  2819|         0|            0|            0|  0.00%|        return formatted
  2820|         0|            0|            0|  0.00%|
  2821|         0|            0|            0|  0.00%|    def __repr__(self):
  2822|         0|            0|            0|  0.00%|        return '<{} "{}">'.format(self.__class__.__name__, self)
  2823|         0|            0|            0|  0.00%|
  2824|         0|            0|            0|  0.00%|    def __hash__(self):
  2825|         0|            0|            0|  0.00%|        return hash((self._name, self._kind, self._annotation, self._default))
  2826|         0|            0|            0|  0.00%|
  2827|         0|            0|            0|  0.00%|    def __eq__(self, other):
  2828|         0|            0|            0|  0.00%|        if self is other:
  2829|         0|            0|            0|  0.00%|            return True
  2830|         0|            0|            0|  0.00%|        if not isinstance(other, Parameter):
  2831|         0|            0|            0|  0.00%|            return NotImplemented
  2832|         0|            0|            0|  0.00%|        return (self._name == other._name and
  2833|         0|            0|            0|  0.00%|                self._kind == other._kind and
  2834|         0|            0|            0|  0.00%|                self._default == other._default and
  2835|         0|            0|            0|  0.00%|                self._annotation == other._annotation)
  2836|         0|            0|            0|  0.00%|
  2837|         0|            0|            0|  0.00%|
  2838|         0|            0|            0|  0.00%|class BoundArguments:
  2839|         0|            0|            0|  0.00%|    """Result of `Signature.bind` call.  Holds the mapping of arguments
  2840|         0|            0|            0|  0.00%|    to the function's parameters.
  2841|         0|            0|            0|  0.00%|
  2842|         0|            0|            0|  0.00%|    Has the following public attributes:
  2843|         0|            0|            0|  0.00%|
  2844|         0|            0|            0|  0.00%|    * arguments : dict
  2845|         0|            0|            0|  0.00%|        An ordered mutable mapping of parameters' names to arguments' values.
  2846|         0|            0|            0|  0.00%|        Does not contain arguments' default values.
  2847|         0|            0|            0|  0.00%|    * signature : Signature
  2848|         0|            0|            0|  0.00%|        The Signature object that created this instance.
  2849|         0|            0|            0|  0.00%|    * args : tuple
  2850|         0|            0|            0|  0.00%|        Tuple of positional arguments values.
  2851|         0|            0|            0|  0.00%|    * kwargs : dict
  2852|         0|            0|            0|  0.00%|        Dict of keyword arguments values.
  2853|         0|            0|            0|  0.00%|    """
  2854|         0|            0|            0|  0.00%|
  2855|         0|            0|            0|  0.00%|    __slots__ = ('arguments', '_signature', '__weakref__')
  2856|         0|            0|            0|  0.00%|
  2857|         0|            0|            0|  0.00%|    def __init__(self, signature, arguments):
  2858|         0|            0|            0|  0.00%|        self.arguments = arguments
  2859|         0|            0|            0|  0.00%|        self._signature = signature
  2860|         0|            0|            0|  0.00%|
  2861|         0|            0|            0|  0.00%|    @property
  2862|         0|            0|            0|  0.00%|    def signature(self):
  2863|         0|            0|            0|  0.00%|        return self._signature
  2864|         0|            0|            0|  0.00%|
  2865|         0|            0|            0|  0.00%|    @property
  2866|         0|            0|            0|  0.00%|    def args(self):
  2867|         0|            0|            0|  0.00%|        args = []
  2868|         0|            0|            0|  0.00%|        for param_name, param in self._signature.parameters.items():
  2869|         0|            0|            0|  0.00%|            if param.kind in (_VAR_KEYWORD, _KEYWORD_ONLY):
  2870|         0|            0|            0|  0.00%|                break
  2871|         0|            0|            0|  0.00%|
  2872|         0|            0|            0|  0.00%|            try:
  2873|         0|            0|            0|  0.00%|                arg = self.arguments[param_name]
  2874|         0|            0|            0|  0.00%|            except KeyError:
  2875|         0|            0|            0|  0.00%|                # We're done here. Other arguments
  2876|         0|            0|            0|  0.00%|                # will be mapped in 'BoundArguments.kwargs'
  2877|         0|            0|            0|  0.00%|                break
  2878|         0|            0|            0|  0.00%|            else:
  2879|         0|            0|            0|  0.00%|                if param.kind == _VAR_POSITIONAL:
  2880|         0|            0|            0|  0.00%|                    # *args
  2881|         0|            0|            0|  0.00%|                    args.extend(arg)
  2882|         0|            0|            0|  0.00%|                else:
  2883|         0|            0|            0|  0.00%|                    # plain argument
  2884|         0|            0|            0|  0.00%|                    args.append(arg)
  2885|         0|            0|            0|  0.00%|
  2886|         0|            0|            0|  0.00%|        return tuple(args)
  2887|         0|            0|            0|  0.00%|
  2888|         0|            0|            0|  0.00%|    @property
  2889|         0|            0|            0|  0.00%|    def kwargs(self):
  2890|         0|            0|            0|  0.00%|        kwargs = {}
  2891|         0|            0|            0|  0.00%|        kwargs_started = False
  2892|         0|            0|            0|  0.00%|        for param_name, param in self._signature.parameters.items():
  2893|         0|            0|            0|  0.00%|            if not kwargs_started:
  2894|         0|            0|            0|  0.00%|                if param.kind in (_VAR_KEYWORD, _KEYWORD_ONLY):
  2895|         0|            0|            0|  0.00%|                    kwargs_started = True
  2896|         0|            0|            0|  0.00%|                else:
  2897|         0|            0|            0|  0.00%|                    if param_name not in self.arguments:
  2898|         0|            0|            0|  0.00%|                        kwargs_started = True
  2899|         0|            0|            0|  0.00%|                        continue
  2900|         0|            0|            0|  0.00%|
  2901|         0|            0|            0|  0.00%|            if not kwargs_started:
  2902|         0|            0|            0|  0.00%|                continue
  2903|         0|            0|            0|  0.00%|
  2904|         0|            0|            0|  0.00%|            try:
  2905|         0|            0|            0|  0.00%|                arg = self.arguments[param_name]
  2906|         0|            0|            0|  0.00%|            except KeyError:
  2907|         0|            0|            0|  0.00%|                pass
  2908|         0|            0|            0|  0.00%|            else:
  2909|         0|            0|            0|  0.00%|                if param.kind == _VAR_KEYWORD:
  2910|         0|            0|            0|  0.00%|                    # **kwargs
  2911|         0|            0|            0|  0.00%|                    kwargs.update(arg)
  2912|         0|            0|            0|  0.00%|                else:
  2913|         0|            0|            0|  0.00%|                    # plain keyword argument
  2914|         0|            0|            0|  0.00%|                    kwargs[param_name] = arg
  2915|         0|            0|            0|  0.00%|
  2916|         0|            0|            0|  0.00%|        return kwargs
  2917|         0|            0|            0|  0.00%|
  2918|         0|            0|            0|  0.00%|    def apply_defaults(self):
  2919|         0|            0|            0|  0.00%|        """Set default values for missing arguments.
  2920|         0|            0|            0|  0.00%|
  2921|         0|            0|            0|  0.00%|        For variable-positional arguments (*args) the default is an
  2922|         0|            0|            0|  0.00%|        empty tuple.
  2923|         0|            0|            0|  0.00%|
  2924|         0|            0|            0|  0.00%|        For variable-keyword arguments (**kwargs) the default is an
  2925|         0|            0|            0|  0.00%|        empty dict.
  2926|         0|            0|            0|  0.00%|        """
  2927|         0|            0|            0|  0.00%|        arguments = self.arguments
  2928|         0|            0|            0|  0.00%|        new_arguments = []
  2929|         0|            0|            0|  0.00%|        for name, param in self._signature.parameters.items():
  2930|         0|            0|            0|  0.00%|            try:
  2931|         0|            0|            0|  0.00%|                new_arguments.append((name, arguments[name]))
  2932|         0|            0|            0|  0.00%|            except KeyError:
  2933|         0|            0|            0|  0.00%|                if param.default is not _empty:
  2934|         0|            0|            0|  0.00%|                    val = param.default
  2935|         0|            0|            0|  0.00%|                elif param.kind is _VAR_POSITIONAL:
  2936|         0|            0|            0|  0.00%|                    val = ()
  2937|         0|            0|            0|  0.00%|                elif param.kind is _VAR_KEYWORD:
  2938|         0|            0|            0|  0.00%|                    val = {}
  2939|         0|            0|            0|  0.00%|                else:
  2940|         0|            0|            0|  0.00%|                    # This BoundArguments was likely produced by
  2941|         0|            0|            0|  0.00%|                    # Signature.bind_partial().
  2942|         0|            0|            0|  0.00%|                    continue
  2943|         0|            0|            0|  0.00%|                new_arguments.append((name, val))
  2944|         0|            0|            0|  0.00%|        self.arguments = dict(new_arguments)
  2945|         0|            0|            0|  0.00%|
  2946|         0|            0|            0|  0.00%|    def __eq__(self, other):
  2947|         0|            0|            0|  0.00%|        if self is other:
  2948|         0|            0|            0|  0.00%|            return True
  2949|         0|            0|            0|  0.00%|        if not isinstance(other, BoundArguments):
  2950|         0|            0|            0|  0.00%|            return NotImplemented
  2951|         0|            0|            0|  0.00%|        return (self.signature == other.signature and
  2952|         0|            0|            0|  0.00%|                self.arguments == other.arguments)
  2953|         0|            0|            0|  0.00%|
  2954|         0|            0|            0|  0.00%|    def __setstate__(self, state):
  2955|         0|            0|            0|  0.00%|        self._signature = state['_signature']
  2956|         0|            0|            0|  0.00%|        self.arguments = state['arguments']
  2957|         0|            0|            0|  0.00%|
  2958|         0|            0|            0|  0.00%|    def __getstate__(self):
  2959|         0|            0|            0|  0.00%|        return {'_signature': self._signature, 'arguments': self.arguments}
  2960|         0|            0|            0|  0.00%|
  2961|         0|            0|            0|  0.00%|    def __repr__(self):
  2962|         0|            0|            0|  0.00%|        args = []
  2963|         0|            0|            0|  0.00%|        for arg, value in self.arguments.items():
  2964|         0|            0|            0|  0.00%|            args.append('{}={!r}'.format(arg, value))
  2965|         0|            0|            0|  0.00%|        return '<{} ({})>'.format(self.__class__.__name__, ', '.join(args))
  2966|         0|            0|            0|  0.00%|
  2967|         0|            0|            0|  0.00%|
  2968|         0|            0|            0|  0.00%|class Signature:
  2969|         0|            0|            0|  0.00%|    """A Signature object represents the overall signature of a function.
  2970|         0|            0|            0|  0.00%|    It stores a Parameter object for each parameter accepted by the
  2971|         0|            0|            0|  0.00%|    function, as well as information specific to the function itself.
  2972|         0|            0|            0|  0.00%|
  2973|         0|            0|            0|  0.00%|    A Signature object has the following public attributes and methods:
  2974|         0|            0|            0|  0.00%|
  2975|         0|            0|            0|  0.00%|    * parameters : OrderedDict
  2976|         0|            0|            0|  0.00%|        An ordered mapping of parameters' names to the corresponding
  2977|         0|            0|            0|  0.00%|        Parameter objects (keyword-only arguments are in the same order
  2978|         0|            0|            0|  0.00%|        as listed in `code.co_varnames`).
  2979|         0|            0|            0|  0.00%|    * return_annotation : object
  2980|         0|            0|            0|  0.00%|        The annotation for the return type of the function if specified.
  2981|         0|            0|            0|  0.00%|        If the function has no annotation for its return type, this
  2982|         0|            0|            0|  0.00%|        attribute is set to `Signature.empty`.
  2983|         0|            0|            0|  0.00%|    * bind(*args, **kwargs) -> BoundArguments
  2984|         0|            0|            0|  0.00%|        Creates a mapping from positional and keyword arguments to
  2985|         0|            0|            0|  0.00%|        parameters.
  2986|         0|            0|            0|  0.00%|    * bind_partial(*args, **kwargs) -> BoundArguments
  2987|         0|            0|            0|  0.00%|        Creates a partial mapping from positional and keyword arguments
  2988|         0|            0|            0|  0.00%|        to parameters (simulating 'functools.partial' behavior.)
  2989|         0|            0|            0|  0.00%|    """
  2990|         0|            0|            0|  0.00%|
  2991|         0|            0|            0|  0.00%|    __slots__ = ('_return_annotation', '_parameters')
  2992|         0|            0|            0|  0.00%|
  2993|         0|            0|            0|  0.00%|    _parameter_cls = Parameter
  2994|         0|            0|            0|  0.00%|    _bound_arguments_cls = BoundArguments
  2995|         0|            0|            0|  0.00%|
  2996|         0|            0|            0|  0.00%|    empty = _empty
  2997|         0|            0|            0|  0.00%|
  2998|         2|  1.95503e-05|  9.77516e-06|  0.02%|    def __init__(self, parameters=None, *, return_annotation=_empty,
  2999|         0|            0|            0|  0.00%|                 __validate_parameters__=True):
  3000|         0|            0|            0|  0.00%|        """Constructs Signature from the given list of Parameter
  3001|         0|            0|            0|  0.00%|        objects and 'return_annotation'.  All arguments are optional.
  3002|         0|            0|            0|  0.00%|        """
  3003|         0|            0|            0|  0.00%|
  3004|         2|  1.14441e-05|  5.72205e-06|  0.01%|        if parameters is None:
  3005|         0|            0|            0|  0.00%|            params = OrderedDict()
  3006|         0|            0|            0|  0.00%|        else:
  3007|         2|  6.91414e-06|  3.45707e-06|  0.01%|            if __validate_parameters__:
  3008|         1|  2.14577e-06|  2.14577e-06|  0.00%|                params = OrderedDict()
  3009|         1|  3.57628e-06|  3.57628e-06|  0.00%|                top_kind = _POSITIONAL_ONLY
  3010|         1|  3.09944e-06|  3.09944e-06|  0.00%|                seen_default = False
  3011|         0|            0|            0|  0.00%|
  3012|         4|  9.77516e-06|  2.44379e-06|  0.01%|                for param in parameters:
  3013|         3|  1.85966e-05|  6.19888e-06|  0.02%|                    kind = param.kind
(call)|         3|  9.05991e-06|  3.01997e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:2777 kind
  3014|         3|  1.83582e-05|  6.11941e-06|  0.02%|                    name = param.name
(call)|         3|  9.05991e-06|  3.01997e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:2765 name
  3015|         0|            0|            0|  0.00%|
  3016|         3|  6.19888e-06|  2.06629e-06|  0.01%|                    if kind < top_kind:
  3017|         0|            0|            0|  0.00%|                        msg = (
  3018|         0|            0|            0|  0.00%|                            'wrong parameter order: {} parameter before {} '
  3019|         0|            0|            0|  0.00%|                            'parameter'
  3020|         0|            0|            0|  0.00%|                        )
  3021|         0|            0|            0|  0.00%|                        msg = msg.format(top_kind.description,
  3022|         0|            0|            0|  0.00%|                                         kind.description)
  3023|         0|            0|            0|  0.00%|                        raise ValueError(msg)
  3024|         3|  8.82149e-06|   2.9405e-06|  0.01%|                    elif kind > top_kind:
  3025|         1|  2.86102e-06|  2.86102e-06|  0.00%|                        top_kind = kind
  3026|         0|            0|            0|  0.00%|
  3027|         3|  6.91414e-06|  2.30471e-06|  0.01%|                    if kind in (_POSITIONAL_ONLY, _POSITIONAL_OR_KEYWORD):
  3028|         3|  1.97887e-05|  6.59625e-06|  0.02%|                        if param.default is _empty:
(call)|         3|  8.10623e-06|  2.70208e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:2769 default
  3029|         3|  6.67572e-06|  2.22524e-06|  0.01%|                            if seen_default:
  3030|         0|            0|            0|  0.00%|                                # No default for this parameter, but the
  3031|         0|            0|            0|  0.00%|                                # previous parameter of had a default
  3032|         0|            0|            0|  0.00%|                                msg = 'non-default argument follows default ' \
  3033|         0|            0|            0|  0.00%|                                      'argument'
  3034|         0|            0|            0|  0.00%|                                raise ValueError(msg)
  3035|         0|            0|            0|  0.00%|                        else:
  3036|         0|            0|            0|  0.00%|                            # There is a default for this parameter.
  3037|         0|            0|            0|  0.00%|                            seen_default = True
  3038|         0|            0|            0|  0.00%|
  3039|         3|   6.4373e-06|  2.14577e-06|  0.01%|                    if name in params:
  3040|         0|            0|            0|  0.00%|                        msg = 'duplicate parameter name: {!r}'.format(name)
  3041|         0|            0|            0|  0.00%|                        raise ValueError(msg)
  3042|         0|            0|            0|  0.00%|
  3043|         3|  6.91414e-06|  2.30471e-06|  0.01%|                    params[name] = param
  3044|         0|            0|            0|  0.00%|            else:
  3045|         9|  6.46114e-05|  7.17905e-06|  0.07%|                params = OrderedDict((param.name, param) for param in parameters)
(call)|         3|  9.25064e-05|  3.08355e-05|  0.10%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:2765 name
(call)|         4|  0.000124216|   3.1054e-05|  0.13%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:3045 <genexpr>
  3046|         0|            0|            0|  0.00%|
  3047|         2|  6.19888e-06|  3.09944e-06|  0.01%|        self._parameters = types.MappingProxyType(params)
  3048|         2|  5.24521e-06|   2.6226e-06|  0.01%|        self._return_annotation = return_annotation
  3049|         0|            0|            0|  0.00%|
  3050|         1|  2.14577e-06|  2.14577e-06|  0.00%|    @classmethod
  3051|         0|            0|            0|  0.00%|    def from_callable(cls, obj, *,
  3052|         0|            0|            0|  0.00%|                      follow_wrapped=True, globals=None, locals=None, eval_str=False):
  3053|         0|            0|            0|  0.00%|        """Constructs Signature for the given callable object."""
  3054|         2|  4.81606e-05|  2.40803e-05|  0.05%|        return _signature_from_callable(obj, sigcls=cls,
(call)|         1|   0.00123167|   0.00123167|  1.27%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:2470 _signature_from_callable
  3055|         1|  1.66893e-06|  1.66893e-06|  0.00%|                                        follow_wrapper_chains=follow_wrapped,
  3056|         1|  1.90735e-06|  1.90735e-06|  0.00%|                                        globals=globals, locals=locals, eval_str=eval_str)
  3057|         0|            0|            0|  0.00%|
  3058|         2|  5.24521e-06|   2.6226e-06|  0.01%|    @property
  3059|         0|            0|            0|  0.00%|    def parameters(self):
  3060|         2|  3.57628e-06|  1.78814e-06|  0.00%|        return self._parameters
  3061|         0|            0|            0|  0.00%|
  3062|         0|            0|            0|  0.00%|    @property
  3063|         0|            0|            0|  0.00%|    def return_annotation(self):
  3064|         0|            0|            0|  0.00%|        return self._return_annotation
  3065|         0|            0|            0|  0.00%|
  3066|         0|            0|            0|  0.00%|    def replace(self, *, parameters=_void, return_annotation=_void):
  3067|         0|            0|            0|  0.00%|        """Creates a customized copy of the Signature.
  3068|         0|            0|            0|  0.00%|        Pass 'parameters' and/or 'return_annotation' arguments
  3069|         0|            0|            0|  0.00%|        to override them in the new copy.
  3070|         0|            0|            0|  0.00%|        """
  3071|         0|            0|            0|  0.00%|
  3072|         0|            0|            0|  0.00%|        if parameters is _void:
  3073|         0|            0|            0|  0.00%|            parameters = self.parameters.values()
  3074|         0|            0|            0|  0.00%|
  3075|         0|            0|            0|  0.00%|        if return_annotation is _void:
  3076|         0|            0|            0|  0.00%|            return_annotation = self._return_annotation
  3077|         0|            0|            0|  0.00%|
  3078|         0|            0|            0|  0.00%|        return type(self)(parameters,
  3079|         0|            0|            0|  0.00%|                          return_annotation=return_annotation)
  3080|         0|            0|            0|  0.00%|
  3081|         0|            0|            0|  0.00%|    def _hash_basis(self):
  3082|         0|            0|            0|  0.00%|        params = tuple(param for param in self.parameters.values()
  3083|         0|            0|            0|  0.00%|                             if param.kind != _KEYWORD_ONLY)
  3084|         0|            0|            0|  0.00%|
  3085|         0|            0|            0|  0.00%|        kwo_params = {param.name: param for param in self.parameters.values()
  3086|         0|            0|            0|  0.00%|                                        if param.kind == _KEYWORD_ONLY}
  3087|         0|            0|            0|  0.00%|
  3088|         0|            0|            0|  0.00%|        return params, kwo_params, self.return_annotation
  3089|         0|            0|            0|  0.00%|
  3090|         0|            0|            0|  0.00%|    def __hash__(self):
  3091|         0|            0|            0|  0.00%|        params, kwo_params, return_annotation = self._hash_basis()
  3092|         0|            0|            0|  0.00%|        kwo_params = frozenset(kwo_params.values())
  3093|         0|            0|            0|  0.00%|        return hash((params, kwo_params, return_annotation))
  3094|         0|            0|            0|  0.00%|
  3095|         0|            0|            0|  0.00%|    def __eq__(self, other):
  3096|         0|            0|            0|  0.00%|        if self is other:
  3097|         0|            0|            0|  0.00%|            return True
  3098|         0|            0|            0|  0.00%|        if not isinstance(other, Signature):
  3099|         0|            0|            0|  0.00%|            return NotImplemented
  3100|         0|            0|            0|  0.00%|        return self._hash_basis() == other._hash_basis()
  3101|         0|            0|            0|  0.00%|
  3102|         0|            0|            0|  0.00%|    def _bind(self, args, kwargs, *, partial=False):
  3103|         0|            0|            0|  0.00%|        """Private method. Don't use directly."""
  3104|         0|            0|            0|  0.00%|
  3105|         0|            0|            0|  0.00%|        arguments = {}
  3106|         0|            0|            0|  0.00%|
  3107|         0|            0|            0|  0.00%|        parameters = iter(self.parameters.values())
  3108|         0|            0|            0|  0.00%|        parameters_ex = ()
  3109|         0|            0|            0|  0.00%|        arg_vals = iter(args)
  3110|         0|            0|            0|  0.00%|
  3111|         0|            0|            0|  0.00%|        while True:
  3112|         0|            0|            0|  0.00%|            # Let's iterate through the positional arguments and corresponding
  3113|         0|            0|            0|  0.00%|            # parameters
  3114|         0|            0|            0|  0.00%|            try:
  3115|         0|            0|            0|  0.00%|                arg_val = next(arg_vals)
  3116|         0|            0|            0|  0.00%|            except StopIteration:
  3117|         0|            0|            0|  0.00%|                # No more positional arguments
  3118|         0|            0|            0|  0.00%|                try:
  3119|         0|            0|            0|  0.00%|                    param = next(parameters)
  3120|         0|            0|            0|  0.00%|                except StopIteration:
  3121|         0|            0|            0|  0.00%|                    # No more parameters. That's it. Just need to check that
  3122|         0|            0|            0|  0.00%|                    # we have no `kwargs` after this while loop
  3123|         0|            0|            0|  0.00%|                    break
  3124|         0|            0|            0|  0.00%|                else:
  3125|         0|            0|            0|  0.00%|                    if param.kind == _VAR_POSITIONAL:
  3126|         0|            0|            0|  0.00%|                        # That's OK, just empty *args.  Let's start parsing
  3127|         0|            0|            0|  0.00%|                        # kwargs
  3128|         0|            0|            0|  0.00%|                        break
  3129|         0|            0|            0|  0.00%|                    elif param.name in kwargs:
  3130|         0|            0|            0|  0.00%|                        if param.kind == _POSITIONAL_ONLY:
  3131|         0|            0|            0|  0.00%|                            msg = '{arg!r} parameter is positional only, ' \
  3132|         0|            0|            0|  0.00%|                                  'but was passed as a keyword'
  3133|         0|            0|            0|  0.00%|                            msg = msg.format(arg=param.name)
  3134|         0|            0|            0|  0.00%|                            raise TypeError(msg) from None
  3135|         0|            0|            0|  0.00%|                        parameters_ex = (param,)
  3136|         0|            0|            0|  0.00%|                        break
  3137|         0|            0|            0|  0.00%|                    elif (param.kind == _VAR_KEYWORD or
  3138|         0|            0|            0|  0.00%|                                                param.default is not _empty):
  3139|         0|            0|            0|  0.00%|                        # That's fine too - we have a default value for this
  3140|         0|            0|            0|  0.00%|                        # parameter.  So, lets start parsing `kwargs`, starting
  3141|         0|            0|            0|  0.00%|                        # with the current parameter
  3142|         0|            0|            0|  0.00%|                        parameters_ex = (param,)
  3143|         0|            0|            0|  0.00%|                        break
  3144|         0|            0|            0|  0.00%|                    else:
  3145|         0|            0|            0|  0.00%|                        # No default, not VAR_KEYWORD, not VAR_POSITIONAL,
  3146|         0|            0|            0|  0.00%|                        # not in `kwargs`
  3147|         0|            0|            0|  0.00%|                        if partial:
  3148|         0|            0|            0|  0.00%|                            parameters_ex = (param,)
  3149|         0|            0|            0|  0.00%|                            break
  3150|         0|            0|            0|  0.00%|                        else:
  3151|         0|            0|            0|  0.00%|                            if param.kind == _KEYWORD_ONLY:
  3152|         0|            0|            0|  0.00%|                                argtype = ' keyword-only'
  3153|         0|            0|            0|  0.00%|                            else:
  3154|         0|            0|            0|  0.00%|                                argtype = ''
  3155|         0|            0|            0|  0.00%|                            msg = 'missing a required{argtype} argument: {arg!r}'
  3156|         0|            0|            0|  0.00%|                            msg = msg.format(arg=param.name, argtype=argtype)
  3157|         0|            0|            0|  0.00%|                            raise TypeError(msg) from None
  3158|         0|            0|            0|  0.00%|            else:
  3159|         0|            0|            0|  0.00%|                # We have a positional argument to process
  3160|         0|            0|            0|  0.00%|                try:
  3161|         0|            0|            0|  0.00%|                    param = next(parameters)
  3162|         0|            0|            0|  0.00%|                except StopIteration:
  3163|         0|            0|            0|  0.00%|                    raise TypeError('too many positional arguments') from None
  3164|         0|            0|            0|  0.00%|                else:
  3165|         0|            0|            0|  0.00%|                    if param.kind in (_VAR_KEYWORD, _KEYWORD_ONLY):
  3166|         0|            0|            0|  0.00%|                        # Looks like we have no parameter for this positional
  3167|         0|            0|            0|  0.00%|                        # argument
  3168|         0|            0|            0|  0.00%|                        raise TypeError(
  3169|         0|            0|            0|  0.00%|                            'too many positional arguments') from None
  3170|         0|            0|            0|  0.00%|
  3171|         0|            0|            0|  0.00%|                    if param.kind == _VAR_POSITIONAL:
  3172|         0|            0|            0|  0.00%|                        # We have an '*args'-like argument, let's fill it with
  3173|         0|            0|            0|  0.00%|                        # all positional arguments we have left and move on to
  3174|         0|            0|            0|  0.00%|                        # the next phase
  3175|         0|            0|            0|  0.00%|                        values = [arg_val]
  3176|         0|            0|            0|  0.00%|                        values.extend(arg_vals)
  3177|         0|            0|            0|  0.00%|                        arguments[param.name] = tuple(values)
  3178|         0|            0|            0|  0.00%|                        break
  3179|         0|            0|            0|  0.00%|
  3180|         0|            0|            0|  0.00%|                    if param.name in kwargs and param.kind != _POSITIONAL_ONLY:
  3181|         0|            0|            0|  0.00%|                        raise TypeError(
  3182|         0|            0|            0|  0.00%|                            'multiple values for argument {arg!r}'.format(
  3183|         0|            0|            0|  0.00%|                                arg=param.name)) from None
  3184|         0|            0|            0|  0.00%|
  3185|         0|            0|            0|  0.00%|                    arguments[param.name] = arg_val
  3186|         0|            0|            0|  0.00%|
  3187|         0|            0|            0|  0.00%|        # Now, we iterate through the remaining parameters to process
  3188|         0|            0|            0|  0.00%|        # keyword arguments
  3189|         0|            0|            0|  0.00%|        kwargs_param = None
  3190|         0|            0|            0|  0.00%|        for param in itertools.chain(parameters_ex, parameters):
  3191|         0|            0|            0|  0.00%|            if param.kind == _VAR_KEYWORD:
  3192|         0|            0|            0|  0.00%|                # Memorize that we have a '**kwargs'-like parameter
  3193|         0|            0|            0|  0.00%|                kwargs_param = param
  3194|         0|            0|            0|  0.00%|                continue
  3195|         0|            0|            0|  0.00%|
  3196|         0|            0|            0|  0.00%|            if param.kind == _VAR_POSITIONAL:
  3197|         0|            0|            0|  0.00%|                # Named arguments don't refer to '*args'-like parameters.
  3198|         0|            0|            0|  0.00%|                # We only arrive here if the positional arguments ended
  3199|         0|            0|            0|  0.00%|                # before reaching the last parameter before *args.
  3200|         0|            0|            0|  0.00%|                continue
  3201|         0|            0|            0|  0.00%|
  3202|         0|            0|            0|  0.00%|            param_name = param.name
  3203|         0|            0|            0|  0.00%|            try:
  3204|         0|            0|            0|  0.00%|                arg_val = kwargs.pop(param_name)
  3205|         0|            0|            0|  0.00%|            except KeyError:
  3206|         0|            0|            0|  0.00%|                # We have no value for this parameter.  It's fine though,
  3207|         0|            0|            0|  0.00%|                # if it has a default value, or it is an '*args'-like
  3208|         0|            0|            0|  0.00%|                # parameter, left alone by the processing of positional
  3209|         0|            0|            0|  0.00%|                # arguments.
  3210|         0|            0|            0|  0.00%|                if (not partial and param.kind != _VAR_POSITIONAL and
  3211|         0|            0|            0|  0.00%|                                                    param.default is _empty):
  3212|         0|            0|            0|  0.00%|                    raise TypeError('missing a required argument: {arg!r}'. \
  3213|         0|            0|            0|  0.00%|                                    format(arg=param_name)) from None
  3214|         0|            0|            0|  0.00%|
  3215|         0|            0|            0|  0.00%|            else:
  3216|         0|            0|            0|  0.00%|                if param.kind == _POSITIONAL_ONLY:
  3217|         0|            0|            0|  0.00%|                    # This should never happen in case of a properly built
  3218|         0|            0|            0|  0.00%|                    # Signature object (but let's have this check here
  3219|         0|            0|            0|  0.00%|                    # to ensure correct behaviour just in case)
  3220|         0|            0|            0|  0.00%|                    raise TypeError('{arg!r} parameter is positional only, '
  3221|         0|            0|            0|  0.00%|                                    'but was passed as a keyword'. \
  3222|         0|            0|            0|  0.00%|                                    format(arg=param.name))
  3223|         0|            0|            0|  0.00%|
  3224|         0|            0|            0|  0.00%|                arguments[param_name] = arg_val
  3225|         0|            0|            0|  0.00%|
  3226|         0|            0|            0|  0.00%|        if kwargs:
  3227|         0|            0|            0|  0.00%|            if kwargs_param is not None:
  3228|         0|            0|            0|  0.00%|                # Process our '**kwargs'-like parameter
  3229|         0|            0|            0|  0.00%|                arguments[kwargs_param.name] = kwargs
  3230|         0|            0|            0|  0.00%|            else:
  3231|         0|            0|            0|  0.00%|                raise TypeError(
  3232|         0|            0|            0|  0.00%|                    'got an unexpected keyword argument {arg!r}'.format(
  3233|         0|            0|            0|  0.00%|                        arg=next(iter(kwargs))))
  3234|         0|            0|            0|  0.00%|
  3235|         0|            0|            0|  0.00%|        return self._bound_arguments_cls(self, arguments)
  3236|         0|            0|            0|  0.00%|
  3237|         0|            0|            0|  0.00%|    def bind(self, /, *args, **kwargs):
  3238|         0|            0|            0|  0.00%|        """Get a BoundArguments object, that maps the passed `args`
  3239|         0|            0|            0|  0.00%|        and `kwargs` to the function's signature.  Raises `TypeError`
  3240|         0|            0|            0|  0.00%|        if the passed arguments can not be bound.
  3241|         0|            0|            0|  0.00%|        """
  3242|         0|            0|            0|  0.00%|        return self._bind(args, kwargs)
  3243|         0|            0|            0|  0.00%|
  3244|         0|            0|            0|  0.00%|    def bind_partial(self, /, *args, **kwargs):
  3245|         0|            0|            0|  0.00%|        """Get a BoundArguments object, that partially maps the
  3246|         0|            0|            0|  0.00%|        passed `args` and `kwargs` to the function's signature.
  3247|         0|            0|            0|  0.00%|        Raises `TypeError` if the passed arguments can not be bound.
  3248|         0|            0|            0|  0.00%|        """
  3249|         0|            0|            0|  0.00%|        return self._bind(args, kwargs, partial=True)
  3250|         0|            0|            0|  0.00%|
  3251|         0|            0|            0|  0.00%|    def __reduce__(self):
  3252|         0|            0|            0|  0.00%|        return (type(self),
  3253|         0|            0|            0|  0.00%|                (tuple(self._parameters.values()),),
  3254|         0|            0|            0|  0.00%|                {'_return_annotation': self._return_annotation})
  3255|         0|            0|            0|  0.00%|
  3256|         0|            0|            0|  0.00%|    def __setstate__(self, state):
  3257|         0|            0|            0|  0.00%|        self._return_annotation = state['_return_annotation']
  3258|         0|            0|            0|  0.00%|
  3259|         0|            0|            0|  0.00%|    def __repr__(self):
  3260|         0|            0|            0|  0.00%|        return '<{} {}>'.format(self.__class__.__name__, self)
  3261|         0|            0|            0|  0.00%|
  3262|         0|            0|            0|  0.00%|    def __str__(self):
  3263|         0|            0|            0|  0.00%|        result = []
  3264|         0|            0|            0|  0.00%|        render_pos_only_separator = False
  3265|         0|            0|            0|  0.00%|        render_kw_only_separator = True
  3266|         0|            0|            0|  0.00%|        for param in self.parameters.values():
  3267|         0|            0|            0|  0.00%|            formatted = str(param)
  3268|         0|            0|            0|  0.00%|
  3269|         0|            0|            0|  0.00%|            kind = param.kind
  3270|         0|            0|            0|  0.00%|
  3271|         0|            0|            0|  0.00%|            if kind == _POSITIONAL_ONLY:
  3272|         0|            0|            0|  0.00%|                render_pos_only_separator = True
  3273|         0|            0|            0|  0.00%|            elif render_pos_only_separator:
  3274|         0|            0|            0|  0.00%|                # It's not a positional-only parameter, and the flag
  3275|         0|            0|            0|  0.00%|                # is set to 'True' (there were pos-only params before.)
  3276|         0|            0|            0|  0.00%|                result.append('/')
  3277|         0|            0|            0|  0.00%|                render_pos_only_separator = False
  3278|         0|            0|            0|  0.00%|
  3279|         0|            0|            0|  0.00%|            if kind == _VAR_POSITIONAL:
  3280|         0|            0|            0|  0.00%|                # OK, we have an '*args'-like parameter, so we won't need
  3281|         0|            0|            0|  0.00%|                # a '*' to separate keyword-only arguments
  3282|         0|            0|            0|  0.00%|                render_kw_only_separator = False
  3283|         0|            0|            0|  0.00%|            elif kind == _KEYWORD_ONLY and render_kw_only_separator:
  3284|         0|            0|            0|  0.00%|                # We have a keyword-only parameter to render and we haven't
  3285|         0|            0|            0|  0.00%|                # rendered an '*args'-like parameter before, so add a '*'
  3286|         0|            0|            0|  0.00%|                # separator to the parameters list ("foo(arg1, *, arg2)" case)
  3287|         0|            0|            0|  0.00%|                result.append('*')
  3288|         0|            0|            0|  0.00%|                # This condition should be only triggered once, so
  3289|         0|            0|            0|  0.00%|                # reset the flag
  3290|         0|            0|            0|  0.00%|                render_kw_only_separator = False
  3291|         0|            0|            0|  0.00%|
  3292|         0|            0|            0|  0.00%|            result.append(formatted)
  3293|         0|            0|            0|  0.00%|
  3294|         0|            0|            0|  0.00%|        if render_pos_only_separator:
  3295|         0|            0|            0|  0.00%|            # There were only positional-only parameters, hence the
  3296|         0|            0|            0|  0.00%|            # flag was not reset to 'False'
  3297|         0|            0|            0|  0.00%|            result.append('/')
  3298|         0|            0|            0|  0.00%|
  3299|         0|            0|            0|  0.00%|        rendered = '({})'.format(', '.join(result))
  3300|         0|            0|            0|  0.00%|
  3301|         0|            0|            0|  0.00%|        if self.return_annotation is not _empty:
  3302|         0|            0|            0|  0.00%|            anno = formatannotation(self.return_annotation)
  3303|         0|            0|            0|  0.00%|            rendered += ' -> {}'.format(anno)
  3304|         0|            0|            0|  0.00%|
  3305|         0|            0|            0|  0.00%|        return rendered
  3306|         0|            0|            0|  0.00%|
  3307|         0|            0|            0|  0.00%|
  3308|         1|   2.6226e-06|   2.6226e-06|  0.00%|def signature(obj, *, follow_wrapped=True, globals=None, locals=None, eval_str=False):
  3309|         0|            0|            0|  0.00%|    """Get a signature object for the passed callable."""
  3310|         2|  1.16825e-05|  5.84126e-06|  0.01%|    return Signature.from_callable(obj, follow_wrapped=follow_wrapped,
(call)|         1|   0.00128555|   0.00128555|  1.32%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:3050 from_callable
  3311|         1|  1.90735e-06|  1.90735e-06|  0.00%|                                   globals=globals, locals=locals, eval_str=eval_str)
  3312|         0|            0|            0|  0.00%|
  3313|         0|            0|            0|  0.00%|
  3314|         0|            0|            0|  0.00%|class BufferFlags(enum.IntFlag):
  3315|         0|            0|            0|  0.00%|    SIMPLE = 0x0
  3316|         0|            0|            0|  0.00%|    WRITABLE = 0x1
  3317|         0|            0|            0|  0.00%|    FORMAT = 0x4
  3318|         0|            0|            0|  0.00%|    ND = 0x8
  3319|         0|            0|            0|  0.00%|    STRIDES = 0x10 | ND
  3320|         0|            0|            0|  0.00%|    C_CONTIGUOUS = 0x20 | STRIDES
  3321|         0|            0|            0|  0.00%|    F_CONTIGUOUS = 0x40 | STRIDES
  3322|         0|            0|            0|  0.00%|    ANY_CONTIGUOUS = 0x80 | STRIDES
  3323|         0|            0|            0|  0.00%|    INDIRECT = 0x100 | STRIDES
  3324|         0|            0|            0|  0.00%|    CONTIG = ND | WRITABLE
  3325|         0|            0|            0|  0.00%|    CONTIG_RO = ND
  3326|         0|            0|            0|  0.00%|    STRIDED = STRIDES | WRITABLE
  3327|         0|            0|            0|  0.00%|    STRIDED_RO = STRIDES
  3328|         0|            0|            0|  0.00%|    RECORDS = STRIDES | WRITABLE | FORMAT
  3329|         0|            0|            0|  0.00%|    RECORDS_RO = STRIDES | FORMAT
  3330|         0|            0|            0|  0.00%|    FULL = INDIRECT | WRITABLE | FORMAT
  3331|         0|            0|            0|  0.00%|    FULL_RO = INDIRECT | FORMAT
  3332|         0|            0|            0|  0.00%|    READ = 0x100
  3333|         0|            0|            0|  0.00%|    WRITE = 0x200
  3334|         0|            0|            0|  0.00%|
  3335|         0|            0|            0|  0.00%|
  3336|         0|            0|            0|  0.00%|def _main():
  3337|         0|            0|            0|  0.00%|    """ Logic for inspecting an object given at command line """
  3338|         0|            0|            0|  0.00%|    import argparse
  3339|         0|            0|            0|  0.00%|    import importlib
  3340|         0|            0|            0|  0.00%|
  3341|         0|            0|            0|  0.00%|    parser = argparse.ArgumentParser()
  3342|         0|            0|            0|  0.00%|    parser.add_argument(
  3343|         0|            0|            0|  0.00%|        'object',
  3344|         0|            0|            0|  0.00%|         help="The object to be analysed. "
  3345|         0|            0|            0|  0.00%|              "It supports the 'module:qualname' syntax")
  3346|         0|            0|            0|  0.00%|    parser.add_argument(
  3347|         0|            0|            0|  0.00%|        '-d', '--details', action='store_true',
  3348|         0|            0|            0|  0.00%|        help='Display info about the module rather than its source code')
  3349|         0|            0|            0|  0.00%|
  3350|         0|            0|            0|  0.00%|    args = parser.parse_args()
  3351|         0|            0|            0|  0.00%|
  3352|         0|            0|            0|  0.00%|    target = args.object
  3353|         0|            0|            0|  0.00%|    mod_name, has_attrs, attrs = target.partition(":")
  3354|         0|            0|            0|  0.00%|    try:
  3355|         0|            0|            0|  0.00%|        obj = module = importlib.import_module(mod_name)
  3356|         0|            0|            0|  0.00%|    except Exception as exc:
  3357|         0|            0|            0|  0.00%|        msg = "Failed to import {} ({}: {})".format(mod_name,
  3358|         0|            0|            0|  0.00%|                                                    type(exc).__name__,
  3359|         0|            0|            0|  0.00%|                                                    exc)
  3360|         0|            0|            0|  0.00%|        print(msg, file=sys.stderr)
  3361|         0|            0|            0|  0.00%|        sys.exit(2)
  3362|         0|            0|            0|  0.00%|
  3363|         0|            0|            0|  0.00%|    if has_attrs:
  3364|         0|            0|            0|  0.00%|        parts = attrs.split(".")
  3365|         0|            0|            0|  0.00%|        obj = module
  3366|         0|            0|            0|  0.00%|        for part in parts:
  3367|         0|            0|            0|  0.00%|            obj = getattr(obj, part)
  3368|         0|            0|            0|  0.00%|
  3369|         0|            0|            0|  0.00%|    if module.__name__ in sys.builtin_module_names:
  3370|         0|            0|            0|  0.00%|        print("Can't get info for builtin modules.", file=sys.stderr)
  3371|         0|            0|            0|  0.00%|        sys.exit(1)
  3372|         0|            0|            0|  0.00%|
  3373|         0|            0|            0|  0.00%|    if args.details:
  3374|         0|            0|            0|  0.00%|        print('Target: {}'.format(target))
  3375|         0|            0|            0|  0.00%|        print('Origin: {}'.format(getsourcefile(module)))
  3376|         0|            0|            0|  0.00%|        print('Cached: {}'.format(module.__cached__))
  3377|         0|            0|            0|  0.00%|        if obj is module:
  3378|         0|            0|            0|  0.00%|            print('Loader: {}'.format(repr(module.__loader__)))
  3379|         0|            0|            0|  0.00%|            if hasattr(module, '__path__'):
  3380|         0|            0|            0|  0.00%|                print('Submodule search path: {}'.format(module.__path__))
  3381|         0|            0|            0|  0.00%|        else:
  3382|         0|            0|            0|  0.00%|            try:
  3383|         0|            0|            0|  0.00%|                __, lineno = findsource(obj)
  3384|         0|            0|            0|  0.00%|            except Exception:
  3385|         0|            0|            0|  0.00%|                pass
  3386|         0|            0|            0|  0.00%|            else:
  3387|         0|            0|            0|  0.00%|                print('Line: {}'.format(lineno))
  3388|         0|            0|            0|  0.00%|
  3389|         0|            0|            0|  0.00%|        print('\n')
  3390|         0|            0|            0|  0.00%|    else:
  3391|         0|            0|            0|  0.00%|        print(getsource(obj))
  3392|         0|            0|            0|  0.00%|
  3393|         0|            0|            0|  0.00%|
  3394|         0|            0|            0|  0.00%|if __name__ == "__main__":
  3395|         0|            0|            0|  0.00%|    _main()
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py
File duration: 0.00200486s (2.06%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""
     2|         0|            0|            0|  0.00%|The typing module: Support for gradual typing as defined by PEP 484 and subsequent PEPs.
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|Among other things, the module includes the following:
     5|         0|            0|            0|  0.00%|* Generic, Protocol, and internal machinery to support generic aliases.
     6|         0|            0|            0|  0.00%|  All subscripted types like X[int], Union[int, str] are generic aliases.
     7|         0|            0|            0|  0.00%|* Various "special forms" that have unique meanings in type annotations:
     8|         0|            0|            0|  0.00%|  NoReturn, Never, ClassVar, Self, Concatenate, Unpack, and others.
     9|         0|            0|            0|  0.00%|* Classes whose instances can be type arguments to generic classes and functions:
    10|         0|            0|            0|  0.00%|  TypeVar, ParamSpec, TypeVarTuple.
    11|         0|            0|            0|  0.00%|* Public helper functions: get_type_hints, overload, cast, final, and others.
    12|         0|            0|            0|  0.00%|* Several protocols to support duck-typing:
    13|         0|            0|            0|  0.00%|  SupportsFloat, SupportsIndex, SupportsAbs, and others.
    14|         0|            0|            0|  0.00%|* Special types: NewType, NamedTuple, TypedDict.
    15|         0|            0|            0|  0.00%|* Deprecated wrapper submodules for re and io related types.
    16|         0|            0|            0|  0.00%|* Deprecated aliases for builtin types and collections.abc ABCs.
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|Any name not present in __all__ is an implementation detail
    19|         0|            0|            0|  0.00%|that may be changed without notice. Use at your own risk!
    20|         0|            0|            0|  0.00%|"""
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|from abc import abstractmethod, ABCMeta
    23|         0|            0|            0|  0.00%|import collections
    24|         0|            0|            0|  0.00%|from collections import defaultdict
    25|         0|            0|            0|  0.00%|import collections.abc
    26|         0|            0|            0|  0.00%|import copyreg
    27|         0|            0|            0|  0.00%|import contextlib
    28|         0|            0|            0|  0.00%|import functools
    29|         0|            0|            0|  0.00%|import operator
    30|         0|            0|            0|  0.00%|import re as stdlib_re  # Avoid confusion with the re we export.
    31|         0|            0|            0|  0.00%|import sys
    32|         0|            0|            0|  0.00%|import types
    33|         0|            0|            0|  0.00%|import warnings
    34|         0|            0|            0|  0.00%|from types import WrapperDescriptorType, MethodWrapperType, MethodDescriptorType, GenericAlias
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|from _typing import (
    37|         0|            0|            0|  0.00%|    _idfunc,
    38|         0|            0|            0|  0.00%|    TypeVar,
    39|         0|            0|            0|  0.00%|    ParamSpec,
    40|         0|            0|            0|  0.00%|    TypeVarTuple,
    41|         0|            0|            0|  0.00%|    ParamSpecArgs,
    42|         0|            0|            0|  0.00%|    ParamSpecKwargs,
    43|         0|            0|            0|  0.00%|    TypeAliasType,
    44|         0|            0|            0|  0.00%|    Generic,
    45|         0|            0|            0|  0.00%|)
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|# Please keep __all__ alphabetized within each category.
    48|         0|            0|            0|  0.00%|__all__ = [
    49|         0|            0|            0|  0.00%|    # Super-special typing primitives.
    50|         0|            0|            0|  0.00%|    'Annotated',
    51|         0|            0|            0|  0.00%|    'Any',
    52|         0|            0|            0|  0.00%|    'Callable',
    53|         0|            0|            0|  0.00%|    'ClassVar',
    54|         0|            0|            0|  0.00%|    'Concatenate',
    55|         0|            0|            0|  0.00%|    'Final',
    56|         0|            0|            0|  0.00%|    'ForwardRef',
    57|         0|            0|            0|  0.00%|    'Generic',
    58|         0|            0|            0|  0.00%|    'Literal',
    59|         0|            0|            0|  0.00%|    'Optional',
    60|         0|            0|            0|  0.00%|    'ParamSpec',
    61|         0|            0|            0|  0.00%|    'Protocol',
    62|         0|            0|            0|  0.00%|    'Tuple',
    63|         0|            0|            0|  0.00%|    'Type',
    64|         0|            0|            0|  0.00%|    'TypeVar',
    65|         0|            0|            0|  0.00%|    'TypeVarTuple',
    66|         0|            0|            0|  0.00%|    'Union',
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|    # ABCs (from collections.abc).
    69|         0|            0|            0|  0.00%|    'AbstractSet',  # collections.abc.Set.
    70|         0|            0|            0|  0.00%|    'ByteString',
    71|         0|            0|            0|  0.00%|    'Container',
    72|         0|            0|            0|  0.00%|    'ContextManager',
    73|         0|            0|            0|  0.00%|    'Hashable',
    74|         0|            0|            0|  0.00%|    'ItemsView',
    75|         0|            0|            0|  0.00%|    'Iterable',
    76|         0|            0|            0|  0.00%|    'Iterator',
    77|         0|            0|            0|  0.00%|    'KeysView',
    78|         0|            0|            0|  0.00%|    'Mapping',
    79|         0|            0|            0|  0.00%|    'MappingView',
    80|         0|            0|            0|  0.00%|    'MutableMapping',
    81|         0|            0|            0|  0.00%|    'MutableSequence',
    82|         0|            0|            0|  0.00%|    'MutableSet',
    83|         0|            0|            0|  0.00%|    'Sequence',
    84|         0|            0|            0|  0.00%|    'Sized',
    85|         0|            0|            0|  0.00%|    'ValuesView',
    86|         0|            0|            0|  0.00%|    'Awaitable',
    87|         0|            0|            0|  0.00%|    'AsyncIterator',
    88|         0|            0|            0|  0.00%|    'AsyncIterable',
    89|         0|            0|            0|  0.00%|    'Coroutine',
    90|         0|            0|            0|  0.00%|    'Collection',
    91|         0|            0|            0|  0.00%|    'AsyncGenerator',
    92|         0|            0|            0|  0.00%|    'AsyncContextManager',
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|    # Structural checks, a.k.a. protocols.
    95|         0|            0|            0|  0.00%|    'Reversible',
    96|         0|            0|            0|  0.00%|    'SupportsAbs',
    97|         0|            0|            0|  0.00%|    'SupportsBytes',
    98|         0|            0|            0|  0.00%|    'SupportsComplex',
    99|         0|            0|            0|  0.00%|    'SupportsFloat',
   100|         0|            0|            0|  0.00%|    'SupportsIndex',
   101|         0|            0|            0|  0.00%|    'SupportsInt',
   102|         0|            0|            0|  0.00%|    'SupportsRound',
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|    # Concrete collection types.
   105|         0|            0|            0|  0.00%|    'ChainMap',
   106|         0|            0|            0|  0.00%|    'Counter',
   107|         0|            0|            0|  0.00%|    'Deque',
   108|         0|            0|            0|  0.00%|    'Dict',
   109|         0|            0|            0|  0.00%|    'DefaultDict',
   110|         0|            0|            0|  0.00%|    'List',
   111|         0|            0|            0|  0.00%|    'OrderedDict',
   112|         0|            0|            0|  0.00%|    'Set',
   113|         0|            0|            0|  0.00%|    'FrozenSet',
   114|         0|            0|            0|  0.00%|    'NamedTuple',  # Not really a type.
   115|         0|            0|            0|  0.00%|    'TypedDict',  # Not really a type.
   116|         0|            0|            0|  0.00%|    'Generator',
   117|         0|            0|            0|  0.00%|
   118|         0|            0|            0|  0.00%|    # Other concrete types.
   119|         0|            0|            0|  0.00%|    'BinaryIO',
   120|         0|            0|            0|  0.00%|    'IO',
   121|         0|            0|            0|  0.00%|    'Match',
   122|         0|            0|            0|  0.00%|    'Pattern',
   123|         0|            0|            0|  0.00%|    'TextIO',
   124|         0|            0|            0|  0.00%|
   125|         0|            0|            0|  0.00%|    # One-off things.
   126|         0|            0|            0|  0.00%|    'AnyStr',
   127|         0|            0|            0|  0.00%|    'assert_type',
   128|         0|            0|            0|  0.00%|    'assert_never',
   129|         0|            0|            0|  0.00%|    'cast',
   130|         0|            0|            0|  0.00%|    'clear_overloads',
   131|         0|            0|            0|  0.00%|    'dataclass_transform',
   132|         0|            0|            0|  0.00%|    'final',
   133|         0|            0|            0|  0.00%|    'get_args',
   134|         0|            0|            0|  0.00%|    'get_origin',
   135|         0|            0|            0|  0.00%|    'get_overloads',
   136|         0|            0|            0|  0.00%|    'get_type_hints',
   137|         0|            0|            0|  0.00%|    'is_typeddict',
   138|         0|            0|            0|  0.00%|    'LiteralString',
   139|         0|            0|            0|  0.00%|    'Never',
   140|         0|            0|            0|  0.00%|    'NewType',
   141|         0|            0|            0|  0.00%|    'no_type_check',
   142|         0|            0|            0|  0.00%|    'no_type_check_decorator',
   143|         0|            0|            0|  0.00%|    'NoReturn',
   144|         0|            0|            0|  0.00%|    'NotRequired',
   145|         0|            0|            0|  0.00%|    'overload',
   146|         0|            0|            0|  0.00%|    'override',
   147|         0|            0|            0|  0.00%|    'ParamSpecArgs',
   148|         0|            0|            0|  0.00%|    'ParamSpecKwargs',
   149|         0|            0|            0|  0.00%|    'Required',
   150|         0|            0|            0|  0.00%|    'reveal_type',
   151|         0|            0|            0|  0.00%|    'runtime_checkable',
   152|         0|            0|            0|  0.00%|    'Self',
   153|         0|            0|            0|  0.00%|    'Text',
   154|         0|            0|            0|  0.00%|    'TYPE_CHECKING',
   155|         0|            0|            0|  0.00%|    'TypeAlias',
   156|         0|            0|            0|  0.00%|    'TypeGuard',
   157|         0|            0|            0|  0.00%|    'TypeAliasType',
   158|         0|            0|            0|  0.00%|    'Unpack',
   159|         0|            0|            0|  0.00%|]
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|# The pseudo-submodules 're' and 'io' are part of the public
   162|         0|            0|            0|  0.00%|# namespace, but excluded from __all__ because they might stomp on
   163|         0|            0|            0|  0.00%|# legitimate imports of those modules.
   164|         0|            0|            0|  0.00%|
   165|         0|            0|            0|  0.00%|
   166|         2|  5.72205e-06|  2.86102e-06|  0.01%|def _type_convert(arg, module=None, *, allow_special_forms=False):
   167|         0|            0|            0|  0.00%|    """For converting None to type(None), and strings to ForwardRef."""
   168|         2|  3.33786e-06|  1.66893e-06|  0.00%|    if arg is None:
   169|         0|            0|            0|  0.00%|        return type(None)
   170|         2|  3.57628e-06|  1.78814e-06|  0.00%|    if isinstance(arg, str):
   171|         0|            0|            0|  0.00%|        return ForwardRef(arg, module=module, is_class=allow_special_forms)
   172|         2|  2.86102e-06|  1.43051e-06|  0.00%|    return arg
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|
   175|         2|  1.12057e-05|  5.60284e-06|  0.01%|def _type_check(arg, msg, is_argument=True, module=None, *, allow_special_forms=False):
   176|         0|            0|            0|  0.00%|    """Check that the argument is a type, and return it (internal helper).
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|    As a special case, accept None and return type(None) instead. Also wrap strings
   179|         0|            0|            0|  0.00%|    into ForwardRef instances. Consider several corner cases, for example plain
   180|         0|            0|            0|  0.00%|    special forms like Union are not valid, while Union[int, str] is OK, etc.
   181|         0|            0|            0|  0.00%|    The msg argument is a human-readable error message, e.g.::
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|        "Union[arg, ...]: arg should be a type."
   184|         0|            0|            0|  0.00%|
   185|         0|            0|            0|  0.00%|    We append the repr() of the actual value (truncated to 100 chars).
   186|         0|            0|            0|  0.00%|    """
   187|         2|  5.48363e-06|  2.74181e-06|  0.01%|    invalid_generic_forms = (Generic, Protocol)
   188|         2|  4.52995e-06|  2.26498e-06|  0.00%|    if not allow_special_forms:
   189|         0|            0|            0|  0.00%|        invalid_generic_forms += (ClassVar,)
   190|         0|            0|            0|  0.00%|        if is_argument:
   191|         0|            0|            0|  0.00%|            invalid_generic_forms += (Final,)
   192|         0|            0|            0|  0.00%|
   193|         2|  1.90735e-05|  9.53674e-06|  0.02%|    arg = _type_convert(arg, module=module, allow_special_forms=allow_special_forms)
(call)|         2|  1.54972e-05|   7.7486e-06|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:166 _type_convert
   194|         2|  5.24521e-06|   2.6226e-06|  0.01%|    if (isinstance(arg, _GenericAlias) and
   195|         0|            0|            0|  0.00%|            arg.__origin__ in invalid_generic_forms):
   196|         0|            0|            0|  0.00%|        raise TypeError(f"{arg} is not valid as type argument")
   197|         2|  5.24521e-06|   2.6226e-06|  0.01%|    if arg in (Any, LiteralString, NoReturn, Never, Self, TypeAlias):
   198|         0|            0|            0|  0.00%|        return arg
   199|         2|  4.76837e-06|  2.38419e-06|  0.00%|    if allow_special_forms and arg in (ClassVar, Final):
   200|         0|            0|            0|  0.00%|        return arg
   201|         2|  5.00679e-06|   2.5034e-06|  0.01%|    if isinstance(arg, _SpecialForm) or arg in (Generic, Protocol):
   202|         0|            0|            0|  0.00%|        raise TypeError(f"Plain {arg} is not valid as type argument")
   203|         2|  4.76837e-06|  2.38419e-06|  0.00%|    if type(arg) is tuple:
   204|         0|            0|            0|  0.00%|        raise TypeError(f"{msg} Got {arg!r:.100}.")
   205|         2|   3.8147e-06|  1.90735e-06|  0.00%|    return arg
   206|         0|            0|            0|  0.00%|
   207|         0|            0|            0|  0.00%|
   208|         0|            0|            0|  0.00%|def _is_param_expr(arg):
   209|         0|            0|            0|  0.00%|    return arg is ... or isinstance(arg,
   210|         0|            0|            0|  0.00%|            (tuple, list, ParamSpec, _ConcatenateGenericAlias))
   211|         0|            0|            0|  0.00%|
   212|         0|            0|            0|  0.00%|
   213|         0|            0|            0|  0.00%|def _should_unflatten_callable_args(typ, args):
   214|         0|            0|            0|  0.00%|    """Internal helper for munging collections.abc.Callable's __args__.
   215|         0|            0|            0|  0.00%|
   216|         0|            0|            0|  0.00%|    The canonical representation for a Callable's __args__ flattens the
   217|         0|            0|            0|  0.00%|    argument types, see https://github.com/python/cpython/issues/86361.
   218|         0|            0|            0|  0.00%|
   219|         0|            0|            0|  0.00%|    For example::
   220|         0|            0|            0|  0.00%|
   221|         0|            0|            0|  0.00%|        >>> import collections.abc
   222|         0|            0|            0|  0.00%|        >>> P = ParamSpec('P')
   223|         0|            0|            0|  0.00%|        >>> collections.abc.Callable[[int, int], str].__args__ == (int, int, str)
   224|         0|            0|            0|  0.00%|        True
   225|         0|            0|            0|  0.00%|        >>> collections.abc.Callable[P, str].__args__ == (P, str)
   226|         0|            0|            0|  0.00%|        True
   227|         0|            0|            0|  0.00%|
   228|         0|            0|            0|  0.00%|    As a result, if we need to reconstruct the Callable from its __args__,
   229|         0|            0|            0|  0.00%|    we need to unflatten it.
   230|         0|            0|            0|  0.00%|    """
   231|         0|            0|            0|  0.00%|    return (
   232|         0|            0|            0|  0.00%|        typ.__origin__ is collections.abc.Callable
   233|         0|            0|            0|  0.00%|        and not (len(args) == 2 and _is_param_expr(args[0]))
   234|         0|            0|            0|  0.00%|    )
   235|         0|            0|            0|  0.00%|
   236|         0|            0|            0|  0.00%|
   237|         2|   6.4373e-06|  3.21865e-06|  0.01%|def _type_repr(obj):
   238|         0|            0|            0|  0.00%|    """Return the repr() of an object, special-casing types (internal helper).
   239|         0|            0|            0|  0.00%|
   240|         0|            0|            0|  0.00%|    If obj is a type, we return a shorter version than the default
   241|         0|            0|            0|  0.00%|    type.__repr__, based on the module and qualified name, which is
   242|         0|            0|            0|  0.00%|    typically enough to uniquely identify a type.  For everything
   243|         0|            0|            0|  0.00%|    else, we fall back on repr(obj).
   244|         0|            0|            0|  0.00%|    """
   245|         0|            0|            0|  0.00%|    # When changing this function, don't forget about
   246|         0|            0|            0|  0.00%|    # `_collections_abc._type_repr`, which does the same thing
   247|         0|            0|            0|  0.00%|    # and must be consistent with this one.
   248|         2|  5.24521e-06|   2.6226e-06|  0.01%|    if isinstance(obj, type):
   249|         2|  5.00679e-06|   2.5034e-06|  0.01%|        if obj.__module__ == 'builtins':
   250|         2|  4.76837e-06|  2.38419e-06|  0.00%|            return obj.__qualname__
   251|         0|            0|            0|  0.00%|        return f'{obj.__module__}.{obj.__qualname__}'
   252|         0|            0|            0|  0.00%|    if obj is ...:
   253|         0|            0|            0|  0.00%|        return '...'
   254|         0|            0|            0|  0.00%|    if isinstance(obj, types.FunctionType):
   255|         0|            0|            0|  0.00%|        return obj.__name__
   256|         0|            0|            0|  0.00%|    if isinstance(obj, tuple):
   257|         0|            0|            0|  0.00%|        # Special case for `repr` of types with `ParamSpec`:
   258|         0|            0|            0|  0.00%|        return '[' + ', '.join(_type_repr(t) for t in obj) + ']'
   259|         0|            0|            0|  0.00%|    return repr(obj)
   260|         0|            0|            0|  0.00%|
   261|         0|            0|            0|  0.00%|
   262|         0|            0|            0|  0.00%|def _collect_parameters(args):
   263|         0|            0|            0|  0.00%|    """Collect all type variables and parameter specifications in args
   264|         0|            0|            0|  0.00%|    in order of first appearance (lexicographic order).
   265|         0|            0|            0|  0.00%|
   266|         0|            0|            0|  0.00%|    For example::
   267|         0|            0|            0|  0.00%|
   268|         0|            0|            0|  0.00%|        >>> P = ParamSpec('P')
   269|         0|            0|            0|  0.00%|        >>> T = TypeVar('T')
   270|         0|            0|            0|  0.00%|        >>> _collect_parameters((T, Callable[P, T]))
   271|         0|            0|            0|  0.00%|        (~T, ~P)
   272|         0|            0|            0|  0.00%|    """
   273|         0|            0|            0|  0.00%|    parameters = []
   274|         0|            0|            0|  0.00%|    for t in args:
   275|         0|            0|            0|  0.00%|        if isinstance(t, type):
   276|         0|            0|            0|  0.00%|            # We don't want __parameters__ descriptor of a bare Python class.
   277|         0|            0|            0|  0.00%|            pass
   278|         0|            0|            0|  0.00%|        elif isinstance(t, tuple):
   279|         0|            0|            0|  0.00%|            # `t` might be a tuple, when `ParamSpec` is substituted with
   280|         0|            0|            0|  0.00%|            # `[T, int]`, or `[int, *Ts]`, etc.
   281|         0|            0|            0|  0.00%|            for x in t:
   282|         0|            0|            0|  0.00%|                for collected in _collect_parameters([x]):
   283|         0|            0|            0|  0.00%|                    if collected not in parameters:
   284|         0|            0|            0|  0.00%|                        parameters.append(collected)
   285|         0|            0|            0|  0.00%|        elif hasattr(t, '__typing_subst__'):
   286|         0|            0|            0|  0.00%|            if t not in parameters:
   287|         0|            0|            0|  0.00%|                parameters.append(t)
   288|         0|            0|            0|  0.00%|        else:
   289|         0|            0|            0|  0.00%|            for x in getattr(t, '__parameters__', ()):
   290|         0|            0|            0|  0.00%|                if x not in parameters:
   291|         0|            0|            0|  0.00%|                    parameters.append(x)
   292|         0|            0|            0|  0.00%|    return tuple(parameters)
   293|         0|            0|            0|  0.00%|
   294|         0|            0|            0|  0.00%|
   295|         0|            0|            0|  0.00%|def _check_generic(cls, parameters, elen):
   296|         0|            0|            0|  0.00%|    """Check correct count for parameters of a generic cls (internal helper).
   297|         0|            0|            0|  0.00%|
   298|         0|            0|            0|  0.00%|    This gives a nice error message in case of count mismatch.
   299|         0|            0|            0|  0.00%|    """
   300|         0|            0|            0|  0.00%|    if not elen:
   301|         0|            0|            0|  0.00%|        raise TypeError(f"{cls} is not a generic class")
   302|         0|            0|            0|  0.00%|    alen = len(parameters)
   303|         0|            0|            0|  0.00%|    if alen != elen:
   304|         0|            0|            0|  0.00%|        raise TypeError(f"Too {'many' if alen > elen else 'few'} arguments for {cls};"
   305|         0|            0|            0|  0.00%|                        f" actual {alen}, expected {elen}")
   306|         0|            0|            0|  0.00%|
   307|         0|            0|            0|  0.00%|def _unpack_args(args):
   308|         0|            0|            0|  0.00%|    newargs = []
   309|         0|            0|            0|  0.00%|    for arg in args:
   310|         0|            0|            0|  0.00%|        subargs = getattr(arg, '__typing_unpacked_tuple_args__', None)
   311|         0|            0|            0|  0.00%|        if subargs is not None and not (subargs and subargs[-1] is ...):
   312|         0|            0|            0|  0.00%|            newargs.extend(subargs)
   313|         0|            0|            0|  0.00%|        else:
   314|         0|            0|            0|  0.00%|            newargs.append(arg)
   315|         0|            0|            0|  0.00%|    return newargs
   316|         0|            0|            0|  0.00%|
   317|         0|            0|            0|  0.00%|def _deduplicate(params, *, unhashable_fallback=False):
   318|         0|            0|            0|  0.00%|    # Weed out strict duplicates, preserving the first of each occurrence.
   319|         0|            0|            0|  0.00%|    try:
   320|         0|            0|            0|  0.00%|        return dict.fromkeys(params)
   321|         0|            0|            0|  0.00%|    except TypeError:
   322|         0|            0|            0|  0.00%|        if not unhashable_fallback:
   323|         0|            0|            0|  0.00%|            raise
   324|         0|            0|            0|  0.00%|        # Happens for cases like `Annotated[dict, {'x': IntValidator()}]`
   325|         0|            0|            0|  0.00%|        return _deduplicate_unhashable(params)
   326|         0|            0|            0|  0.00%|
   327|         0|            0|            0|  0.00%|def _deduplicate_unhashable(unhashable_params):
   328|         0|            0|            0|  0.00%|    new_unhashable = []
   329|         0|            0|            0|  0.00%|    for t in unhashable_params:
   330|         0|            0|            0|  0.00%|        if t not in new_unhashable:
   331|         0|            0|            0|  0.00%|            new_unhashable.append(t)
   332|         0|            0|            0|  0.00%|    return new_unhashable
   333|         0|            0|            0|  0.00%|
   334|         0|            0|            0|  0.00%|def _compare_args_orderless(first_args, second_args):
   335|         0|            0|            0|  0.00%|    first_unhashable = _deduplicate_unhashable(first_args)
   336|         0|            0|            0|  0.00%|    second_unhashable = _deduplicate_unhashable(second_args)
   337|         0|            0|            0|  0.00%|    t = list(second_unhashable)
   338|         0|            0|            0|  0.00%|    try:
   339|         0|            0|            0|  0.00%|        for elem in first_unhashable:
   340|         0|            0|            0|  0.00%|            t.remove(elem)
   341|         0|            0|            0|  0.00%|    except ValueError:
   342|         0|            0|            0|  0.00%|        return False
   343|         0|            0|            0|  0.00%|    return not t
   344|         0|            0|            0|  0.00%|
   345|         0|            0|            0|  0.00%|def _remove_dups_flatten(parameters):
   346|         0|            0|            0|  0.00%|    """Internal helper for Union creation and substitution.
   347|         0|            0|            0|  0.00%|
   348|         0|            0|            0|  0.00%|    Flatten Unions among parameters, then remove duplicates.
   349|         0|            0|            0|  0.00%|    """
   350|         0|            0|            0|  0.00%|    # Flatten out Union[Union[...], ...].
   351|         0|            0|            0|  0.00%|    params = []
   352|         0|            0|            0|  0.00%|    for p in parameters:
   353|         0|            0|            0|  0.00%|        if isinstance(p, (_UnionGenericAlias, types.UnionType)):
   354|         0|            0|            0|  0.00%|            params.extend(p.__args__)
   355|         0|            0|            0|  0.00%|        else:
   356|         0|            0|            0|  0.00%|            params.append(p)
   357|         0|            0|            0|  0.00%|
   358|         0|            0|            0|  0.00%|    return tuple(_deduplicate(params, unhashable_fallback=True))
   359|         0|            0|            0|  0.00%|
   360|         0|            0|            0|  0.00%|
   361|         0|            0|            0|  0.00%|def _flatten_literal_params(parameters):
   362|         0|            0|            0|  0.00%|    """Internal helper for Literal creation: flatten Literals among parameters."""
   363|         0|            0|            0|  0.00%|    params = []
   364|         0|            0|            0|  0.00%|    for p in parameters:
   365|         0|            0|            0|  0.00%|        if isinstance(p, _LiteralGenericAlias):
   366|         0|            0|            0|  0.00%|            params.extend(p.__args__)
   367|         0|            0|            0|  0.00%|        else:
   368|         0|            0|            0|  0.00%|            params.append(p)
   369|         0|            0|            0|  0.00%|    return tuple(params)
   370|         0|            0|            0|  0.00%|
   371|         0|            0|            0|  0.00%|
   372|         0|            0|            0|  0.00%|_cleanups = []
   373|         0|            0|            0|  0.00%|_caches = {}
   374|         0|            0|            0|  0.00%|
   375|         0|            0|            0|  0.00%|
   376|         0|            0|            0|  0.00%|def _tp_cache(func=None, /, *, typed=False):
   377|         0|            0|            0|  0.00%|    """Internal wrapper caching __getitem__ of generic types.
   378|         0|            0|            0|  0.00%|
   379|         0|            0|            0|  0.00%|    For non-hashable arguments, the original function is used as a fallback.
   380|         0|            0|            0|  0.00%|    """
   381|         0|            0|            0|  0.00%|    def decorator(func):
   382|         0|            0|            0|  0.00%|        # The callback 'inner' references the newly created lru_cache
   383|         0|            0|            0|  0.00%|        # indirectly by performing a lookup in the global '_caches' dictionary.
   384|         0|            0|            0|  0.00%|        # This breaks a reference that can be problematic when combined with
   385|         0|            0|            0|  0.00%|        # C API extensions that leak references to types. See GH-98253.
   386|         0|            0|            0|  0.00%|
   387|         0|            0|            0|  0.00%|        cache = functools.lru_cache(typed=typed)(func)
   388|         0|            0|            0|  0.00%|        _caches[func] = cache
   389|         0|            0|            0|  0.00%|        _cleanups.append(cache.cache_clear)
   390|         0|            0|            0|  0.00%|        del cache
   391|         0|            0|            0|  0.00%|
   392|         4|  6.67572e-06|  1.66893e-06|  0.01%|        @functools.wraps(func)
   393|         0|            0|            0|  0.00%|        def inner(*args, **kwds):
   394|         4|  5.72205e-06|  1.43051e-06|  0.01%|            try:
   395|         4|  2.59876e-05|  6.49691e-06|  0.03%|                return _caches[func](*args, **kwds)
(call)|         2|  0.000670671|  0.000335336|  0.69%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:2092 _class_getitem_inner
   396|         0|            0|            0|  0.00%|            except TypeError:
   397|         0|            0|            0|  0.00%|                pass  # All real errors (not unhashable args) are raised below.
   398|         0|            0|            0|  0.00%|            return func(*args, **kwds)
   399|         0|            0|            0|  0.00%|        return inner
   400|         0|            0|            0|  0.00%|
   401|         0|            0|            0|  0.00%|    if func is not None:
   402|         0|            0|            0|  0.00%|        return decorator(func)
   403|         0|            0|            0|  0.00%|
   404|         0|            0|            0|  0.00%|    return decorator
   405|         0|            0|            0|  0.00%|
   406|         0|            0|            0|  0.00%|def _eval_type(t, globalns, localns, recursive_guard=frozenset()):
   407|         0|            0|            0|  0.00%|    """Evaluate all forward references in the given type t.
   408|         0|            0|            0|  0.00%|
   409|         0|            0|            0|  0.00%|    For use of globalns and localns see the docstring for get_type_hints().
   410|         0|            0|            0|  0.00%|    recursive_guard is used to prevent infinite recursion with a recursive
   411|         0|            0|            0|  0.00%|    ForwardRef.
   412|         0|            0|            0|  0.00%|    """
   413|         0|            0|            0|  0.00%|    if isinstance(t, ForwardRef):
   414|         0|            0|            0|  0.00%|        return t._evaluate(globalns, localns, recursive_guard)
   415|         0|            0|            0|  0.00%|    if isinstance(t, (_GenericAlias, GenericAlias, types.UnionType)):
   416|         0|            0|            0|  0.00%|        if isinstance(t, GenericAlias):
   417|         0|            0|            0|  0.00%|            args = tuple(
   418|         0|            0|            0|  0.00%|                ForwardRef(arg) if isinstance(arg, str) else arg
   419|         0|            0|            0|  0.00%|                for arg in t.__args__
   420|         0|            0|            0|  0.00%|            )
   421|         0|            0|            0|  0.00%|            is_unpacked = t.__unpacked__
   422|         0|            0|            0|  0.00%|            if _should_unflatten_callable_args(t, args):
   423|         0|            0|            0|  0.00%|                t = t.__origin__[(args[:-1], args[-1])]
   424|         0|            0|            0|  0.00%|            else:
   425|         0|            0|            0|  0.00%|                t = t.__origin__[args]
   426|         0|            0|            0|  0.00%|            if is_unpacked:
   427|         0|            0|            0|  0.00%|                t = Unpack[t]
   428|         0|            0|            0|  0.00%|        ev_args = tuple(_eval_type(a, globalns, localns, recursive_guard) for a in t.__args__)
   429|         0|            0|            0|  0.00%|        if ev_args == t.__args__:
   430|         0|            0|            0|  0.00%|            return t
   431|         0|            0|            0|  0.00%|        if isinstance(t, GenericAlias):
   432|         0|            0|            0|  0.00%|            return GenericAlias(t.__origin__, ev_args)
   433|         0|            0|            0|  0.00%|        if isinstance(t, types.UnionType):
   434|         0|            0|            0|  0.00%|            return functools.reduce(operator.or_, ev_args)
   435|         0|            0|            0|  0.00%|        else:
   436|         0|            0|            0|  0.00%|            return t.copy_with(ev_args)
   437|         0|            0|            0|  0.00%|    return t
   438|         0|            0|            0|  0.00%|
   439|         0|            0|            0|  0.00%|
   440|         0|            0|            0|  0.00%|class _Final:
   441|         0|            0|            0|  0.00%|    """Mixin to prohibit subclassing."""
   442|         0|            0|            0|  0.00%|
   443|         0|            0|            0|  0.00%|    __slots__ = ('__weakref__',)
   444|         0|            0|            0|  0.00%|
   445|         0|            0|            0|  0.00%|    def __init_subclass__(cls, /, *args, **kwds):
   446|         0|            0|            0|  0.00%|        if '_root' not in kwds:
   447|         0|            0|            0|  0.00%|            raise TypeError("Cannot subclass special typing classes")
   448|         0|            0|            0|  0.00%|
   449|         0|            0|            0|  0.00%|
   450|         0|            0|            0|  0.00%|class _NotIterable:
   451|         0|            0|            0|  0.00%|    """Mixin to prevent iteration, without being compatible with Iterable.
   452|         0|            0|            0|  0.00%|
   453|         0|            0|            0|  0.00%|    That is, we could do::
   454|         0|            0|            0|  0.00%|
   455|         0|            0|            0|  0.00%|        def __iter__(self): raise TypeError()
   456|         0|            0|            0|  0.00%|
   457|         0|            0|            0|  0.00%|    But this would make users of this mixin duck type-compatible with
   458|         0|            0|            0|  0.00%|    collections.abc.Iterable - isinstance(foo, Iterable) would be True.
   459|         0|            0|            0|  0.00%|
   460|         0|            0|            0|  0.00%|    Luckily, we can instead prevent iteration by setting __iter__ to None, which
   461|         0|            0|            0|  0.00%|    is treated specially.
   462|         0|            0|            0|  0.00%|    """
   463|         0|            0|            0|  0.00%|
   464|         0|            0|            0|  0.00%|    __slots__ = ()
   465|         0|            0|            0|  0.00%|    __iter__ = None
   466|         0|            0|            0|  0.00%|
   467|         0|            0|            0|  0.00%|
   468|         0|            0|            0|  0.00%|# Internal indicator of special typing constructs.
   469|         0|            0|            0|  0.00%|# See __doc__ instance attribute for specific docs.
   470|         0|            0|            0|  0.00%|class _SpecialForm(_Final, _NotIterable, _root=True):
   471|         0|            0|            0|  0.00%|    __slots__ = ('_name', '__doc__', '_getitem')
   472|         0|            0|            0|  0.00%|
   473|         0|            0|            0|  0.00%|    def __init__(self, getitem):
   474|         0|            0|            0|  0.00%|        self._getitem = getitem
   475|         0|            0|            0|  0.00%|        self._name = getitem.__name__
   476|         0|            0|            0|  0.00%|        self.__doc__ = getitem.__doc__
   477|         0|            0|            0|  0.00%|
   478|         0|            0|            0|  0.00%|    def __getattr__(self, item):
   479|         0|            0|            0|  0.00%|        if item in {'__name__', '__qualname__'}:
   480|         0|            0|            0|  0.00%|            return self._name
   481|         0|            0|            0|  0.00%|
   482|         0|            0|            0|  0.00%|        raise AttributeError(item)
   483|         0|            0|            0|  0.00%|
   484|         0|            0|            0|  0.00%|    def __mro_entries__(self, bases):
   485|         0|            0|            0|  0.00%|        raise TypeError(f"Cannot subclass {self!r}")
   486|         0|            0|            0|  0.00%|
   487|         0|            0|            0|  0.00%|    def __repr__(self):
   488|         0|            0|            0|  0.00%|        return 'typing.' + self._name
   489|         0|            0|            0|  0.00%|
   490|         0|            0|            0|  0.00%|    def __reduce__(self):
   491|         0|            0|            0|  0.00%|        return self._name
   492|         0|            0|            0|  0.00%|
   493|         0|            0|            0|  0.00%|    def __call__(self, *args, **kwds):
   494|         0|            0|            0|  0.00%|        raise TypeError(f"Cannot instantiate {self!r}")
   495|         0|            0|            0|  0.00%|
   496|         0|            0|            0|  0.00%|    def __or__(self, other):
   497|         0|            0|            0|  0.00%|        return Union[self, other]
   498|         0|            0|            0|  0.00%|
   499|         0|            0|            0|  0.00%|    def __ror__(self, other):
   500|         0|            0|            0|  0.00%|        return Union[other, self]
   501|         0|            0|            0|  0.00%|
   502|         0|            0|            0|  0.00%|    def __instancecheck__(self, obj):
   503|         0|            0|            0|  0.00%|        raise TypeError(f"{self} cannot be used with isinstance()")
   504|         0|            0|            0|  0.00%|
   505|         0|            0|            0|  0.00%|    def __subclasscheck__(self, cls):
   506|         0|            0|            0|  0.00%|        raise TypeError(f"{self} cannot be used with issubclass()")
   507|         0|            0|            0|  0.00%|
   508|         0|            0|            0|  0.00%|    @_tp_cache
   509|         0|            0|            0|  0.00%|    def __getitem__(self, parameters):
   510|         0|            0|            0|  0.00%|        return self._getitem(self, parameters)
   511|         0|            0|            0|  0.00%|
   512|         0|            0|            0|  0.00%|
   513|         0|            0|            0|  0.00%|class _LiteralSpecialForm(_SpecialForm, _root=True):
   514|         0|            0|            0|  0.00%|    def __getitem__(self, parameters):
   515|         0|            0|            0|  0.00%|        if not isinstance(parameters, tuple):
   516|         0|            0|            0|  0.00%|            parameters = (parameters,)
   517|         0|            0|            0|  0.00%|        return self._getitem(self, *parameters)
   518|         0|            0|            0|  0.00%|
   519|         0|            0|            0|  0.00%|
   520|         0|            0|            0|  0.00%|class _AnyMeta(type):
   521|         0|            0|            0|  0.00%|    def __instancecheck__(self, obj):
   522|         0|            0|            0|  0.00%|        if self is Any:
   523|         0|            0|            0|  0.00%|            raise TypeError("typing.Any cannot be used with isinstance()")
   524|         0|            0|            0|  0.00%|        return super().__instancecheck__(obj)
   525|         0|            0|            0|  0.00%|
   526|         0|            0|            0|  0.00%|    def __repr__(self):
   527|         0|            0|            0|  0.00%|        if self is Any:
   528|         0|            0|            0|  0.00%|            return "typing.Any"
   529|         0|            0|            0|  0.00%|        return super().__repr__()  # respect to subclasses
   530|         0|            0|            0|  0.00%|
   531|         0|            0|            0|  0.00%|
   532|         0|            0|            0|  0.00%|class Any(metaclass=_AnyMeta):
   533|         0|            0|            0|  0.00%|    """Special type indicating an unconstrained type.
   534|         0|            0|            0|  0.00%|
   535|         0|            0|            0|  0.00%|    - Any is compatible with every type.
   536|         0|            0|            0|  0.00%|    - Any assumed to have all methods.
   537|         0|            0|            0|  0.00%|    - All values assumed to be instances of Any.
   538|         0|            0|            0|  0.00%|
   539|         0|            0|            0|  0.00%|    Note that all the above statements are true from the point of view of
   540|         0|            0|            0|  0.00%|    static type checkers. At runtime, Any should not be used with instance
   541|         0|            0|            0|  0.00%|    checks.
   542|         0|            0|            0|  0.00%|    """
   543|         0|            0|            0|  0.00%|
   544|         0|            0|            0|  0.00%|    def __new__(cls, *args, **kwargs):
   545|         0|            0|            0|  0.00%|        if cls is Any:
   546|         0|            0|            0|  0.00%|            raise TypeError("Any cannot be instantiated")
   547|         0|            0|            0|  0.00%|        return super().__new__(cls)
   548|         0|            0|            0|  0.00%|
   549|         0|            0|            0|  0.00%|
   550|         0|            0|            0|  0.00%|@_SpecialForm
   551|         0|            0|            0|  0.00%|def NoReturn(self, parameters):
   552|         0|            0|            0|  0.00%|    """Special type indicating functions that never return.
   553|         0|            0|            0|  0.00%|
   554|         0|            0|            0|  0.00%|    Example::
   555|         0|            0|            0|  0.00%|
   556|         0|            0|            0|  0.00%|        from typing import NoReturn
   557|         0|            0|            0|  0.00%|
   558|         0|            0|            0|  0.00%|        def stop() -> NoReturn:
   559|         0|            0|            0|  0.00%|            raise Exception('no way')
   560|         0|            0|            0|  0.00%|
   561|         0|            0|            0|  0.00%|    NoReturn can also be used as a bottom type, a type that
   562|         0|            0|            0|  0.00%|    has no values. Starting in Python 3.11, the Never type should
   563|         0|            0|            0|  0.00%|    be used for this concept instead. Type checkers should treat the two
   564|         0|            0|            0|  0.00%|    equivalently.
   565|         0|            0|            0|  0.00%|    """
   566|         0|            0|            0|  0.00%|    raise TypeError(f"{self} is not subscriptable")
   567|         0|            0|            0|  0.00%|
   568|         0|            0|            0|  0.00%|# This is semantically identical to NoReturn, but it is implemented
   569|         0|            0|            0|  0.00%|# separately so that type checkers can distinguish between the two
   570|         0|            0|            0|  0.00%|# if they want.
   571|         0|            0|            0|  0.00%|@_SpecialForm
   572|         0|            0|            0|  0.00%|def Never(self, parameters):
   573|         0|            0|            0|  0.00%|    """The bottom type, a type that has no members.
   574|         0|            0|            0|  0.00%|
   575|         0|            0|            0|  0.00%|    This can be used to define a function that should never be
   576|         0|            0|            0|  0.00%|    called, or a function that never returns::
   577|         0|            0|            0|  0.00%|
   578|         0|            0|            0|  0.00%|        from typing import Never
   579|         0|            0|            0|  0.00%|
   580|         0|            0|            0|  0.00%|        def never_call_me(arg: Never) -> None:
   581|         0|            0|            0|  0.00%|            pass
   582|         0|            0|            0|  0.00%|
   583|         0|            0|            0|  0.00%|        def int_or_str(arg: int | str) -> None:
   584|         0|            0|            0|  0.00%|            never_call_me(arg)  # type checker error
   585|         0|            0|            0|  0.00%|            match arg:
   586|         0|            0|            0|  0.00%|                case int():
   587|         0|            0|            0|  0.00%|                    print("It's an int")
   588|         0|            0|            0|  0.00%|                case str():
   589|         0|            0|            0|  0.00%|                    print("It's a str")
   590|         0|            0|            0|  0.00%|                case _:
   591|         0|            0|            0|  0.00%|                    never_call_me(arg)  # OK, arg is of type Never
   592|         0|            0|            0|  0.00%|    """
   593|         0|            0|            0|  0.00%|    raise TypeError(f"{self} is not subscriptable")
   594|         0|            0|            0|  0.00%|
   595|         0|            0|            0|  0.00%|
   596|         0|            0|            0|  0.00%|@_SpecialForm
   597|         0|            0|            0|  0.00%|def Self(self, parameters):
   598|         0|            0|            0|  0.00%|    """Used to spell the type of "self" in classes.
   599|         0|            0|            0|  0.00%|
   600|         0|            0|            0|  0.00%|    Example::
   601|         0|            0|            0|  0.00%|
   602|         0|            0|            0|  0.00%|        from typing import Self
   603|         0|            0|            0|  0.00%|
   604|         0|            0|            0|  0.00%|        class Foo:
   605|         0|            0|            0|  0.00%|            def return_self(self) -> Self:
   606|         0|            0|            0|  0.00%|                ...
   607|         0|            0|            0|  0.00%|                return self
   608|         0|            0|            0|  0.00%|
   609|         0|            0|            0|  0.00%|    This is especially useful for:
   610|         0|            0|            0|  0.00%|        - classmethods that are used as alternative constructors
   611|         0|            0|            0|  0.00%|        - annotating an `__enter__` method which returns self
   612|         0|            0|            0|  0.00%|    """
   613|         0|            0|            0|  0.00%|    raise TypeError(f"{self} is not subscriptable")
   614|         0|            0|            0|  0.00%|
   615|         0|            0|            0|  0.00%|
   616|         0|            0|            0|  0.00%|@_SpecialForm
   617|         0|            0|            0|  0.00%|def LiteralString(self, parameters):
   618|         0|            0|            0|  0.00%|    """Represents an arbitrary literal string.
   619|         0|            0|            0|  0.00%|
   620|         0|            0|            0|  0.00%|    Example::
   621|         0|            0|            0|  0.00%|
   622|         0|            0|            0|  0.00%|        from typing import LiteralString
   623|         0|            0|            0|  0.00%|
   624|         0|            0|            0|  0.00%|        def run_query(sql: LiteralString) -> None:
   625|         0|            0|            0|  0.00%|            ...
   626|         0|            0|            0|  0.00%|
   627|         0|            0|            0|  0.00%|        def caller(arbitrary_string: str, literal_string: LiteralString) -> None:
   628|         0|            0|            0|  0.00%|            run_query("SELECT * FROM students")  # OK
   629|         0|            0|            0|  0.00%|            run_query(literal_string)  # OK
   630|         0|            0|            0|  0.00%|            run_query("SELECT * FROM " + literal_string)  # OK
   631|         0|            0|            0|  0.00%|            run_query(arbitrary_string)  # type checker error
   632|         0|            0|            0|  0.00%|            run_query(  # type checker error
   633|         0|            0|            0|  0.00%|                f"SELECT * FROM students WHERE name = {arbitrary_string}"
   634|         0|            0|            0|  0.00%|            )
   635|         0|            0|            0|  0.00%|
   636|         0|            0|            0|  0.00%|    Only string literals and other LiteralStrings are compatible
   637|         0|            0|            0|  0.00%|    with LiteralString. This provides a tool to help prevent
   638|         0|            0|            0|  0.00%|    security issues such as SQL injection.
   639|         0|            0|            0|  0.00%|    """
   640|         0|            0|            0|  0.00%|    raise TypeError(f"{self} is not subscriptable")
   641|         0|            0|            0|  0.00%|
   642|         0|            0|            0|  0.00%|
   643|         0|            0|            0|  0.00%|@_SpecialForm
   644|         0|            0|            0|  0.00%|def ClassVar(self, parameters):
   645|         0|            0|            0|  0.00%|    """Special type construct to mark class variables.
   646|         0|            0|            0|  0.00%|
   647|         0|            0|            0|  0.00%|    An annotation wrapped in ClassVar indicates that a given
   648|         0|            0|            0|  0.00%|    attribute is intended to be used as a class variable and
   649|         0|            0|            0|  0.00%|    should not be set on instances of that class.
   650|         0|            0|            0|  0.00%|
   651|         0|            0|            0|  0.00%|    Usage::
   652|         0|            0|            0|  0.00%|
   653|         0|            0|            0|  0.00%|        class Starship:
   654|         0|            0|            0|  0.00%|            stats: ClassVar[dict[str, int]] = {} # class variable
   655|         0|            0|            0|  0.00%|            damage: int = 10                     # instance variable
   656|         0|            0|            0|  0.00%|
   657|         0|            0|            0|  0.00%|    ClassVar accepts only types and cannot be further subscribed.
   658|         0|            0|            0|  0.00%|
   659|         0|            0|            0|  0.00%|    Note that ClassVar is not a class itself, and should not
   660|         0|            0|            0|  0.00%|    be used with isinstance() or issubclass().
   661|         0|            0|            0|  0.00%|    """
   662|         0|            0|            0|  0.00%|    item = _type_check(parameters, f'{self} accepts only single type.')
   663|         0|            0|            0|  0.00%|    return _GenericAlias(self, (item,))
   664|         0|            0|            0|  0.00%|
   665|         0|            0|            0|  0.00%|@_SpecialForm
   666|         0|            0|            0|  0.00%|def Final(self, parameters):
   667|         0|            0|            0|  0.00%|    """Special typing construct to indicate final names to type checkers.
   668|         0|            0|            0|  0.00%|
   669|         0|            0|            0|  0.00%|    A final name cannot be re-assigned or overridden in a subclass.
   670|         0|            0|            0|  0.00%|
   671|         0|            0|            0|  0.00%|    For example::
   672|         0|            0|            0|  0.00%|
   673|         0|            0|            0|  0.00%|        MAX_SIZE: Final = 9000
   674|         0|            0|            0|  0.00%|        MAX_SIZE += 1  # Error reported by type checker
   675|         0|            0|            0|  0.00%|
   676|         0|            0|            0|  0.00%|        class Connection:
   677|         0|            0|            0|  0.00%|            TIMEOUT: Final[int] = 10
   678|         0|            0|            0|  0.00%|
   679|         0|            0|            0|  0.00%|        class FastConnector(Connection):
   680|         0|            0|            0|  0.00%|            TIMEOUT = 1  # Error reported by type checker
   681|         0|            0|            0|  0.00%|
   682|         0|            0|            0|  0.00%|    There is no runtime checking of these properties.
   683|         0|            0|            0|  0.00%|    """
   684|         0|            0|            0|  0.00%|    item = _type_check(parameters, f'{self} accepts only single type.')
   685|         0|            0|            0|  0.00%|    return _GenericAlias(self, (item,))
   686|         0|            0|            0|  0.00%|
   687|         0|            0|            0|  0.00%|@_SpecialForm
   688|         0|            0|            0|  0.00%|def Union(self, parameters):
   689|         0|            0|            0|  0.00%|    """Union type; Union[X, Y] means either X or Y.
   690|         0|            0|            0|  0.00%|
   691|         0|            0|            0|  0.00%|    On Python 3.10 and higher, the | operator
   692|         0|            0|            0|  0.00%|    can also be used to denote unions;
   693|         0|            0|            0|  0.00%|    X | Y means the same thing to the type checker as Union[X, Y].
   694|         0|            0|            0|  0.00%|
   695|         0|            0|            0|  0.00%|    To define a union, use e.g. Union[int, str]. Details:
   696|         0|            0|            0|  0.00%|    - The arguments must be types and there must be at least one.
   697|         0|            0|            0|  0.00%|    - None as an argument is a special case and is replaced by
   698|         0|            0|            0|  0.00%|      type(None).
   699|         0|            0|            0|  0.00%|    - Unions of unions are flattened, e.g.::
   700|         0|            0|            0|  0.00%|
   701|         0|            0|            0|  0.00%|        assert Union[Union[int, str], float] == Union[int, str, float]
   702|         0|            0|            0|  0.00%|
   703|         0|            0|            0|  0.00%|    - Unions of a single argument vanish, e.g.::
   704|         0|            0|            0|  0.00%|
   705|         0|            0|            0|  0.00%|        assert Union[int] == int  # The constructor actually returns int
   706|         0|            0|            0|  0.00%|
   707|         0|            0|            0|  0.00%|    - Redundant arguments are skipped, e.g.::
   708|         0|            0|            0|  0.00%|
   709|         0|            0|            0|  0.00%|        assert Union[int, str, int] == Union[int, str]
   710|         0|            0|            0|  0.00%|
   711|         0|            0|            0|  0.00%|    - When comparing unions, the argument order is ignored, e.g.::
   712|         0|            0|            0|  0.00%|
   713|         0|            0|            0|  0.00%|        assert Union[int, str] == Union[str, int]
   714|         0|            0|            0|  0.00%|
   715|         0|            0|            0|  0.00%|    - You cannot subclass or instantiate a union.
   716|         0|            0|            0|  0.00%|    - You can use Optional[X] as a shorthand for Union[X, None].
   717|         0|            0|            0|  0.00%|    """
   718|         0|            0|            0|  0.00%|    if parameters == ():
   719|         0|            0|            0|  0.00%|        raise TypeError("Cannot take a Union of no types.")
   720|         0|            0|            0|  0.00%|    if not isinstance(parameters, tuple):
   721|         0|            0|            0|  0.00%|        parameters = (parameters,)
   722|         0|            0|            0|  0.00%|    msg = "Union[arg, ...]: each arg must be a type."
   723|         0|            0|            0|  0.00%|    parameters = tuple(_type_check(p, msg) for p in parameters)
   724|         0|            0|            0|  0.00%|    parameters = _remove_dups_flatten(parameters)
   725|         0|            0|            0|  0.00%|    if len(parameters) == 1:
   726|         0|            0|            0|  0.00%|        return parameters[0]
   727|         0|            0|            0|  0.00%|    if len(parameters) == 2 and type(None) in parameters:
   728|         0|            0|            0|  0.00%|        return _UnionGenericAlias(self, parameters, name="Optional")
   729|         0|            0|            0|  0.00%|    return _UnionGenericAlias(self, parameters)
   730|         0|            0|            0|  0.00%|
   731|         0|            0|            0|  0.00%|def _make_union(left, right):
   732|         0|            0|            0|  0.00%|    """Used from the C implementation of TypeVar.
   733|         0|            0|            0|  0.00%|
   734|         0|            0|            0|  0.00%|    TypeVar.__or__ calls this instead of returning types.UnionType
   735|         0|            0|            0|  0.00%|    because we want to allow unions between TypeVars and strings
   736|         0|            0|            0|  0.00%|    (forward references).
   737|         0|            0|            0|  0.00%|    """
   738|         0|            0|            0|  0.00%|    return Union[left, right]
   739|         0|            0|            0|  0.00%|
   740|         0|            0|            0|  0.00%|@_SpecialForm
   741|         0|            0|            0|  0.00%|def Optional(self, parameters):
   742|         0|            0|            0|  0.00%|    """Optional[X] is equivalent to Union[X, None]."""
   743|         0|            0|            0|  0.00%|    arg = _type_check(parameters, f"{self} requires a single type.")
   744|         0|            0|            0|  0.00%|    return Union[arg, type(None)]
   745|         0|            0|            0|  0.00%|
   746|         0|            0|            0|  0.00%|@_LiteralSpecialForm
   747|         0|            0|            0|  0.00%|@_tp_cache(typed=True)
   748|         0|            0|            0|  0.00%|def Literal(self, *parameters):
   749|         0|            0|            0|  0.00%|    """Special typing form to define literal types (a.k.a. value types).
   750|         0|            0|            0|  0.00%|
   751|         0|            0|            0|  0.00%|    This form can be used to indicate to type checkers that the corresponding
   752|         0|            0|            0|  0.00%|    variable or function parameter has a value equivalent to the provided
   753|         0|            0|            0|  0.00%|    literal (or one of several literals)::
   754|         0|            0|            0|  0.00%|
   755|         0|            0|            0|  0.00%|        def validate_simple(data: Any) -> Literal[True]:  # always returns True
   756|         0|            0|            0|  0.00%|            ...
   757|         0|            0|            0|  0.00%|
   758|         0|            0|            0|  0.00%|        MODE = Literal['r', 'rb', 'w', 'wb']
   759|         0|            0|            0|  0.00%|        def open_helper(file: str, mode: MODE) -> str:
   760|         0|            0|            0|  0.00%|            ...
   761|         0|            0|            0|  0.00%|
   762|         0|            0|            0|  0.00%|        open_helper('/some/path', 'r')  # Passes type check
   763|         0|            0|            0|  0.00%|        open_helper('/other/path', 'typo')  # Error in type checker
   764|         0|            0|            0|  0.00%|
   765|         0|            0|            0|  0.00%|    Literal[...] cannot be subclassed. At runtime, an arbitrary value
   766|         0|            0|            0|  0.00%|    is allowed as type argument to Literal[...], but type checkers may
   767|         0|            0|            0|  0.00%|    impose restrictions.
   768|         0|            0|            0|  0.00%|    """
   769|         0|            0|            0|  0.00%|    # There is no '_type_check' call because arguments to Literal[...] are
   770|         0|            0|            0|  0.00%|    # values, not types.
   771|         0|            0|            0|  0.00%|    parameters = _flatten_literal_params(parameters)
   772|         0|            0|            0|  0.00%|
   773|         0|            0|            0|  0.00%|    try:
   774|         0|            0|            0|  0.00%|        parameters = tuple(p for p, _ in _deduplicate(list(_value_and_type_iter(parameters))))
   775|         0|            0|            0|  0.00%|    except TypeError:  # unhashable parameters
   776|         0|            0|            0|  0.00%|        pass
   777|         0|            0|            0|  0.00%|
   778|         0|            0|            0|  0.00%|    return _LiteralGenericAlias(self, parameters)
   779|         0|            0|            0|  0.00%|
   780|         0|            0|            0|  0.00%|
   781|         0|            0|            0|  0.00%|@_SpecialForm
   782|         0|            0|            0|  0.00%|def TypeAlias(self, parameters):
   783|         0|            0|            0|  0.00%|    """Special form for marking type aliases.
   784|         0|            0|            0|  0.00%|
   785|         0|            0|            0|  0.00%|    Use TypeAlias to indicate that an assignment should
   786|         0|            0|            0|  0.00%|    be recognized as a proper type alias definition by type
   787|         0|            0|            0|  0.00%|    checkers.
   788|         0|            0|            0|  0.00%|
   789|         0|            0|            0|  0.00%|    For example::
   790|         0|            0|            0|  0.00%|
   791|         0|            0|            0|  0.00%|        Predicate: TypeAlias = Callable[..., bool]
   792|         0|            0|            0|  0.00%|
   793|         0|            0|            0|  0.00%|    It's invalid when used anywhere except as in the example above.
   794|         0|            0|            0|  0.00%|    """
   795|         0|            0|            0|  0.00%|    raise TypeError(f"{self} is not subscriptable")
   796|         0|            0|            0|  0.00%|
   797|         0|            0|            0|  0.00%|
   798|         0|            0|            0|  0.00%|@_SpecialForm
   799|         0|            0|            0|  0.00%|def Concatenate(self, parameters):
   800|         0|            0|            0|  0.00%|    """Special form for annotating higher-order functions.
   801|         0|            0|            0|  0.00%|
   802|         0|            0|            0|  0.00%|    ``Concatenate`` can be used in conjunction with ``ParamSpec`` and
   803|         0|            0|            0|  0.00%|    ``Callable`` to represent a higher-order function which adds, removes or
   804|         0|            0|            0|  0.00%|    transforms the parameters of a callable.
   805|         0|            0|            0|  0.00%|
   806|         0|            0|            0|  0.00%|    For example::
   807|         0|            0|            0|  0.00%|
   808|         0|            0|            0|  0.00%|        Callable[Concatenate[int, P], int]
   809|         0|            0|            0|  0.00%|
   810|         0|            0|            0|  0.00%|    See PEP 612 for detailed information.
   811|         0|            0|            0|  0.00%|    """
   812|         0|            0|            0|  0.00%|    if parameters == ():
   813|         0|            0|            0|  0.00%|        raise TypeError("Cannot take a Concatenate of no types.")
   814|         0|            0|            0|  0.00%|    if not isinstance(parameters, tuple):
   815|         0|            0|            0|  0.00%|        parameters = (parameters,)
   816|         0|            0|            0|  0.00%|    if not (parameters[-1] is ... or isinstance(parameters[-1], ParamSpec)):
   817|         0|            0|            0|  0.00%|        raise TypeError("The last parameter to Concatenate should be a "
   818|         0|            0|            0|  0.00%|                        "ParamSpec variable or ellipsis.")
   819|         0|            0|            0|  0.00%|    msg = "Concatenate[arg, ...]: each arg must be a type."
   820|         0|            0|            0|  0.00%|    parameters = (*(_type_check(p, msg) for p in parameters[:-1]), parameters[-1])
   821|         0|            0|            0|  0.00%|    return _ConcatenateGenericAlias(self, parameters)
   822|         0|            0|            0|  0.00%|
   823|         0|            0|            0|  0.00%|
   824|         0|            0|            0|  0.00%|@_SpecialForm
   825|         0|            0|            0|  0.00%|def TypeGuard(self, parameters):
   826|         0|            0|            0|  0.00%|    """Special typing construct for marking user-defined type guard functions.
   827|         0|            0|            0|  0.00%|
   828|         0|            0|            0|  0.00%|    ``TypeGuard`` can be used to annotate the return type of a user-defined
   829|         0|            0|            0|  0.00%|    type guard function.  ``TypeGuard`` only accepts a single type argument.
   830|         0|            0|            0|  0.00%|    At runtime, functions marked this way should return a boolean.
   831|         0|            0|            0|  0.00%|
   832|         0|            0|            0|  0.00%|    ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static
   833|         0|            0|            0|  0.00%|    type checkers to determine a more precise type of an expression within a
   834|         0|            0|            0|  0.00%|    program's code flow.  Usually type narrowing is done by analyzing
   835|         0|            0|            0|  0.00%|    conditional code flow and applying the narrowing to a block of code.  The
   836|         0|            0|            0|  0.00%|    conditional expression here is sometimes referred to as a "type guard".
   837|         0|            0|            0|  0.00%|
   838|         0|            0|            0|  0.00%|    Sometimes it would be convenient to use a user-defined boolean function
   839|         0|            0|            0|  0.00%|    as a type guard.  Such a function should use ``TypeGuard[...]`` as its
   840|         0|            0|            0|  0.00%|    return type to alert static type checkers to this intention.
   841|         0|            0|            0|  0.00%|
   842|         0|            0|            0|  0.00%|    Using  ``-> TypeGuard`` tells the static type checker that for a given
   843|         0|            0|            0|  0.00%|    function:
   844|         0|            0|            0|  0.00%|
   845|         0|            0|            0|  0.00%|    1. The return value is a boolean.
   846|         0|            0|            0|  0.00%|    2. If the return value is ``True``, the type of its argument
   847|         0|            0|            0|  0.00%|       is the type inside ``TypeGuard``.
   848|         0|            0|            0|  0.00%|
   849|         0|            0|            0|  0.00%|    For example::
   850|         0|            0|            0|  0.00%|
   851|         0|            0|            0|  0.00%|         def is_str_list(val: list[object]) -> TypeGuard[list[str]]:
   852|         0|            0|            0|  0.00%|             '''Determines whether all objects in the list are strings'''
   853|         0|            0|            0|  0.00%|             return all(isinstance(x, str) for x in val)
   854|         0|            0|            0|  0.00%|
   855|         0|            0|            0|  0.00%|         def func1(val: list[object]):
   856|         0|            0|            0|  0.00%|             if is_str_list(val):
   857|         0|            0|            0|  0.00%|                 # Type of ``val`` is narrowed to ``list[str]``.
   858|         0|            0|            0|  0.00%|                 print(" ".join(val))
   859|         0|            0|            0|  0.00%|             else:
   860|         0|            0|            0|  0.00%|                 # Type of ``val`` remains as ``list[object]``.
   861|         0|            0|            0|  0.00%|                 print("Not a list of strings!")
   862|         0|            0|            0|  0.00%|
   863|         0|            0|            0|  0.00%|    Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower
   864|         0|            0|            0|  0.00%|    form of ``TypeA`` (it can even be a wider form) and this may lead to
   865|         0|            0|            0|  0.00%|    type-unsafe results.  The main reason is to allow for things like
   866|         0|            0|            0|  0.00%|    narrowing ``list[object]`` to ``list[str]`` even though the latter is not
   867|         0|            0|            0|  0.00%|    a subtype of the former, since ``list`` is invariant.  The responsibility of
   868|         0|            0|            0|  0.00%|    writing type-safe type guards is left to the user.
   869|         0|            0|            0|  0.00%|
   870|         0|            0|            0|  0.00%|    ``TypeGuard`` also works with type variables.  For more information, see
   871|         0|            0|            0|  0.00%|    PEP 647 (User-Defined Type Guards).
   872|         0|            0|            0|  0.00%|    """
   873|         0|            0|            0|  0.00%|    item = _type_check(parameters, f'{self} accepts only single type.')
   874|         0|            0|            0|  0.00%|    return _GenericAlias(self, (item,))
   875|         0|            0|            0|  0.00%|
   876|         0|            0|            0|  0.00%|
   877|         0|            0|            0|  0.00%|class ForwardRef(_Final, _root=True):
   878|         0|            0|            0|  0.00%|    """Internal wrapper to hold a forward reference."""
   879|         0|            0|            0|  0.00%|
   880|         0|            0|            0|  0.00%|    __slots__ = ('__forward_arg__', '__forward_code__',
   881|         0|            0|            0|  0.00%|                 '__forward_evaluated__', '__forward_value__',
   882|         0|            0|            0|  0.00%|                 '__forward_is_argument__', '__forward_is_class__',
   883|         0|            0|            0|  0.00%|                 '__forward_module__')
   884|         0|            0|            0|  0.00%|
   885|         0|            0|            0|  0.00%|    def __init__(self, arg, is_argument=True, module=None, *, is_class=False):
   886|         0|            0|            0|  0.00%|        if not isinstance(arg, str):
   887|         0|            0|            0|  0.00%|            raise TypeError(f"Forward reference must be a string -- got {arg!r}")
   888|         0|            0|            0|  0.00%|
   889|         0|            0|            0|  0.00%|        # If we do `def f(*args: *Ts)`, then we'll have `arg = '*Ts'`.
   890|         0|            0|            0|  0.00%|        # Unfortunately, this isn't a valid expression on its own, so we
   891|         0|            0|            0|  0.00%|        # do the unpacking manually.
   892|         0|            0|            0|  0.00%|        if arg.startswith('*'):
   893|         0|            0|            0|  0.00%|            arg_to_compile = f'({arg},)[0]'  # E.g. (*Ts,)[0] or (*tuple[int, int],)[0]
   894|         0|            0|            0|  0.00%|        else:
   895|         0|            0|            0|  0.00%|            arg_to_compile = arg
   896|         0|            0|            0|  0.00%|        try:
   897|         0|            0|            0|  0.00%|            code = compile(arg_to_compile, '<string>', 'eval')
   898|         0|            0|            0|  0.00%|        except SyntaxError:
   899|         0|            0|            0|  0.00%|            raise SyntaxError(f"Forward reference must be an expression -- got {arg!r}")
   900|         0|            0|            0|  0.00%|
   901|         0|            0|            0|  0.00%|        self.__forward_arg__ = arg
   902|         0|            0|            0|  0.00%|        self.__forward_code__ = code
   903|         0|            0|            0|  0.00%|        self.__forward_evaluated__ = False
   904|         0|            0|            0|  0.00%|        self.__forward_value__ = None
   905|         0|            0|            0|  0.00%|        self.__forward_is_argument__ = is_argument
   906|         0|            0|            0|  0.00%|        self.__forward_is_class__ = is_class
   907|         0|            0|            0|  0.00%|        self.__forward_module__ = module
   908|         0|            0|            0|  0.00%|
   909|         0|            0|            0|  0.00%|    def _evaluate(self, globalns, localns, recursive_guard):
   910|         0|            0|            0|  0.00%|        if self.__forward_arg__ in recursive_guard:
   911|         0|            0|            0|  0.00%|            return self
   912|         0|            0|            0|  0.00%|        if not self.__forward_evaluated__ or localns is not globalns:
   913|         0|            0|            0|  0.00%|            if globalns is None and localns is None:
   914|         0|            0|            0|  0.00%|                globalns = localns = {}
   915|         0|            0|            0|  0.00%|            elif globalns is None:
   916|         0|            0|            0|  0.00%|                globalns = localns
   917|         0|            0|            0|  0.00%|            elif localns is None:
   918|         0|            0|            0|  0.00%|                localns = globalns
   919|         0|            0|            0|  0.00%|            if self.__forward_module__ is not None:
   920|         0|            0|            0|  0.00%|                globalns = getattr(
   921|         0|            0|            0|  0.00%|                    sys.modules.get(self.__forward_module__, None), '__dict__', globalns
   922|         0|            0|            0|  0.00%|                )
   923|         0|            0|            0|  0.00%|            type_ = _type_check(
   924|         0|            0|            0|  0.00%|                eval(self.__forward_code__, globalns, localns),
   925|         0|            0|            0|  0.00%|                "Forward references must evaluate to types.",
   926|         0|            0|            0|  0.00%|                is_argument=self.__forward_is_argument__,
   927|         0|            0|            0|  0.00%|                allow_special_forms=self.__forward_is_class__,
   928|         0|            0|            0|  0.00%|            )
   929|         0|            0|            0|  0.00%|            self.__forward_value__ = _eval_type(
   930|         0|            0|            0|  0.00%|                type_, globalns, localns, recursive_guard | {self.__forward_arg__}
   931|         0|            0|            0|  0.00%|            )
   932|         0|            0|            0|  0.00%|            self.__forward_evaluated__ = True
   933|         0|            0|            0|  0.00%|        return self.__forward_value__
   934|         0|            0|            0|  0.00%|
   935|         0|            0|            0|  0.00%|    def __eq__(self, other):
   936|         0|            0|            0|  0.00%|        if not isinstance(other, ForwardRef):
   937|         0|            0|            0|  0.00%|            return NotImplemented
   938|         0|            0|            0|  0.00%|        if self.__forward_evaluated__ and other.__forward_evaluated__:
   939|         0|            0|            0|  0.00%|            return (self.__forward_arg__ == other.__forward_arg__ and
   940|         0|            0|            0|  0.00%|                    self.__forward_value__ == other.__forward_value__)
   941|         0|            0|            0|  0.00%|        return (self.__forward_arg__ == other.__forward_arg__ and
   942|         0|            0|            0|  0.00%|                self.__forward_module__ == other.__forward_module__)
   943|         0|            0|            0|  0.00%|
   944|         0|            0|            0|  0.00%|    def __hash__(self):
   945|         0|            0|            0|  0.00%|        return hash((self.__forward_arg__, self.__forward_module__))
   946|         0|            0|            0|  0.00%|
   947|         0|            0|            0|  0.00%|    def __or__(self, other):
   948|         0|            0|            0|  0.00%|        return Union[self, other]
   949|         0|            0|            0|  0.00%|
   950|         0|            0|            0|  0.00%|    def __ror__(self, other):
   951|         0|            0|            0|  0.00%|        return Union[other, self]
   952|         0|            0|            0|  0.00%|
   953|         0|            0|            0|  0.00%|    def __repr__(self):
   954|         0|            0|            0|  0.00%|        if self.__forward_module__ is None:
   955|         0|            0|            0|  0.00%|            module_repr = ''
   956|         0|            0|            0|  0.00%|        else:
   957|         0|            0|            0|  0.00%|            module_repr = f', module={self.__forward_module__!r}'
   958|         0|            0|            0|  0.00%|        return f'ForwardRef({self.__forward_arg__!r}{module_repr})'
   959|         0|            0|            0|  0.00%|
   960|         0|            0|            0|  0.00%|
   961|         2|  3.57628e-06|  1.78814e-06|  0.00%|def _is_unpacked_typevartuple(x: Any) -> bool:
   962|         2|  4.52995e-06|  2.26498e-06|  0.00%|    return ((not isinstance(x, type)) and
   963|         0|            0|            0|  0.00%|            getattr(x, '__typing_is_unpacked_typevartuple__', False))
   964|         0|            0|            0|  0.00%|
   965|         0|            0|            0|  0.00%|
   966|         0|            0|            0|  0.00%|def _is_typevar_like(x: Any) -> bool:
   967|         0|            0|            0|  0.00%|    return isinstance(x, (TypeVar, ParamSpec)) or _is_unpacked_typevartuple(x)
   968|         0|            0|            0|  0.00%|
   969|         0|            0|            0|  0.00%|
   970|         0|            0|            0|  0.00%|class _PickleUsingNameMixin:
   971|         0|            0|            0|  0.00%|    """Mixin enabling pickling based on self.__name__."""
   972|         0|            0|            0|  0.00%|
   973|         0|            0|            0|  0.00%|    def __reduce__(self):
   974|         0|            0|            0|  0.00%|        return self.__name__
   975|         0|            0|            0|  0.00%|
   976|         0|            0|            0|  0.00%|
   977|         0|            0|            0|  0.00%|def _typevar_subst(self, arg):
   978|         0|            0|            0|  0.00%|    msg = "Parameters to generic types must be types."
   979|         0|            0|            0|  0.00%|    arg = _type_check(arg, msg, is_argument=True)
   980|         0|            0|            0|  0.00%|    if ((isinstance(arg, _GenericAlias) and arg.__origin__ is Unpack) or
   981|         0|            0|            0|  0.00%|        (isinstance(arg, GenericAlias) and getattr(arg, '__unpacked__', False))):
   982|         0|            0|            0|  0.00%|        raise TypeError(f"{arg} is not valid as type argument")
   983|         0|            0|            0|  0.00%|    return arg
   984|         0|            0|            0|  0.00%|
   985|         0|            0|            0|  0.00%|
   986|         0|            0|            0|  0.00%|def _typevartuple_prepare_subst(self, alias, args):
   987|         0|            0|            0|  0.00%|    params = alias.__parameters__
   988|         0|            0|            0|  0.00%|    typevartuple_index = params.index(self)
   989|         0|            0|            0|  0.00%|    for param in params[typevartuple_index + 1:]:
   990|         0|            0|            0|  0.00%|        if isinstance(param, TypeVarTuple):
   991|         0|            0|            0|  0.00%|            raise TypeError(f"More than one TypeVarTuple parameter in {alias}")
   992|         0|            0|            0|  0.00%|
   993|         0|            0|            0|  0.00%|    alen = len(args)
   994|         0|            0|            0|  0.00%|    plen = len(params)
   995|         0|            0|            0|  0.00%|    left = typevartuple_index
   996|         0|            0|            0|  0.00%|    right = plen - typevartuple_index - 1
   997|         0|            0|            0|  0.00%|    var_tuple_index = None
   998|         0|            0|            0|  0.00%|    fillarg = None
   999|         0|            0|            0|  0.00%|    for k, arg in enumerate(args):
  1000|         0|            0|            0|  0.00%|        if not isinstance(arg, type):
  1001|         0|            0|            0|  0.00%|            subargs = getattr(arg, '__typing_unpacked_tuple_args__', None)
  1002|         0|            0|            0|  0.00%|            if subargs and len(subargs) == 2 and subargs[-1] is ...:
  1003|         0|            0|            0|  0.00%|                if var_tuple_index is not None:
  1004|         0|            0|            0|  0.00%|                    raise TypeError("More than one unpacked arbitrary-length tuple argument")
  1005|         0|            0|            0|  0.00%|                var_tuple_index = k
  1006|         0|            0|            0|  0.00%|                fillarg = subargs[0]
  1007|         0|            0|            0|  0.00%|    if var_tuple_index is not None:
  1008|         0|            0|            0|  0.00%|        left = min(left, var_tuple_index)
  1009|         0|            0|            0|  0.00%|        right = min(right, alen - var_tuple_index - 1)
  1010|         0|            0|            0|  0.00%|    elif left + right > alen:
  1011|         0|            0|            0|  0.00%|        raise TypeError(f"Too few arguments for {alias};"
  1012|         0|            0|            0|  0.00%|                        f" actual {alen}, expected at least {plen-1}")
  1013|         0|            0|            0|  0.00%|
  1014|         0|            0|            0|  0.00%|    return (
  1015|         0|            0|            0|  0.00%|        *args[:left],
  1016|         0|            0|            0|  0.00%|        *([fillarg]*(typevartuple_index - left)),
  1017|         0|            0|            0|  0.00%|        tuple(args[left: alen - right]),
  1018|         0|            0|            0|  0.00%|        *([fillarg]*(plen - right - left - typevartuple_index - 1)),
  1019|         0|            0|            0|  0.00%|        *args[alen - right:],
  1020|         0|            0|            0|  0.00%|    )
  1021|         0|            0|            0|  0.00%|
  1022|         0|            0|            0|  0.00%|
  1023|         0|            0|            0|  0.00%|def _paramspec_subst(self, arg):
  1024|         0|            0|            0|  0.00%|    if isinstance(arg, (list, tuple)):
  1025|         0|            0|            0|  0.00%|        arg = tuple(_type_check(a, "Expected a type.") for a in arg)
  1026|         0|            0|            0|  0.00%|    elif not _is_param_expr(arg):
  1027|         0|            0|            0|  0.00%|        raise TypeError(f"Expected a list of types, an ellipsis, "
  1028|         0|            0|            0|  0.00%|                        f"ParamSpec, or Concatenate. Got {arg}")
  1029|         0|            0|            0|  0.00%|    return arg
  1030|         0|            0|            0|  0.00%|
  1031|         0|            0|            0|  0.00%|
  1032|         0|            0|            0|  0.00%|def _paramspec_prepare_subst(self, alias, args):
  1033|         0|            0|            0|  0.00%|    params = alias.__parameters__
  1034|         0|            0|            0|  0.00%|    i = params.index(self)
  1035|         0|            0|            0|  0.00%|    if i >= len(args):
  1036|         0|            0|            0|  0.00%|        raise TypeError(f"Too few arguments for {alias}")
  1037|         0|            0|            0|  0.00%|    # Special case where Z[[int, str, bool]] == Z[int, str, bool] in PEP 612.
  1038|         0|            0|            0|  0.00%|    if len(params) == 1 and not _is_param_expr(args[0]):
  1039|         0|            0|            0|  0.00%|        assert i == 0
  1040|         0|            0|            0|  0.00%|        args = (args,)
  1041|         0|            0|            0|  0.00%|    # Convert lists to tuples to help other libraries cache the results.
  1042|         0|            0|            0|  0.00%|    elif isinstance(args[i], list):
  1043|         0|            0|            0|  0.00%|        args = (*args[:i], tuple(args[i]), *args[i+1:])
  1044|         0|            0|            0|  0.00%|    return args
  1045|         0|            0|            0|  0.00%|
  1046|         0|            0|            0|  0.00%|
  1047|         0|            0|            0|  0.00%|@_tp_cache
  1048|         0|            0|            0|  0.00%|def _generic_class_getitem(cls, params):
  1049|         0|            0|            0|  0.00%|    """Parameterizes a generic class.
  1050|         0|            0|            0|  0.00%|
  1051|         0|            0|            0|  0.00%|    At least, parameterizing a generic class is the *main* thing this method
  1052|         0|            0|            0|  0.00%|    does. For example, for some generic class `Foo`, this is called when we
  1053|         0|            0|            0|  0.00%|    do `Foo[int]` - there, with `cls=Foo` and `params=int`.
  1054|         0|            0|            0|  0.00%|
  1055|         0|            0|            0|  0.00%|    However, note that this method is also called when defining generic
  1056|         0|            0|            0|  0.00%|    classes in the first place with `class Foo(Generic[T]): ...`.
  1057|         0|            0|            0|  0.00%|    """
  1058|         0|            0|            0|  0.00%|    if not isinstance(params, tuple):
  1059|         0|            0|            0|  0.00%|        params = (params,)
  1060|         0|            0|            0|  0.00%|
  1061|         0|            0|            0|  0.00%|    params = tuple(_type_convert(p) for p in params)
  1062|         0|            0|            0|  0.00%|    is_generic_or_protocol = cls in (Generic, Protocol)
  1063|         0|            0|            0|  0.00%|
  1064|         0|            0|            0|  0.00%|    if is_generic_or_protocol:
  1065|         0|            0|            0|  0.00%|        # Generic and Protocol can only be subscripted with unique type variables.
  1066|         0|            0|            0|  0.00%|        if not params:
  1067|         0|            0|            0|  0.00%|            raise TypeError(
  1068|         0|            0|            0|  0.00%|                f"Parameter list to {cls.__qualname__}[...] cannot be empty"
  1069|         0|            0|            0|  0.00%|            )
  1070|         0|            0|            0|  0.00%|        if not all(_is_typevar_like(p) for p in params):
  1071|         0|            0|            0|  0.00%|            raise TypeError(
  1072|         0|            0|            0|  0.00%|                f"Parameters to {cls.__name__}[...] must all be type variables "
  1073|         0|            0|            0|  0.00%|                f"or parameter specification variables.")
  1074|         0|            0|            0|  0.00%|        if len(set(params)) != len(params):
  1075|         0|            0|            0|  0.00%|            raise TypeError(
  1076|         0|            0|            0|  0.00%|                f"Parameters to {cls.__name__}[...] must all be unique")
  1077|         0|            0|            0|  0.00%|    else:
  1078|         0|            0|            0|  0.00%|        # Subscripting a regular Generic subclass.
  1079|         0|            0|            0|  0.00%|        for param in cls.__parameters__:
  1080|         0|            0|            0|  0.00%|            prepare = getattr(param, '__typing_prepare_subst__', None)
  1081|         0|            0|            0|  0.00%|            if prepare is not None:
  1082|         0|            0|            0|  0.00%|                params = prepare(cls, params)
  1083|         0|            0|            0|  0.00%|        _check_generic(cls, params, len(cls.__parameters__))
  1084|         0|            0|            0|  0.00%|
  1085|         0|            0|            0|  0.00%|        new_args = []
  1086|         0|            0|            0|  0.00%|        for param, new_arg in zip(cls.__parameters__, params):
  1087|         0|            0|            0|  0.00%|            if isinstance(param, TypeVarTuple):
  1088|         0|            0|            0|  0.00%|                new_args.extend(new_arg)
  1089|         0|            0|            0|  0.00%|            else:
  1090|         0|            0|            0|  0.00%|                new_args.append(new_arg)
  1091|         0|            0|            0|  0.00%|        params = tuple(new_args)
  1092|         0|            0|            0|  0.00%|
  1093|         0|            0|            0|  0.00%|    return _GenericAlias(cls, params)
  1094|         0|            0|            0|  0.00%|
  1095|         0|            0|            0|  0.00%|
  1096|         0|            0|            0|  0.00%|def _generic_init_subclass(cls, *args, **kwargs):
  1097|         0|            0|            0|  0.00%|    super(Generic, cls).__init_subclass__(*args, **kwargs)
  1098|         0|            0|            0|  0.00%|    tvars = []
  1099|         0|            0|            0|  0.00%|    if '__orig_bases__' in cls.__dict__:
  1100|         0|            0|            0|  0.00%|        error = Generic in cls.__orig_bases__
  1101|         0|            0|            0|  0.00%|    else:
  1102|         0|            0|            0|  0.00%|        error = (Generic in cls.__bases__ and
  1103|         0|            0|            0|  0.00%|                    cls.__name__ != 'Protocol' and
  1104|         0|            0|            0|  0.00%|                    type(cls) != _TypedDictMeta)
  1105|         0|            0|            0|  0.00%|    if error:
  1106|         0|            0|            0|  0.00%|        raise TypeError("Cannot inherit from plain Generic")
  1107|         0|            0|            0|  0.00%|    if '__orig_bases__' in cls.__dict__:
  1108|         0|            0|            0|  0.00%|        tvars = _collect_parameters(cls.__orig_bases__)
  1109|         0|            0|            0|  0.00%|        # Look for Generic[T1, ..., Tn].
  1110|         0|            0|            0|  0.00%|        # If found, tvars must be a subset of it.
  1111|         0|            0|            0|  0.00%|        # If not found, tvars is it.
  1112|         0|            0|            0|  0.00%|        # Also check for and reject plain Generic,
  1113|         0|            0|            0|  0.00%|        # and reject multiple Generic[...].
  1114|         0|            0|            0|  0.00%|        gvars = None
  1115|         0|            0|            0|  0.00%|        for base in cls.__orig_bases__:
  1116|         0|            0|            0|  0.00%|            if (isinstance(base, _GenericAlias) and
  1117|         0|            0|            0|  0.00%|                    base.__origin__ is Generic):
  1118|         0|            0|            0|  0.00%|                if gvars is not None:
  1119|         0|            0|            0|  0.00%|                    raise TypeError(
  1120|         0|            0|            0|  0.00%|                        "Cannot inherit from Generic[...] multiple times.")
  1121|         0|            0|            0|  0.00%|                gvars = base.__parameters__
  1122|         0|            0|            0|  0.00%|        if gvars is not None:
  1123|         0|            0|            0|  0.00%|            tvarset = set(tvars)
  1124|         0|            0|            0|  0.00%|            gvarset = set(gvars)
  1125|         0|            0|            0|  0.00%|            if not tvarset <= gvarset:
  1126|         0|            0|            0|  0.00%|                s_vars = ', '.join(str(t) for t in tvars if t not in gvarset)
  1127|         0|            0|            0|  0.00%|                s_args = ', '.join(str(g) for g in gvars)
  1128|         0|            0|            0|  0.00%|                raise TypeError(f"Some type variables ({s_vars}) are"
  1129|         0|            0|            0|  0.00%|                                f" not listed in Generic[{s_args}]")
  1130|         0|            0|            0|  0.00%|            tvars = gvars
  1131|         0|            0|            0|  0.00%|    cls.__parameters__ = tuple(tvars)
  1132|         0|            0|            0|  0.00%|
  1133|         0|            0|            0|  0.00%|
  1134|        26|  4.05312e-05|  1.55889e-06|  0.04%|def _is_dunder(attr):
  1135|        26|    5.126e-05|  1.97154e-06|  0.05%|    return attr.startswith('__') and attr.endswith('__')
  1136|         0|            0|            0|  0.00%|
  1137|         0|            0|            0|  0.00%|class _BaseGenericAlias(_Final, _root=True):
  1138|         0|            0|            0|  0.00%|    """The central part of the internal API.
  1139|         0|            0|            0|  0.00%|
  1140|         0|            0|            0|  0.00%|    This represents a generic version of type 'origin' with type arguments 'params'.
  1141|         0|            0|            0|  0.00%|    There are two kind of these aliases: user defined and special. The special ones
  1142|         0|            0|            0|  0.00%|    are wrappers around builtin collections and ABCs in collections.abc. These must
  1143|         0|            0|            0|  0.00%|    have 'name' always set. If 'inst' is False, then the alias can't be instantiated;
  1144|         0|            0|            0|  0.00%|    this is used by e.g. typing.List and typing.Dict.
  1145|         0|            0|            0|  0.00%|    """
  1146|         0|            0|            0|  0.00%|
  1147|         2|  4.29153e-06|  2.14577e-06|  0.00%|    def __init__(self, origin, *, inst=True, name=None):
  1148|         2|   1.5974e-05|  7.98702e-06|  0.02%|        self._inst = inst
(call)|         2|  4.57764e-05|  2.28882e-05|  0.05%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:1188 __setattr__
  1149|         2|  9.77516e-06|  4.88758e-06|  0.01%|        self._name = name
(call)|         2|  1.85966e-05|  9.29832e-06|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:1188 __setattr__
  1150|         2|  8.82149e-06|  4.41074e-06|  0.01%|        self.__origin__ = origin
(call)|         2|  1.88351e-05|  9.41753e-06|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:1188 __setattr__
  1151|         2|  9.05991e-06|  4.52995e-06|  0.01%|        self.__slots__ = None  # This is not documented.
(call)|         2|  1.62125e-05|  8.10623e-06|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:1188 __setattr__
  1152|         0|            0|            0|  0.00%|
  1153|         0|            0|            0|  0.00%|    def __call__(self, *args, **kwargs):
  1154|         0|            0|            0|  0.00%|        if not self._inst:
  1155|         0|            0|            0|  0.00%|            raise TypeError(f"Type {self._name} cannot be instantiated; "
  1156|         0|            0|            0|  0.00%|                            f"use {self.__origin__.__name__}() instead")
  1157|         0|            0|            0|  0.00%|        result = self.__origin__(*args, **kwargs)
  1158|         0|            0|            0|  0.00%|        try:
  1159|         0|            0|            0|  0.00%|            result.__orig_class__ = self
  1160|         0|            0|            0|  0.00%|        # Some objects raise TypeError (or something even more exotic)
  1161|         0|            0|            0|  0.00%|        # if you try to set attributes on them; we guard against that here
  1162|         0|            0|            0|  0.00%|        except Exception:
  1163|         0|            0|            0|  0.00%|            pass
  1164|         0|            0|            0|  0.00%|        return result
  1165|         0|            0|            0|  0.00%|
  1166|         0|            0|            0|  0.00%|    def __mro_entries__(self, bases):
  1167|         0|            0|            0|  0.00%|        res = []
  1168|         0|            0|            0|  0.00%|        if self.__origin__ not in bases:
  1169|         0|            0|            0|  0.00%|            res.append(self.__origin__)
  1170|         0|            0|            0|  0.00%|        i = bases.index(self)
  1171|         0|            0|            0|  0.00%|        for b in bases[i+1:]:
  1172|         0|            0|            0|  0.00%|            if isinstance(b, _BaseGenericAlias) or issubclass(b, Generic):
  1173|         0|            0|            0|  0.00%|                break
  1174|         0|            0|            0|  0.00%|        else:
  1175|         0|            0|            0|  0.00%|            res.append(Generic)
  1176|         0|            0|            0|  0.00%|        return tuple(res)
  1177|         0|            0|            0|  0.00%|
  1178|        12|  2.07424e-05|  1.72853e-06|  0.02%|    def __getattr__(self, attr):
  1179|        12|  2.00272e-05|  1.66893e-06|  0.02%|        if attr in {'__name__', '__qualname__'}:
  1180|         0|            0|            0|  0.00%|            return self._name or self.__origin__.__name__
  1181|         0|            0|            0|  0.00%|
  1182|         0|            0|            0|  0.00%|        # We are careful for copy and pickle.
  1183|         0|            0|            0|  0.00%|        # Also for simplicity we don't relay any dunder names
  1184|        12|  7.10487e-05|  5.92073e-06|  0.07%|        if '__origin__' in self.__dict__ and not _is_dunder(attr):
(call)|        12|  4.79221e-05|  3.99351e-06|  0.05%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:1134 _is_dunder
  1185|         0|            0|            0|  0.00%|            return getattr(self.__origin__, attr)
  1186|        12|  3.12328e-05|  2.60274e-06|  0.03%|        raise AttributeError(attr)
  1187|         0|            0|            0|  0.00%|
  1188|        14|  2.19345e-05|  1.56675e-06|  0.02%|    def __setattr__(self, attr, val):
  1189|        14|  6.29425e-05|  4.49589e-06|  0.06%|        if _is_dunder(attr) or attr in {'_name', '_inst', '_nparams'}:
(call)|        14|   4.3869e-05|   3.1335e-06|  0.05%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:1134 _is_dunder
  1190|        14|  2.98023e-05|  2.12874e-06|  0.03%|            super().__setattr__(attr, val)
  1191|         0|            0|            0|  0.00%|        else:
  1192|         0|            0|            0|  0.00%|            setattr(self.__origin__, attr, val)
  1193|         0|            0|            0|  0.00%|
  1194|         0|            0|            0|  0.00%|    def __instancecheck__(self, obj):
  1195|         0|            0|            0|  0.00%|        return self.__subclasscheck__(type(obj))
  1196|         0|            0|            0|  0.00%|
  1197|         0|            0|            0|  0.00%|    def __subclasscheck__(self, cls):
  1198|         0|            0|            0|  0.00%|        raise TypeError("Subscripted generics cannot be used with"
  1199|         0|            0|            0|  0.00%|                        " class and instance checks")
  1200|         0|            0|            0|  0.00%|
  1201|         0|            0|            0|  0.00%|    def __dir__(self):
  1202|         0|            0|            0|  0.00%|        return list(set(super().__dir__()
  1203|         0|            0|            0|  0.00%|                + [attr for attr in dir(self.__origin__) if not _is_dunder(attr)]))
  1204|         0|            0|            0|  0.00%|
  1205|         0|            0|            0|  0.00%|
  1206|         0|            0|            0|  0.00%|# Special typing constructs Union, Optional, Generic, Callable and Tuple
  1207|         0|            0|            0|  0.00%|# use three special attributes for internal bookkeeping of generic types:
  1208|         0|            0|            0|  0.00%|# * __parameters__ is a tuple of unique free type parameters of a generic
  1209|         0|            0|            0|  0.00%|#   type, for example, Dict[T, T].__parameters__ == (T,);
  1210|         0|            0|            0|  0.00%|# * __origin__ keeps a reference to a type that was subscripted,
  1211|         0|            0|            0|  0.00%|#   e.g., Union[T, int].__origin__ == Union, or the non-generic version of
  1212|         0|            0|            0|  0.00%|#   the type.
  1213|         0|            0|            0|  0.00%|# * __args__ is a tuple of all arguments used in subscripting,
  1214|         0|            0|            0|  0.00%|#   e.g., Dict[T, int].__args__ == (T, int).
  1215|         0|            0|            0|  0.00%|
  1216|         0|            0|            0|  0.00%|
  1217|         0|            0|            0|  0.00%|class _GenericAlias(_BaseGenericAlias, _root=True):
  1218|         0|            0|            0|  0.00%|    # The type of parameterized generics.
  1219|         0|            0|            0|  0.00%|    #
  1220|         0|            0|            0|  0.00%|    # That is, for example, `type(List[int])` is `_GenericAlias`.
  1221|         0|            0|            0|  0.00%|    #
  1222|         0|            0|            0|  0.00%|    # Objects which are instances of this class include:
  1223|         0|            0|            0|  0.00%|    # * Parameterized container types, e.g. `Tuple[int]`, `List[int]`.
  1224|         0|            0|            0|  0.00%|    #  * Note that native container types, e.g. `tuple`, `list`, use
  1225|         0|            0|            0|  0.00%|    #    `types.GenericAlias` instead.
  1226|         0|            0|            0|  0.00%|    # * Parameterized classes:
  1227|         0|            0|            0|  0.00%|    #     class C[T]: pass
  1228|         0|            0|            0|  0.00%|    #     # C[int] is a _GenericAlias
  1229|         0|            0|            0|  0.00%|    # * `Callable` aliases, generic `Callable` aliases, and
  1230|         0|            0|            0|  0.00%|    #   parameterized `Callable` aliases:
  1231|         0|            0|            0|  0.00%|    #     T = TypeVar('T')
  1232|         0|            0|            0|  0.00%|    #     # _CallableGenericAlias inherits from _GenericAlias.
  1233|         0|            0|            0|  0.00%|    #     A = Callable[[], None]  # _CallableGenericAlias
  1234|         0|            0|            0|  0.00%|    #     B = Callable[[T], None]  # _CallableGenericAlias
  1235|         0|            0|            0|  0.00%|    #     C = B[int]  # _CallableGenericAlias
  1236|         0|            0|            0|  0.00%|    # * Parameterized `Final`, `ClassVar` and `TypeGuard`:
  1237|         0|            0|            0|  0.00%|    #     # All _GenericAlias
  1238|         0|            0|            0|  0.00%|    #     Final[int]
  1239|         0|            0|            0|  0.00%|    #     ClassVar[float]
  1240|         0|            0|            0|  0.00%|    #     TypeVar[bool]
  1241|         0|            0|            0|  0.00%|
  1242|         2|  6.19888e-06|  3.09944e-06|  0.01%|    def __init__(self, origin, args, *, inst=True, name=None):
  1243|         2|  1.38283e-05|  6.91414e-06|  0.01%|        super().__init__(origin, inst=inst, name=name)
(call)|         2|  0.000147343|  7.36713e-05|  0.15%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:1147 __init__
  1244|         2|  4.05312e-06|  2.02656e-06|  0.00%|        if not isinstance(args, tuple):
  1245|         2|  3.57628e-06|  1.78814e-06|  0.00%|            args = (args,)
  1246|        16|  5.38826e-05|  3.36766e-06|  0.06%|        self.__args__ = tuple(... if a is _TypingEllipsis else
(call)|         4|  2.19345e-05|  5.48363e-06|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:1246 <genexpr>
(call)|         2|  1.93119e-05|  9.65595e-06|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:1188 __setattr__
  1247|         6|  7.62939e-06|  1.27157e-06|  0.01%|                              a for a in args)
  1248|         2|  3.50475e-05|  1.75238e-05|  0.04%|        self.__parameters__ = _collect_parameters(args)
(call)|         2|  0.000114202|  5.71012e-05|  0.12%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/typing_extensions.py:3029 _collect_parameters
(call)|         2|  1.90735e-05|  9.53674e-06|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:1188 __setattr__
  1249|         2|  5.24521e-06|   2.6226e-06|  0.01%|        if not name:
  1250|         0|            0|            0|  0.00%|            self.__module__ = origin.__module__
  1251|         0|            0|            0|  0.00%|
  1252|         0|            0|            0|  0.00%|    def __eq__(self, other):
  1253|         0|            0|            0|  0.00%|        if not isinstance(other, _GenericAlias):
  1254|         0|            0|            0|  0.00%|            return NotImplemented
  1255|         0|            0|            0|  0.00%|        return (self.__origin__ == other.__origin__
  1256|         0|            0|            0|  0.00%|                and self.__args__ == other.__args__)
  1257|         0|            0|            0|  0.00%|
  1258|         0|            0|            0|  0.00%|    def __hash__(self):
  1259|         0|            0|            0|  0.00%|        return hash((self.__origin__, self.__args__))
  1260|         0|            0|            0|  0.00%|
  1261|         0|            0|            0|  0.00%|    def __or__(self, right):
  1262|         0|            0|            0|  0.00%|        return Union[self, right]
  1263|         0|            0|            0|  0.00%|
  1264|         0|            0|            0|  0.00%|    def __ror__(self, left):
  1265|         0|            0|            0|  0.00%|        return Union[left, self]
  1266|         0|            0|            0|  0.00%|
  1267|         0|            0|            0|  0.00%|    @_tp_cache
  1268|         0|            0|            0|  0.00%|    def __getitem__(self, args):
  1269|         0|            0|            0|  0.00%|        # Parameterizes an already-parameterized object.
  1270|         0|            0|            0|  0.00%|        #
  1271|         0|            0|            0|  0.00%|        # For example, we arrive here doing something like:
  1272|         0|            0|            0|  0.00%|        #   T1 = TypeVar('T1')
  1273|         0|            0|            0|  0.00%|        #   T2 = TypeVar('T2')
  1274|         0|            0|            0|  0.00%|        #   T3 = TypeVar('T3')
  1275|         0|            0|            0|  0.00%|        #   class A(Generic[T1]): pass
  1276|         0|            0|            0|  0.00%|        #   B = A[T2]  # B is a _GenericAlias
  1277|         0|            0|            0|  0.00%|        #   C = B[T3]  # Invokes _GenericAlias.__getitem__
  1278|         0|            0|            0|  0.00%|        #
  1279|         0|            0|            0|  0.00%|        # We also arrive here when parameterizing a generic `Callable` alias:
  1280|         0|            0|            0|  0.00%|        #   T = TypeVar('T')
  1281|         0|            0|            0|  0.00%|        #   C = Callable[[T], None]
  1282|         0|            0|            0|  0.00%|        #   C[int]  # Invokes _GenericAlias.__getitem__
  1283|         0|            0|            0|  0.00%|
  1284|         0|            0|            0|  0.00%|        if self.__origin__ in (Generic, Protocol):
  1285|         0|            0|            0|  0.00%|            # Can't subscript Generic[...] or Protocol[...].
  1286|         0|            0|            0|  0.00%|            raise TypeError(f"Cannot subscript already-subscripted {self}")
  1287|         0|            0|            0|  0.00%|        if not self.__parameters__:
  1288|         0|            0|            0|  0.00%|            raise TypeError(f"{self} is not a generic class")
  1289|         0|            0|            0|  0.00%|
  1290|         0|            0|            0|  0.00%|        # Preprocess `args`.
  1291|         0|            0|            0|  0.00%|        if not isinstance(args, tuple):
  1292|         0|            0|            0|  0.00%|            args = (args,)
  1293|         0|            0|            0|  0.00%|        args = tuple(_type_convert(p) for p in args)
  1294|         0|            0|            0|  0.00%|        args = _unpack_args(args)
  1295|         0|            0|            0|  0.00%|        new_args = self._determine_new_args(args)
  1296|         0|            0|            0|  0.00%|        r = self.copy_with(new_args)
  1297|         0|            0|            0|  0.00%|        return r
  1298|         0|            0|            0|  0.00%|
  1299|         0|            0|            0|  0.00%|    def _determine_new_args(self, args):
  1300|         0|            0|            0|  0.00%|        # Determines new __args__ for __getitem__.
  1301|         0|            0|            0|  0.00%|        #
  1302|         0|            0|            0|  0.00%|        # For example, suppose we had:
  1303|         0|            0|            0|  0.00%|        #   T1 = TypeVar('T1')
  1304|         0|            0|            0|  0.00%|        #   T2 = TypeVar('T2')
  1305|         0|            0|            0|  0.00%|        #   class A(Generic[T1, T2]): pass
  1306|         0|            0|            0|  0.00%|        #   T3 = TypeVar('T3')
  1307|         0|            0|            0|  0.00%|        #   B = A[int, T3]
  1308|         0|            0|            0|  0.00%|        #   C = B[str]
  1309|         0|            0|            0|  0.00%|        # `B.__args__` is `(int, T3)`, so `C.__args__` should be `(int, str)`.
  1310|         0|            0|            0|  0.00%|        # Unfortunately, this is harder than it looks, because if `T3` is
  1311|         0|            0|            0|  0.00%|        # anything more exotic than a plain `TypeVar`, we need to consider
  1312|         0|            0|            0|  0.00%|        # edge cases.
  1313|         0|            0|            0|  0.00%|
  1314|         0|            0|            0|  0.00%|        params = self.__parameters__
  1315|         0|            0|            0|  0.00%|        # In the example above, this would be {T3: str}
  1316|         0|            0|            0|  0.00%|        for param in params:
  1317|         0|            0|            0|  0.00%|            prepare = getattr(param, '__typing_prepare_subst__', None)
  1318|         0|            0|            0|  0.00%|            if prepare is not None:
  1319|         0|            0|            0|  0.00%|                args = prepare(self, args)
  1320|         0|            0|            0|  0.00%|        alen = len(args)
  1321|         0|            0|            0|  0.00%|        plen = len(params)
  1322|         0|            0|            0|  0.00%|        if alen != plen:
  1323|         0|            0|            0|  0.00%|            raise TypeError(f"Too {'many' if alen > plen else 'few'} arguments for {self};"
  1324|         0|            0|            0|  0.00%|                            f" actual {alen}, expected {plen}")
  1325|         0|            0|            0|  0.00%|        new_arg_by_param = dict(zip(params, args))
  1326|         0|            0|            0|  0.00%|        return tuple(self._make_substitution(self.__args__, new_arg_by_param))
  1327|         0|            0|            0|  0.00%|
  1328|         0|            0|            0|  0.00%|    def _make_substitution(self, args, new_arg_by_param):
  1329|         0|            0|            0|  0.00%|        """Create a list of new type arguments."""
  1330|         0|            0|            0|  0.00%|        new_args = []
  1331|         0|            0|            0|  0.00%|        for old_arg in args:
  1332|         0|            0|            0|  0.00%|            if isinstance(old_arg, type):
  1333|         0|            0|            0|  0.00%|                new_args.append(old_arg)
  1334|         0|            0|            0|  0.00%|                continue
  1335|         0|            0|            0|  0.00%|
  1336|         0|            0|            0|  0.00%|            substfunc = getattr(old_arg, '__typing_subst__', None)
  1337|         0|            0|            0|  0.00%|            if substfunc:
  1338|         0|            0|            0|  0.00%|                new_arg = substfunc(new_arg_by_param[old_arg])
  1339|         0|            0|            0|  0.00%|            else:
  1340|         0|            0|            0|  0.00%|                subparams = getattr(old_arg, '__parameters__', ())
  1341|         0|            0|            0|  0.00%|                if not subparams:
  1342|         0|            0|            0|  0.00%|                    new_arg = old_arg
  1343|         0|            0|            0|  0.00%|                else:
  1344|         0|            0|            0|  0.00%|                    subargs = []
  1345|         0|            0|            0|  0.00%|                    for x in subparams:
  1346|         0|            0|            0|  0.00%|                        if isinstance(x, TypeVarTuple):
  1347|         0|            0|            0|  0.00%|                            subargs.extend(new_arg_by_param[x])
  1348|         0|            0|            0|  0.00%|                        else:
  1349|         0|            0|            0|  0.00%|                            subargs.append(new_arg_by_param[x])
  1350|         0|            0|            0|  0.00%|                    new_arg = old_arg[tuple(subargs)]
  1351|         0|            0|            0|  0.00%|
  1352|         0|            0|            0|  0.00%|            if self.__origin__ == collections.abc.Callable and isinstance(new_arg, tuple):
  1353|         0|            0|            0|  0.00%|                # Consider the following `Callable`.
  1354|         0|            0|            0|  0.00%|                #   C = Callable[[int], str]
  1355|         0|            0|            0|  0.00%|                # Here, `C.__args__` should be (int, str) - NOT ([int], str).
  1356|         0|            0|            0|  0.00%|                # That means that if we had something like...
  1357|         0|            0|            0|  0.00%|                #   P = ParamSpec('P')
  1358|         0|            0|            0|  0.00%|                #   T = TypeVar('T')
  1359|         0|            0|            0|  0.00%|                #   C = Callable[P, T]
  1360|         0|            0|            0|  0.00%|                #   D = C[[int, str], float]
  1361|         0|            0|            0|  0.00%|                # ...we need to be careful; `new_args` should end up as
  1362|         0|            0|            0|  0.00%|                # `(int, str, float)` rather than `([int, str], float)`.
  1363|         0|            0|            0|  0.00%|                new_args.extend(new_arg)
  1364|         0|            0|            0|  0.00%|            elif _is_unpacked_typevartuple(old_arg):
  1365|         0|            0|            0|  0.00%|                # Consider the following `_GenericAlias`, `B`:
  1366|         0|            0|            0|  0.00%|                #   class A(Generic[*Ts]): ...
  1367|         0|            0|            0|  0.00%|                #   B = A[T, *Ts]
  1368|         0|            0|            0|  0.00%|                # If we then do:
  1369|         0|            0|            0|  0.00%|                #   B[float, int, str]
  1370|         0|            0|            0|  0.00%|                # The `new_arg` corresponding to `T` will be `float`, and the
  1371|         0|            0|            0|  0.00%|                # `new_arg` corresponding to `*Ts` will be `(int, str)`. We
  1372|         0|            0|            0|  0.00%|                # should join all these types together in a flat list
  1373|         0|            0|            0|  0.00%|                # `(float, int, str)` - so again, we should `extend`.
  1374|         0|            0|            0|  0.00%|                new_args.extend(new_arg)
  1375|         0|            0|            0|  0.00%|            elif isinstance(old_arg, tuple):
  1376|         0|            0|            0|  0.00%|                # Corner case:
  1377|         0|            0|            0|  0.00%|                #    P = ParamSpec('P')
  1378|         0|            0|            0|  0.00%|                #    T = TypeVar('T')
  1379|         0|            0|            0|  0.00%|                #    class Base(Generic[P]): ...
  1380|         0|            0|            0|  0.00%|                # Can be substituted like this:
  1381|         0|            0|            0|  0.00%|                #    X = Base[[int, T]]
  1382|         0|            0|            0|  0.00%|                # In this case, `old_arg` will be a tuple:
  1383|         0|            0|            0|  0.00%|                new_args.append(
  1384|         0|            0|            0|  0.00%|                    tuple(self._make_substitution(old_arg, new_arg_by_param)),
  1385|         0|            0|            0|  0.00%|                )
  1386|         0|            0|            0|  0.00%|            else:
  1387|         0|            0|            0|  0.00%|                new_args.append(new_arg)
  1388|         0|            0|            0|  0.00%|        return new_args
  1389|         0|            0|            0|  0.00%|
  1390|         0|            0|            0|  0.00%|    def copy_with(self, args):
  1391|         0|            0|            0|  0.00%|        return self.__class__(self.__origin__, args, name=self._name, inst=self._inst)
  1392|         0|            0|            0|  0.00%|
  1393|         0|            0|            0|  0.00%|    def __repr__(self):
  1394|         0|            0|            0|  0.00%|        if self._name:
  1395|         0|            0|            0|  0.00%|            name = 'typing.' + self._name
  1396|         0|            0|            0|  0.00%|        else:
  1397|         0|            0|            0|  0.00%|            name = _type_repr(self.__origin__)
  1398|         0|            0|            0|  0.00%|        if self.__args__:
  1399|         0|            0|            0|  0.00%|            args = ", ".join([_type_repr(a) for a in self.__args__])
  1400|         0|            0|            0|  0.00%|        else:
  1401|         0|            0|            0|  0.00%|            # To ensure the repr is eval-able.
  1402|         0|            0|            0|  0.00%|            args = "()"
  1403|         0|            0|            0|  0.00%|        return f'{name}[{args}]'
  1404|         0|            0|            0|  0.00%|
  1405|         0|            0|            0|  0.00%|    def __reduce__(self):
  1406|         0|            0|            0|  0.00%|        if self._name:
  1407|         0|            0|            0|  0.00%|            origin = globals()[self._name]
  1408|         0|            0|            0|  0.00%|        else:
  1409|         0|            0|            0|  0.00%|            origin = self.__origin__
  1410|         0|            0|            0|  0.00%|        args = tuple(self.__args__)
  1411|         0|            0|            0|  0.00%|        if len(args) == 1 and not isinstance(args[0], tuple):
  1412|         0|            0|            0|  0.00%|            args, = args
  1413|         0|            0|            0|  0.00%|        return operator.getitem, (origin, args)
  1414|         0|            0|            0|  0.00%|
  1415|         0|            0|            0|  0.00%|    def __mro_entries__(self, bases):
  1416|         0|            0|            0|  0.00%|        if isinstance(self.__origin__, _SpecialForm):
  1417|         0|            0|            0|  0.00%|            raise TypeError(f"Cannot subclass {self!r}")
  1418|         0|            0|            0|  0.00%|
  1419|         0|            0|            0|  0.00%|        if self._name:  # generic version of an ABC or built-in class
  1420|         0|            0|            0|  0.00%|            return super().__mro_entries__(bases)
  1421|         0|            0|            0|  0.00%|        if self.__origin__ is Generic:
  1422|         0|            0|            0|  0.00%|            if Protocol in bases:
  1423|         0|            0|            0|  0.00%|                return ()
  1424|         0|            0|            0|  0.00%|            i = bases.index(self)
  1425|         0|            0|            0|  0.00%|            for b in bases[i+1:]:
  1426|         0|            0|            0|  0.00%|                if isinstance(b, _BaseGenericAlias) and b is not self:
  1427|         0|            0|            0|  0.00%|                    return ()
  1428|         0|            0|            0|  0.00%|        return (self.__origin__,)
  1429|         0|            0|            0|  0.00%|
  1430|         0|            0|            0|  0.00%|    def __iter__(self):
  1431|         0|            0|            0|  0.00%|        yield Unpack[self]
  1432|         0|            0|            0|  0.00%|
  1433|         0|            0|            0|  0.00%|
  1434|         0|            0|            0|  0.00%|# _nparams is the number of accepted parameters, e.g. 0 for Hashable,
  1435|         0|            0|            0|  0.00%|# 1 for List and 2 for Dict.  It may be -1 if variable number of
  1436|         0|            0|            0|  0.00%|# parameters are accepted (needs custom __getitem__).
  1437|         0|            0|            0|  0.00%|
  1438|         0|            0|            0|  0.00%|class _SpecialGenericAlias(_NotIterable, _BaseGenericAlias, _root=True):
  1439|         0|            0|            0|  0.00%|    def __init__(self, origin, nparams, *, inst=True, name=None):
  1440|         0|            0|            0|  0.00%|        if name is None:
  1441|         0|            0|            0|  0.00%|            name = origin.__name__
  1442|         0|            0|            0|  0.00%|        super().__init__(origin, inst=inst, name=name)
  1443|         0|            0|            0|  0.00%|        self._nparams = nparams
  1444|         0|            0|            0|  0.00%|        if origin.__module__ == 'builtins':
  1445|         0|            0|            0|  0.00%|            self.__doc__ = f'A generic version of {origin.__qualname__}.'
  1446|         0|            0|            0|  0.00%|        else:
  1447|         0|            0|            0|  0.00%|            self.__doc__ = f'A generic version of {origin.__module__}.{origin.__qualname__}.'
  1448|         0|            0|            0|  0.00%|
  1449|         0|            0|            0|  0.00%|    @_tp_cache
  1450|         0|            0|            0|  0.00%|    def __getitem__(self, params):
  1451|         0|            0|            0|  0.00%|        if not isinstance(params, tuple):
  1452|         0|            0|            0|  0.00%|            params = (params,)
  1453|         0|            0|            0|  0.00%|        msg = "Parameters to generic types must be types."
  1454|         0|            0|            0|  0.00%|        params = tuple(_type_check(p, msg) for p in params)
  1455|         0|            0|            0|  0.00%|        _check_generic(self, params, self._nparams)
  1456|         0|            0|            0|  0.00%|        return self.copy_with(params)
  1457|         0|            0|            0|  0.00%|
  1458|         0|            0|            0|  0.00%|    def copy_with(self, params):
  1459|         0|            0|            0|  0.00%|        return _GenericAlias(self.__origin__, params,
  1460|         0|            0|            0|  0.00%|                             name=self._name, inst=self._inst)
  1461|         0|            0|            0|  0.00%|
  1462|         0|            0|            0|  0.00%|    def __repr__(self):
  1463|         0|            0|            0|  0.00%|        return 'typing.' + self._name
  1464|         0|            0|            0|  0.00%|
  1465|         3|  6.19888e-06|  2.06629e-06|  0.01%|    def __subclasscheck__(self, cls):
  1466|         3|  5.72205e-06|  1.90735e-06|  0.01%|        if isinstance(cls, _SpecialGenericAlias):
  1467|         0|            0|            0|  0.00%|            return issubclass(cls.__origin__, self.__origin__)
  1468|         3|  4.52995e-06|  1.50998e-06|  0.00%|        if not isinstance(cls, _GenericAlias):
  1469|         3|  2.28882e-05|  7.62939e-06|  0.02%|            return issubclass(cls, self.__origin__)
(call)|         3|  0.000771284|  0.000257095|  0.79%|# <frozen abc>:121 __subclasscheck__
  1470|         0|            0|            0|  0.00%|        return super().__subclasscheck__(cls)
  1471|         0|            0|            0|  0.00%|
  1472|         0|            0|            0|  0.00%|    def __reduce__(self):
  1473|         0|            0|            0|  0.00%|        return self._name
  1474|         0|            0|            0|  0.00%|
  1475|         0|            0|            0|  0.00%|    def __or__(self, right):
  1476|         0|            0|            0|  0.00%|        return Union[self, right]
  1477|         0|            0|            0|  0.00%|
  1478|         0|            0|            0|  0.00%|    def __ror__(self, left):
  1479|         0|            0|            0|  0.00%|        return Union[left, self]
  1480|         0|            0|            0|  0.00%|
  1481|         0|            0|            0|  0.00%|
  1482|         0|            0|            0|  0.00%|class _DeprecatedGenericAlias(_SpecialGenericAlias, _root=True):
  1483|         0|            0|            0|  0.00%|    def __init__(
  1484|         0|            0|            0|  0.00%|        self, origin, nparams, *, removal_version, inst=True, name=None
  1485|         0|            0|            0|  0.00%|    ):
  1486|         0|            0|            0|  0.00%|        super().__init__(origin, nparams, inst=inst, name=name)
  1487|         0|            0|            0|  0.00%|        self._removal_version = removal_version
  1488|         0|            0|            0|  0.00%|
  1489|         0|            0|            0|  0.00%|    def __instancecheck__(self, inst):
  1490|         0|            0|            0|  0.00%|        import warnings
  1491|         0|            0|            0|  0.00%|        warnings._deprecated(
  1492|         0|            0|            0|  0.00%|            f"{self.__module__}.{self._name}", remove=self._removal_version
  1493|         0|            0|            0|  0.00%|        )
  1494|         0|            0|            0|  0.00%|        return super().__instancecheck__(inst)
  1495|         0|            0|            0|  0.00%|
  1496|         0|            0|            0|  0.00%|
  1497|         0|            0|            0|  0.00%|class _CallableGenericAlias(_NotIterable, _GenericAlias, _root=True):
  1498|         0|            0|            0|  0.00%|    def __repr__(self):
  1499|         0|            0|            0|  0.00%|        assert self._name == 'Callable'
  1500|         0|            0|            0|  0.00%|        args = self.__args__
  1501|         0|            0|            0|  0.00%|        if len(args) == 2 and _is_param_expr(args[0]):
  1502|         0|            0|            0|  0.00%|            return super().__repr__()
  1503|         0|            0|            0|  0.00%|        return (f'typing.Callable'
  1504|         0|            0|            0|  0.00%|                f'[[{", ".join([_type_repr(a) for a in args[:-1]])}], '
  1505|         0|            0|            0|  0.00%|                f'{_type_repr(args[-1])}]')
  1506|         0|            0|            0|  0.00%|
  1507|         0|            0|            0|  0.00%|    def __reduce__(self):
  1508|         0|            0|            0|  0.00%|        args = self.__args__
  1509|         0|            0|            0|  0.00%|        if not (len(args) == 2 and _is_param_expr(args[0])):
  1510|         0|            0|            0|  0.00%|            args = list(args[:-1]), args[-1]
  1511|         0|            0|            0|  0.00%|        return operator.getitem, (Callable, args)
  1512|         0|            0|            0|  0.00%|
  1513|         0|            0|            0|  0.00%|
  1514|         0|            0|            0|  0.00%|class _CallableType(_SpecialGenericAlias, _root=True):
  1515|         0|            0|            0|  0.00%|    def copy_with(self, params):
  1516|         0|            0|            0|  0.00%|        return _CallableGenericAlias(self.__origin__, params,
  1517|         0|            0|            0|  0.00%|                                     name=self._name, inst=self._inst)
  1518|         0|            0|            0|  0.00%|
  1519|         0|            0|            0|  0.00%|    def __getitem__(self, params):
  1520|         0|            0|            0|  0.00%|        if not isinstance(params, tuple) or len(params) != 2:
  1521|         0|            0|            0|  0.00%|            raise TypeError("Callable must be used as "
  1522|         0|            0|            0|  0.00%|                            "Callable[[arg, ...], result].")
  1523|         0|            0|            0|  0.00%|        args, result = params
  1524|         0|            0|            0|  0.00%|        # This relaxes what args can be on purpose to allow things like
  1525|         0|            0|            0|  0.00%|        # PEP 612 ParamSpec.  Responsibility for whether a user is using
  1526|         0|            0|            0|  0.00%|        # Callable[...] properly is deferred to static type checkers.
  1527|         0|            0|            0|  0.00%|        if isinstance(args, list):
  1528|         0|            0|            0|  0.00%|            params = (tuple(args), result)
  1529|         0|            0|            0|  0.00%|        else:
  1530|         0|            0|            0|  0.00%|            params = (args, result)
  1531|         0|            0|            0|  0.00%|        return self.__getitem_inner__(params)
  1532|         0|            0|            0|  0.00%|
  1533|         0|            0|            0|  0.00%|    @_tp_cache
  1534|         0|            0|            0|  0.00%|    def __getitem_inner__(self, params):
  1535|         0|            0|            0|  0.00%|        args, result = params
  1536|         0|            0|            0|  0.00%|        msg = "Callable[args, result]: result must be a type."
  1537|         0|            0|            0|  0.00%|        result = _type_check(result, msg)
  1538|         0|            0|            0|  0.00%|        if args is Ellipsis:
  1539|         0|            0|            0|  0.00%|            return self.copy_with((_TypingEllipsis, result))
  1540|         0|            0|            0|  0.00%|        if not isinstance(args, tuple):
  1541|         0|            0|            0|  0.00%|            args = (args,)
  1542|         0|            0|            0|  0.00%|        args = tuple(_type_convert(arg) for arg in args)
  1543|         0|            0|            0|  0.00%|        params = args + (result,)
  1544|         0|            0|            0|  0.00%|        return self.copy_with(params)
  1545|         0|            0|            0|  0.00%|
  1546|         0|            0|            0|  0.00%|
  1547|         0|            0|            0|  0.00%|class _TupleType(_SpecialGenericAlias, _root=True):
  1548|         0|            0|            0|  0.00%|    @_tp_cache
  1549|         0|            0|            0|  0.00%|    def __getitem__(self, params):
  1550|         0|            0|            0|  0.00%|        if not isinstance(params, tuple):
  1551|         0|            0|            0|  0.00%|            params = (params,)
  1552|         0|            0|            0|  0.00%|        if len(params) >= 2 and params[-1] is ...:
  1553|         0|            0|            0|  0.00%|            msg = "Tuple[t, ...]: t must be a type."
  1554|         0|            0|            0|  0.00%|            params = tuple(_type_check(p, msg) for p in params[:-1])
  1555|         0|            0|            0|  0.00%|            return self.copy_with((*params, _TypingEllipsis))
  1556|         0|            0|            0|  0.00%|        msg = "Tuple[t0, t1, ...]: each t must be a type."
  1557|         0|            0|            0|  0.00%|        params = tuple(_type_check(p, msg) for p in params)
  1558|         0|            0|            0|  0.00%|        return self.copy_with(params)
  1559|         0|            0|            0|  0.00%|
  1560|         0|            0|            0|  0.00%|
  1561|         0|            0|            0|  0.00%|class _UnionGenericAlias(_NotIterable, _GenericAlias, _root=True):
  1562|         0|            0|            0|  0.00%|    def copy_with(self, params):
  1563|         0|            0|            0|  0.00%|        return Union[params]
  1564|         0|            0|            0|  0.00%|
  1565|         0|            0|            0|  0.00%|    def __eq__(self, other):
  1566|         0|            0|            0|  0.00%|        if not isinstance(other, (_UnionGenericAlias, types.UnionType)):
  1567|         0|            0|            0|  0.00%|            return NotImplemented
  1568|         0|            0|            0|  0.00%|        try:  # fast path
  1569|         0|            0|            0|  0.00%|            return set(self.__args__) == set(other.__args__)
  1570|         0|            0|            0|  0.00%|        except TypeError:  # not hashable, slow path
  1571|         0|            0|            0|  0.00%|            return _compare_args_orderless(self.__args__, other.__args__)
  1572|         0|            0|            0|  0.00%|
  1573|         0|            0|            0|  0.00%|    def __hash__(self):
  1574|         0|            0|            0|  0.00%|        return hash(frozenset(self.__args__))
  1575|         0|            0|            0|  0.00%|
  1576|         0|            0|            0|  0.00%|    def __repr__(self):
  1577|         0|            0|            0|  0.00%|        args = self.__args__
  1578|         0|            0|            0|  0.00%|        if len(args) == 2:
  1579|         0|            0|            0|  0.00%|            if args[0] is type(None):
  1580|         0|            0|            0|  0.00%|                return f'typing.Optional[{_type_repr(args[1])}]'
  1581|         0|            0|            0|  0.00%|            elif args[1] is type(None):
  1582|         0|            0|            0|  0.00%|                return f'typing.Optional[{_type_repr(args[0])}]'
  1583|         0|            0|            0|  0.00%|        return super().__repr__()
  1584|         0|            0|            0|  0.00%|
  1585|         0|            0|            0|  0.00%|    def __instancecheck__(self, obj):
  1586|         0|            0|            0|  0.00%|        return self.__subclasscheck__(type(obj))
  1587|         0|            0|            0|  0.00%|
  1588|         0|            0|            0|  0.00%|    def __subclasscheck__(self, cls):
  1589|         0|            0|            0|  0.00%|        for arg in self.__args__:
  1590|         0|            0|            0|  0.00%|            if issubclass(cls, arg):
  1591|         0|            0|            0|  0.00%|                return True
  1592|         0|            0|            0|  0.00%|
  1593|         0|            0|            0|  0.00%|    def __reduce__(self):
  1594|         0|            0|            0|  0.00%|        func, (origin, args) = super().__reduce__()
  1595|         0|            0|            0|  0.00%|        return func, (Union, args)
  1596|         0|            0|            0|  0.00%|
  1597|         0|            0|            0|  0.00%|
  1598|         0|            0|            0|  0.00%|def _value_and_type_iter(parameters):
  1599|         0|            0|            0|  0.00%|    return ((p, type(p)) for p in parameters)
  1600|         0|            0|            0|  0.00%|
  1601|         0|            0|            0|  0.00%|
  1602|         0|            0|            0|  0.00%|class _LiteralGenericAlias(_GenericAlias, _root=True):
  1603|         0|            0|            0|  0.00%|    def __eq__(self, other):
  1604|         0|            0|            0|  0.00%|        if not isinstance(other, _LiteralGenericAlias):
  1605|         0|            0|            0|  0.00%|            return NotImplemented
  1606|         0|            0|            0|  0.00%|
  1607|         0|            0|            0|  0.00%|        return set(_value_and_type_iter(self.__args__)) == set(_value_and_type_iter(other.__args__))
  1608|         0|            0|            0|  0.00%|
  1609|         0|            0|            0|  0.00%|    def __hash__(self):
  1610|         0|            0|            0|  0.00%|        return hash(frozenset(_value_and_type_iter(self.__args__)))
  1611|         0|            0|            0|  0.00%|
  1612|         0|            0|            0|  0.00%|
  1613|         0|            0|            0|  0.00%|class _ConcatenateGenericAlias(_GenericAlias, _root=True):
  1614|         0|            0|            0|  0.00%|    def copy_with(self, params):
  1615|         0|            0|            0|  0.00%|        if isinstance(params[-1], (list, tuple)):
  1616|         0|            0|            0|  0.00%|            return (*params[:-1], *params[-1])
  1617|         0|            0|            0|  0.00%|        if isinstance(params[-1], _ConcatenateGenericAlias):
  1618|         0|            0|            0|  0.00%|            params = (*params[:-1], *params[-1].__args__)
  1619|         0|            0|            0|  0.00%|        return super().copy_with(params)
  1620|         0|            0|            0|  0.00%|
  1621|         0|            0|            0|  0.00%|
  1622|         0|            0|            0|  0.00%|@_SpecialForm
  1623|         0|            0|            0|  0.00%|def Unpack(self, parameters):
  1624|         0|            0|            0|  0.00%|    """Type unpack operator.
  1625|         0|            0|            0|  0.00%|
  1626|         0|            0|            0|  0.00%|    The type unpack operator takes the child types from some container type,
  1627|         0|            0|            0|  0.00%|    such as `tuple[int, str]` or a `TypeVarTuple`, and 'pulls them out'.
  1628|         0|            0|            0|  0.00%|
  1629|         0|            0|            0|  0.00%|    For example::
  1630|         0|            0|            0|  0.00%|
  1631|         0|            0|            0|  0.00%|        # For some generic class `Foo`:
  1632|         0|            0|            0|  0.00%|        Foo[Unpack[tuple[int, str]]]  # Equivalent to Foo[int, str]
  1633|         0|            0|            0|  0.00%|
  1634|         0|            0|            0|  0.00%|        Ts = TypeVarTuple('Ts')
  1635|         0|            0|            0|  0.00%|        # Specifies that `Bar` is generic in an arbitrary number of types.
  1636|         0|            0|            0|  0.00%|        # (Think of `Ts` as a tuple of an arbitrary number of individual
  1637|         0|            0|            0|  0.00%|        #  `TypeVar`s, which the `Unpack` is 'pulling out' directly into the
  1638|         0|            0|            0|  0.00%|        #  `Generic[]`.)
  1639|         0|            0|            0|  0.00%|        class Bar(Generic[Unpack[Ts]]): ...
  1640|         0|            0|            0|  0.00%|        Bar[int]  # Valid
  1641|         0|            0|            0|  0.00%|        Bar[int, str]  # Also valid
  1642|         0|            0|            0|  0.00%|
  1643|         0|            0|            0|  0.00%|    From Python 3.11, this can also be done using the `*` operator::
  1644|         0|            0|            0|  0.00%|
  1645|         0|            0|            0|  0.00%|        Foo[*tuple[int, str]]
  1646|         0|            0|            0|  0.00%|        class Bar(Generic[*Ts]): ...
  1647|         0|            0|            0|  0.00%|
  1648|         0|            0|            0|  0.00%|    And from Python 3.12, it can be done using built-in syntax for generics::
  1649|         0|            0|            0|  0.00%|
  1650|         0|            0|            0|  0.00%|        Foo[*tuple[int, str]]
  1651|         0|            0|            0|  0.00%|        class Bar[*Ts]: ...
  1652|         0|            0|            0|  0.00%|
  1653|         0|            0|            0|  0.00%|    The operator can also be used along with a `TypedDict` to annotate
  1654|         0|            0|            0|  0.00%|    `**kwargs` in a function signature::
  1655|         0|            0|            0|  0.00%|
  1656|         0|            0|            0|  0.00%|        class Movie(TypedDict):
  1657|         0|            0|            0|  0.00%|            name: str
  1658|         0|            0|            0|  0.00%|            year: int
  1659|         0|            0|            0|  0.00%|
  1660|         0|            0|            0|  0.00%|        # This function expects two keyword arguments - *name* of type `str` and
  1661|         0|            0|            0|  0.00%|        # *year* of type `int`.
  1662|         0|            0|            0|  0.00%|        def foo(**kwargs: Unpack[Movie]): ...
  1663|         0|            0|            0|  0.00%|
  1664|         0|            0|            0|  0.00%|    Note that there is only some runtime checking of this operator. Not
  1665|         0|            0|            0|  0.00%|    everything the runtime allows may be accepted by static type checkers.
  1666|         0|            0|            0|  0.00%|
  1667|         0|            0|            0|  0.00%|    For more information, see PEPs 646 and 692.
  1668|         0|            0|            0|  0.00%|    """
  1669|         0|            0|            0|  0.00%|    item = _type_check(parameters, f'{self} accepts only single type.')
  1670|         0|            0|            0|  0.00%|    return _UnpackGenericAlias(origin=self, args=(item,))
  1671|         0|            0|            0|  0.00%|
  1672|         0|            0|            0|  0.00%|
  1673|         0|            0|            0|  0.00%|class _UnpackGenericAlias(_GenericAlias, _root=True):
  1674|         0|            0|            0|  0.00%|    def __repr__(self):
  1675|         0|            0|            0|  0.00%|        # `Unpack` only takes one argument, so __args__ should contain only
  1676|         0|            0|            0|  0.00%|        # a single item.
  1677|         0|            0|            0|  0.00%|        return f'typing.Unpack[{_type_repr(self.__args__[0])}]'
  1678|         0|            0|            0|  0.00%|
  1679|         0|            0|            0|  0.00%|    def __getitem__(self, args):
  1680|         0|            0|            0|  0.00%|        if self.__typing_is_unpacked_typevartuple__:
  1681|         0|            0|            0|  0.00%|            return args
  1682|         0|            0|            0|  0.00%|        return super().__getitem__(args)
  1683|         0|            0|            0|  0.00%|
  1684|         0|            0|            0|  0.00%|    @property
  1685|         0|            0|            0|  0.00%|    def __typing_unpacked_tuple_args__(self):
  1686|         0|            0|            0|  0.00%|        assert self.__origin__ is Unpack
  1687|         0|            0|            0|  0.00%|        assert len(self.__args__) == 1
  1688|         0|            0|            0|  0.00%|        arg, = self.__args__
  1689|         0|            0|            0|  0.00%|        if isinstance(arg, _GenericAlias):
  1690|         0|            0|            0|  0.00%|            assert arg.__origin__ is tuple
  1691|         0|            0|            0|  0.00%|            return arg.__args__
  1692|         0|            0|            0|  0.00%|        return None
  1693|         0|            0|            0|  0.00%|
  1694|         0|            0|            0|  0.00%|    @property
  1695|         0|            0|            0|  0.00%|    def __typing_is_unpacked_typevartuple__(self):
  1696|         0|            0|            0|  0.00%|        assert self.__origin__ is Unpack
  1697|         0|            0|            0|  0.00%|        assert len(self.__args__) == 1
  1698|         0|            0|            0|  0.00%|        return isinstance(self.__args__[0], TypeVarTuple)
  1699|         0|            0|            0|  0.00%|
  1700|         0|            0|            0|  0.00%|
  1701|         0|            0|            0|  0.00%|class _TypingEllipsis:
  1702|         0|            0|            0|  0.00%|    """Internal placeholder for ... (ellipsis)."""
  1703|         0|            0|            0|  0.00%|
  1704|         0|            0|            0|  0.00%|
  1705|         0|            0|            0|  0.00%|_TYPING_INTERNALS = frozenset({
  1706|         0|            0|            0|  0.00%|    '__parameters__', '__orig_bases__',  '__orig_class__',
  1707|         0|            0|            0|  0.00%|    '_is_protocol', '_is_runtime_protocol', '__protocol_attrs__',
  1708|         0|            0|            0|  0.00%|    '__non_callable_proto_members__', '__type_params__',
  1709|         0|            0|            0|  0.00%|})
  1710|         0|            0|            0|  0.00%|
  1711|         0|            0|            0|  0.00%|_SPECIAL_NAMES = frozenset({
  1712|         0|            0|            0|  0.00%|    '__abstractmethods__', '__annotations__', '__dict__', '__doc__',
  1713|         0|            0|            0|  0.00%|    '__init__', '__module__', '__new__', '__slots__',
  1714|         0|            0|            0|  0.00%|    '__subclasshook__', '__weakref__', '__class_getitem__'
  1715|         0|            0|            0|  0.00%|})
  1716|         0|            0|            0|  0.00%|
  1717|         0|            0|            0|  0.00%|# These special attributes will be not collected as protocol members.
  1718|         0|            0|            0|  0.00%|EXCLUDED_ATTRIBUTES = _TYPING_INTERNALS | _SPECIAL_NAMES | {'_MutableMapping__marker'}
  1719|         0|            0|            0|  0.00%|
  1720|         0|            0|            0|  0.00%|
  1721|         0|            0|            0|  0.00%|def _get_protocol_attrs(cls):
  1722|         0|            0|            0|  0.00%|    """Collect protocol members from a protocol class objects.
  1723|         0|            0|            0|  0.00%|
  1724|         0|            0|            0|  0.00%|    This includes names actually defined in the class dictionary, as well
  1725|         0|            0|            0|  0.00%|    as names that appear in annotations. Special names (above) are skipped.
  1726|         0|            0|            0|  0.00%|    """
  1727|         0|            0|            0|  0.00%|    attrs = set()
  1728|         0|            0|            0|  0.00%|    for base in cls.__mro__[:-1]:  # without object
  1729|         0|            0|            0|  0.00%|        if base.__name__ in {'Protocol', 'Generic'}:
  1730|         0|            0|            0|  0.00%|            continue
  1731|         0|            0|            0|  0.00%|        annotations = getattr(base, '__annotations__', {})
  1732|         0|            0|            0|  0.00%|        for attr in (*base.__dict__, *annotations):
  1733|         0|            0|            0|  0.00%|            if not attr.startswith('_abc_') and attr not in EXCLUDED_ATTRIBUTES:
  1734|         0|            0|            0|  0.00%|                attrs.add(attr)
  1735|         0|            0|            0|  0.00%|    return attrs
  1736|         0|            0|            0|  0.00%|
  1737|         0|            0|            0|  0.00%|
  1738|         0|            0|            0|  0.00%|def _no_init_or_replace_init(self, *args, **kwargs):
  1739|         0|            0|            0|  0.00%|    cls = type(self)
  1740|         0|            0|            0|  0.00%|
  1741|         0|            0|            0|  0.00%|    if cls._is_protocol:
  1742|         0|            0|            0|  0.00%|        raise TypeError('Protocols cannot be instantiated')
  1743|         0|            0|            0|  0.00%|
  1744|         0|            0|            0|  0.00%|    # Already using a custom `__init__`. No need to calculate correct
  1745|         0|            0|            0|  0.00%|    # `__init__` to call. This can lead to RecursionError. See bpo-45121.
  1746|         0|            0|            0|  0.00%|    if cls.__init__ is not _no_init_or_replace_init:
  1747|         0|            0|            0|  0.00%|        return
  1748|         0|            0|            0|  0.00%|
  1749|         0|            0|            0|  0.00%|    # Initially, `__init__` of a protocol subclass is set to `_no_init_or_replace_init`.
  1750|         0|            0|            0|  0.00%|    # The first instantiation of the subclass will call `_no_init_or_replace_init` which
  1751|         0|            0|            0|  0.00%|    # searches for a proper new `__init__` in the MRO. The new `__init__`
  1752|         0|            0|            0|  0.00%|    # replaces the subclass' old `__init__` (ie `_no_init_or_replace_init`). Subsequent
  1753|         0|            0|            0|  0.00%|    # instantiation of the protocol subclass will thus use the new
  1754|         0|            0|            0|  0.00%|    # `__init__` and no longer call `_no_init_or_replace_init`.
  1755|         0|            0|            0|  0.00%|    for base in cls.__mro__:
  1756|         0|            0|            0|  0.00%|        init = base.__dict__.get('__init__', _no_init_or_replace_init)
  1757|         0|            0|            0|  0.00%|        if init is not _no_init_or_replace_init:
  1758|         0|            0|            0|  0.00%|            cls.__init__ = init
  1759|         0|            0|            0|  0.00%|            break
  1760|         0|            0|            0|  0.00%|    else:
  1761|         0|            0|            0|  0.00%|        # should not happen
  1762|         0|            0|            0|  0.00%|        cls.__init__ = object.__init__
  1763|         0|            0|            0|  0.00%|
  1764|         0|            0|            0|  0.00%|    cls.__init__(self, *args, **kwargs)
  1765|         0|            0|            0|  0.00%|
  1766|         0|            0|            0|  0.00%|
  1767|         2|  4.29153e-06|  2.14577e-06|  0.00%|def _caller(depth=1, default='__main__'):
  1768|         2|  3.33786e-06|  1.66893e-06|  0.00%|    try:
  1769|         2|  4.52995e-06|  2.26498e-06|  0.00%|        return sys._getframemodulename(depth + 1) or default
  1770|         0|            0|            0|  0.00%|    except AttributeError:  # For platforms without _getframemodulename()
  1771|         0|            0|            0|  0.00%|        pass
  1772|         0|            0|            0|  0.00%|    try:
  1773|         0|            0|            0|  0.00%|        return sys._getframe(depth + 1).f_globals.get('__name__', default)
  1774|         0|            0|            0|  0.00%|    except (AttributeError, ValueError):  # For platforms without _getframe()
  1775|         0|            0|            0|  0.00%|        pass
  1776|         0|            0|            0|  0.00%|    return None
  1777|         0|            0|            0|  0.00%|
  1778|         2|  4.52995e-06|  2.26498e-06|  0.00%|def _allow_reckless_class_checks(depth=2):
  1779|         0|            0|            0|  0.00%|    """Allow instance and class checks for special stdlib modules.
  1780|         0|            0|            0|  0.00%|
  1781|         0|            0|            0|  0.00%|    The abc and functools modules indiscriminately call isinstance() and
  1782|         0|            0|            0|  0.00%|    issubclass() on the whole MRO of a user class, which may contain protocols.
  1783|         0|            0|            0|  0.00%|    """
  1784|         2|  1.52588e-05|  7.62939e-06|  0.02%|    return _caller(depth) in {'abc', 'functools', None}
(call)|         2|  1.21593e-05|  6.07967e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:1767 _caller
  1785|         0|            0|            0|  0.00%|
  1786|         0|            0|            0|  0.00%|
  1787|         0|            0|            0|  0.00%|_PROTO_ALLOWLIST = {
  1788|         0|            0|            0|  0.00%|    'collections.abc': [
  1789|         0|            0|            0|  0.00%|        'Callable', 'Awaitable', 'Iterable', 'Iterator', 'AsyncIterable',
  1790|         0|            0|            0|  0.00%|        'Hashable', 'Sized', 'Container', 'Collection', 'Reversible', 'Buffer',
  1791|         0|            0|            0|  0.00%|    ],
  1792|         0|            0|            0|  0.00%|    'contextlib': ['AbstractContextManager', 'AbstractAsyncContextManager'],
  1793|         0|            0|            0|  0.00%|}
  1794|         0|            0|            0|  0.00%|
  1795|         0|            0|            0|  0.00%|
  1796|         0|            0|            0|  0.00%|@functools.cache
  1797|         0|            0|            0|  0.00%|def _lazy_load_getattr_static():
  1798|         0|            0|            0|  0.00%|    # Import getattr_static lazily so as not to slow down the import of typing.py
  1799|         0|            0|            0|  0.00%|    # Cache the result so we don't slow down _ProtocolMeta.__instancecheck__ unnecessarily
  1800|         0|            0|            0|  0.00%|    from inspect import getattr_static
  1801|         0|            0|            0|  0.00%|    return getattr_static
  1802|         0|            0|            0|  0.00%|
  1803|         0|            0|            0|  0.00%|
  1804|         0|            0|            0|  0.00%|_cleanups.append(_lazy_load_getattr_static.cache_clear)
  1805|         0|            0|            0|  0.00%|
  1806|         0|            0|            0|  0.00%|def _pickle_psargs(psargs):
  1807|         0|            0|            0|  0.00%|    return ParamSpecArgs, (psargs.__origin__,)
  1808|         0|            0|            0|  0.00%|
  1809|         0|            0|            0|  0.00%|copyreg.pickle(ParamSpecArgs, _pickle_psargs)
  1810|         0|            0|            0|  0.00%|
  1811|         0|            0|            0|  0.00%|def _pickle_pskwargs(pskwargs):
  1812|         0|            0|            0|  0.00%|    return ParamSpecKwargs, (pskwargs.__origin__,)
  1813|         0|            0|            0|  0.00%|
  1814|         0|            0|            0|  0.00%|copyreg.pickle(ParamSpecKwargs, _pickle_pskwargs)
  1815|         0|            0|            0|  0.00%|
  1816|         0|            0|            0|  0.00%|del _pickle_psargs, _pickle_pskwargs
  1817|         0|            0|            0|  0.00%|
  1818|         0|            0|            0|  0.00%|
  1819|         0|            0|            0|  0.00%|class _ProtocolMeta(ABCMeta):
  1820|         0|            0|            0|  0.00%|    # This metaclass is somewhat unfortunate,
  1821|         0|            0|            0|  0.00%|    # but is necessary for several reasons...
  1822|         0|            0|            0|  0.00%|    def __new__(mcls, name, bases, namespace, /, **kwargs):
  1823|         0|            0|            0|  0.00%|        if name == "Protocol" and bases == (Generic,):
  1824|         0|            0|            0|  0.00%|            pass
  1825|         0|            0|            0|  0.00%|        elif Protocol in bases:
  1826|         0|            0|            0|  0.00%|            for base in bases:
  1827|         0|            0|            0|  0.00%|                if not (
  1828|         0|            0|            0|  0.00%|                    base in {object, Generic}
  1829|         0|            0|            0|  0.00%|                    or base.__name__ in _PROTO_ALLOWLIST.get(base.__module__, [])
  1830|         0|            0|            0|  0.00%|                    or (
  1831|         0|            0|            0|  0.00%|                        issubclass(base, Generic)
  1832|         0|            0|            0|  0.00%|                        and getattr(base, "_is_protocol", False)
  1833|         0|            0|            0|  0.00%|                    )
  1834|         0|            0|            0|  0.00%|                ):
  1835|         0|            0|            0|  0.00%|                    raise TypeError(
  1836|         0|            0|            0|  0.00%|                        f"Protocols can only inherit from other protocols, "
  1837|         0|            0|            0|  0.00%|                        f"got {base!r}"
  1838|         0|            0|            0|  0.00%|                    )
  1839|         0|            0|            0|  0.00%|        return super().__new__(mcls, name, bases, namespace, **kwargs)
  1840|         0|            0|            0|  0.00%|
  1841|         0|            0|            0|  0.00%|    def __init__(cls, *args, **kwargs):
  1842|         0|            0|            0|  0.00%|        super().__init__(*args, **kwargs)
  1843|         0|            0|            0|  0.00%|        if getattr(cls, "_is_protocol", False):
  1844|         0|            0|            0|  0.00%|            cls.__protocol_attrs__ = _get_protocol_attrs(cls)
  1845|         0|            0|            0|  0.00%|
  1846|        12|  2.00272e-05|  1.66893e-06|  0.02%|    def __subclasscheck__(cls, other):
  1847|        12|   1.7643e-05|  1.47025e-06|  0.02%|        if cls is Protocol:
  1848|         0|            0|            0|  0.00%|            return type.__subclasscheck__(cls, other)
  1849|         0|            0|            0|  0.00%|        if (
  1850|        12|  2.38419e-05|  1.98682e-06|  0.02%|            getattr(cls, '_is_protocol', False)
  1851|         2|  1.38283e-05|  6.91414e-06|  0.01%|            and not _allow_reckless_class_checks()
(call)|         2|  3.19481e-05|   1.5974e-05|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:1778 _allow_reckless_class_checks
  1852|         0|            0|            0|  0.00%|        ):
  1853|         0|            0|            0|  0.00%|            if not isinstance(other, type):
  1854|         0|            0|            0|  0.00%|                # Same error message as for issubclass(1, int).
  1855|         0|            0|            0|  0.00%|                raise TypeError('issubclass() arg 1 must be a class')
  1856|         0|            0|            0|  0.00%|            if not getattr(cls, '_is_runtime_protocol', False):
  1857|         0|            0|            0|  0.00%|                raise TypeError(
  1858|         0|            0|            0|  0.00%|                    "Instance and class checks can only be used with "
  1859|         0|            0|            0|  0.00%|                    "@runtime_checkable protocols"
  1860|         0|            0|            0|  0.00%|                )
  1861|         0|            0|            0|  0.00%|            if (
  1862|         0|            0|            0|  0.00%|                # this attribute is set by @runtime_checkable:
  1863|         0|            0|            0|  0.00%|                cls.__non_callable_proto_members__
  1864|         0|            0|            0|  0.00%|                and cls.__dict__.get("__subclasshook__") is _proto_hook
  1865|         0|            0|            0|  0.00%|            ):
  1866|         0|            0|            0|  0.00%|                raise TypeError(
  1867|         0|            0|            0|  0.00%|                    "Protocols with non-method members don't support issubclass()"
  1868|         0|            0|            0|  0.00%|                )
  1869|        12|  6.22272e-05|   5.1856e-06|  0.06%|        return super().__subclasscheck__(other)
(call)|        12|  0.000474453|  3.95377e-05|  0.49%|# <frozen abc>:121 __subclasscheck__
  1870|         0|            0|            0|  0.00%|
  1871|         4|  1.97887e-05|  4.94719e-06|  0.02%|    def __instancecheck__(cls, instance):
  1872|         0|            0|            0|  0.00%|        # We need this method for situations where attributes are
  1873|         0|            0|            0|  0.00%|        # assigned in __init__.
  1874|         4|  8.82149e-06|  2.20537e-06|  0.01%|        if cls is Protocol:
  1875|         0|            0|            0|  0.00%|            return type.__instancecheck__(cls, instance)
  1876|         4|   1.0252e-05|    2.563e-06|  0.01%|        if not getattr(cls, "_is_protocol", False):
  1877|         0|            0|            0|  0.00%|            # i.e., it's a concrete subclass of a protocol
  1878|         0|            0|            0|  0.00%|            return super().__instancecheck__(instance)
  1879|         0|            0|            0|  0.00%|
  1880|         0|            0|            0|  0.00%|        if (
  1881|         4|  7.86781e-06|  1.96695e-06|  0.01%|            not getattr(cls, '_is_runtime_protocol', False) and
  1882|         0|            0|            0|  0.00%|            not _allow_reckless_class_checks()
  1883|         0|            0|            0|  0.00%|        ):
  1884|         0|            0|            0|  0.00%|            raise TypeError("Instance and class checks can only be used with"
  1885|         0|            0|            0|  0.00%|                            " @runtime_checkable protocols")
  1886|         0|            0|            0|  0.00%|
  1887|         4|  2.74181e-05|  6.85453e-06|  0.03%|        if super().__instancecheck__(instance):
(call)|         4|  0.000578642|   0.00014466|  0.59%|# <frozen abc>:117 __instancecheck__
  1888|         0|            0|            0|  0.00%|            return True
  1889|         0|            0|            0|  0.00%|
  1890|         4|  1.07288e-05|  2.68221e-06|  0.01%|        getattr_static = _lazy_load_getattr_static()
  1891|         4|  8.34465e-06|  2.08616e-06|  0.01%|        for attr in cls.__protocol_attrs__:
  1892|         4|  6.67572e-06|  1.66893e-06|  0.01%|            try:
  1893|         4|  4.48227e-05|  1.12057e-05|  0.05%|                val = getattr_static(instance, attr)
(call)|         4|  0.000484943|  0.000121236|  0.50%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/inspect.py:1816 getattr_static
  1894|         4|  8.10623e-06|  2.02656e-06|  0.01%|            except AttributeError:
  1895|         4|  1.04904e-05|   2.6226e-06|  0.01%|                break
  1896|         0|            0|            0|  0.00%|            # this attribute is set by @runtime_checkable:
  1897|         0|            0|            0|  0.00%|            if val is None and attr not in cls.__non_callable_proto_members__:
  1898|         0|            0|            0|  0.00%|                break
  1899|         0|            0|            0|  0.00%|        else:
  1900|         0|            0|            0|  0.00%|            return True
  1901|         0|            0|            0|  0.00%|
  1902|         4|  6.67572e-06|  1.66893e-06|  0.01%|        return False
  1903|         0|            0|            0|  0.00%|
  1904|         0|            0|            0|  0.00%|
  1905|        12|  2.00272e-05|  1.66893e-06|  0.02%|@classmethod
  1906|         0|            0|            0|  0.00%|def _proto_hook(cls, other):
  1907|        12|  2.88486e-05|  2.40405e-06|  0.03%|    if not cls.__dict__.get('_is_protocol', False):
  1908|        10|   1.4782e-05|   1.4782e-06|  0.02%|        return NotImplemented
  1909|         0|            0|            0|  0.00%|
  1910|         2|  8.10623e-06|  4.05312e-06|  0.01%|    for attr in cls.__protocol_attrs__:
  1911|        12|  1.97887e-05|  1.64906e-06|  0.02%|        for base in other.__mro__:
  1912|         0|            0|            0|  0.00%|            # Check if the members appears in the class dictionary...
  1913|        10|  1.74046e-05|  1.74046e-06|  0.02%|            if attr in base.__dict__:
  1914|         0|            0|            0|  0.00%|                if base.__dict__[attr] is None:
  1915|         0|            0|            0|  0.00%|                    return NotImplemented
  1916|         0|            0|            0|  0.00%|                break
  1917|         0|            0|            0|  0.00%|
  1918|         0|            0|            0|  0.00%|            # ...or in annotations, if it is a sub-protocol.
  1919|        10|  2.09808e-05|  2.09808e-06|  0.02%|            annotations = getattr(base, '__annotations__', {})
  1920|        10|  6.00815e-05|  6.00815e-06|  0.06%|            if (isinstance(annotations, collections.abc.Mapping) and
(call)|        10|  2.67029e-05|  2.67029e-06|  0.03%|# <frozen abc>:117 __instancecheck__
  1921|        10|  1.66893e-05|  1.66893e-06|  0.02%|                    attr in annotations and
  1922|         0|            0|            0|  0.00%|                    issubclass(other, Generic) and getattr(other, '_is_protocol', False)):
  1923|         0|            0|            0|  0.00%|                break
  1924|         0|            0|            0|  0.00%|        else:
  1925|         2|  3.09944e-06|  1.54972e-06|  0.00%|            return NotImplemented
  1926|         0|            0|            0|  0.00%|    return True
  1927|         0|            0|            0|  0.00%|
  1928|         0|            0|            0|  0.00%|
  1929|         0|            0|            0|  0.00%|class Protocol(Generic, metaclass=_ProtocolMeta):
  1930|         0|            0|            0|  0.00%|    """Base class for protocol classes.
  1931|         0|            0|            0|  0.00%|
  1932|         0|            0|            0|  0.00%|    Protocol classes are defined as::
  1933|         0|            0|            0|  0.00%|
  1934|         0|            0|            0|  0.00%|        class Proto(Protocol):
  1935|         0|            0|            0|  0.00%|            def meth(self) -> int:
  1936|         0|            0|            0|  0.00%|                ...
  1937|         0|            0|            0|  0.00%|
  1938|         0|            0|            0|  0.00%|    Such classes are primarily used with static type checkers that recognize
  1939|         0|            0|            0|  0.00%|    structural subtyping (static duck-typing).
  1940|         0|            0|            0|  0.00%|
  1941|         0|            0|            0|  0.00%|    For example::
  1942|         0|            0|            0|  0.00%|
  1943|         0|            0|            0|  0.00%|        class C:
  1944|         0|            0|            0|  0.00%|            def meth(self) -> int:
  1945|         0|            0|            0|  0.00%|                return 0
  1946|         0|            0|            0|  0.00%|
  1947|         0|            0|            0|  0.00%|        def func(x: Proto) -> int:
  1948|         0|            0|            0|  0.00%|            return x.meth()
  1949|         0|            0|            0|  0.00%|
  1950|         0|            0|            0|  0.00%|        func(C())  # Passes static type check
  1951|         0|            0|            0|  0.00%|
  1952|         0|            0|            0|  0.00%|    See PEP 544 for details. Protocol classes decorated with
  1953|         0|            0|            0|  0.00%|    @typing.runtime_checkable act as simple-minded runtime protocols that check
  1954|         0|            0|            0|  0.00%|    only the presence of given attributes, ignoring their type signatures.
  1955|         0|            0|            0|  0.00%|    Protocol classes can be generic, they are defined as::
  1956|         0|            0|            0|  0.00%|
  1957|         0|            0|            0|  0.00%|        class GenProto[T](Protocol):
  1958|         0|            0|            0|  0.00%|            def meth(self) -> T:
  1959|         0|            0|            0|  0.00%|                ...
  1960|         0|            0|            0|  0.00%|    """
  1961|         0|            0|            0|  0.00%|
  1962|         0|            0|            0|  0.00%|    __slots__ = ()
  1963|         0|            0|            0|  0.00%|    _is_protocol = True
  1964|         0|            0|            0|  0.00%|    _is_runtime_protocol = False
  1965|         0|            0|            0|  0.00%|
  1966|         0|            0|            0|  0.00%|    def __init_subclass__(cls, *args, **kwargs):
  1967|         0|            0|            0|  0.00%|        super().__init_subclass__(*args, **kwargs)
  1968|         0|            0|            0|  0.00%|
  1969|         0|            0|            0|  0.00%|        # Determine if this is a protocol or a concrete subclass.
  1970|         0|            0|            0|  0.00%|        if not cls.__dict__.get('_is_protocol', False):
  1971|         0|            0|            0|  0.00%|            cls._is_protocol = any(b is Protocol for b in cls.__bases__)
  1972|         0|            0|            0|  0.00%|
  1973|         0|            0|            0|  0.00%|        # Set (or override) the protocol subclass hook.
  1974|         0|            0|            0|  0.00%|        if '__subclasshook__' not in cls.__dict__:
  1975|         0|            0|            0|  0.00%|            cls.__subclasshook__ = _proto_hook
  1976|         0|            0|            0|  0.00%|
  1977|         0|            0|            0|  0.00%|        # Prohibit instantiation for protocol classes
  1978|         0|            0|            0|  0.00%|        if cls._is_protocol and cls.__init__ is Protocol.__init__:
  1979|         0|            0|            0|  0.00%|            cls.__init__ = _no_init_or_replace_init
  1980|         0|            0|            0|  0.00%|
  1981|         0|            0|            0|  0.00%|
  1982|         0|            0|            0|  0.00%|class _AnnotatedAlias(_NotIterable, _GenericAlias, _root=True):
  1983|         0|            0|            0|  0.00%|    """Runtime representation of an annotated type.
  1984|         0|            0|            0|  0.00%|
  1985|         0|            0|            0|  0.00%|    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
  1986|         0|            0|            0|  0.00%|    with extra annotations. The alias behaves like a normal typing alias.
  1987|         0|            0|            0|  0.00%|    Instantiating is the same as instantiating the underlying type; binding
  1988|         0|            0|            0|  0.00%|    it to types is also the same.
  1989|         0|            0|            0|  0.00%|
  1990|         0|            0|            0|  0.00%|    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  1991|         0|            0|            0|  0.00%|    """
  1992|         0|            0|            0|  0.00%|
  1993|         2|  4.52995e-06|  2.26498e-06|  0.00%|    def __init__(self, origin, metadata):
  1994|         2|  3.57628e-06|  1.78814e-06|  0.00%|        if isinstance(origin, _AnnotatedAlias):
  1995|         0|            0|            0|  0.00%|            metadata = origin.__metadata__ + metadata
  1996|         0|            0|            0|  0.00%|            origin = origin.__origin__
  1997|         2|  1.95503e-05|  9.77516e-06|  0.02%|        super().__init__(origin, origin, name='Annotated')
(call)|         2|  0.000429392|  0.000214696|  0.44%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:1242 __init__
  1998|         2|  1.07288e-05|  5.36442e-06|  0.01%|        self.__metadata__ = metadata
(call)|         2|  2.07424e-05|  1.03712e-05|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:1188 __setattr__
  1999|         0|            0|            0|  0.00%|
  2000|         0|            0|            0|  0.00%|    def copy_with(self, params):
  2001|         0|            0|            0|  0.00%|        assert len(params) == 1
  2002|         0|            0|            0|  0.00%|        new_type = params[0]
  2003|         0|            0|            0|  0.00%|        return _AnnotatedAlias(new_type, self.__metadata__)
  2004|         0|            0|            0|  0.00%|
  2005|         2|  8.34465e-06|  4.17233e-06|  0.01%|    def __repr__(self):
  2006|         4|  9.77516e-06|  2.44379e-06|  0.01%|        return "typing.Annotated[{}, {}]".format(
  2007|         2|  2.28882e-05|  1.14441e-05|  0.02%|            _type_repr(self.__origin__),
(call)|         2|  2.14577e-05|  1.07288e-05|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:237 _type_repr
  2008|        10|  4.43459e-05|  4.43459e-06|  0.05%|            ", ".join(repr(a) for a in self.__metadata__)
(call)|         2|  1.23978e-05|  6.19888e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/params.py:131 __repr__
(call)|         4|  3.40939e-05|  8.52346e-06|  0.04%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:2008 <genexpr>
  2009|         0|            0|            0|  0.00%|        )
  2010|         0|            0|            0|  0.00%|
  2011|         0|            0|            0|  0.00%|    def __reduce__(self):
  2012|         0|            0|            0|  0.00%|        return operator.getitem, (
  2013|         0|            0|            0|  0.00%|            Annotated, (self.__origin__,) + self.__metadata__
  2014|         0|            0|            0|  0.00%|        )
  2015|         0|            0|            0|  0.00%|
  2016|         0|            0|            0|  0.00%|    def __eq__(self, other):
  2017|         0|            0|            0|  0.00%|        if not isinstance(other, _AnnotatedAlias):
  2018|         0|            0|            0|  0.00%|            return NotImplemented
  2019|         0|            0|            0|  0.00%|        return (self.__origin__ == other.__origin__
  2020|         0|            0|            0|  0.00%|                and self.__metadata__ == other.__metadata__)
  2021|         0|            0|            0|  0.00%|
  2022|         0|            0|            0|  0.00%|    def __hash__(self):
  2023|         0|            0|            0|  0.00%|        return hash((self.__origin__, self.__metadata__))
  2024|         0|            0|            0|  0.00%|
  2025|        12|  3.38554e-05|  2.82129e-06|  0.03%|    def __getattr__(self, attr):
  2026|        12|   2.3365e-05|  1.94709e-06|  0.02%|        if attr in {'__name__', '__qualname__'}:
  2027|         0|            0|            0|  0.00%|            return 'Annotated'
  2028|        12|  8.03471e-05|  6.69559e-06|  0.08%|        return super().__getattr__(attr)
(call)|        12|  0.000190973|  1.59144e-05|  0.20%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:1178 __getattr__
  2029|         0|            0|            0|  0.00%|
  2030|         0|            0|            0|  0.00%|    def __mro_entries__(self, bases):
  2031|         0|            0|            0|  0.00%|        return (self.__origin__,)
  2032|         0|            0|            0|  0.00%|
  2033|         0|            0|            0|  0.00%|
  2034|         0|            0|            0|  0.00%|class Annotated:
  2035|         0|            0|            0|  0.00%|    """Add context-specific metadata to a type.
  2036|         0|            0|            0|  0.00%|
  2037|         0|            0|            0|  0.00%|    Example: Annotated[int, runtime_check.Unsigned] indicates to the
  2038|         0|            0|            0|  0.00%|    hypothetical runtime_check module that this type is an unsigned int.
  2039|         0|            0|            0|  0.00%|    Every other consumer of this type can ignore this metadata and treat
  2040|         0|            0|            0|  0.00%|    this type as int.
  2041|         0|            0|            0|  0.00%|
  2042|         0|            0|            0|  0.00%|    The first argument to Annotated must be a valid type.
  2043|         0|            0|            0|  0.00%|
  2044|         0|            0|            0|  0.00%|    Details:
  2045|         0|            0|            0|  0.00%|
  2046|         0|            0|            0|  0.00%|    - It's an error to call `Annotated` with less than two arguments.
  2047|         0|            0|            0|  0.00%|    - Access the metadata via the ``__metadata__`` attribute::
  2048|         0|            0|            0|  0.00%|
  2049|         0|            0|            0|  0.00%|        assert Annotated[int, '$'].__metadata__ == ('$',)
  2050|         0|            0|            0|  0.00%|
  2051|         0|            0|            0|  0.00%|    - Nested Annotated types are flattened::
  2052|         0|            0|            0|  0.00%|
  2053|         0|            0|            0|  0.00%|        assert Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3]
  2054|         0|            0|            0|  0.00%|
  2055|         0|            0|            0|  0.00%|    - Instantiating an annotated type is equivalent to instantiating the
  2056|         0|            0|            0|  0.00%|    underlying type::
  2057|         0|            0|            0|  0.00%|
  2058|         0|            0|            0|  0.00%|        assert Annotated[C, Ann1](5) == C(5)
  2059|         0|            0|            0|  0.00%|
  2060|         0|            0|            0|  0.00%|    - Annotated can be used as a generic type alias::
  2061|         0|            0|            0|  0.00%|
  2062|         0|            0|            0|  0.00%|        type Optimized[T] = Annotated[T, runtime.Optimize()]
  2063|         0|            0|            0|  0.00%|        # type checker will treat Optimized[int]
  2064|         0|            0|            0|  0.00%|        # as equivalent to Annotated[int, runtime.Optimize()]
  2065|         0|            0|            0|  0.00%|
  2066|         0|            0|            0|  0.00%|        type OptimizedList[T] = Annotated[list[T], runtime.Optimize()]
  2067|         0|            0|            0|  0.00%|        # type checker will treat OptimizedList[int]
  2068|         0|            0|            0|  0.00%|        # as equivalent to Annotated[list[int], runtime.Optimize()]
  2069|         0|            0|            0|  0.00%|
  2070|         0|            0|            0|  0.00%|    - Annotated cannot be used with an unpacked TypeVarTuple::
  2071|         0|            0|            0|  0.00%|
  2072|         0|            0|            0|  0.00%|        type Variadic[*Ts] = Annotated[*Ts, Ann1]  # NOT valid
  2073|         0|            0|            0|  0.00%|
  2074|         0|            0|            0|  0.00%|      This would be equivalent to::
  2075|         0|            0|            0|  0.00%|
  2076|         0|            0|            0|  0.00%|        Annotated[T1, T2, T3, ..., Ann1]
  2077|         0|            0|            0|  0.00%|
  2078|         0|            0|            0|  0.00%|      where T1, T2 etc. are TypeVars, which would be invalid, because
  2079|         0|            0|            0|  0.00%|      only one type should be passed to Annotated.
  2080|         0|            0|            0|  0.00%|    """
  2081|         0|            0|            0|  0.00%|
  2082|         0|            0|            0|  0.00%|    __slots__ = ()
  2083|         0|            0|            0|  0.00%|
  2084|         0|            0|            0|  0.00%|    def __new__(cls, *args, **kwargs):
  2085|         0|            0|            0|  0.00%|        raise TypeError("Type Annotated cannot be instantiated.")
  2086|         0|            0|            0|  0.00%|
  2087|         4|  8.10623e-06|  2.02656e-06|  0.01%|    def __class_getitem__(cls, params):
  2088|         4|  5.96046e-06|  1.49012e-06|  0.01%|        if not isinstance(params, tuple):
  2089|         0|            0|            0|  0.00%|            params = (params,)
  2090|         4|  2.76566e-05|  6.91414e-06|  0.03%|        return cls._class_getitem_inner(cls, *params)
(call)|         4|  0.000709057|  0.000177264|  0.73%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:392 inner
  2091|         0|            0|            0|  0.00%|
  2092|         2|  6.67572e-06|  3.33786e-06|  0.01%|    @_tp_cache(typed=True)
  2093|         0|            0|            0|  0.00%|    def _class_getitem_inner(cls, *params):
  2094|         2|   6.4373e-06|  3.21865e-06|  0.01%|        if len(params) < 2:
  2095|         0|            0|            0|  0.00%|            raise TypeError("Annotated[...] should be used "
  2096|         0|            0|            0|  0.00%|                            "with at least two arguments (a type and an "
  2097|         0|            0|            0|  0.00%|                            "annotation).")
  2098|         2|  1.90735e-05|  9.53674e-06|  0.02%|        if _is_unpacked_typevartuple(params[0]):
(call)|         2|  8.10623e-06|  4.05312e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:961 _is_unpacked_typevartuple
  2099|         0|            0|            0|  0.00%|            raise TypeError("Annotated[...] should not be used with an "
  2100|         0|            0|            0|  0.00%|                            "unpacked TypeVarTuple")
  2101|         2|   6.4373e-06|  3.21865e-06|  0.01%|        msg = "Annotated[t, ...]: t must be a type."
  2102|         2|  2.64645e-05|  1.32322e-05|  0.03%|        origin = _type_check(params[0], msg, allow_special_forms=True)
(call)|         2|  8.46386e-05|  4.23193e-05|  0.09%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:175 _type_check
  2103|         2|  5.00679e-06|   2.5034e-06|  0.01%|        metadata = tuple(params[1:])
  2104|         2|  1.93119e-05|  9.65595e-06|  0.02%|        return _AnnotatedAlias(origin, metadata)
(call)|         2|   0.00048852|   0.00024426|  0.50%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:1993 __init__
  2105|         0|            0|            0|  0.00%|
  2106|         0|            0|            0|  0.00%|    def __init_subclass__(cls, *args, **kwargs):
  2107|         0|            0|            0|  0.00%|        raise TypeError(
  2108|         0|            0|            0|  0.00%|            "Cannot subclass {}.Annotated".format(cls.__module__)
  2109|         0|            0|            0|  0.00%|        )
  2110|         0|            0|            0|  0.00%|
  2111|         0|            0|            0|  0.00%|
  2112|         0|            0|            0|  0.00%|def runtime_checkable(cls):
  2113|         0|            0|            0|  0.00%|    """Mark a protocol class as a runtime protocol.
  2114|         0|            0|            0|  0.00%|
  2115|         0|            0|            0|  0.00%|    Such protocol can be used with isinstance() and issubclass().
  2116|         0|            0|            0|  0.00%|    Raise TypeError if applied to a non-protocol class.
  2117|         0|            0|            0|  0.00%|    This allows a simple-minded structural check very similar to
  2118|         0|            0|            0|  0.00%|    one trick ponies in collections.abc such as Iterable.
  2119|         0|            0|            0|  0.00%|
  2120|         0|            0|            0|  0.00%|    For example::
  2121|         0|            0|            0|  0.00%|
  2122|         0|            0|            0|  0.00%|        @runtime_checkable
  2123|         0|            0|            0|  0.00%|        class Closable(Protocol):
  2124|         0|            0|            0|  0.00%|            def close(self): ...
  2125|         0|            0|            0|  0.00%|
  2126|         0|            0|            0|  0.00%|        assert isinstance(open('/some/file'), Closable)
  2127|         0|            0|            0|  0.00%|
  2128|         0|            0|            0|  0.00%|    Warning: this will check only the presence of the required methods,
  2129|         0|            0|            0|  0.00%|    not their type signatures!
  2130|         0|            0|            0|  0.00%|    """
  2131|         0|            0|            0|  0.00%|    if not issubclass(cls, Generic) or not getattr(cls, '_is_protocol', False):
  2132|         0|            0|            0|  0.00%|        raise TypeError('@runtime_checkable can be only applied to protocol classes,'
  2133|         0|            0|            0|  0.00%|                        ' got %r' % cls)
  2134|         0|            0|            0|  0.00%|    cls._is_runtime_protocol = True
  2135|         0|            0|            0|  0.00%|    # PEP 544 prohibits using issubclass()
  2136|         0|            0|            0|  0.00%|    # with protocols that have non-method members.
  2137|         0|            0|            0|  0.00%|    # See gh-113320 for why we compute this attribute here,
  2138|         0|            0|            0|  0.00%|    # rather than in `_ProtocolMeta.__init__`
  2139|         0|            0|            0|  0.00%|    cls.__non_callable_proto_members__ = set()
  2140|         0|            0|            0|  0.00%|    for attr in cls.__protocol_attrs__:
  2141|         0|            0|            0|  0.00%|        try:
  2142|         0|            0|            0|  0.00%|            is_callable = callable(getattr(cls, attr, None))
  2143|         0|            0|            0|  0.00%|        except Exception as e:
  2144|         0|            0|            0|  0.00%|            raise TypeError(
  2145|         0|            0|            0|  0.00%|                f"Failed to determine whether protocol member {attr!r} "
  2146|         0|            0|            0|  0.00%|                "is a method member"
  2147|         0|            0|            0|  0.00%|            ) from e
  2148|         0|            0|            0|  0.00%|        else:
  2149|         0|            0|            0|  0.00%|            if not is_callable:
  2150|         0|            0|            0|  0.00%|                cls.__non_callable_proto_members__.add(attr)
  2151|         0|            0|            0|  0.00%|    return cls
  2152|         0|            0|            0|  0.00%|
  2153|         0|            0|            0|  0.00%|
  2154|         4|  1.00136e-05|   2.5034e-06|  0.01%|def cast(typ, val):
  2155|         0|            0|            0|  0.00%|    """Cast a value to a type.
  2156|         0|            0|            0|  0.00%|
  2157|         0|            0|            0|  0.00%|    This returns the value unchanged.  To the type checker this
  2158|         0|            0|            0|  0.00%|    signals that the return value has the designated type, but at
  2159|         0|            0|            0|  0.00%|    runtime we intentionally don't check anything (we want this
  2160|         0|            0|            0|  0.00%|    to be as fast as possible).
  2161|         0|            0|            0|  0.00%|    """
  2162|         4|  5.72205e-06|  1.43051e-06|  0.01%|    return val
  2163|         0|            0|            0|  0.00%|
  2164|         0|            0|            0|  0.00%|
  2165|         0|            0|            0|  0.00%|def assert_type(val, typ, /):
  2166|         0|            0|            0|  0.00%|    """Ask a static type checker to confirm that the value is of the given type.
  2167|         0|            0|            0|  0.00%|
  2168|         0|            0|            0|  0.00%|    At runtime this does nothing: it returns the first argument unchanged with no
  2169|         0|            0|            0|  0.00%|    checks or side effects, no matter the actual type of the argument.
  2170|         0|            0|            0|  0.00%|
  2171|         0|            0|            0|  0.00%|    When a static type checker encounters a call to assert_type(), it
  2172|         0|            0|            0|  0.00%|    emits an error if the value is not of the specified type::
  2173|         0|            0|            0|  0.00%|
  2174|         0|            0|            0|  0.00%|        def greet(name: str) -> None:
  2175|         0|            0|            0|  0.00%|            assert_type(name, str)  # OK
  2176|         0|            0|            0|  0.00%|            assert_type(name, int)  # type checker error
  2177|         0|            0|            0|  0.00%|    """
  2178|         0|            0|            0|  0.00%|    return val
  2179|         0|            0|            0|  0.00%|
  2180|         0|            0|            0|  0.00%|
  2181|         0|            0|            0|  0.00%|_allowed_types = (types.FunctionType, types.BuiltinFunctionType,
  2182|         0|            0|            0|  0.00%|                  types.MethodType, types.ModuleType,
  2183|         0|            0|            0|  0.00%|                  WrapperDescriptorType, MethodWrapperType, MethodDescriptorType)
  2184|         0|            0|            0|  0.00%|
  2185|         0|            0|            0|  0.00%|
  2186|         0|            0|            0|  0.00%|def get_type_hints(obj, globalns=None, localns=None, include_extras=False):
  2187|         0|            0|            0|  0.00%|    """Return type hints for an object.
  2188|         0|            0|            0|  0.00%|
  2189|         0|            0|            0|  0.00%|    This is often the same as obj.__annotations__, but it handles
  2190|         0|            0|            0|  0.00%|    forward references encoded as string literals and recursively replaces all
  2191|         0|            0|            0|  0.00%|    'Annotated[T, ...]' with 'T' (unless 'include_extras=True').
  2192|         0|            0|            0|  0.00%|
  2193|         0|            0|            0|  0.00%|    The argument may be a module, class, method, or function. The annotations
  2194|         0|            0|            0|  0.00%|    are returned as a dictionary. For classes, annotations include also
  2195|         0|            0|            0|  0.00%|    inherited members.
  2196|         0|            0|            0|  0.00%|
  2197|         0|            0|            0|  0.00%|    TypeError is raised if the argument is not of a type that can contain
  2198|         0|            0|            0|  0.00%|    annotations, and an empty dictionary is returned if no annotations are
  2199|         0|            0|            0|  0.00%|    present.
  2200|         0|            0|            0|  0.00%|
  2201|         0|            0|            0|  0.00%|    BEWARE -- the behavior of globalns and localns is counterintuitive
  2202|         0|            0|            0|  0.00%|    (unless you are familiar with how eval() and exec() work).  The
  2203|         0|            0|            0|  0.00%|    search order is locals first, then globals.
  2204|         0|            0|            0|  0.00%|
  2205|         0|            0|            0|  0.00%|    - If no dict arguments are passed, an attempt is made to use the
  2206|         0|            0|            0|  0.00%|      globals from obj (or the respective module's globals for classes),
  2207|         0|            0|            0|  0.00%|      and these are also used as the locals.  If the object does not appear
  2208|         0|            0|            0|  0.00%|      to have globals, an empty dictionary is used.  For classes, the search
  2209|         0|            0|            0|  0.00%|      order is globals first then locals.
  2210|         0|            0|            0|  0.00%|
  2211|         0|            0|            0|  0.00%|    - If one dict argument is passed, it is used for both globals and
  2212|         0|            0|            0|  0.00%|      locals.
  2213|         0|            0|            0|  0.00%|
  2214|         0|            0|            0|  0.00%|    - If two dict arguments are passed, they specify globals and
  2215|         0|            0|            0|  0.00%|      locals, respectively.
  2216|         0|            0|            0|  0.00%|    """
  2217|         0|            0|            0|  0.00%|    if getattr(obj, '__no_type_check__', None):
  2218|         0|            0|            0|  0.00%|        return {}
  2219|         0|            0|            0|  0.00%|    # Classes require a special treatment.
  2220|         0|            0|            0|  0.00%|    if isinstance(obj, type):
  2221|         0|            0|            0|  0.00%|        hints = {}
  2222|         0|            0|            0|  0.00%|        for base in reversed(obj.__mro__):
  2223|         0|            0|            0|  0.00%|            if globalns is None:
  2224|         0|            0|            0|  0.00%|                base_globals = getattr(sys.modules.get(base.__module__, None), '__dict__', {})
  2225|         0|            0|            0|  0.00%|            else:
  2226|         0|            0|            0|  0.00%|                base_globals = globalns
  2227|         0|            0|            0|  0.00%|            ann = base.__dict__.get('__annotations__', {})
  2228|         0|            0|            0|  0.00%|            if isinstance(ann, types.GetSetDescriptorType):
  2229|         0|            0|            0|  0.00%|                ann = {}
  2230|         0|            0|            0|  0.00%|            base_locals = dict(vars(base)) if localns is None else localns
  2231|         0|            0|            0|  0.00%|            if localns is None and globalns is None:
  2232|         0|            0|            0|  0.00%|                # This is surprising, but required.  Before Python 3.10,
  2233|         0|            0|            0|  0.00%|                # get_type_hints only evaluated the globalns of
  2234|         0|            0|            0|  0.00%|                # a class.  To maintain backwards compatibility, we reverse
  2235|         0|            0|            0|  0.00%|                # the globalns and localns order so that eval() looks into
  2236|         0|            0|            0|  0.00%|                # *base_globals* first rather than *base_locals*.
  2237|         0|            0|            0|  0.00%|                # This only affects ForwardRefs.
  2238|         0|            0|            0|  0.00%|                base_globals, base_locals = base_locals, base_globals
  2239|         0|            0|            0|  0.00%|            for name, value in ann.items():
  2240|         0|            0|            0|  0.00%|                if value is None:
  2241|         0|            0|            0|  0.00%|                    value = type(None)
  2242|         0|            0|            0|  0.00%|                if isinstance(value, str):
  2243|         0|            0|            0|  0.00%|                    value = ForwardRef(value, is_argument=False, is_class=True)
  2244|         0|            0|            0|  0.00%|                value = _eval_type(value, base_globals, base_locals)
  2245|         0|            0|            0|  0.00%|                hints[name] = value
  2246|         0|            0|            0|  0.00%|        return hints if include_extras else {k: _strip_annotations(t) for k, t in hints.items()}
  2247|         0|            0|            0|  0.00%|
  2248|         0|            0|            0|  0.00%|    if globalns is None:
  2249|         0|            0|            0|  0.00%|        if isinstance(obj, types.ModuleType):
  2250|         0|            0|            0|  0.00%|            globalns = obj.__dict__
  2251|         0|            0|            0|  0.00%|        else:
  2252|         0|            0|            0|  0.00%|            nsobj = obj
  2253|         0|            0|            0|  0.00%|            # Find globalns for the unwrapped object.
  2254|         0|            0|            0|  0.00%|            while hasattr(nsobj, '__wrapped__'):
  2255|         0|            0|            0|  0.00%|                nsobj = nsobj.__wrapped__
  2256|         0|            0|            0|  0.00%|            globalns = getattr(nsobj, '__globals__', {})
  2257|         0|            0|            0|  0.00%|        if localns is None:
  2258|         0|            0|            0|  0.00%|            localns = globalns
  2259|         0|            0|            0|  0.00%|    elif localns is None:
  2260|         0|            0|            0|  0.00%|        localns = globalns
  2261|         0|            0|            0|  0.00%|    hints = getattr(obj, '__annotations__', None)
  2262|         0|            0|            0|  0.00%|    if hints is None:
  2263|         0|            0|            0|  0.00%|        # Return empty annotations for something that _could_ have them.
  2264|         0|            0|            0|  0.00%|        if isinstance(obj, _allowed_types):
  2265|         0|            0|            0|  0.00%|            return {}
  2266|         0|            0|            0|  0.00%|        else:
  2267|         0|            0|            0|  0.00%|            raise TypeError('{!r} is not a module, class, method, '
  2268|         0|            0|            0|  0.00%|                            'or function.'.format(obj))
  2269|         0|            0|            0|  0.00%|    hints = dict(hints)
  2270|         0|            0|            0|  0.00%|    for name, value in hints.items():
  2271|         0|            0|            0|  0.00%|        if value is None:
  2272|         0|            0|            0|  0.00%|            value = type(None)
  2273|         0|            0|            0|  0.00%|        if isinstance(value, str):
  2274|         0|            0|            0|  0.00%|            # class-level forward refs were handled above, this must be either
  2275|         0|            0|            0|  0.00%|            # a module-level annotation or a function argument annotation
  2276|         0|            0|            0|  0.00%|            value = ForwardRef(
  2277|         0|            0|            0|  0.00%|                value,
  2278|         0|            0|            0|  0.00%|                is_argument=not isinstance(obj, types.ModuleType),
  2279|         0|            0|            0|  0.00%|                is_class=False,
  2280|         0|            0|            0|  0.00%|            )
  2281|         0|            0|            0|  0.00%|        hints[name] = _eval_type(value, globalns, localns)
  2282|         0|            0|            0|  0.00%|    return hints if include_extras else {k: _strip_annotations(t) for k, t in hints.items()}
  2283|         0|            0|            0|  0.00%|
  2284|         0|            0|            0|  0.00%|
  2285|         0|            0|            0|  0.00%|def _strip_annotations(t):
  2286|         0|            0|            0|  0.00%|    """Strip the annotations from a given type."""
  2287|         0|            0|            0|  0.00%|    if isinstance(t, _AnnotatedAlias):
  2288|         0|            0|            0|  0.00%|        return _strip_annotations(t.__origin__)
  2289|         0|            0|            0|  0.00%|    if hasattr(t, "__origin__") and t.__origin__ in (Required, NotRequired):
  2290|         0|            0|            0|  0.00%|        return _strip_annotations(t.__args__[0])
  2291|         0|            0|            0|  0.00%|    if isinstance(t, _GenericAlias):
  2292|         0|            0|            0|  0.00%|        stripped_args = tuple(_strip_annotations(a) for a in t.__args__)
  2293|         0|            0|            0|  0.00%|        if stripped_args == t.__args__:
  2294|         0|            0|            0|  0.00%|            return t
  2295|         0|            0|            0|  0.00%|        return t.copy_with(stripped_args)
  2296|         0|            0|            0|  0.00%|    if isinstance(t, GenericAlias):
  2297|         0|            0|            0|  0.00%|        stripped_args = tuple(_strip_annotations(a) for a in t.__args__)
  2298|         0|            0|            0|  0.00%|        if stripped_args == t.__args__:
  2299|         0|            0|            0|  0.00%|            return t
  2300|         0|            0|            0|  0.00%|        return GenericAlias(t.__origin__, stripped_args)
  2301|         0|            0|            0|  0.00%|    if isinstance(t, types.UnionType):
  2302|         0|            0|            0|  0.00%|        stripped_args = tuple(_strip_annotations(a) for a in t.__args__)
  2303|         0|            0|            0|  0.00%|        if stripped_args == t.__args__:
  2304|         0|            0|            0|  0.00%|            return t
  2305|         0|            0|            0|  0.00%|        return functools.reduce(operator.or_, stripped_args)
  2306|         0|            0|            0|  0.00%|
  2307|         0|            0|            0|  0.00%|    return t
  2308|         0|            0|            0|  0.00%|
  2309|         0|            0|            0|  0.00%|
  2310|        25|  7.31945e-05|  2.92778e-06|  0.08%|def get_origin(tp):
  2311|         0|            0|            0|  0.00%|    """Get the unsubscripted version of a type.
  2312|         0|            0|            0|  0.00%|
  2313|         0|            0|            0|  0.00%|    This supports generic types, Callable, Tuple, Union, Literal, Final, ClassVar,
  2314|         0|            0|            0|  0.00%|    Annotated, and others. Return None for unsupported types.
  2315|         0|            0|            0|  0.00%|
  2316|         0|            0|            0|  0.00%|    Examples::
  2317|         0|            0|            0|  0.00%|
  2318|         0|            0|            0|  0.00%|        >>> P = ParamSpec('P')
  2319|         0|            0|            0|  0.00%|        >>> assert get_origin(Literal[42]) is Literal
  2320|         0|            0|            0|  0.00%|        >>> assert get_origin(int) is None
  2321|         0|            0|            0|  0.00%|        >>> assert get_origin(ClassVar[int]) is ClassVar
  2322|         0|            0|            0|  0.00%|        >>> assert get_origin(Generic) is Generic
  2323|         0|            0|            0|  0.00%|        >>> assert get_origin(Generic[T]) is Generic
  2324|         0|            0|            0|  0.00%|        >>> assert get_origin(Union[T, int]) is Union
  2325|         0|            0|            0|  0.00%|        >>> assert get_origin(List[Tuple[T, T]][int]) is list
  2326|         0|            0|            0|  0.00%|        >>> assert get_origin(P.args) is P
  2327|         0|            0|            0|  0.00%|    """
  2328|        25|  5.07832e-05|  2.03133e-06|  0.05%|    if isinstance(tp, _AnnotatedAlias):
  2329|         6|  9.29832e-06|  1.54972e-06|  0.01%|        return Annotated
  2330|        38|  5.38826e-05|  1.41796e-06|  0.06%|    if isinstance(tp, (_BaseGenericAlias, GenericAlias,
  2331|        19|  2.31266e-05|  1.21719e-06|  0.02%|                       ParamSpecArgs, ParamSpecKwargs)):
  2332|         0|            0|            0|  0.00%|        return tp.__origin__
  2333|        19|  2.24113e-05|  1.17954e-06|  0.02%|    if tp is Generic:
  2334|         0|            0|            0|  0.00%|        return Generic
  2335|        19|   2.6226e-05|  1.38032e-06|  0.03%|    if isinstance(tp, types.UnionType):
  2336|         0|            0|            0|  0.00%|        return types.UnionType
  2337|        19|  2.26498e-05|  1.19209e-06|  0.02%|    return None
  2338|         0|            0|            0|  0.00%|
  2339|         0|            0|            0|  0.00%|
  2340|         8|  1.85966e-05|  2.32458e-06|  0.02%|def get_args(tp):
  2341|         0|            0|            0|  0.00%|    """Get type arguments with all substitutions performed.
  2342|         0|            0|            0|  0.00%|
  2343|         0|            0|            0|  0.00%|    For unions, basic simplifications used by Union constructor are performed.
  2344|         0|            0|            0|  0.00%|
  2345|         0|            0|            0|  0.00%|    Examples::
  2346|         0|            0|            0|  0.00%|
  2347|         0|            0|            0|  0.00%|        >>> T = TypeVar('T')
  2348|         0|            0|            0|  0.00%|        >>> assert get_args(Dict[str, int]) == (str, int)
  2349|         0|            0|            0|  0.00%|        >>> assert get_args(int) == ()
  2350|         0|            0|            0|  0.00%|        >>> assert get_args(Union[int, Union[T, int], str][int]) == (int, str)
  2351|         0|            0|            0|  0.00%|        >>> assert get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int])
  2352|         0|            0|            0|  0.00%|        >>> assert get_args(Callable[[], T][int]) == ([], int)
  2353|         0|            0|            0|  0.00%|    """
  2354|         8|   1.3113e-05|  1.63913e-06|  0.01%|    if isinstance(tp, _AnnotatedAlias):
  2355|         8|  1.52588e-05|  1.90735e-06|  0.02%|        return (tp.__origin__,) + tp.__metadata__
  2356|         0|            0|            0|  0.00%|    if isinstance(tp, (_GenericAlias, GenericAlias)):
  2357|         0|            0|            0|  0.00%|        res = tp.__args__
  2358|         0|            0|            0|  0.00%|        if _should_unflatten_callable_args(tp, res):
  2359|         0|            0|            0|  0.00%|            res = (list(res[:-1]), res[-1])
  2360|         0|            0|            0|  0.00%|        return res
  2361|         0|            0|            0|  0.00%|    if isinstance(tp, types.UnionType):
  2362|         0|            0|            0|  0.00%|        return tp.__args__
  2363|         0|            0|            0|  0.00%|    return ()
  2364|         0|            0|            0|  0.00%|
  2365|         0|            0|            0|  0.00%|
  2366|         0|            0|            0|  0.00%|def is_typeddict(tp):
  2367|         0|            0|            0|  0.00%|    """Check if an annotation is a TypedDict class.
  2368|         0|            0|            0|  0.00%|
  2369|         0|            0|            0|  0.00%|    For example::
  2370|         0|            0|            0|  0.00%|
  2371|         0|            0|            0|  0.00%|        >>> from typing import TypedDict
  2372|         0|            0|            0|  0.00%|        >>> class Film(TypedDict):
  2373|         0|            0|            0|  0.00%|        ...     title: str
  2374|         0|            0|            0|  0.00%|        ...     year: int
  2375|         0|            0|            0|  0.00%|        ...
  2376|         0|            0|            0|  0.00%|        >>> is_typeddict(Film)
  2377|         0|            0|            0|  0.00%|        True
  2378|         0|            0|            0|  0.00%|        >>> is_typeddict(dict)
  2379|         0|            0|            0|  0.00%|        False
  2380|         0|            0|            0|  0.00%|    """
  2381|         0|            0|            0|  0.00%|    return isinstance(tp, _TypedDictMeta)
  2382|         0|            0|            0|  0.00%|
  2383|         0|            0|            0|  0.00%|
  2384|         0|            0|            0|  0.00%|_ASSERT_NEVER_REPR_MAX_LENGTH = 100
  2385|         0|            0|            0|  0.00%|
  2386|         0|            0|            0|  0.00%|
  2387|         0|            0|            0|  0.00%|def assert_never(arg: Never, /) -> Never:
  2388|         0|            0|            0|  0.00%|    """Statically assert that a line of code is unreachable.
  2389|         0|            0|            0|  0.00%|
  2390|         0|            0|            0|  0.00%|    Example::
  2391|         0|            0|            0|  0.00%|
  2392|         0|            0|            0|  0.00%|        def int_or_str(arg: int | str) -> None:
  2393|         0|            0|            0|  0.00%|            match arg:
  2394|         0|            0|            0|  0.00%|                case int():
  2395|         0|            0|            0|  0.00%|                    print("It's an int")
  2396|         0|            0|            0|  0.00%|                case str():
  2397|         0|            0|            0|  0.00%|                    print("It's a str")
  2398|         0|            0|            0|  0.00%|                case _:
  2399|         0|            0|            0|  0.00%|                    assert_never(arg)
  2400|         0|            0|            0|  0.00%|
  2401|         0|            0|            0|  0.00%|    If a type checker finds that a call to assert_never() is
  2402|         0|            0|            0|  0.00%|    reachable, it will emit an error.
  2403|         0|            0|            0|  0.00%|
  2404|         0|            0|            0|  0.00%|    At runtime, this throws an exception when called.
  2405|         0|            0|            0|  0.00%|    """
  2406|         0|            0|            0|  0.00%|    value = repr(arg)
  2407|         0|            0|            0|  0.00%|    if len(value) > _ASSERT_NEVER_REPR_MAX_LENGTH:
  2408|         0|            0|            0|  0.00%|        value = value[:_ASSERT_NEVER_REPR_MAX_LENGTH] + '...'
  2409|         0|            0|            0|  0.00%|    raise AssertionError(f"Expected code to be unreachable, but got: {value}")
  2410|         0|            0|            0|  0.00%|
  2411|         0|            0|            0|  0.00%|
  2412|         0|            0|            0|  0.00%|def no_type_check(arg):
  2413|         0|            0|            0|  0.00%|    """Decorator to indicate that annotations are not type hints.
  2414|         0|            0|            0|  0.00%|
  2415|         0|            0|            0|  0.00%|    The argument must be a class or function; if it is a class, it
  2416|         0|            0|            0|  0.00%|    applies recursively to all methods and classes defined in that class
  2417|         0|            0|            0|  0.00%|    (but not to methods defined in its superclasses or subclasses).
  2418|         0|            0|            0|  0.00%|
  2419|         0|            0|            0|  0.00%|    This mutates the function(s) or class(es) in place.
  2420|         0|            0|            0|  0.00%|    """
  2421|         0|            0|            0|  0.00%|    if isinstance(arg, type):
  2422|         0|            0|            0|  0.00%|        for key in dir(arg):
  2423|         0|            0|            0|  0.00%|            obj = getattr(arg, key)
  2424|         0|            0|            0|  0.00%|            if (
  2425|         0|            0|            0|  0.00%|                not hasattr(obj, '__qualname__')
  2426|         0|            0|            0|  0.00%|                or obj.__qualname__ != f'{arg.__qualname__}.{obj.__name__}'
  2427|         0|            0|            0|  0.00%|                or getattr(obj, '__module__', None) != arg.__module__
  2428|         0|            0|            0|  0.00%|            ):
  2429|         0|            0|            0|  0.00%|                # We only modify objects that are defined in this type directly.
  2430|         0|            0|            0|  0.00%|                # If classes / methods are nested in multiple layers,
  2431|         0|            0|            0|  0.00%|                # we will modify them when processing their direct holders.
  2432|         0|            0|            0|  0.00%|                continue
  2433|         0|            0|            0|  0.00%|            # Instance, class, and static methods:
  2434|         0|            0|            0|  0.00%|            if isinstance(obj, types.FunctionType):
  2435|         0|            0|            0|  0.00%|                obj.__no_type_check__ = True
  2436|         0|            0|            0|  0.00%|            if isinstance(obj, types.MethodType):
  2437|         0|            0|            0|  0.00%|                obj.__func__.__no_type_check__ = True
  2438|         0|            0|            0|  0.00%|            # Nested types:
  2439|         0|            0|            0|  0.00%|            if isinstance(obj, type):
  2440|         0|            0|            0|  0.00%|                no_type_check(obj)
  2441|         0|            0|            0|  0.00%|    try:
  2442|         0|            0|            0|  0.00%|        arg.__no_type_check__ = True
  2443|         0|            0|            0|  0.00%|    except TypeError:  # built-in classes
  2444|         0|            0|            0|  0.00%|        pass
  2445|         0|            0|            0|  0.00%|    return arg
  2446|         0|            0|            0|  0.00%|
  2447|         0|            0|            0|  0.00%|
  2448|         0|            0|            0|  0.00%|def no_type_check_decorator(decorator):
  2449|         0|            0|            0|  0.00%|    """Decorator to give another decorator the @no_type_check effect.
  2450|         0|            0|            0|  0.00%|
  2451|         0|            0|            0|  0.00%|    This wraps the decorator with something that wraps the decorated
  2452|         0|            0|            0|  0.00%|    function in @no_type_check.
  2453|         0|            0|            0|  0.00%|    """
  2454|         0|            0|            0|  0.00%|    @functools.wraps(decorator)
  2455|         0|            0|            0|  0.00%|    def wrapped_decorator(*args, **kwds):
  2456|         0|            0|            0|  0.00%|        func = decorator(*args, **kwds)
  2457|         0|            0|            0|  0.00%|        func = no_type_check(func)
  2458|         0|            0|            0|  0.00%|        return func
  2459|         0|            0|            0|  0.00%|
  2460|         0|            0|            0|  0.00%|    return wrapped_decorator
  2461|         0|            0|            0|  0.00%|
  2462|         0|            0|            0|  0.00%|
  2463|         0|            0|            0|  0.00%|def _overload_dummy(*args, **kwds):
  2464|         0|            0|            0|  0.00%|    """Helper for @overload to raise when called."""
  2465|         0|            0|            0|  0.00%|    raise NotImplementedError(
  2466|         0|            0|            0|  0.00%|        "You should not call an overloaded function. "
  2467|         0|            0|            0|  0.00%|        "A series of @overload-decorated functions "
  2468|         0|            0|            0|  0.00%|        "outside a stub module should always be followed "
  2469|         0|            0|            0|  0.00%|        "by an implementation that is not @overload-ed.")
  2470|         0|            0|            0|  0.00%|
  2471|         0|            0|            0|  0.00%|
  2472|         0|            0|            0|  0.00%|# {module: {qualname: {firstlineno: func}}}
  2473|         0|            0|            0|  0.00%|_overload_registry = defaultdict(functools.partial(defaultdict, dict))
  2474|         0|            0|            0|  0.00%|
  2475|         0|            0|            0|  0.00%|
  2476|         0|            0|            0|  0.00%|def overload(func):
  2477|         0|            0|            0|  0.00%|    """Decorator for overloaded functions/methods.
  2478|         0|            0|            0|  0.00%|
  2479|         0|            0|            0|  0.00%|    In a stub file, place two or more stub definitions for the same
  2480|         0|            0|            0|  0.00%|    function in a row, each decorated with @overload.
  2481|         0|            0|            0|  0.00%|
  2482|         0|            0|            0|  0.00%|    For example::
  2483|         0|            0|            0|  0.00%|
  2484|         0|            0|            0|  0.00%|        @overload
  2485|         0|            0|            0|  0.00%|        def utf8(value: None) -> None: ...
  2486|         0|            0|            0|  0.00%|        @overload
  2487|         0|            0|            0|  0.00%|        def utf8(value: bytes) -> bytes: ...
  2488|         0|            0|            0|  0.00%|        @overload
  2489|         0|            0|            0|  0.00%|        def utf8(value: str) -> bytes: ...
  2490|         0|            0|            0|  0.00%|
  2491|         0|            0|            0|  0.00%|    In a non-stub file (i.e. a regular .py file), do the same but
  2492|         0|            0|            0|  0.00%|    follow it with an implementation.  The implementation should *not*
  2493|         0|            0|            0|  0.00%|    be decorated with @overload::
  2494|         0|            0|            0|  0.00%|
  2495|         0|            0|            0|  0.00%|        @overload
  2496|         0|            0|            0|  0.00%|        def utf8(value: None) -> None: ...
  2497|         0|            0|            0|  0.00%|        @overload
  2498|         0|            0|            0|  0.00%|        def utf8(value: bytes) -> bytes: ...
  2499|         0|            0|            0|  0.00%|        @overload
  2500|         0|            0|            0|  0.00%|        def utf8(value: str) -> bytes: ...
  2501|         0|            0|            0|  0.00%|        def utf8(value):
  2502|         0|            0|            0|  0.00%|            ...  # implementation goes here
  2503|         0|            0|            0|  0.00%|
  2504|         0|            0|            0|  0.00%|    The overloads for a function can be retrieved at runtime using the
  2505|         0|            0|            0|  0.00%|    get_overloads() function.
  2506|         0|            0|            0|  0.00%|    """
  2507|         0|            0|            0|  0.00%|    # classmethod and staticmethod
  2508|         0|            0|            0|  0.00%|    f = getattr(func, "__func__", func)
  2509|         0|            0|            0|  0.00%|    try:
  2510|         0|            0|            0|  0.00%|        _overload_registry[f.__module__][f.__qualname__][f.__code__.co_firstlineno] = func
  2511|         0|            0|            0|  0.00%|    except AttributeError:
  2512|         0|            0|            0|  0.00%|        # Not a normal function; ignore.
  2513|         0|            0|            0|  0.00%|        pass
  2514|         0|            0|            0|  0.00%|    return _overload_dummy
  2515|         0|            0|            0|  0.00%|
  2516|         0|            0|            0|  0.00%|
  2517|         0|            0|            0|  0.00%|def get_overloads(func):
  2518|         0|            0|            0|  0.00%|    """Return all defined overloads for *func* as a sequence."""
  2519|         0|            0|            0|  0.00%|    # classmethod and staticmethod
  2520|         0|            0|            0|  0.00%|    f = getattr(func, "__func__", func)
  2521|         0|            0|            0|  0.00%|    if f.__module__ not in _overload_registry:
  2522|         0|            0|            0|  0.00%|        return []
  2523|         0|            0|            0|  0.00%|    mod_dict = _overload_registry[f.__module__]
  2524|         0|            0|            0|  0.00%|    if f.__qualname__ not in mod_dict:
  2525|         0|            0|            0|  0.00%|        return []
  2526|         0|            0|            0|  0.00%|    return list(mod_dict[f.__qualname__].values())
  2527|         0|            0|            0|  0.00%|
  2528|         0|            0|            0|  0.00%|
  2529|         0|            0|            0|  0.00%|def clear_overloads():
  2530|         0|            0|            0|  0.00%|    """Clear all overloads in the registry."""
  2531|         0|            0|            0|  0.00%|    _overload_registry.clear()
  2532|         0|            0|            0|  0.00%|
  2533|         0|            0|            0|  0.00%|
  2534|         0|            0|            0|  0.00%|def final(f):
  2535|         0|            0|            0|  0.00%|    """Decorator to indicate final methods and final classes.
  2536|         0|            0|            0|  0.00%|
  2537|         0|            0|            0|  0.00%|    Use this decorator to indicate to type checkers that the decorated
  2538|         0|            0|            0|  0.00%|    method cannot be overridden, and decorated class cannot be subclassed.
  2539|         0|            0|            0|  0.00%|
  2540|         0|            0|            0|  0.00%|    For example::
  2541|         0|            0|            0|  0.00%|
  2542|         0|            0|            0|  0.00%|        class Base:
  2543|         0|            0|            0|  0.00%|            @final
  2544|         0|            0|            0|  0.00%|            def done(self) -> None:
  2545|         0|            0|            0|  0.00%|                ...
  2546|         0|            0|            0|  0.00%|        class Sub(Base):
  2547|         0|            0|            0|  0.00%|            def done(self) -> None:  # Error reported by type checker
  2548|         0|            0|            0|  0.00%|                ...
  2549|         0|            0|            0|  0.00%|
  2550|         0|            0|            0|  0.00%|        @final
  2551|         0|            0|            0|  0.00%|        class Leaf:
  2552|         0|            0|            0|  0.00%|            ...
  2553|         0|            0|            0|  0.00%|        class Other(Leaf):  # Error reported by type checker
  2554|         0|            0|            0|  0.00%|            ...
  2555|         0|            0|            0|  0.00%|
  2556|         0|            0|            0|  0.00%|    There is no runtime checking of these properties. The decorator
  2557|         0|            0|            0|  0.00%|    attempts to set the ``__final__`` attribute to ``True`` on the decorated
  2558|         0|            0|            0|  0.00%|    object to allow runtime introspection.
  2559|         0|            0|            0|  0.00%|    """
  2560|         0|            0|            0|  0.00%|    try:
  2561|         0|            0|            0|  0.00%|        f.__final__ = True
  2562|         0|            0|            0|  0.00%|    except (AttributeError, TypeError):
  2563|         0|            0|            0|  0.00%|        # Skip the attribute silently if it is not writable.
  2564|         0|            0|            0|  0.00%|        # AttributeError happens if the object has __slots__ or a
  2565|         0|            0|            0|  0.00%|        # read-only property, TypeError if it's a builtin class.
  2566|         0|            0|            0|  0.00%|        pass
  2567|         0|            0|            0|  0.00%|    return f
  2568|         0|            0|            0|  0.00%|
  2569|         0|            0|            0|  0.00%|
  2570|         0|            0|            0|  0.00%|# Some unconstrained type variables.  These were initially used by the container types.
  2571|         0|            0|            0|  0.00%|# They were never meant for export and are now unused, but we keep them around to
  2572|         0|            0|            0|  0.00%|# avoid breaking compatibility with users who import them.
  2573|         0|            0|            0|  0.00%|T = TypeVar('T')  # Any type.
  2574|         0|            0|            0|  0.00%|KT = TypeVar('KT')  # Key type.
  2575|         0|            0|            0|  0.00%|VT = TypeVar('VT')  # Value type.
  2576|         0|            0|            0|  0.00%|T_co = TypeVar('T_co', covariant=True)  # Any type covariant containers.
  2577|         0|            0|            0|  0.00%|V_co = TypeVar('V_co', covariant=True)  # Any type covariant containers.
  2578|         0|            0|            0|  0.00%|VT_co = TypeVar('VT_co', covariant=True)  # Value type covariant containers.
  2579|         0|            0|            0|  0.00%|T_contra = TypeVar('T_contra', contravariant=True)  # Ditto contravariant.
  2580|         0|            0|            0|  0.00%|# Internal type variable used for Type[].
  2581|         0|            0|            0|  0.00%|CT_co = TypeVar('CT_co', covariant=True, bound=type)
  2582|         0|            0|            0|  0.00%|
  2583|         0|            0|            0|  0.00%|
  2584|         0|            0|            0|  0.00%|# A useful type variable with constraints.  This represents string types.
  2585|         0|            0|            0|  0.00%|# (This one *is* for export!)
  2586|         0|            0|            0|  0.00%|AnyStr = TypeVar('AnyStr', bytes, str)
  2587|         0|            0|            0|  0.00%|
  2588|         0|            0|            0|  0.00%|
  2589|         0|            0|            0|  0.00%|# Various ABCs mimicking those in collections.abc.
  2590|         0|            0|            0|  0.00%|_alias = _SpecialGenericAlias
  2591|         0|            0|            0|  0.00%|
  2592|         0|            0|            0|  0.00%|Hashable = _alias(collections.abc.Hashable, 0)  # Not generic.
  2593|         0|            0|            0|  0.00%|Awaitable = _alias(collections.abc.Awaitable, 1)
  2594|         0|            0|            0|  0.00%|Coroutine = _alias(collections.abc.Coroutine, 3)
  2595|         0|            0|            0|  0.00%|AsyncIterable = _alias(collections.abc.AsyncIterable, 1)
  2596|         0|            0|            0|  0.00%|AsyncIterator = _alias(collections.abc.AsyncIterator, 1)
  2597|         0|            0|            0|  0.00%|Iterable = _alias(collections.abc.Iterable, 1)
  2598|         0|            0|            0|  0.00%|Iterator = _alias(collections.abc.Iterator, 1)
  2599|         0|            0|            0|  0.00%|Reversible = _alias(collections.abc.Reversible, 1)
  2600|         0|            0|            0|  0.00%|Sized = _alias(collections.abc.Sized, 0)  # Not generic.
  2601|         0|            0|            0|  0.00%|Container = _alias(collections.abc.Container, 1)
  2602|         0|            0|            0|  0.00%|Collection = _alias(collections.abc.Collection, 1)
  2603|         0|            0|            0|  0.00%|Callable = _CallableType(collections.abc.Callable, 2)
  2604|         0|            0|            0|  0.00%|Callable.__doc__ = \
  2605|         0|            0|            0|  0.00%|    """Deprecated alias to collections.abc.Callable.
  2606|         0|            0|            0|  0.00%|
  2607|         0|            0|            0|  0.00%|    Callable[[int], str] signifies a function that takes a single
  2608|         0|            0|            0|  0.00%|    parameter of type int and returns a str.
  2609|         0|            0|            0|  0.00%|
  2610|         0|            0|            0|  0.00%|    The subscription syntax must always be used with exactly two
  2611|         0|            0|            0|  0.00%|    values: the argument list and the return type.
  2612|         0|            0|            0|  0.00%|    The argument list must be a list of types, a ParamSpec,
  2613|         0|            0|            0|  0.00%|    Concatenate or ellipsis. The return type must be a single type.
  2614|         0|            0|            0|  0.00%|
  2615|         0|            0|            0|  0.00%|    There is no syntax to indicate optional or keyword arguments;
  2616|         0|            0|            0|  0.00%|    such function types are rarely used as callback types.
  2617|         0|            0|            0|  0.00%|    """
  2618|         0|            0|            0|  0.00%|AbstractSet = _alias(collections.abc.Set, 1, name='AbstractSet')
  2619|         0|            0|            0|  0.00%|MutableSet = _alias(collections.abc.MutableSet, 1)
  2620|         0|            0|            0|  0.00%|# NOTE: Mapping is only covariant in the value type.
  2621|         0|            0|            0|  0.00%|Mapping = _alias(collections.abc.Mapping, 2)
  2622|         0|            0|            0|  0.00%|MutableMapping = _alias(collections.abc.MutableMapping, 2)
  2623|         0|            0|            0|  0.00%|Sequence = _alias(collections.abc.Sequence, 1)
  2624|         0|            0|            0|  0.00%|MutableSequence = _alias(collections.abc.MutableSequence, 1)
  2625|         0|            0|            0|  0.00%|ByteString = _DeprecatedGenericAlias(
  2626|         0|            0|            0|  0.00%|    collections.abc.ByteString, 0, removal_version=(3, 14)  # Not generic.
  2627|         0|            0|            0|  0.00%|)
  2628|         0|            0|            0|  0.00%|# Tuple accepts variable number of parameters.
  2629|         0|            0|            0|  0.00%|Tuple = _TupleType(tuple, -1, inst=False, name='Tuple')
  2630|         0|            0|            0|  0.00%|Tuple.__doc__ = \
  2631|         0|            0|            0|  0.00%|    """Deprecated alias to builtins.tuple.
  2632|         0|            0|            0|  0.00%|
  2633|         0|            0|            0|  0.00%|    Tuple[X, Y] is the cross-product type of X and Y.
  2634|         0|            0|            0|  0.00%|
  2635|         0|            0|            0|  0.00%|    Example: Tuple[T1, T2] is a tuple of two elements corresponding
  2636|         0|            0|            0|  0.00%|    to type variables T1 and T2.  Tuple[int, float, str] is a tuple
  2637|         0|            0|            0|  0.00%|    of an int, a float and a string.
  2638|         0|            0|            0|  0.00%|
  2639|         0|            0|            0|  0.00%|    To specify a variable-length tuple of homogeneous type, use Tuple[T, ...].
  2640|         0|            0|            0|  0.00%|    """
  2641|         0|            0|            0|  0.00%|List = _alias(list, 1, inst=False, name='List')
  2642|         0|            0|            0|  0.00%|Deque = _alias(collections.deque, 1, name='Deque')
  2643|         0|            0|            0|  0.00%|Set = _alias(set, 1, inst=False, name='Set')
  2644|         0|            0|            0|  0.00%|FrozenSet = _alias(frozenset, 1, inst=False, name='FrozenSet')
  2645|         0|            0|            0|  0.00%|MappingView = _alias(collections.abc.MappingView, 1)
  2646|         0|            0|            0|  0.00%|KeysView = _alias(collections.abc.KeysView, 1)
  2647|         0|            0|            0|  0.00%|ItemsView = _alias(collections.abc.ItemsView, 2)
  2648|         0|            0|            0|  0.00%|ValuesView = _alias(collections.abc.ValuesView, 1)
  2649|         0|            0|            0|  0.00%|ContextManager = _alias(contextlib.AbstractContextManager, 1, name='ContextManager')
  2650|         0|            0|            0|  0.00%|AsyncContextManager = _alias(contextlib.AbstractAsyncContextManager, 1, name='AsyncContextManager')
  2651|         0|            0|            0|  0.00%|Dict = _alias(dict, 2, inst=False, name='Dict')
  2652|         0|            0|            0|  0.00%|DefaultDict = _alias(collections.defaultdict, 2, name='DefaultDict')
  2653|         0|            0|            0|  0.00%|OrderedDict = _alias(collections.OrderedDict, 2)
  2654|         0|            0|            0|  0.00%|Counter = _alias(collections.Counter, 1)
  2655|         0|            0|            0|  0.00%|ChainMap = _alias(collections.ChainMap, 2)
  2656|         0|            0|            0|  0.00%|Generator = _alias(collections.abc.Generator, 3)
  2657|         0|            0|            0|  0.00%|AsyncGenerator = _alias(collections.abc.AsyncGenerator, 2)
  2658|         0|            0|            0|  0.00%|Type = _alias(type, 1, inst=False, name='Type')
  2659|         0|            0|            0|  0.00%|Type.__doc__ = \
  2660|         0|            0|            0|  0.00%|    """Deprecated alias to builtins.type.
  2661|         0|            0|            0|  0.00%|
  2662|         0|            0|            0|  0.00%|    builtins.type or typing.Type can be used to annotate class objects.
  2663|         0|            0|            0|  0.00%|    For example, suppose we have the following classes::
  2664|         0|            0|            0|  0.00%|
  2665|         0|            0|            0|  0.00%|        class User: ...  # Abstract base for User classes
  2666|         0|            0|            0|  0.00%|        class BasicUser(User): ...
  2667|         0|            0|            0|  0.00%|        class ProUser(User): ...
  2668|         0|            0|            0|  0.00%|        class TeamUser(User): ...
  2669|         0|            0|            0|  0.00%|
  2670|         0|            0|            0|  0.00%|    And a function that takes a class argument that's a subclass of
  2671|         0|            0|            0|  0.00%|    User and returns an instance of the corresponding class::
  2672|         0|            0|            0|  0.00%|
  2673|         0|            0|            0|  0.00%|        def new_user[U](user_class: Type[U]) -> U:
  2674|         0|            0|            0|  0.00%|            user = user_class()
  2675|         0|            0|            0|  0.00%|            # (Here we could write the user object to a database)
  2676|         0|            0|            0|  0.00%|            return user
  2677|         0|            0|            0|  0.00%|
  2678|         0|            0|            0|  0.00%|        joe = new_user(BasicUser)
  2679|         0|            0|            0|  0.00%|
  2680|         0|            0|            0|  0.00%|    At this point the type checker knows that joe has type BasicUser.
  2681|         0|            0|            0|  0.00%|    """
  2682|         0|            0|            0|  0.00%|
  2683|         0|            0|            0|  0.00%|
  2684|         0|            0|            0|  0.00%|@runtime_checkable
  2685|         0|            0|            0|  0.00%|class SupportsInt(Protocol):
  2686|         0|            0|            0|  0.00%|    """An ABC with one abstract method __int__."""
  2687|         0|            0|            0|  0.00%|
  2688|         0|            0|            0|  0.00%|    __slots__ = ()
  2689|         0|            0|            0|  0.00%|
  2690|         0|            0|            0|  0.00%|    @abstractmethod
  2691|         0|            0|            0|  0.00%|    def __int__(self) -> int:
  2692|         0|            0|            0|  0.00%|        pass
  2693|         0|            0|            0|  0.00%|
  2694|         0|            0|            0|  0.00%|
  2695|         0|            0|            0|  0.00%|@runtime_checkable
  2696|         0|            0|            0|  0.00%|class SupportsFloat(Protocol):
  2697|         0|            0|            0|  0.00%|    """An ABC with one abstract method __float__."""
  2698|         0|            0|            0|  0.00%|
  2699|         0|            0|            0|  0.00%|    __slots__ = ()
  2700|         0|            0|            0|  0.00%|
  2701|         0|            0|            0|  0.00%|    @abstractmethod
  2702|         0|            0|            0|  0.00%|    def __float__(self) -> float:
  2703|         0|            0|            0|  0.00%|        pass
  2704|         0|            0|            0|  0.00%|
  2705|         0|            0|            0|  0.00%|
  2706|         0|            0|            0|  0.00%|@runtime_checkable
  2707|         0|            0|            0|  0.00%|class SupportsComplex(Protocol):
  2708|         0|            0|            0|  0.00%|    """An ABC with one abstract method __complex__."""
  2709|         0|            0|            0|  0.00%|
  2710|         0|            0|            0|  0.00%|    __slots__ = ()
  2711|         0|            0|            0|  0.00%|
  2712|         0|            0|            0|  0.00%|    @abstractmethod
  2713|         0|            0|            0|  0.00%|    def __complex__(self) -> complex:
  2714|         0|            0|            0|  0.00%|        pass
  2715|         0|            0|            0|  0.00%|
  2716|         0|            0|            0|  0.00%|
  2717|         0|            0|            0|  0.00%|@runtime_checkable
  2718|         0|            0|            0|  0.00%|class SupportsBytes(Protocol):
  2719|         0|            0|            0|  0.00%|    """An ABC with one abstract method __bytes__."""
  2720|         0|            0|            0|  0.00%|
  2721|         0|            0|            0|  0.00%|    __slots__ = ()
  2722|         0|            0|            0|  0.00%|
  2723|         0|            0|            0|  0.00%|    @abstractmethod
  2724|         0|            0|            0|  0.00%|    def __bytes__(self) -> bytes:
  2725|         0|            0|            0|  0.00%|        pass
  2726|         0|            0|            0|  0.00%|
  2727|         0|            0|            0|  0.00%|
  2728|         0|            0|            0|  0.00%|@runtime_checkable
  2729|         0|            0|            0|  0.00%|class SupportsIndex(Protocol):
  2730|         0|            0|            0|  0.00%|    """An ABC with one abstract method __index__."""
  2731|         0|            0|            0|  0.00%|
  2732|         0|            0|            0|  0.00%|    __slots__ = ()
  2733|         0|            0|            0|  0.00%|
  2734|         0|            0|            0|  0.00%|    @abstractmethod
  2735|         0|            0|            0|  0.00%|    def __index__(self) -> int:
  2736|         0|            0|            0|  0.00%|        pass
  2737|         0|            0|            0|  0.00%|
  2738|         0|            0|            0|  0.00%|
  2739|         0|            0|            0|  0.00%|@runtime_checkable
  2740|         0|            0|            0|  0.00%|class SupportsAbs[T](Protocol):
  2741|         0|            0|            0|  0.00%|    """An ABC with one abstract method __abs__ that is covariant in its return type."""
  2742|         0|            0|            0|  0.00%|
  2743|         0|            0|            0|  0.00%|    __slots__ = ()
  2744|         0|            0|            0|  0.00%|
  2745|         0|            0|            0|  0.00%|    @abstractmethod
  2746|         0|            0|            0|  0.00%|    def __abs__(self) -> T:
  2747|         0|            0|            0|  0.00%|        pass
  2748|         0|            0|            0|  0.00%|
  2749|         0|            0|            0|  0.00%|
  2750|         0|            0|            0|  0.00%|@runtime_checkable
  2751|         0|            0|            0|  0.00%|class SupportsRound[T](Protocol):
  2752|         0|            0|            0|  0.00%|    """An ABC with one abstract method __round__ that is covariant in its return type."""
  2753|         0|            0|            0|  0.00%|
  2754|         0|            0|            0|  0.00%|    __slots__ = ()
  2755|         0|            0|            0|  0.00%|
  2756|         0|            0|            0|  0.00%|    @abstractmethod
  2757|         0|            0|            0|  0.00%|    def __round__(self, ndigits: int = 0) -> T:
  2758|         0|            0|            0|  0.00%|        pass
  2759|         0|            0|            0|  0.00%|
  2760|         0|            0|            0|  0.00%|
  2761|         0|            0|            0|  0.00%|def _make_nmtuple(name, types, module, defaults = ()):
  2762|         0|            0|            0|  0.00%|    fields = [n for n, t in types]
  2763|         0|            0|            0|  0.00%|    types = {n: _type_check(t, f"field {n} annotation must be a type")
  2764|         0|            0|            0|  0.00%|             for n, t in types}
  2765|         0|            0|            0|  0.00%|    nm_tpl = collections.namedtuple(name, fields,
  2766|         0|            0|            0|  0.00%|                                    defaults=defaults, module=module)
  2767|         0|            0|            0|  0.00%|    nm_tpl.__annotations__ = nm_tpl.__new__.__annotations__ = types
  2768|         0|            0|            0|  0.00%|    return nm_tpl
  2769|         0|            0|            0|  0.00%|
  2770|         0|            0|            0|  0.00%|
  2771|         0|            0|            0|  0.00%|# attributes prohibited to set in NamedTuple class syntax
  2772|         0|            0|            0|  0.00%|_prohibited = frozenset({'__new__', '__init__', '__slots__', '__getnewargs__',
  2773|         0|            0|            0|  0.00%|                         '_fields', '_field_defaults',
  2774|         0|            0|            0|  0.00%|                         '_make', '_replace', '_asdict', '_source'})
  2775|         0|            0|            0|  0.00%|
  2776|         0|            0|            0|  0.00%|_special = frozenset({'__module__', '__name__', '__annotations__'})
  2777|         0|            0|            0|  0.00%|
  2778|         0|            0|            0|  0.00%|
  2779|         0|            0|            0|  0.00%|class NamedTupleMeta(type):
  2780|         0|            0|            0|  0.00%|    def __new__(cls, typename, bases, ns):
  2781|         0|            0|            0|  0.00%|        assert _NamedTuple in bases
  2782|         0|            0|            0|  0.00%|        for base in bases:
  2783|         0|            0|            0|  0.00%|            if base is not _NamedTuple and base is not Generic:
  2784|         0|            0|            0|  0.00%|                raise TypeError(
  2785|         0|            0|            0|  0.00%|                    'can only inherit from a NamedTuple type and Generic')
  2786|         0|            0|            0|  0.00%|        bases = tuple(tuple if base is _NamedTuple else base for base in bases)
  2787|         0|            0|            0|  0.00%|        types = ns.get('__annotations__', {})
  2788|         0|            0|            0|  0.00%|        default_names = []
  2789|         0|            0|            0|  0.00%|        for field_name in types:
  2790|         0|            0|            0|  0.00%|            if field_name in ns:
  2791|         0|            0|            0|  0.00%|                default_names.append(field_name)
  2792|         0|            0|            0|  0.00%|            elif default_names:
  2793|         0|            0|            0|  0.00%|                raise TypeError(f"Non-default namedtuple field {field_name} "
  2794|         0|            0|            0|  0.00%|                                f"cannot follow default field"
  2795|         0|            0|            0|  0.00%|                                f"{'s' if len(default_names) > 1 else ''} "
  2796|         0|            0|            0|  0.00%|                                f"{', '.join(default_names)}")
  2797|         0|            0|            0|  0.00%|        nm_tpl = _make_nmtuple(typename, types.items(),
  2798|         0|            0|            0|  0.00%|                               defaults=[ns[n] for n in default_names],
  2799|         0|            0|            0|  0.00%|                               module=ns['__module__'])
  2800|         0|            0|            0|  0.00%|        nm_tpl.__bases__ = bases
  2801|         0|            0|            0|  0.00%|        if Generic in bases:
  2802|         0|            0|            0|  0.00%|            class_getitem = _generic_class_getitem
  2803|         0|            0|            0|  0.00%|            nm_tpl.__class_getitem__ = classmethod(class_getitem)
  2804|         0|            0|            0|  0.00%|        # update from user namespace without overriding special namedtuple attributes
  2805|         0|            0|            0|  0.00%|        for key in ns:
  2806|         0|            0|            0|  0.00%|            if key in _prohibited:
  2807|         0|            0|            0|  0.00%|                raise AttributeError("Cannot overwrite NamedTuple attribute " + key)
  2808|         0|            0|            0|  0.00%|            elif key not in _special and key not in nm_tpl._fields:
  2809|         0|            0|            0|  0.00%|                setattr(nm_tpl, key, ns[key])
  2810|         0|            0|            0|  0.00%|        if Generic in bases:
  2811|         0|            0|            0|  0.00%|            nm_tpl.__init_subclass__()
  2812|         0|            0|            0|  0.00%|        return nm_tpl
  2813|         0|            0|            0|  0.00%|
  2814|         0|            0|            0|  0.00%|
  2815|         0|            0|            0|  0.00%|def NamedTuple(typename, fields=None, /, **kwargs):
  2816|         0|            0|            0|  0.00%|    """Typed version of namedtuple.
  2817|         0|            0|            0|  0.00%|
  2818|         0|            0|            0|  0.00%|    Usage::
  2819|         0|            0|            0|  0.00%|
  2820|         0|            0|            0|  0.00%|        class Employee(NamedTuple):
  2821|         0|            0|            0|  0.00%|            name: str
  2822|         0|            0|            0|  0.00%|            id: int
  2823|         0|            0|            0|  0.00%|
  2824|         0|            0|            0|  0.00%|    This is equivalent to::
  2825|         0|            0|            0|  0.00%|
  2826|         0|            0|            0|  0.00%|        Employee = collections.namedtuple('Employee', ['name', 'id'])
  2827|         0|            0|            0|  0.00%|
  2828|         0|            0|            0|  0.00%|    The resulting class has an extra __annotations__ attribute, giving a
  2829|         0|            0|            0|  0.00%|    dict that maps field names to types.  (The field names are also in
  2830|         0|            0|            0|  0.00%|    the _fields attribute, which is part of the namedtuple API.)
  2831|         0|            0|            0|  0.00%|    An alternative equivalent functional syntax is also accepted::
  2832|         0|            0|            0|  0.00%|
  2833|         0|            0|            0|  0.00%|        Employee = NamedTuple('Employee', [('name', str), ('id', int)])
  2834|         0|            0|            0|  0.00%|    """
  2835|         0|            0|            0|  0.00%|    if fields is None:
  2836|         0|            0|            0|  0.00%|        fields = kwargs.items()
  2837|         0|            0|            0|  0.00%|    elif kwargs:
  2838|         0|            0|            0|  0.00%|        raise TypeError("Either list of fields or keywords"
  2839|         0|            0|            0|  0.00%|                        " can be provided to NamedTuple, not both")
  2840|         0|            0|            0|  0.00%|    nt = _make_nmtuple(typename, fields, module=_caller())
  2841|         0|            0|            0|  0.00%|    nt.__orig_bases__ = (NamedTuple,)
  2842|         0|            0|            0|  0.00%|    return nt
  2843|         0|            0|            0|  0.00%|
  2844|         0|            0|            0|  0.00%|_NamedTuple = type.__new__(NamedTupleMeta, 'NamedTuple', (), {})
  2845|         0|            0|            0|  0.00%|
  2846|         0|            0|            0|  0.00%|def _namedtuple_mro_entries(bases):
  2847|         0|            0|            0|  0.00%|    assert NamedTuple in bases
  2848|         0|            0|            0|  0.00%|    return (_NamedTuple,)
  2849|         0|            0|            0|  0.00%|
  2850|         0|            0|            0|  0.00%|NamedTuple.__mro_entries__ = _namedtuple_mro_entries
  2851|         0|            0|            0|  0.00%|
  2852|         0|            0|            0|  0.00%|
  2853|         0|            0|            0|  0.00%|class _TypedDictMeta(type):
  2854|         0|            0|            0|  0.00%|    def __new__(cls, name, bases, ns, total=True):
  2855|         0|            0|            0|  0.00%|        """Create a new typed dict class object.
  2856|         0|            0|            0|  0.00%|
  2857|         0|            0|            0|  0.00%|        This method is called when TypedDict is subclassed,
  2858|         0|            0|            0|  0.00%|        or when TypedDict is instantiated. This way
  2859|         0|            0|            0|  0.00%|        TypedDict supports all three syntax forms described in its docstring.
  2860|         0|            0|            0|  0.00%|        Subclasses and instances of TypedDict return actual dictionaries.
  2861|         0|            0|            0|  0.00%|        """
  2862|         0|            0|            0|  0.00%|        for base in bases:
  2863|         0|            0|            0|  0.00%|            if type(base) is not _TypedDictMeta and base is not Generic:
  2864|         0|            0|            0|  0.00%|                raise TypeError('cannot inherit from both a TypedDict type '
  2865|         0|            0|            0|  0.00%|                                'and a non-TypedDict base class')
  2866|         0|            0|            0|  0.00%|
  2867|         0|            0|            0|  0.00%|        if any(issubclass(b, Generic) for b in bases):
  2868|         0|            0|            0|  0.00%|            generic_base = (Generic,)
  2869|         0|            0|            0|  0.00%|        else:
  2870|         0|            0|            0|  0.00%|            generic_base = ()
  2871|         0|            0|            0|  0.00%|
  2872|         0|            0|            0|  0.00%|        tp_dict = type.__new__(_TypedDictMeta, name, (*generic_base, dict), ns)
  2873|         0|            0|            0|  0.00%|
  2874|         0|            0|            0|  0.00%|        if not hasattr(tp_dict, '__orig_bases__'):
  2875|         0|            0|            0|  0.00%|            tp_dict.__orig_bases__ = bases
  2876|         0|            0|            0|  0.00%|
  2877|         0|            0|            0|  0.00%|        annotations = {}
  2878|         0|            0|            0|  0.00%|        own_annotations = ns.get('__annotations__', {})
  2879|         0|            0|            0|  0.00%|        msg = "TypedDict('Name', {f0: t0, f1: t1, ...}); each t must be a type"
  2880|         0|            0|            0|  0.00%|        own_annotations = {
  2881|         0|            0|            0|  0.00%|            n: _type_check(tp, msg, module=tp_dict.__module__)
  2882|         0|            0|            0|  0.00%|            for n, tp in own_annotations.items()
  2883|         0|            0|            0|  0.00%|        }
  2884|         0|            0|            0|  0.00%|        required_keys = set()
  2885|         0|            0|            0|  0.00%|        optional_keys = set()
  2886|         0|            0|            0|  0.00%|
  2887|         0|            0|            0|  0.00%|        for base in bases:
  2888|         0|            0|            0|  0.00%|            annotations.update(base.__dict__.get('__annotations__', {}))
  2889|         0|            0|            0|  0.00%|
  2890|         0|            0|            0|  0.00%|            base_required = base.__dict__.get('__required_keys__', set())
  2891|         0|            0|            0|  0.00%|            required_keys |= base_required
  2892|         0|            0|            0|  0.00%|            optional_keys -= base_required
  2893|         0|            0|            0|  0.00%|
  2894|         0|            0|            0|  0.00%|            base_optional = base.__dict__.get('__optional_keys__', set())
  2895|         0|            0|            0|  0.00%|            required_keys -= base_optional
  2896|         0|            0|            0|  0.00%|            optional_keys |= base_optional
  2897|         0|            0|            0|  0.00%|
  2898|         0|            0|            0|  0.00%|        annotations.update(own_annotations)
  2899|         0|            0|            0|  0.00%|        for annotation_key, annotation_type in own_annotations.items():
  2900|         0|            0|            0|  0.00%|            annotation_origin = get_origin(annotation_type)
  2901|         0|            0|            0|  0.00%|            if annotation_origin is Annotated:
  2902|         0|            0|            0|  0.00%|                annotation_args = get_args(annotation_type)
  2903|         0|            0|            0|  0.00%|                if annotation_args:
  2904|         0|            0|            0|  0.00%|                    annotation_type = annotation_args[0]
  2905|         0|            0|            0|  0.00%|                    annotation_origin = get_origin(annotation_type)
  2906|         0|            0|            0|  0.00%|
  2907|         0|            0|            0|  0.00%|            if annotation_origin is Required:
  2908|         0|            0|            0|  0.00%|                is_required = True
  2909|         0|            0|            0|  0.00%|            elif annotation_origin is NotRequired:
  2910|         0|            0|            0|  0.00%|                is_required = False
  2911|         0|            0|            0|  0.00%|            else:
  2912|         0|            0|            0|  0.00%|                is_required = total
  2913|         0|            0|            0|  0.00%|
  2914|         0|            0|            0|  0.00%|            if is_required:
  2915|         0|            0|            0|  0.00%|                required_keys.add(annotation_key)
  2916|         0|            0|            0|  0.00%|                optional_keys.discard(annotation_key)
  2917|         0|            0|            0|  0.00%|            else:
  2918|         0|            0|            0|  0.00%|                optional_keys.add(annotation_key)
  2919|         0|            0|            0|  0.00%|                required_keys.discard(annotation_key)
  2920|         0|            0|            0|  0.00%|
  2921|         0|            0|            0|  0.00%|        assert required_keys.isdisjoint(optional_keys), (
  2922|         0|            0|            0|  0.00%|            f"Required keys overlap with optional keys in {name}:"
  2923|         0|            0|            0|  0.00%|            f" {required_keys=}, {optional_keys=}"
  2924|         0|            0|            0|  0.00%|        )
  2925|         0|            0|            0|  0.00%|        tp_dict.__annotations__ = annotations
  2926|         0|            0|            0|  0.00%|        tp_dict.__required_keys__ = frozenset(required_keys)
  2927|         0|            0|            0|  0.00%|        tp_dict.__optional_keys__ = frozenset(optional_keys)
  2928|         0|            0|            0|  0.00%|        if not hasattr(tp_dict, '__total__'):
  2929|         0|            0|            0|  0.00%|            tp_dict.__total__ = total
  2930|         0|            0|            0|  0.00%|        return tp_dict
  2931|         0|            0|            0|  0.00%|
  2932|         0|            0|            0|  0.00%|    __call__ = dict  # static method
  2933|         0|            0|            0|  0.00%|
  2934|         0|            0|            0|  0.00%|    def __subclasscheck__(cls, other):
  2935|         0|            0|            0|  0.00%|        # Typed dicts are only for static structural subtyping.
  2936|         0|            0|            0|  0.00%|        raise TypeError('TypedDict does not support instance and class checks')
  2937|         0|            0|            0|  0.00%|
  2938|         0|            0|            0|  0.00%|    __instancecheck__ = __subclasscheck__
  2939|         0|            0|            0|  0.00%|
  2940|         0|            0|            0|  0.00%|
  2941|         0|            0|            0|  0.00%|def TypedDict(typename, fields=None, /, *, total=True, **kwargs):
  2942|         0|            0|            0|  0.00%|    """A simple typed namespace. At runtime it is equivalent to a plain dict.
  2943|         0|            0|            0|  0.00%|
  2944|         0|            0|            0|  0.00%|    TypedDict creates a dictionary type such that a type checker will expect all
  2945|         0|            0|            0|  0.00%|    instances to have a certain set of keys, where each key is
  2946|         0|            0|            0|  0.00%|    associated with a value of a consistent type. This expectation
  2947|         0|            0|            0|  0.00%|    is not checked at runtime.
  2948|         0|            0|            0|  0.00%|
  2949|         0|            0|            0|  0.00%|    Usage::
  2950|         0|            0|            0|  0.00%|
  2951|         0|            0|            0|  0.00%|        >>> class Point2D(TypedDict):
  2952|         0|            0|            0|  0.00%|        ...     x: int
  2953|         0|            0|            0|  0.00%|        ...     y: int
  2954|         0|            0|            0|  0.00%|        ...     label: str
  2955|         0|            0|            0|  0.00%|        ...
  2956|         0|            0|            0|  0.00%|        >>> a: Point2D = {'x': 1, 'y': 2, 'label': 'good'}  # OK
  2957|         0|            0|            0|  0.00%|        >>> b: Point2D = {'z': 3, 'label': 'bad'}           # Fails type check
  2958|         0|            0|            0|  0.00%|        >>> Point2D(x=1, y=2, label='first') == dict(x=1, y=2, label='first')
  2959|         0|            0|            0|  0.00%|        True
  2960|         0|            0|            0|  0.00%|
  2961|         0|            0|            0|  0.00%|    The type info can be accessed via the Point2D.__annotations__ dict, and
  2962|         0|            0|            0|  0.00%|    the Point2D.__required_keys__ and Point2D.__optional_keys__ frozensets.
  2963|         0|            0|            0|  0.00%|    TypedDict supports an additional equivalent form::
  2964|         0|            0|            0|  0.00%|
  2965|         0|            0|            0|  0.00%|        Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': str})
  2966|         0|            0|            0|  0.00%|
  2967|         0|            0|            0|  0.00%|    By default, all keys must be present in a TypedDict. It is possible
  2968|         0|            0|            0|  0.00%|    to override this by specifying totality::
  2969|         0|            0|            0|  0.00%|
  2970|         0|            0|            0|  0.00%|        class Point2D(TypedDict, total=False):
  2971|         0|            0|            0|  0.00%|            x: int
  2972|         0|            0|            0|  0.00%|            y: int
  2973|         0|            0|            0|  0.00%|
  2974|         0|            0|            0|  0.00%|    This means that a Point2D TypedDict can have any of the keys omitted. A type
  2975|         0|            0|            0|  0.00%|    checker is only expected to support a literal False or True as the value of
  2976|         0|            0|            0|  0.00%|    the total argument. True is the default, and makes all items defined in the
  2977|         0|            0|            0|  0.00%|    class body be required.
  2978|         0|            0|            0|  0.00%|
  2979|         0|            0|            0|  0.00%|    The Required and NotRequired special forms can also be used to mark
  2980|         0|            0|            0|  0.00%|    individual keys as being required or not required::
  2981|         0|            0|            0|  0.00%|
  2982|         0|            0|            0|  0.00%|        class Point2D(TypedDict):
  2983|         0|            0|            0|  0.00%|            x: int               # the "x" key must always be present (Required is the default)
  2984|         0|            0|            0|  0.00%|            y: NotRequired[int]  # the "y" key can be omitted
  2985|         0|            0|            0|  0.00%|
  2986|         0|            0|            0|  0.00%|    See PEP 655 for more details on Required and NotRequired.
  2987|         0|            0|            0|  0.00%|    """
  2988|         0|            0|            0|  0.00%|    if fields is None:
  2989|         0|            0|            0|  0.00%|        fields = kwargs
  2990|         0|            0|            0|  0.00%|    elif kwargs:
  2991|         0|            0|            0|  0.00%|        raise TypeError("TypedDict takes either a dict or keyword arguments,"
  2992|         0|            0|            0|  0.00%|                        " but not both")
  2993|         0|            0|            0|  0.00%|    if kwargs:
  2994|         0|            0|            0|  0.00%|        warnings.warn(
  2995|         0|            0|            0|  0.00%|            "The kwargs-based syntax for TypedDict definitions is deprecated "
  2996|         0|            0|            0|  0.00%|            "in Python 3.11, will be removed in Python 3.13, and may not be "
  2997|         0|            0|            0|  0.00%|            "understood by third-party type checkers.",
  2998|         0|            0|            0|  0.00%|            DeprecationWarning,
  2999|         0|            0|            0|  0.00%|            stacklevel=2,
  3000|         0|            0|            0|  0.00%|        )
  3001|         0|            0|            0|  0.00%|
  3002|         0|            0|            0|  0.00%|    ns = {'__annotations__': dict(fields)}
  3003|         0|            0|            0|  0.00%|    module = _caller()
  3004|         0|            0|            0|  0.00%|    if module is not None:
  3005|         0|            0|            0|  0.00%|        # Setting correct module is necessary to make typed dict classes pickleable.
  3006|         0|            0|            0|  0.00%|        ns['__module__'] = module
  3007|         0|            0|            0|  0.00%|
  3008|         0|            0|            0|  0.00%|    td = _TypedDictMeta(typename, (), ns, total=total)
  3009|         0|            0|            0|  0.00%|    td.__orig_bases__ = (TypedDict,)
  3010|         0|            0|            0|  0.00%|    return td
  3011|         0|            0|            0|  0.00%|
  3012|         0|            0|            0|  0.00%|_TypedDict = type.__new__(_TypedDictMeta, 'TypedDict', (), {})
  3013|         0|            0|            0|  0.00%|TypedDict.__mro_entries__ = lambda bases: (_TypedDict,)
  3014|         0|            0|            0|  0.00%|
  3015|         0|            0|            0|  0.00%|
  3016|         0|            0|            0|  0.00%|@_SpecialForm
  3017|         0|            0|            0|  0.00%|def Required(self, parameters):
  3018|         0|            0|            0|  0.00%|    """Special typing construct to mark a TypedDict key as required.
  3019|         0|            0|            0|  0.00%|
  3020|         0|            0|            0|  0.00%|    This is mainly useful for total=False TypedDicts.
  3021|         0|            0|            0|  0.00%|
  3022|         0|            0|            0|  0.00%|    For example::
  3023|         0|            0|            0|  0.00%|
  3024|         0|            0|            0|  0.00%|        class Movie(TypedDict, total=False):
  3025|         0|            0|            0|  0.00%|            title: Required[str]
  3026|         0|            0|            0|  0.00%|            year: int
  3027|         0|            0|            0|  0.00%|
  3028|         0|            0|            0|  0.00%|        m = Movie(
  3029|         0|            0|            0|  0.00%|            title='The Matrix',  # typechecker error if key is omitted
  3030|         0|            0|            0|  0.00%|            year=1999,
  3031|         0|            0|            0|  0.00%|        )
  3032|         0|            0|            0|  0.00%|
  3033|         0|            0|            0|  0.00%|    There is no runtime checking that a required key is actually provided
  3034|         0|            0|            0|  0.00%|    when instantiating a related TypedDict.
  3035|         0|            0|            0|  0.00%|    """
  3036|         0|            0|            0|  0.00%|    item = _type_check(parameters, f'{self._name} accepts only a single type.')
  3037|         0|            0|            0|  0.00%|    return _GenericAlias(self, (item,))
  3038|         0|            0|            0|  0.00%|
  3039|         0|            0|            0|  0.00%|
  3040|         0|            0|            0|  0.00%|@_SpecialForm
  3041|         0|            0|            0|  0.00%|def NotRequired(self, parameters):
  3042|         0|            0|            0|  0.00%|    """Special typing construct to mark a TypedDict key as potentially missing.
  3043|         0|            0|            0|  0.00%|
  3044|         0|            0|            0|  0.00%|    For example::
  3045|         0|            0|            0|  0.00%|
  3046|         0|            0|            0|  0.00%|        class Movie(TypedDict):
  3047|         0|            0|            0|  0.00%|            title: str
  3048|         0|            0|            0|  0.00%|            year: NotRequired[int]
  3049|         0|            0|            0|  0.00%|
  3050|         0|            0|            0|  0.00%|        m = Movie(
  3051|         0|            0|            0|  0.00%|            title='The Matrix',  # typechecker error if key is omitted
  3052|         0|            0|            0|  0.00%|            year=1999,
  3053|         0|            0|            0|  0.00%|        )
  3054|         0|            0|            0|  0.00%|    """
  3055|         0|            0|            0|  0.00%|    item = _type_check(parameters, f'{self._name} accepts only a single type.')
  3056|         0|            0|            0|  0.00%|    return _GenericAlias(self, (item,))
  3057|         0|            0|            0|  0.00%|
  3058|         0|            0|            0|  0.00%|
  3059|         0|            0|            0|  0.00%|class NewType:
  3060|         0|            0|            0|  0.00%|    """NewType creates simple unique types with almost zero runtime overhead.
  3061|         0|            0|            0|  0.00%|
  3062|         0|            0|            0|  0.00%|    NewType(name, tp) is considered a subtype of tp
  3063|         0|            0|            0|  0.00%|    by static type checkers. At runtime, NewType(name, tp) returns
  3064|         0|            0|            0|  0.00%|    a dummy callable that simply returns its argument.
  3065|         0|            0|            0|  0.00%|
  3066|         0|            0|            0|  0.00%|    Usage::
  3067|         0|            0|            0|  0.00%|
  3068|         0|            0|            0|  0.00%|        UserId = NewType('UserId', int)
  3069|         0|            0|            0|  0.00%|
  3070|         0|            0|            0|  0.00%|        def name_by_id(user_id: UserId) -> str:
  3071|         0|            0|            0|  0.00%|            ...
  3072|         0|            0|            0|  0.00%|
  3073|         0|            0|            0|  0.00%|        UserId('user')          # Fails type check
  3074|         0|            0|            0|  0.00%|
  3075|         0|            0|            0|  0.00%|        name_by_id(42)          # Fails type check
  3076|         0|            0|            0|  0.00%|        name_by_id(UserId(42))  # OK
  3077|         0|            0|            0|  0.00%|
  3078|         0|            0|            0|  0.00%|        num = UserId(5) + 1     # type: int
  3079|         0|            0|            0|  0.00%|    """
  3080|         0|            0|            0|  0.00%|
  3081|         0|            0|            0|  0.00%|    __call__ = _idfunc
  3082|         0|            0|            0|  0.00%|
  3083|         0|            0|            0|  0.00%|    def __init__(self, name, tp):
  3084|         0|            0|            0|  0.00%|        self.__qualname__ = name
  3085|         0|            0|            0|  0.00%|        if '.' in name:
  3086|         0|            0|            0|  0.00%|            name = name.rpartition('.')[-1]
  3087|         0|            0|            0|  0.00%|        self.__name__ = name
  3088|         0|            0|            0|  0.00%|        self.__supertype__ = tp
  3089|         0|            0|            0|  0.00%|        def_mod = _caller()
  3090|         0|            0|            0|  0.00%|        if def_mod != 'typing':
  3091|         0|            0|            0|  0.00%|            self.__module__ = def_mod
  3092|         0|            0|            0|  0.00%|
  3093|         0|            0|            0|  0.00%|    def __mro_entries__(self, bases):
  3094|         0|            0|            0|  0.00%|        # We defined __mro_entries__ to get a better error message
  3095|         0|            0|            0|  0.00%|        # if a user attempts to subclass a NewType instance. bpo-46170
  3096|         0|            0|            0|  0.00%|        superclass_name = self.__name__
  3097|         0|            0|            0|  0.00%|
  3098|         0|            0|            0|  0.00%|        class Dummy:
  3099|         0|            0|            0|  0.00%|            def __init_subclass__(cls):
  3100|         0|            0|            0|  0.00%|                subclass_name = cls.__name__
  3101|         0|            0|            0|  0.00%|                raise TypeError(
  3102|         0|            0|            0|  0.00%|                    f"Cannot subclass an instance of NewType. Perhaps you were looking for: "
  3103|         0|            0|            0|  0.00%|                    f"`{subclass_name} = NewType({subclass_name!r}, {superclass_name})`"
  3104|         0|            0|            0|  0.00%|                )
  3105|         0|            0|            0|  0.00%|
  3106|         0|            0|            0|  0.00%|        return (Dummy,)
  3107|         0|            0|            0|  0.00%|
  3108|         0|            0|            0|  0.00%|    def __repr__(self):
  3109|         0|            0|            0|  0.00%|        return f'{self.__module__}.{self.__qualname__}'
  3110|         0|            0|            0|  0.00%|
  3111|         0|            0|            0|  0.00%|    def __reduce__(self):
  3112|         0|            0|            0|  0.00%|        return self.__qualname__
  3113|         0|            0|            0|  0.00%|
  3114|         0|            0|            0|  0.00%|    def __or__(self, other):
  3115|         0|            0|            0|  0.00%|        return Union[self, other]
  3116|         0|            0|            0|  0.00%|
  3117|         0|            0|            0|  0.00%|    def __ror__(self, other):
  3118|         0|            0|            0|  0.00%|        return Union[other, self]
  3119|         0|            0|            0|  0.00%|
  3120|         0|            0|            0|  0.00%|
  3121|         0|            0|            0|  0.00%|# Python-version-specific alias (Python 2: unicode; Python 3: str)
  3122|         0|            0|            0|  0.00%|Text = str
  3123|         0|            0|            0|  0.00%|
  3124|         0|            0|            0|  0.00%|
  3125|         0|            0|            0|  0.00%|# Constant that's True when type checking, but False here.
  3126|         0|            0|            0|  0.00%|TYPE_CHECKING = False
  3127|         0|            0|            0|  0.00%|
  3128|         0|            0|            0|  0.00%|
  3129|         0|            0|            0|  0.00%|class IO(Generic[AnyStr]):
  3130|         0|            0|            0|  0.00%|    """Generic base class for TextIO and BinaryIO.
  3131|         0|            0|            0|  0.00%|
  3132|         0|            0|            0|  0.00%|    This is an abstract, generic version of the return of open().
  3133|         0|            0|            0|  0.00%|
  3134|         0|            0|            0|  0.00%|    NOTE: This does not distinguish between the different possible
  3135|         0|            0|            0|  0.00%|    classes (text vs. binary, read vs. write vs. read/write,
  3136|         0|            0|            0|  0.00%|    append-only, unbuffered).  The TextIO and BinaryIO subclasses
  3137|         0|            0|            0|  0.00%|    below capture the distinctions between text vs. binary, which is
  3138|         0|            0|            0|  0.00%|    pervasive in the interface; however we currently do not offer a
  3139|         0|            0|            0|  0.00%|    way to track the other distinctions in the type system.
  3140|         0|            0|            0|  0.00%|    """
  3141|         0|            0|            0|  0.00%|
  3142|         0|            0|            0|  0.00%|    __slots__ = ()
  3143|         0|            0|            0|  0.00%|
  3144|         0|            0|            0|  0.00%|    @property
  3145|         0|            0|            0|  0.00%|    @abstractmethod
  3146|         0|            0|            0|  0.00%|    def mode(self) -> str:
  3147|         0|            0|            0|  0.00%|        pass
  3148|         0|            0|            0|  0.00%|
  3149|         0|            0|            0|  0.00%|    @property
  3150|         0|            0|            0|  0.00%|    @abstractmethod
  3151|         0|            0|            0|  0.00%|    def name(self) -> str:
  3152|         0|            0|            0|  0.00%|        pass
  3153|         0|            0|            0|  0.00%|
  3154|         0|            0|            0|  0.00%|    @abstractmethod
  3155|         0|            0|            0|  0.00%|    def close(self) -> None:
  3156|         0|            0|            0|  0.00%|        pass
  3157|         0|            0|            0|  0.00%|
  3158|         0|            0|            0|  0.00%|    @property
  3159|         0|            0|            0|  0.00%|    @abstractmethod
  3160|         0|            0|            0|  0.00%|    def closed(self) -> bool:
  3161|         0|            0|            0|  0.00%|        pass
  3162|         0|            0|            0|  0.00%|
  3163|         0|            0|            0|  0.00%|    @abstractmethod
  3164|         0|            0|            0|  0.00%|    def fileno(self) -> int:
  3165|         0|            0|            0|  0.00%|        pass
  3166|         0|            0|            0|  0.00%|
  3167|         0|            0|            0|  0.00%|    @abstractmethod
  3168|         0|            0|            0|  0.00%|    def flush(self) -> None:
  3169|         0|            0|            0|  0.00%|        pass
  3170|         0|            0|            0|  0.00%|
  3171|         0|            0|            0|  0.00%|    @abstractmethod
  3172|         0|            0|            0|  0.00%|    def isatty(self) -> bool:
  3173|         0|            0|            0|  0.00%|        pass
  3174|         0|            0|            0|  0.00%|
  3175|         0|            0|            0|  0.00%|    @abstractmethod
  3176|         0|            0|            0|  0.00%|    def read(self, n: int = -1) -> AnyStr:
  3177|         0|            0|            0|  0.00%|        pass
  3178|         0|            0|            0|  0.00%|
  3179|         0|            0|            0|  0.00%|    @abstractmethod
  3180|         0|            0|            0|  0.00%|    def readable(self) -> bool:
  3181|         0|            0|            0|  0.00%|        pass
  3182|         0|            0|            0|  0.00%|
  3183|         0|            0|            0|  0.00%|    @abstractmethod
  3184|         0|            0|            0|  0.00%|    def readline(self, limit: int = -1) -> AnyStr:
  3185|         0|            0|            0|  0.00%|        pass
  3186|         0|            0|            0|  0.00%|
  3187|         0|            0|            0|  0.00%|    @abstractmethod
  3188|         0|            0|            0|  0.00%|    def readlines(self, hint: int = -1) -> List[AnyStr]:
  3189|         0|            0|            0|  0.00%|        pass
  3190|         0|            0|            0|  0.00%|
  3191|         0|            0|            0|  0.00%|    @abstractmethod
  3192|         0|            0|            0|  0.00%|    def seek(self, offset: int, whence: int = 0) -> int:
  3193|         0|            0|            0|  0.00%|        pass
  3194|         0|            0|            0|  0.00%|
  3195|         0|            0|            0|  0.00%|    @abstractmethod
  3196|         0|            0|            0|  0.00%|    def seekable(self) -> bool:
  3197|         0|            0|            0|  0.00%|        pass
  3198|         0|            0|            0|  0.00%|
  3199|         0|            0|            0|  0.00%|    @abstractmethod
  3200|         0|            0|            0|  0.00%|    def tell(self) -> int:
  3201|         0|            0|            0|  0.00%|        pass
  3202|         0|            0|            0|  0.00%|
  3203|         0|            0|            0|  0.00%|    @abstractmethod
  3204|         0|            0|            0|  0.00%|    def truncate(self, size: int = None) -> int:
  3205|         0|            0|            0|  0.00%|        pass
  3206|         0|            0|            0|  0.00%|
  3207|         0|            0|            0|  0.00%|    @abstractmethod
  3208|         0|            0|            0|  0.00%|    def writable(self) -> bool:
  3209|         0|            0|            0|  0.00%|        pass
  3210|         0|            0|            0|  0.00%|
  3211|         0|            0|            0|  0.00%|    @abstractmethod
  3212|         0|            0|            0|  0.00%|    def write(self, s: AnyStr) -> int:
  3213|         0|            0|            0|  0.00%|        pass
  3214|         0|            0|            0|  0.00%|
  3215|         0|            0|            0|  0.00%|    @abstractmethod
  3216|         0|            0|            0|  0.00%|    def writelines(self, lines: List[AnyStr]) -> None:
  3217|         0|            0|            0|  0.00%|        pass
  3218|         0|            0|            0|  0.00%|
  3219|         0|            0|            0|  0.00%|    @abstractmethod
  3220|         0|            0|            0|  0.00%|    def __enter__(self) -> 'IO[AnyStr]':
  3221|         0|            0|            0|  0.00%|        pass
  3222|         0|            0|            0|  0.00%|
  3223|         0|            0|            0|  0.00%|    @abstractmethod
  3224|         0|            0|            0|  0.00%|    def __exit__(self, type, value, traceback) -> None:
  3225|         0|            0|            0|  0.00%|        pass
  3226|         0|            0|            0|  0.00%|
  3227|         0|            0|            0|  0.00%|
  3228|         0|            0|            0|  0.00%|class BinaryIO(IO[bytes]):
  3229|         0|            0|            0|  0.00%|    """Typed version of the return of open() in binary mode."""
  3230|         0|            0|            0|  0.00%|
  3231|         0|            0|            0|  0.00%|    __slots__ = ()
  3232|         0|            0|            0|  0.00%|
  3233|         0|            0|            0|  0.00%|    @abstractmethod
  3234|         0|            0|            0|  0.00%|    def write(self, s: Union[bytes, bytearray]) -> int:
  3235|         0|            0|            0|  0.00%|        pass
  3236|         0|            0|            0|  0.00%|
  3237|         0|            0|            0|  0.00%|    @abstractmethod
  3238|         0|            0|            0|  0.00%|    def __enter__(self) -> 'BinaryIO':
  3239|         0|            0|            0|  0.00%|        pass
  3240|         0|            0|            0|  0.00%|
  3241|         0|            0|            0|  0.00%|
  3242|         0|            0|            0|  0.00%|class TextIO(IO[str]):
  3243|         0|            0|            0|  0.00%|    """Typed version of the return of open() in text mode."""
  3244|         0|            0|            0|  0.00%|
  3245|         0|            0|            0|  0.00%|    __slots__ = ()
  3246|         0|            0|            0|  0.00%|
  3247|         0|            0|            0|  0.00%|    @property
  3248|         0|            0|            0|  0.00%|    @abstractmethod
  3249|         0|            0|            0|  0.00%|    def buffer(self) -> BinaryIO:
  3250|         0|            0|            0|  0.00%|        pass
  3251|         0|            0|            0|  0.00%|
  3252|         0|            0|            0|  0.00%|    @property
  3253|         0|            0|            0|  0.00%|    @abstractmethod
  3254|         0|            0|            0|  0.00%|    def encoding(self) -> str:
  3255|         0|            0|            0|  0.00%|        pass
  3256|         0|            0|            0|  0.00%|
  3257|         0|            0|            0|  0.00%|    @property
  3258|         0|            0|            0|  0.00%|    @abstractmethod
  3259|         0|            0|            0|  0.00%|    def errors(self) -> Optional[str]:
  3260|         0|            0|            0|  0.00%|        pass
  3261|         0|            0|            0|  0.00%|
  3262|         0|            0|            0|  0.00%|    @property
  3263|         0|            0|            0|  0.00%|    @abstractmethod
  3264|         0|            0|            0|  0.00%|    def line_buffering(self) -> bool:
  3265|         0|            0|            0|  0.00%|        pass
  3266|         0|            0|            0|  0.00%|
  3267|         0|            0|            0|  0.00%|    @property
  3268|         0|            0|            0|  0.00%|    @abstractmethod
  3269|         0|            0|            0|  0.00%|    def newlines(self) -> Any:
  3270|         0|            0|            0|  0.00%|        pass
  3271|         0|            0|            0|  0.00%|
  3272|         0|            0|            0|  0.00%|    @abstractmethod
  3273|         0|            0|            0|  0.00%|    def __enter__(self) -> 'TextIO':
  3274|         0|            0|            0|  0.00%|        pass
  3275|         0|            0|            0|  0.00%|
  3276|         0|            0|            0|  0.00%|
  3277|         0|            0|            0|  0.00%|class _DeprecatedType(type):
  3278|         0|            0|            0|  0.00%|    def __getattribute__(cls, name):
  3279|         0|            0|            0|  0.00%|        if name not in {"__dict__", "__module__", "__doc__"} and name in cls.__dict__:
  3280|         0|            0|            0|  0.00%|            warnings.warn(
  3281|         0|            0|            0|  0.00%|                f"{cls.__name__} is deprecated, import directly "
  3282|         0|            0|            0|  0.00%|                f"from typing instead. {cls.__name__} will be removed "
  3283|         0|            0|            0|  0.00%|                "in Python 3.13.",
  3284|         0|            0|            0|  0.00%|                DeprecationWarning,
  3285|         0|            0|            0|  0.00%|                stacklevel=2,
  3286|         0|            0|            0|  0.00%|            )
  3287|         0|            0|            0|  0.00%|        return super().__getattribute__(name)
  3288|         0|            0|            0|  0.00%|
  3289|         0|            0|            0|  0.00%|
  3290|         0|            0|            0|  0.00%|class io(metaclass=_DeprecatedType):
  3291|         0|            0|            0|  0.00%|    """Wrapper namespace for IO generic classes."""
  3292|         0|            0|            0|  0.00%|
  3293|         0|            0|            0|  0.00%|    __all__ = ['IO', 'TextIO', 'BinaryIO']
  3294|         0|            0|            0|  0.00%|    IO = IO
  3295|         0|            0|            0|  0.00%|    TextIO = TextIO
  3296|         0|            0|            0|  0.00%|    BinaryIO = BinaryIO
  3297|         0|            0|            0|  0.00%|
  3298|         0|            0|            0|  0.00%|
  3299|         0|            0|            0|  0.00%|io.__name__ = __name__ + '.io'
  3300|         0|            0|            0|  0.00%|sys.modules[io.__name__] = io
  3301|         0|            0|            0|  0.00%|
  3302|         0|            0|            0|  0.00%|Pattern = _alias(stdlib_re.Pattern, 1)
  3303|         0|            0|            0|  0.00%|Match = _alias(stdlib_re.Match, 1)
  3304|         0|            0|            0|  0.00%|
  3305|         0|            0|            0|  0.00%|class re(metaclass=_DeprecatedType):
  3306|         0|            0|            0|  0.00%|    """Wrapper namespace for re type aliases."""
  3307|         0|            0|            0|  0.00%|
  3308|         0|            0|            0|  0.00%|    __all__ = ['Pattern', 'Match']
  3309|         0|            0|            0|  0.00%|    Pattern = Pattern
  3310|         0|            0|            0|  0.00%|    Match = Match
  3311|         0|            0|            0|  0.00%|
  3312|         0|            0|            0|  0.00%|
  3313|         0|            0|            0|  0.00%|re.__name__ = __name__ + '.re'
  3314|         0|            0|            0|  0.00%|sys.modules[re.__name__] = re
  3315|         0|            0|            0|  0.00%|
  3316|         0|            0|            0|  0.00%|
  3317|         0|            0|            0|  0.00%|def reveal_type[T](obj: T, /) -> T:
  3318|         0|            0|            0|  0.00%|    """Ask a static type checker to reveal the inferred type of an expression.
  3319|         0|            0|            0|  0.00%|
  3320|         0|            0|            0|  0.00%|    When a static type checker encounters a call to ``reveal_type()``,
  3321|         0|            0|            0|  0.00%|    it will emit the inferred type of the argument::
  3322|         0|            0|            0|  0.00%|
  3323|         0|            0|            0|  0.00%|        x: int = 1
  3324|         0|            0|            0|  0.00%|        reveal_type(x)
  3325|         0|            0|            0|  0.00%|
  3326|         0|            0|            0|  0.00%|    Running a static type checker (e.g., mypy) on this example
  3327|         0|            0|            0|  0.00%|    will produce output similar to 'Revealed type is "builtins.int"'.
  3328|         0|            0|            0|  0.00%|
  3329|         0|            0|            0|  0.00%|    At runtime, the function prints the runtime type of the
  3330|         0|            0|            0|  0.00%|    argument and returns the argument unchanged.
  3331|         0|            0|            0|  0.00%|    """
  3332|         0|            0|            0|  0.00%|    print(f"Runtime type is {type(obj).__name__!r}", file=sys.stderr)
  3333|         0|            0|            0|  0.00%|    return obj
  3334|         0|            0|            0|  0.00%|
  3335|         0|            0|            0|  0.00%|
  3336|         0|            0|            0|  0.00%|class _IdentityCallable(Protocol):
  3337|         0|            0|            0|  0.00%|    def __call__[T](self, arg: T, /) -> T:
  3338|         0|            0|            0|  0.00%|        ...
  3339|         0|            0|            0|  0.00%|
  3340|         0|            0|            0|  0.00%|
  3341|         0|            0|            0|  0.00%|def dataclass_transform(
  3342|         0|            0|            0|  0.00%|    *,
  3343|         0|            0|            0|  0.00%|    eq_default: bool = True,
  3344|         0|            0|            0|  0.00%|    order_default: bool = False,
  3345|         0|            0|            0|  0.00%|    kw_only_default: bool = False,
  3346|         0|            0|            0|  0.00%|    frozen_default: bool = False,
  3347|         0|            0|            0|  0.00%|    field_specifiers: tuple[type[Any] | Callable[..., Any], ...] = (),
  3348|         0|            0|            0|  0.00%|    **kwargs: Any,
  3349|         0|            0|            0|  0.00%|) -> _IdentityCallable:
  3350|         0|            0|            0|  0.00%|    """Decorator to mark an object as providing dataclass-like behaviour.
  3351|         0|            0|            0|  0.00%|
  3352|         0|            0|            0|  0.00%|    The decorator can be applied to a function, class, or metaclass.
  3353|         0|            0|            0|  0.00%|
  3354|         0|            0|            0|  0.00%|    Example usage with a decorator function::
  3355|         0|            0|            0|  0.00%|
  3356|         0|            0|            0|  0.00%|        @dataclass_transform()
  3357|         0|            0|            0|  0.00%|        def create_model[T](cls: type[T]) -> type[T]:
  3358|         0|            0|            0|  0.00%|            ...
  3359|         0|            0|            0|  0.00%|            return cls
  3360|         0|            0|            0|  0.00%|
  3361|         0|            0|            0|  0.00%|        @create_model
  3362|         0|            0|            0|  0.00%|        class CustomerModel:
  3363|         0|            0|            0|  0.00%|            id: int
  3364|         0|            0|            0|  0.00%|            name: str
  3365|         0|            0|            0|  0.00%|
  3366|         0|            0|            0|  0.00%|    On a base class::
  3367|         0|            0|            0|  0.00%|
  3368|         0|            0|            0|  0.00%|        @dataclass_transform()
  3369|         0|            0|            0|  0.00%|        class ModelBase: ...
  3370|         0|            0|            0|  0.00%|
  3371|         0|            0|            0|  0.00%|        class CustomerModel(ModelBase):
  3372|         0|            0|            0|  0.00%|            id: int
  3373|         0|            0|            0|  0.00%|            name: str
  3374|         0|            0|            0|  0.00%|
  3375|         0|            0|            0|  0.00%|    On a metaclass::
  3376|         0|            0|            0|  0.00%|
  3377|         0|            0|            0|  0.00%|        @dataclass_transform()
  3378|         0|            0|            0|  0.00%|        class ModelMeta(type): ...
  3379|         0|            0|            0|  0.00%|
  3380|         0|            0|            0|  0.00%|        class ModelBase(metaclass=ModelMeta): ...
  3381|         0|            0|            0|  0.00%|
  3382|         0|            0|            0|  0.00%|        class CustomerModel(ModelBase):
  3383|         0|            0|            0|  0.00%|            id: int
  3384|         0|            0|            0|  0.00%|            name: str
  3385|         0|            0|            0|  0.00%|
  3386|         0|            0|            0|  0.00%|    The ``CustomerModel`` classes defined above will
  3387|         0|            0|            0|  0.00%|    be treated by type checkers similarly to classes created with
  3388|         0|            0|            0|  0.00%|    ``@dataclasses.dataclass``.
  3389|         0|            0|            0|  0.00%|    For example, type checkers will assume these classes have
  3390|         0|            0|            0|  0.00%|    ``__init__`` methods that accept ``id`` and ``name``.
  3391|         0|            0|            0|  0.00%|
  3392|         0|            0|            0|  0.00%|    The arguments to this decorator can be used to customize this behavior:
  3393|         0|            0|            0|  0.00%|    - ``eq_default`` indicates whether the ``eq`` parameter is assumed to be
  3394|         0|            0|            0|  0.00%|        ``True`` or ``False`` if it is omitted by the caller.
  3395|         0|            0|            0|  0.00%|    - ``order_default`` indicates whether the ``order`` parameter is
  3396|         0|            0|            0|  0.00%|        assumed to be True or False if it is omitted by the caller.
  3397|         0|            0|            0|  0.00%|    - ``kw_only_default`` indicates whether the ``kw_only`` parameter is
  3398|         0|            0|            0|  0.00%|        assumed to be True or False if it is omitted by the caller.
  3399|         0|            0|            0|  0.00%|    - ``frozen_default`` indicates whether the ``frozen`` parameter is
  3400|         0|            0|            0|  0.00%|        assumed to be True or False if it is omitted by the caller.
  3401|         0|            0|            0|  0.00%|    - ``field_specifiers`` specifies a static list of supported classes
  3402|         0|            0|            0|  0.00%|        or functions that describe fields, similar to ``dataclasses.field()``.
  3403|         0|            0|            0|  0.00%|    - Arbitrary other keyword arguments are accepted in order to allow for
  3404|         0|            0|            0|  0.00%|        possible future extensions.
  3405|         0|            0|            0|  0.00%|
  3406|         0|            0|            0|  0.00%|    At runtime, this decorator records its arguments in the
  3407|         0|            0|            0|  0.00%|    ``__dataclass_transform__`` attribute on the decorated object.
  3408|         0|            0|            0|  0.00%|    It has no other runtime effect.
  3409|         0|            0|            0|  0.00%|
  3410|         0|            0|            0|  0.00%|    See PEP 681 for more details.
  3411|         0|            0|            0|  0.00%|    """
  3412|         0|            0|            0|  0.00%|    def decorator(cls_or_fn):
  3413|         0|            0|            0|  0.00%|        cls_or_fn.__dataclass_transform__ = {
  3414|         0|            0|            0|  0.00%|            "eq_default": eq_default,
  3415|         0|            0|            0|  0.00%|            "order_default": order_default,
  3416|         0|            0|            0|  0.00%|            "kw_only_default": kw_only_default,
  3417|         0|            0|            0|  0.00%|            "frozen_default": frozen_default,
  3418|         0|            0|            0|  0.00%|            "field_specifiers": field_specifiers,
  3419|         0|            0|            0|  0.00%|            "kwargs": kwargs,
  3420|         0|            0|            0|  0.00%|        }
  3421|         0|            0|            0|  0.00%|        return cls_or_fn
  3422|         0|            0|            0|  0.00%|    return decorator
  3423|         0|            0|            0|  0.00%|
  3424|         0|            0|            0|  0.00%|
  3425|         0|            0|            0|  0.00%|type _Func = Callable[..., Any]
  3426|         0|            0|            0|  0.00%|
  3427|         0|            0|            0|  0.00%|
  3428|         0|            0|            0|  0.00%|def override[F: _Func](method: F, /) -> F:
  3429|         0|            0|            0|  0.00%|    """Indicate that a method is intended to override a method in a base class.
  3430|         0|            0|            0|  0.00%|
  3431|         0|            0|            0|  0.00%|    Usage::
  3432|         0|            0|            0|  0.00%|
  3433|         0|            0|            0|  0.00%|        class Base:
  3434|         0|            0|            0|  0.00%|            def method(self) -> None:
  3435|         0|            0|            0|  0.00%|                pass
  3436|         0|            0|            0|  0.00%|
  3437|         0|            0|            0|  0.00%|        class Child(Base):
  3438|         0|            0|            0|  0.00%|            @override
  3439|         0|            0|            0|  0.00%|            def method(self) -> None:
  3440|         0|            0|            0|  0.00%|                super().method()
  3441|         0|            0|            0|  0.00%|
  3442|         0|            0|            0|  0.00%|    When this decorator is applied to a method, the type checker will
  3443|         0|            0|            0|  0.00%|    validate that it overrides a method or attribute with the same name on a
  3444|         0|            0|            0|  0.00%|    base class.  This helps prevent bugs that may occur when a base class is
  3445|         0|            0|            0|  0.00%|    changed without an equivalent change to a child class.
  3446|         0|            0|            0|  0.00%|
  3447|         0|            0|            0|  0.00%|    There is no runtime checking of this property. The decorator attempts to
  3448|         0|            0|            0|  0.00%|    set the ``__override__`` attribute to ``True`` on the decorated object to
  3449|         0|            0|            0|  0.00%|    allow runtime introspection.
  3450|         0|            0|            0|  0.00%|
  3451|         0|            0|            0|  0.00%|    See PEP 698 for details.
  3452|         0|            0|            0|  0.00%|    """
  3453|         0|            0|            0|  0.00%|    try:
  3454|         0|            0|            0|  0.00%|        method.__override__ = True
  3455|         0|            0|            0|  0.00%|    except (AttributeError, TypeError):
  3456|         0|            0|            0|  0.00%|        # Skip the attribute silently if it is not writable.
  3457|         0|            0|            0|  0.00%|        # AttributeError happens if the object has __slots__ or a
  3458|         0|            0|            0|  0.00%|        # read-only property, TypeError if it's a builtin class.
  3459|         0|            0|            0|  0.00%|        pass
  3460|         0|            0|            0|  0.00%|    return method
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py
File duration: 0.0014019s (1.44%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|from __future__ import annotations
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|import os
     4|         0|            0|            0|  0.00%|from collections import defaultdict
     5|         0|            0|            0|  0.00%|from typing import (
     6|         0|            0|            0|  0.00%|    Any,
     7|         0|            0|            0|  0.00%|    Callable,
     8|         0|            0|            0|  0.00%|    Hashable,
     9|         0|            0|            0|  0.00%|    TypeVar,
    10|         0|            0|            0|  0.00%|    Union,
    11|         0|            0|            0|  0.00%|)
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|from pydantic_core import CoreSchema, core_schema
    14|         0|            0|            0|  0.00%|from pydantic_core import validate_core_schema as _validate_core_schema
    15|         0|            0|            0|  0.00%|from typing_extensions import TypeAliasType, TypeGuard, get_args, get_origin
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|from . import _repr
    18|         0|            0|            0|  0.00%|from ._typing_extra import is_generic_alias
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|AnyFunctionSchema = Union[
    21|         0|            0|            0|  0.00%|    core_schema.AfterValidatorFunctionSchema,
    22|         0|            0|            0|  0.00%|    core_schema.BeforeValidatorFunctionSchema,
    23|         0|            0|            0|  0.00%|    core_schema.WrapValidatorFunctionSchema,
    24|         0|            0|            0|  0.00%|    core_schema.PlainValidatorFunctionSchema,
    25|         0|            0|            0|  0.00%|]
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|FunctionSchemaWithInnerSchema = Union[
    29|         0|            0|            0|  0.00%|    core_schema.AfterValidatorFunctionSchema,
    30|         0|            0|            0|  0.00%|    core_schema.BeforeValidatorFunctionSchema,
    31|         0|            0|            0|  0.00%|    core_schema.WrapValidatorFunctionSchema,
    32|         0|            0|            0|  0.00%|]
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|CoreSchemaField = Union[
    35|         0|            0|            0|  0.00%|    core_schema.ModelField, core_schema.DataclassField, core_schema.TypedDictField, core_schema.ComputedField
    36|         0|            0|            0|  0.00%|]
    37|         0|            0|            0|  0.00%|CoreSchemaOrField = Union[core_schema.CoreSchema, CoreSchemaField]
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|_CORE_SCHEMA_FIELD_TYPES = {'typed-dict-field', 'dataclass-field', 'model-field', 'computed-field'}
    40|         0|            0|            0|  0.00%|_FUNCTION_WITH_INNER_SCHEMA_TYPES = {'function-before', 'function-after', 'function-wrap'}
    41|         0|            0|            0|  0.00%|_LIST_LIKE_SCHEMA_WITH_ITEMS_TYPES = {'list', 'set', 'frozenset'}
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|TAGGED_UNION_TAG_KEY = 'pydantic.internal.tagged_union_tag'
    44|         0|            0|            0|  0.00%|"""
    45|         0|            0|            0|  0.00%|Used in a `Tag` schema to specify the tag used for a discriminated union.
    46|         0|            0|            0|  0.00%|"""
    47|         0|            0|            0|  0.00%|HAS_INVALID_SCHEMAS_METADATA_KEY = 'pydantic.internal.invalid'
    48|         0|            0|            0|  0.00%|"""Used to mark a schema that is invalid because it refers to a definition that was not yet defined when the
    49|         0|            0|            0|  0.00%|schema was first encountered.
    50|         0|            0|            0|  0.00%|"""
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|def is_core_schema(
    54|         0|            0|            0|  0.00%|    schema: CoreSchemaOrField,
    55|         0|            0|            0|  0.00%|) -> TypeGuard[CoreSchema]:
    56|         0|            0|            0|  0.00%|    return schema['type'] not in _CORE_SCHEMA_FIELD_TYPES
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|def is_core_schema_field(
    60|         0|            0|            0|  0.00%|    schema: CoreSchemaOrField,
    61|         0|            0|            0|  0.00%|) -> TypeGuard[CoreSchemaField]:
    62|         0|            0|            0|  0.00%|    return schema['type'] in _CORE_SCHEMA_FIELD_TYPES
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|def is_function_with_inner_schema(
    66|         0|            0|            0|  0.00%|    schema: CoreSchemaOrField,
    67|         0|            0|            0|  0.00%|) -> TypeGuard[FunctionSchemaWithInnerSchema]:
    68|         0|            0|            0|  0.00%|    return schema['type'] in _FUNCTION_WITH_INNER_SCHEMA_TYPES
    69|         0|            0|            0|  0.00%|
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|def is_list_like_schema_with_items_schema(
    72|         0|            0|            0|  0.00%|    schema: CoreSchema,
    73|         0|            0|            0|  0.00%|) -> TypeGuard[core_schema.ListSchema | core_schema.SetSchema | core_schema.FrozenSetSchema]:
    74|         0|            0|            0|  0.00%|    return schema['type'] in _LIST_LIKE_SCHEMA_WITH_ITEMS_TYPES
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|
    77|         4|  2.40803e-05|  6.02007e-06|  0.02%|def get_type_ref(type_: type[Any], args_override: tuple[type[Any], ...] | None = None) -> str:
    78|         0|            0|            0|  0.00%|    """Produces the ref to be used for this type by pydantic_core's core schemas.
    79|         0|            0|            0|  0.00%|
    80|         0|            0|            0|  0.00%|    This `args_override` argument was added for the purpose of creating valid recursive references
    81|         0|            0|            0|  0.00%|    when creating generic models without needing to create a concrete class.
    82|         0|            0|            0|  0.00%|    """
    83|         4|  3.88622e-05|  9.71556e-06|  0.04%|    origin = get_origin(type_) or type_
(call)|         4|  3.86238e-05|  9.65595e-06|  0.04%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:2310 get_origin
    84|         0|            0|            0|  0.00%|
    85|         4|  4.64916e-05|  1.16229e-05|  0.05%|    args = get_args(type_) if is_generic_alias(type_) else (args_override or ())
(call)|         4|  2.02656e-05|  5.06639e-06|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_typing_extra.py:497 is_generic_alias
(call)|         2|   1.3113e-05|  6.55651e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:2340 get_args
    86|         4|  2.88486e-05|  7.21216e-06|  0.03%|    generic_metadata = getattr(type_, '__pydantic_generic_metadata__', None)
(call)|         2|  6.22272e-05|  3.11136e-05|  0.06%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:2025 __getattr__
    87|         4|   1.0252e-05|    2.563e-06|  0.01%|    if generic_metadata:
    88|         0|            0|            0|  0.00%|        origin = generic_metadata['origin'] or origin
    89|         0|            0|            0|  0.00%|        args = generic_metadata['args'] or args
    90|         0|            0|            0|  0.00%|
    91|         4|  1.23978e-05|  3.09944e-06|  0.01%|    module_name = getattr(origin, '__module__', '<No __module__>')
    92|         4|  1.26362e-05|  3.15905e-06|  0.01%|    if isinstance(origin, TypeAliasType):
    93|         0|            0|            0|  0.00%|        type_ref = f'{module_name}.{origin.__name__}:{id(origin)}'
    94|         0|            0|            0|  0.00%|    else:
    95|         4|  9.05991e-06|  2.26498e-06|  0.01%|        try:
    96|         4|  2.24113e-05|  5.60284e-06|  0.02%|            qualname = getattr(origin, '__qualname__', f'<No __qualname__: {origin}>')
    97|         0|            0|            0|  0.00%|        except Exception:
    98|         0|            0|            0|  0.00%|            qualname = getattr(origin, '__qualname__', '<No __qualname__>')
    99|         4|  1.28746e-05|  3.21865e-06|  0.01%|        type_ref = f'{module_name}.{qualname}:{id(origin)}'
   100|         0|            0|            0|  0.00%|
   101|         4|  1.23978e-05|  3.09944e-06|  0.01%|    arg_refs: list[str] = []
   102|         8|  2.36034e-05|  2.95043e-06|  0.02%|    for arg in args:
   103|         4|  1.38283e-05|  3.45707e-06|  0.01%|        if isinstance(arg, str):
   104|         0|            0|            0|  0.00%|            # Handle string literals as a special case; we may be able to remove this special handling if we
   105|         0|            0|            0|  0.00%|            # wrap them in a ForwardRef at some point.
   106|         0|            0|            0|  0.00%|            arg_ref = f'{arg}:str-{id(arg)}'
   107|         0|            0|            0|  0.00%|        else:
   108|         4|  5.79357e-05|  1.44839e-05|  0.06%|            arg_ref = f'{_repr.display_as_type(arg)}:{id(arg)}'
(call)|         4|  0.000263214|  6.58035e-05|  0.27%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_repr.py:86 display_as_type
   109|         4|   1.0252e-05|    2.563e-06|  0.01%|        arg_refs.append(arg_ref)
   110|         4|  8.82149e-06|  2.20537e-06|  0.01%|    if arg_refs:
   111|         2|   6.4373e-06|  3.21865e-06|  0.01%|        type_ref = f'{type_ref}[{",".join(arg_refs)}]'
   112|         4|   1.0252e-05|    2.563e-06|  0.01%|    return type_ref
   113|         0|            0|            0|  0.00%|
   114|         0|            0|            0|  0.00%|
   115|         6|  9.05991e-06|  1.50998e-06|  0.01%|def get_ref(s: core_schema.CoreSchema) -> None | str:
   116|         0|            0|            0|  0.00%|    """Get the ref from the schema if it has one.
   117|         0|            0|            0|  0.00%|    This exists just for type checking to work correctly.
   118|         0|            0|            0|  0.00%|    """
   119|         6|  8.10623e-06|  1.35104e-06|  0.01%|    return s.get('ref', None)
   120|         0|            0|            0|  0.00%|
   121|         0|            0|            0|  0.00%|
   122|         2|  4.52995e-06|  2.26498e-06|  0.00%|def collect_definitions(schema: core_schema.CoreSchema) -> dict[str, core_schema.CoreSchema]:
   123|         2|  5.96046e-06|  2.98023e-06|  0.01%|    defs: dict[str, CoreSchema] = {}
   124|         0|            0|            0|  0.00%|
   125|         6|  8.10623e-06|  1.35104e-06|  0.01%|    def _record_valid_refs(s: core_schema.CoreSchema, recurse: Recurse) -> core_schema.CoreSchema:
   126|         4|  3.12328e-05|  7.80821e-06|  0.03%|        ref = get_ref(s)
(call)|         4|  1.00136e-05|   2.5034e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:115 get_ref
   127|         4|  4.52995e-06|  1.13249e-06|  0.00%|        if ref:
   128|         0|            0|            0|  0.00%|            defs[ref] = s
   129|         4|  1.85966e-05|  4.64916e-06|  0.02%|        return recurse(s, _record_valid_refs)
(call)|         2|  2.69413e-05|  1.34706e-05|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:199 _walk
(call)|         2|  7.60555e-05|  3.80278e-05|  0.08%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:196 walk
   130|         0|            0|            0|  0.00%|
   131|         2|  9.29832e-06|  4.64916e-06|  0.01%|    walk_core_schema(schema, _record_valid_refs)
(call)|         2|  0.000119925|  5.99623e-05|  0.12%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:400 walk_core_schema
   132|         0|            0|            0|  0.00%|
   133|         2|  3.57628e-06|  1.78814e-06|  0.00%|    return defs
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|
   136|         0|            0|            0|  0.00%|def define_expected_missing_refs(
   137|         0|            0|            0|  0.00%|    schema: core_schema.CoreSchema, allowed_missing_refs: set[str]
   138|         0|            0|            0|  0.00%|) -> core_schema.CoreSchema | None:
   139|         0|            0|            0|  0.00%|    if not allowed_missing_refs:
   140|         0|            0|            0|  0.00%|        # in this case, there are no missing refs to potentially substitute, so there's no need to walk the schema
   141|         0|            0|            0|  0.00%|        # this is a common case (will be hit for all non-generic models), so it's worth optimizing for
   142|         0|            0|            0|  0.00%|        return None
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|    refs = collect_definitions(schema).keys()
   145|         0|            0|            0|  0.00%|
   146|         0|            0|            0|  0.00%|    expected_missing_refs = allowed_missing_refs.difference(refs)
   147|         0|            0|            0|  0.00%|    if expected_missing_refs:
   148|         0|            0|            0|  0.00%|        definitions: list[core_schema.CoreSchema] = [
   149|         0|            0|            0|  0.00%|            # TODO: Replace this with a (new) CoreSchema that, if present at any level, makes validation fail
   150|         0|            0|            0|  0.00%|            #   Issue: https://github.com/pydantic/pydantic-core/issues/619
   151|         0|            0|            0|  0.00%|            core_schema.none_schema(ref=ref, metadata={HAS_INVALID_SCHEMAS_METADATA_KEY: True})
   152|         0|            0|            0|  0.00%|            for ref in expected_missing_refs
   153|         0|            0|            0|  0.00%|        ]
   154|         0|            0|            0|  0.00%|        return core_schema.definitions_schema(schema, definitions)
   155|         0|            0|            0|  0.00%|    return None
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|
   158|         2|  4.76837e-06|  2.38419e-06|  0.00%|def collect_invalid_schemas(schema: core_schema.CoreSchema) -> bool:
   159|         2|   3.8147e-06|  1.90735e-06|  0.00%|    invalid = False
   160|         0|            0|            0|  0.00%|
   161|         6|  8.10623e-06|  1.35104e-06|  0.01%|    def _is_schema_valid(s: core_schema.CoreSchema, recurse: Recurse) -> core_schema.CoreSchema:
   162|         0|            0|            0|  0.00%|        nonlocal invalid
   163|         4|  5.48363e-06|  1.37091e-06|  0.01%|        if 'metadata' in s:
   164|         0|            0|            0|  0.00%|            metadata = s['metadata']
   165|         0|            0|            0|  0.00%|            if HAS_INVALID_SCHEMAS_METADATA_KEY in metadata:
   166|         0|            0|            0|  0.00%|                invalid = metadata[HAS_INVALID_SCHEMAS_METADATA_KEY]
   167|         0|            0|            0|  0.00%|                return s
   168|         4|  1.78814e-05|  4.47035e-06|  0.02%|        return recurse(s, _is_schema_valid)
(call)|         2|  2.55108e-05|  1.27554e-05|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:199 _walk
(call)|         2|  5.93662e-05|  2.96831e-05|  0.06%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:196 walk
   169|         0|            0|            0|  0.00%|
   170|         2|  9.77516e-06|  4.88758e-06|  0.01%|    walk_core_schema(schema, _is_schema_valid)
(call)|         2|  8.67844e-05|  4.33922e-05|  0.09%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:400 walk_core_schema
   171|         2|   3.8147e-06|  1.90735e-06|  0.00%|    return invalid
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|T = TypeVar('T')
   175|         0|            0|            0|  0.00%|
   176|         0|            0|            0|  0.00%|
   177|         0|            0|            0|  0.00%|Recurse = Callable[[core_schema.CoreSchema, 'Walk'], core_schema.CoreSchema]
   178|         0|            0|            0|  0.00%|Walk = Callable[[core_schema.CoreSchema, Recurse], core_schema.CoreSchema]
   179|         0|            0|            0|  0.00%|
   180|         0|            0|            0|  0.00%|# TODO: Should we move _WalkCoreSchema into pydantic_core proper?
   181|         0|            0|            0|  0.00%|#   Issue: https://github.com/pydantic/pydantic-core/issues/615
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|
   184|         0|            0|            0|  0.00%|class _WalkCoreSchema:
   185|         0|            0|            0|  0.00%|    def __init__(self):
   186|         0|            0|            0|  0.00%|        self._schema_type_to_method = self._build_schema_type_to_method()
   187|         0|            0|            0|  0.00%|
   188|         0|            0|            0|  0.00%|    def _build_schema_type_to_method(self) -> dict[core_schema.CoreSchemaType, Recurse]:
   189|         0|            0|            0|  0.00%|        mapping: dict[core_schema.CoreSchemaType, Recurse] = {}
   190|         0|            0|            0|  0.00%|        key: core_schema.CoreSchemaType
   191|         0|            0|            0|  0.00%|        for key in get_args(core_schema.CoreSchemaType):
   192|         0|            0|            0|  0.00%|            method_name = f"handle_{key.replace('-', '_')}_schema"
   193|         0|            0|            0|  0.00%|            mapping[key] = getattr(self, method_name, self._handle_other_schemas)
   194|         0|            0|            0|  0.00%|        return mapping
   195|         0|            0|            0|  0.00%|
   196|        12|   2.3365e-05|  1.94709e-06|  0.02%|    def walk(self, schema: core_schema.CoreSchema, f: Walk) -> core_schema.CoreSchema:
   197|        12|  7.20024e-05|   6.0002e-06|  0.07%|        return f(schema, self._walk)
(call)|         2|  0.000101328|  5.06639e-05|  0.10%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:423 collect_refs
(call)|         2|  4.57764e-05|  2.28882e-05|  0.05%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:445 count_refs
(call)|         2|  4.31538e-05|  2.15769e-05|  0.04%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:486 inline_refs
(call)|         2|  3.91006e-05|  1.95503e-05|  0.04%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:161 _is_schema_valid
(call)|         2|  6.53267e-05|  3.26633e-05|  0.07%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:125 _record_valid_refs
(call)|         2|  8.79765e-05|  4.39882e-05|  0.09%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_discriminated_union.py:45 inner
   198|         0|            0|            0|  0.00%|
   199|        12|  2.36034e-05|  1.96695e-06|  0.02%|    def _walk(self, schema: core_schema.CoreSchema, f: Walk) -> core_schema.CoreSchema:
   200|        12|  6.36578e-05|  5.30481e-06|  0.07%|        schema = self._schema_type_to_method[schema['type']](schema.copy(), f)
(call)|        12|  7.58171e-05|  6.31809e-06|  0.08%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:206 _handle_other_schemas
   201|        12|  1.38283e-05|  1.15236e-06|  0.01%|        ser_schema: core_schema.SerSchema | None = schema.get('serialization')  # type: ignore
   202|        12|  1.40667e-05|  1.17222e-06|  0.01%|        if ser_schema:
   203|         0|            0|            0|  0.00%|            schema['serialization'] = self._handle_ser_schemas(ser_schema, f)
   204|        12|  1.33514e-05|  1.11262e-06|  0.01%|        return schema
   205|         0|            0|            0|  0.00%|
   206|        12|   1.5974e-05|  1.33117e-06|  0.02%|    def _handle_other_schemas(self, schema: core_schema.CoreSchema, f: Walk) -> core_schema.CoreSchema:
   207|        12|  1.64509e-05|  1.37091e-06|  0.02%|        sub_schema = schema.get('schema', None)
   208|        12|   2.7895e-05|  2.32458e-06|  0.03%|        if sub_schema is not None:
   209|         0|            0|            0|  0.00%|            schema['schema'] = self.walk(sub_schema, f)  # type: ignore
   210|        12|  1.54972e-05|  1.29143e-06|  0.02%|        return schema
   211|         0|            0|            0|  0.00%|
   212|         0|            0|            0|  0.00%|    def _handle_ser_schemas(self, ser_schema: core_schema.SerSchema, f: Walk) -> core_schema.SerSchema:
   213|         0|            0|            0|  0.00%|        schema: core_schema.CoreSchema | None = ser_schema.get('schema', None)
   214|         0|            0|            0|  0.00%|        if schema is not None:
   215|         0|            0|            0|  0.00%|            ser_schema['schema'] = self.walk(schema, f)  # type: ignore
   216|         0|            0|            0|  0.00%|        return_schema: core_schema.CoreSchema | None = ser_schema.get('return_schema', None)
   217|         0|            0|            0|  0.00%|        if return_schema is not None:
   218|         0|            0|            0|  0.00%|            ser_schema['return_schema'] = self.walk(return_schema, f)  # type: ignore
   219|         0|            0|            0|  0.00%|        return ser_schema
   220|         0|            0|            0|  0.00%|
   221|         0|            0|            0|  0.00%|    def handle_definitions_schema(self, schema: core_schema.DefinitionsSchema, f: Walk) -> core_schema.CoreSchema:
   222|         0|            0|            0|  0.00%|        new_definitions: list[core_schema.CoreSchema] = []
   223|         0|            0|            0|  0.00%|        for definition in schema['definitions']:
   224|         0|            0|            0|  0.00%|            if 'schema_ref' in definition and 'ref' in definition:
   225|         0|            0|            0|  0.00%|                # This indicates a purposely indirect reference
   226|         0|            0|            0|  0.00%|                # We want to keep such references around for implications related to JSON schema, etc.:
   227|         0|            0|            0|  0.00%|                new_definitions.append(definition)
   228|         0|            0|            0|  0.00%|                # However, we still need to walk the referenced definition:
   229|         0|            0|            0|  0.00%|                self.walk(definition, f)
   230|         0|            0|            0|  0.00%|                continue
   231|         0|            0|            0|  0.00%|
   232|         0|            0|            0|  0.00%|            updated_definition = self.walk(definition, f)
   233|         0|            0|            0|  0.00%|            if 'ref' in updated_definition:
   234|         0|            0|            0|  0.00%|                # If the updated definition schema doesn't have a 'ref', it shouldn't go in the definitions
   235|         0|            0|            0|  0.00%|                # This is most likely to happen due to replacing something with a definition reference, in
   236|         0|            0|            0|  0.00%|                # which case it should certainly not go in the definitions list
   237|         0|            0|            0|  0.00%|                new_definitions.append(updated_definition)
   238|         0|            0|            0|  0.00%|        new_inner_schema = self.walk(schema['schema'], f)
   239|         0|            0|            0|  0.00%|
   240|         0|            0|            0|  0.00%|        if not new_definitions and len(schema) == 3:
   241|         0|            0|            0|  0.00%|            # This means we'd be returning a "trivial" definitions schema that just wrapped the inner schema
   242|         0|            0|            0|  0.00%|            return new_inner_schema
   243|         0|            0|            0|  0.00%|
   244|         0|            0|            0|  0.00%|        new_schema = schema.copy()
   245|         0|            0|            0|  0.00%|        new_schema['schema'] = new_inner_schema
   246|         0|            0|            0|  0.00%|        new_schema['definitions'] = new_definitions
   247|         0|            0|            0|  0.00%|        return new_schema
   248|         0|            0|            0|  0.00%|
   249|         0|            0|            0|  0.00%|    def handle_list_schema(self, schema: core_schema.ListSchema, f: Walk) -> core_schema.CoreSchema:
   250|         0|            0|            0|  0.00%|        items_schema = schema.get('items_schema')
   251|         0|            0|            0|  0.00%|        if items_schema is not None:
   252|         0|            0|            0|  0.00%|            schema['items_schema'] = self.walk(items_schema, f)
   253|         0|            0|            0|  0.00%|        return schema
   254|         0|            0|            0|  0.00%|
   255|         0|            0|            0|  0.00%|    def handle_set_schema(self, schema: core_schema.SetSchema, f: Walk) -> core_schema.CoreSchema:
   256|         0|            0|            0|  0.00%|        items_schema = schema.get('items_schema')
   257|         0|            0|            0|  0.00%|        if items_schema is not None:
   258|         0|            0|            0|  0.00%|            schema['items_schema'] = self.walk(items_schema, f)
   259|         0|            0|            0|  0.00%|        return schema
   260|         0|            0|            0|  0.00%|
   261|         0|            0|            0|  0.00%|    def handle_frozenset_schema(self, schema: core_schema.FrozenSetSchema, f: Walk) -> core_schema.CoreSchema:
   262|         0|            0|            0|  0.00%|        items_schema = schema.get('items_schema')
   263|         0|            0|            0|  0.00%|        if items_schema is not None:
   264|         0|            0|            0|  0.00%|            schema['items_schema'] = self.walk(items_schema, f)
   265|         0|            0|            0|  0.00%|        return schema
   266|         0|            0|            0|  0.00%|
   267|         0|            0|            0|  0.00%|    def handle_generator_schema(self, schema: core_schema.GeneratorSchema, f: Walk) -> core_schema.CoreSchema:
   268|         0|            0|            0|  0.00%|        items_schema = schema.get('items_schema')
   269|         0|            0|            0|  0.00%|        if items_schema is not None:
   270|         0|            0|            0|  0.00%|            schema['items_schema'] = self.walk(items_schema, f)
   271|         0|            0|            0|  0.00%|        return schema
   272|         0|            0|            0|  0.00%|
   273|         0|            0|            0|  0.00%|    def handle_tuple_schema(self, schema: core_schema.TupleSchema, f: Walk) -> core_schema.CoreSchema:
   274|         0|            0|            0|  0.00%|        schema['items_schema'] = [self.walk(v, f) for v in schema['items_schema']]
   275|         0|            0|            0|  0.00%|        return schema
   276|         0|            0|            0|  0.00%|
   277|         0|            0|            0|  0.00%|    def handle_dict_schema(self, schema: core_schema.DictSchema, f: Walk) -> core_schema.CoreSchema:
   278|         0|            0|            0|  0.00%|        keys_schema = schema.get('keys_schema')
   279|         0|            0|            0|  0.00%|        if keys_schema is not None:
   280|         0|            0|            0|  0.00%|            schema['keys_schema'] = self.walk(keys_schema, f)
   281|         0|            0|            0|  0.00%|        values_schema = schema.get('values_schema')
   282|         0|            0|            0|  0.00%|        if values_schema:
   283|         0|            0|            0|  0.00%|            schema['values_schema'] = self.walk(values_schema, f)
   284|         0|            0|            0|  0.00%|        return schema
   285|         0|            0|            0|  0.00%|
   286|         0|            0|            0|  0.00%|    def handle_function_schema(self, schema: AnyFunctionSchema, f: Walk) -> core_schema.CoreSchema:
   287|         0|            0|            0|  0.00%|        if not is_function_with_inner_schema(schema):
   288|         0|            0|            0|  0.00%|            return schema
   289|         0|            0|            0|  0.00%|        schema['schema'] = self.walk(schema['schema'], f)
   290|         0|            0|            0|  0.00%|        return schema
   291|         0|            0|            0|  0.00%|
   292|         0|            0|            0|  0.00%|    def handle_union_schema(self, schema: core_schema.UnionSchema, f: Walk) -> core_schema.CoreSchema:
   293|         0|            0|            0|  0.00%|        new_choices: list[CoreSchema | tuple[CoreSchema, str]] = []
   294|         0|            0|            0|  0.00%|        for v in schema['choices']:
   295|         0|            0|            0|  0.00%|            if isinstance(v, tuple):
   296|         0|            0|            0|  0.00%|                new_choices.append((self.walk(v[0], f), v[1]))
   297|         0|            0|            0|  0.00%|            else:
   298|         0|            0|            0|  0.00%|                new_choices.append(self.walk(v, f))
   299|         0|            0|            0|  0.00%|        schema['choices'] = new_choices
   300|         0|            0|            0|  0.00%|        return schema
   301|         0|            0|            0|  0.00%|
   302|         0|            0|            0|  0.00%|    def handle_tagged_union_schema(self, schema: core_schema.TaggedUnionSchema, f: Walk) -> core_schema.CoreSchema:
   303|         0|            0|            0|  0.00%|        new_choices: dict[Hashable, core_schema.CoreSchema] = {}
   304|         0|            0|            0|  0.00%|        for k, v in schema['choices'].items():
   305|         0|            0|            0|  0.00%|            new_choices[k] = v if isinstance(v, (str, int)) else self.walk(v, f)
   306|         0|            0|            0|  0.00%|        schema['choices'] = new_choices
   307|         0|            0|            0|  0.00%|        return schema
   308|         0|            0|            0|  0.00%|
   309|         0|            0|            0|  0.00%|    def handle_chain_schema(self, schema: core_schema.ChainSchema, f: Walk) -> core_schema.CoreSchema:
   310|         0|            0|            0|  0.00%|        schema['steps'] = [self.walk(v, f) for v in schema['steps']]
   311|         0|            0|            0|  0.00%|        return schema
   312|         0|            0|            0|  0.00%|
   313|         0|            0|            0|  0.00%|    def handle_lax_or_strict_schema(self, schema: core_schema.LaxOrStrictSchema, f: Walk) -> core_schema.CoreSchema:
   314|         0|            0|            0|  0.00%|        schema['lax_schema'] = self.walk(schema['lax_schema'], f)
   315|         0|            0|            0|  0.00%|        schema['strict_schema'] = self.walk(schema['strict_schema'], f)
   316|         0|            0|            0|  0.00%|        return schema
   317|         0|            0|            0|  0.00%|
   318|         0|            0|            0|  0.00%|    def handle_json_or_python_schema(self, schema: core_schema.JsonOrPythonSchema, f: Walk) -> core_schema.CoreSchema:
   319|         0|            0|            0|  0.00%|        schema['json_schema'] = self.walk(schema['json_schema'], f)
   320|         0|            0|            0|  0.00%|        schema['python_schema'] = self.walk(schema['python_schema'], f)
   321|         0|            0|            0|  0.00%|        return schema
   322|         0|            0|            0|  0.00%|
   323|         0|            0|            0|  0.00%|    def handle_model_fields_schema(self, schema: core_schema.ModelFieldsSchema, f: Walk) -> core_schema.CoreSchema:
   324|         0|            0|            0|  0.00%|        extras_schema = schema.get('extras_schema')
   325|         0|            0|            0|  0.00%|        if extras_schema is not None:
   326|         0|            0|            0|  0.00%|            schema['extras_schema'] = self.walk(extras_schema, f)
   327|         0|            0|            0|  0.00%|        replaced_fields: dict[str, core_schema.ModelField] = {}
   328|         0|            0|            0|  0.00%|        replaced_computed_fields: list[core_schema.ComputedField] = []
   329|         0|            0|            0|  0.00%|        for computed_field in schema.get('computed_fields', ()):
   330|         0|            0|            0|  0.00%|            replaced_field = computed_field.copy()
   331|         0|            0|            0|  0.00%|            replaced_field['return_schema'] = self.walk(computed_field['return_schema'], f)
   332|         0|            0|            0|  0.00%|            replaced_computed_fields.append(replaced_field)
   333|         0|            0|            0|  0.00%|        if replaced_computed_fields:
   334|         0|            0|            0|  0.00%|            schema['computed_fields'] = replaced_computed_fields
   335|         0|            0|            0|  0.00%|        for k, v in schema['fields'].items():
   336|         0|            0|            0|  0.00%|            replaced_field = v.copy()
   337|         0|            0|            0|  0.00%|            replaced_field['schema'] = self.walk(v['schema'], f)
   338|         0|            0|            0|  0.00%|            replaced_fields[k] = replaced_field
   339|         0|            0|            0|  0.00%|        schema['fields'] = replaced_fields
   340|         0|            0|            0|  0.00%|        return schema
   341|         0|            0|            0|  0.00%|
   342|         0|            0|            0|  0.00%|    def handle_typed_dict_schema(self, schema: core_schema.TypedDictSchema, f: Walk) -> core_schema.CoreSchema:
   343|         0|            0|            0|  0.00%|        extras_schema = schema.get('extras_schema')
   344|         0|            0|            0|  0.00%|        if extras_schema is not None:
   345|         0|            0|            0|  0.00%|            schema['extras_schema'] = self.walk(extras_schema, f)
   346|         0|            0|            0|  0.00%|        replaced_computed_fields: list[core_schema.ComputedField] = []
   347|         0|            0|            0|  0.00%|        for computed_field in schema.get('computed_fields', ()):
   348|         0|            0|            0|  0.00%|            replaced_field = computed_field.copy()
   349|         0|            0|            0|  0.00%|            replaced_field['return_schema'] = self.walk(computed_field['return_schema'], f)
   350|         0|            0|            0|  0.00%|            replaced_computed_fields.append(replaced_field)
   351|         0|            0|            0|  0.00%|        if replaced_computed_fields:
   352|         0|            0|            0|  0.00%|            schema['computed_fields'] = replaced_computed_fields
   353|         0|            0|            0|  0.00%|        replaced_fields: dict[str, core_schema.TypedDictField] = {}
   354|         0|            0|            0|  0.00%|        for k, v in schema['fields'].items():
   355|         0|            0|            0|  0.00%|            replaced_field = v.copy()
   356|         0|            0|            0|  0.00%|            replaced_field['schema'] = self.walk(v['schema'], f)
   357|         0|            0|            0|  0.00%|            replaced_fields[k] = replaced_field
   358|         0|            0|            0|  0.00%|        schema['fields'] = replaced_fields
   359|         0|            0|            0|  0.00%|        return schema
   360|         0|            0|            0|  0.00%|
   361|         0|            0|            0|  0.00%|    def handle_dataclass_args_schema(self, schema: core_schema.DataclassArgsSchema, f: Walk) -> core_schema.CoreSchema:
   362|         0|            0|            0|  0.00%|        replaced_fields: list[core_schema.DataclassField] = []
   363|         0|            0|            0|  0.00%|        replaced_computed_fields: list[core_schema.ComputedField] = []
   364|         0|            0|            0|  0.00%|        for computed_field in schema.get('computed_fields', ()):
   365|         0|            0|            0|  0.00%|            replaced_field = computed_field.copy()
   366|         0|            0|            0|  0.00%|            replaced_field['return_schema'] = self.walk(computed_field['return_schema'], f)
   367|         0|            0|            0|  0.00%|            replaced_computed_fields.append(replaced_field)
   368|         0|            0|            0|  0.00%|        if replaced_computed_fields:
   369|         0|            0|            0|  0.00%|            schema['computed_fields'] = replaced_computed_fields
   370|         0|            0|            0|  0.00%|        for field in schema['fields']:
   371|         0|            0|            0|  0.00%|            replaced_field = field.copy()
   372|         0|            0|            0|  0.00%|            replaced_field['schema'] = self.walk(field['schema'], f)
   373|         0|            0|            0|  0.00%|            replaced_fields.append(replaced_field)
   374|         0|            0|            0|  0.00%|        schema['fields'] = replaced_fields
   375|         0|            0|            0|  0.00%|        return schema
   376|         0|            0|            0|  0.00%|
   377|         0|            0|            0|  0.00%|    def handle_arguments_schema(self, schema: core_schema.ArgumentsSchema, f: Walk) -> core_schema.CoreSchema:
   378|         0|            0|            0|  0.00%|        replaced_arguments_schema: list[core_schema.ArgumentsParameter] = []
   379|         0|            0|            0|  0.00%|        for param in schema['arguments_schema']:
   380|         0|            0|            0|  0.00%|            replaced_param = param.copy()
   381|         0|            0|            0|  0.00%|            replaced_param['schema'] = self.walk(param['schema'], f)
   382|         0|            0|            0|  0.00%|            replaced_arguments_schema.append(replaced_param)
   383|         0|            0|            0|  0.00%|        schema['arguments_schema'] = replaced_arguments_schema
   384|         0|            0|            0|  0.00%|        if 'var_args_schema' in schema:
   385|         0|            0|            0|  0.00%|            schema['var_args_schema'] = self.walk(schema['var_args_schema'], f)
   386|         0|            0|            0|  0.00%|        if 'var_kwargs_schema' in schema:
   387|         0|            0|            0|  0.00%|            schema['var_kwargs_schema'] = self.walk(schema['var_kwargs_schema'], f)
   388|         0|            0|            0|  0.00%|        return schema
   389|         0|            0|            0|  0.00%|
   390|         0|            0|            0|  0.00%|    def handle_call_schema(self, schema: core_schema.CallSchema, f: Walk) -> core_schema.CoreSchema:
   391|         0|            0|            0|  0.00%|        schema['arguments_schema'] = self.walk(schema['arguments_schema'], f)
   392|         0|            0|            0|  0.00%|        if 'return_schema' in schema:
   393|         0|            0|            0|  0.00%|            schema['return_schema'] = self.walk(schema['return_schema'], f)
   394|         0|            0|            0|  0.00%|        return schema
   395|         0|            0|            0|  0.00%|
   396|         0|            0|            0|  0.00%|
   397|         0|            0|            0|  0.00%|_dispatch = _WalkCoreSchema().walk
   398|         0|            0|            0|  0.00%|
   399|         0|            0|            0|  0.00%|
   400|        12|  3.50475e-05|  2.92063e-06|  0.04%|def walk_core_schema(schema: core_schema.CoreSchema, f: Walk) -> core_schema.CoreSchema:
   401|         0|            0|            0|  0.00%|    """Recursively traverse a CoreSchema.
   402|         0|            0|            0|  0.00%|
   403|         0|            0|            0|  0.00%|    Args:
   404|         0|            0|            0|  0.00%|        schema (core_schema.CoreSchema): The CoreSchema to process, it will not be modified.
   405|         0|            0|            0|  0.00%|        f (Walk): A function to apply. This function takes two arguments:
   406|         0|            0|            0|  0.00%|          1. The current CoreSchema that is being processed
   407|         0|            0|            0|  0.00%|             (not the same one you passed into this function, one level down).
   408|         0|            0|            0|  0.00%|          2. The "next" `f` to call. This lets you for example use `f=functools.partial(some_method, some_context)`
   409|         0|            0|            0|  0.00%|             to pass data down the recursive calls without using globals or other mutable state.
   410|         0|            0|            0|  0.00%|
   411|         0|            0|            0|  0.00%|    Returns:
   412|         0|            0|            0|  0.00%|        core_schema.CoreSchema: A processed CoreSchema.
   413|         0|            0|            0|  0.00%|    """
   414|        12|  7.70092e-05|  6.41743e-06|  0.08%|    return f(schema.copy(), _dispatch)
(call)|         2|  0.000146627|  7.33137e-05|  0.15%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:423 collect_refs
(call)|         2|  7.93934e-05|  3.96967e-05|  0.08%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:445 count_refs
(call)|         2|  7.86781e-05|  3.93391e-05|  0.08%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:486 inline_refs
(call)|         2|  7.36713e-05|  3.68357e-05|  0.08%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:161 _is_schema_valid
(call)|         2|  0.000106573|  5.32866e-05|  0.11%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:125 _record_valid_refs
(call)|         2|  0.000131369|  6.56843e-05|  0.14%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_discriminated_union.py:45 inner
   415|         0|            0|            0|  0.00%|
   416|         0|            0|            0|  0.00%|
   417|         2|  1.66893e-05|  8.34465e-06|  0.02%|def simplify_schema_references(schema: core_schema.CoreSchema) -> core_schema.CoreSchema:  # noqa: C901
   418|         2|  1.14441e-05|  5.72205e-06|  0.01%|    definitions: dict[str, core_schema.CoreSchema] = {}
   419|         2|  1.16825e-05|  5.84126e-06|  0.01%|    ref_counts: dict[str, int] = defaultdict(int)
   420|         2|  9.77516e-06|  4.88758e-06|  0.01%|    involved_in_recursion: dict[str, bool] = {}
   421|         2|  1.28746e-05|   6.4373e-06|  0.01%|    current_recursion_ref_count: dict[str, int] = defaultdict(int)
   422|         0|            0|            0|  0.00%|
   423|         6|  1.78814e-05|  2.98023e-06|  0.02%|    def collect_refs(s: core_schema.CoreSchema, recurse: Recurse) -> core_schema.CoreSchema:
   424|         4|  7.39098e-06|  1.84774e-06|  0.01%|        if s['type'] == 'definitions':
   425|         2|  4.29153e-06|  2.14577e-06|  0.00%|            for definition in s['definitions']:
   426|         0|            0|            0|  0.00%|                ref = get_ref(definition)
   427|         0|            0|            0|  0.00%|                assert ref is not None
   428|         0|            0|            0|  0.00%|                if ref not in definitions:
   429|         0|            0|            0|  0.00%|                    definitions[ref] = definition
   430|         0|            0|            0|  0.00%|                recurse(definition, collect_refs)
   431|         2|   1.5974e-05|  7.98702e-06|  0.02%|            return recurse(s['schema'], collect_refs)
(call)|         2|  0.000118494|   5.9247e-05|  0.12%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:196 walk
   432|         0|            0|            0|  0.00%|        else:
   433|         2|  1.28746e-05|   6.4373e-06|  0.01%|            ref = get_ref(s)
(call)|         2|  7.15256e-06|  3.57628e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:115 get_ref
   434|         2|   3.8147e-06|  1.90735e-06|  0.00%|            if ref is not None:
   435|         0|            0|            0|  0.00%|                new = recurse(s, collect_refs)
   436|         0|            0|            0|  0.00%|                new_ref = get_ref(new)
   437|         0|            0|            0|  0.00%|                if new_ref:
   438|         0|            0|            0|  0.00%|                    definitions[new_ref] = new
   439|         0|            0|            0|  0.00%|                return core_schema.definition_reference_schema(schema_ref=ref)
   440|         0|            0|            0|  0.00%|            else:
   441|         2|  1.64509e-05|  8.22544e-06|  0.02%|                return recurse(s, collect_refs)
(call)|         2|  5.38826e-05|  2.69413e-05|  0.06%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:199 _walk
   442|         0|            0|            0|  0.00%|
   443|         2|  2.98023e-05|  1.49012e-05|  0.03%|    schema = walk_core_schema(schema, collect_refs)
(call)|         2|  0.000176191|  8.80957e-05|  0.18%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:400 walk_core_schema
   444|         0|            0|            0|  0.00%|
   445|         6|  1.90735e-05|  3.17891e-06|  0.02%|    def count_refs(s: core_schema.CoreSchema, recurse: Recurse) -> core_schema.CoreSchema:
   446|         4|  6.91414e-06|  1.72853e-06|  0.01%|        if s['type'] != 'definition-ref':
   447|         4|  2.16961e-05|  5.42402e-06|  0.02%|            return recurse(s, count_refs)
(call)|         2|  2.67029e-05|  1.33514e-05|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:199 _walk
(call)|         2|  6.10352e-05|  3.05176e-05|  0.06%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:196 walk
   448|         0|            0|            0|  0.00%|        ref = s['schema_ref']
   449|         0|            0|            0|  0.00%|        ref_counts[ref] += 1
   450|         0|            0|            0|  0.00%|
   451|         0|            0|            0|  0.00%|        if ref_counts[ref] >= 2:
   452|         0|            0|            0|  0.00%|            # If this model is involved in a recursion this should be detected
   453|         0|            0|            0|  0.00%|            # on its second encounter, we can safely stop the walk here.
   454|         0|            0|            0|  0.00%|            if current_recursion_ref_count[ref] != 0:
   455|         0|            0|            0|  0.00%|                involved_in_recursion[ref] = True
   456|         0|            0|            0|  0.00%|            return s
   457|         0|            0|            0|  0.00%|
   458|         0|            0|            0|  0.00%|        current_recursion_ref_count[ref] += 1
   459|         0|            0|            0|  0.00%|        recurse(definitions[ref], count_refs)
   460|         0|            0|            0|  0.00%|        current_recursion_ref_count[ref] -= 1
   461|         0|            0|            0|  0.00%|        return s
   462|         0|            0|            0|  0.00%|
   463|         2|  3.00407e-05|  1.50204e-05|  0.03%|    schema = walk_core_schema(schema, count_refs)
(call)|         2|  0.000100374|  5.01871e-05|  0.10%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:400 walk_core_schema
   464|         0|            0|            0|  0.00%|
   465|         6|  4.69685e-05|  7.82808e-06|  0.05%|    assert all(c == 0 for c in current_recursion_ref_count.values()), 'this is a bug! please report it'
(call)|         2|  1.40667e-05|  7.03335e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:465 <genexpr>
   466|         0|            0|            0|  0.00%|
   467|         2|  9.77516e-06|  4.88758e-06|  0.01%|    def can_be_inlined(s: core_schema.DefinitionReferenceSchema, ref: str) -> bool:
   468|         0|            0|            0|  0.00%|        if ref_counts[ref] > 1:
   469|         0|            0|            0|  0.00%|            return False
   470|         0|            0|            0|  0.00%|        if involved_in_recursion.get(ref, False):
   471|         0|            0|            0|  0.00%|            return False
   472|         0|            0|            0|  0.00%|        if 'serialization' in s:
   473|         0|            0|            0|  0.00%|            return False
   474|         0|            0|            0|  0.00%|        if 'metadata' in s:
   475|         0|            0|            0|  0.00%|            metadata = s['metadata']
   476|         0|            0|            0|  0.00%|            for k in (
   477|         0|            0|            0|  0.00%|                'pydantic_js_functions',
   478|         0|            0|            0|  0.00%|                'pydantic_js_annotation_functions',
   479|         0|            0|            0|  0.00%|                'pydantic.internal.union_discriminator',
   480|         0|            0|            0|  0.00%|            ):
   481|         0|            0|            0|  0.00%|                if k in metadata:
   482|         0|            0|            0|  0.00%|                    # we need to keep this as a ref
   483|         0|            0|            0|  0.00%|                    return False
   484|         0|            0|            0|  0.00%|        return True
   485|         0|            0|            0|  0.00%|
   486|         6|   1.7643e-05|   2.9405e-06|  0.02%|    def inline_refs(s: core_schema.CoreSchema, recurse: Recurse) -> core_schema.CoreSchema:
   487|         4|  5.72205e-06|  1.43051e-06|  0.01%|        if s['type'] == 'definition-ref':
   488|         0|            0|            0|  0.00%|            ref = s['schema_ref']
   489|         0|            0|            0|  0.00%|            # Check if the reference is only used once, not involved in recursion and does not have
   490|         0|            0|            0|  0.00%|            # any extra keys (like 'serialization')
   491|         0|            0|            0|  0.00%|            if can_be_inlined(s, ref):
   492|         0|            0|            0|  0.00%|                # Inline the reference by replacing the reference with the actual schema
   493|         0|            0|            0|  0.00%|                new = definitions.pop(ref)
   494|         0|            0|            0|  0.00%|                ref_counts[ref] -= 1  # because we just replaced it!
   495|         0|            0|            0|  0.00%|                # put all other keys that were on the def-ref schema into the inlined version
   496|         0|            0|            0|  0.00%|                # in particular this is needed for `serialization`
   497|         0|            0|            0|  0.00%|                if 'serialization' in s:
   498|         0|            0|            0|  0.00%|                    new['serialization'] = s['serialization']
   499|         0|            0|            0|  0.00%|                s = recurse(new, inline_refs)
   500|         0|            0|            0|  0.00%|                return s
   501|         0|            0|            0|  0.00%|            else:
   502|         0|            0|            0|  0.00%|                return recurse(s, inline_refs)
   503|         0|            0|            0|  0.00%|        else:
   504|         4|  2.16961e-05|  5.42402e-06|  0.02%|            return recurse(s, inline_refs)
(call)|         2|   2.6226e-05|   1.3113e-05|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:199 _walk
(call)|         2|  6.07967e-05|  3.03984e-05|  0.06%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:196 walk
   505|         0|            0|            0|  0.00%|
   506|         2|  2.76566e-05|  1.38283e-05|  0.03%|    schema = walk_core_schema(schema, inline_refs)
(call)|         2|  9.82285e-05|  4.91142e-05|  0.10%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:400 walk_core_schema
   507|         0|            0|            0|  0.00%|
   508|         2|  1.09673e-05|  5.48363e-06|  0.01%|    def_values = [v for v in definitions.values() if ref_counts[v['ref']] > 0]  # type: ignore
   509|         0|            0|            0|  0.00%|
   510|         2|   1.0252e-05|    5.126e-06|  0.01%|    if def_values:
   511|         0|            0|            0|  0.00%|        schema = core_schema.definitions_schema(schema=schema, definitions=def_values)
   512|         2|  9.77516e-06|  4.88758e-06|  0.01%|    return schema
   513|         0|            0|            0|  0.00%|
   514|         0|            0|            0|  0.00%|
   515|         0|            0|            0|  0.00%|def _strip_metadata(schema: CoreSchema) -> CoreSchema:
   516|         0|            0|            0|  0.00%|    def strip_metadata(s: CoreSchema, recurse: Recurse) -> CoreSchema:
   517|         0|            0|            0|  0.00%|        s = s.copy()
   518|         0|            0|            0|  0.00%|        s.pop('metadata', None)
   519|         0|            0|            0|  0.00%|        if s['type'] == 'model-fields':
   520|         0|            0|            0|  0.00%|            s = s.copy()
   521|         0|            0|            0|  0.00%|            s['fields'] = {k: v.copy() for k, v in s['fields'].items()}
   522|         0|            0|            0|  0.00%|            for field_name, field_schema in s['fields'].items():
   523|         0|            0|            0|  0.00%|                field_schema.pop('metadata', None)
   524|         0|            0|            0|  0.00%|                s['fields'][field_name] = field_schema
   525|         0|            0|            0|  0.00%|            computed_fields = s.get('computed_fields', None)
   526|         0|            0|            0|  0.00%|            if computed_fields:
   527|         0|            0|            0|  0.00%|                s['computed_fields'] = [cf.copy() for cf in computed_fields]
   528|         0|            0|            0|  0.00%|                for cf in computed_fields:
   529|         0|            0|            0|  0.00%|                    cf.pop('metadata', None)
   530|         0|            0|            0|  0.00%|            else:
   531|         0|            0|            0|  0.00%|                s.pop('computed_fields', None)
   532|         0|            0|            0|  0.00%|        elif s['type'] == 'model':
   533|         0|            0|            0|  0.00%|            # remove some defaults
   534|         0|            0|            0|  0.00%|            if s.get('custom_init', True) is False:
   535|         0|            0|            0|  0.00%|                s.pop('custom_init')
   536|         0|            0|            0|  0.00%|            if s.get('root_model', True) is False:
   537|         0|            0|            0|  0.00%|                s.pop('root_model')
   538|         0|            0|            0|  0.00%|            if {'title'}.issuperset(s.get('config', {}).keys()):
   539|         0|            0|            0|  0.00%|                s.pop('config', None)
   540|         0|            0|            0|  0.00%|
   541|         0|            0|            0|  0.00%|        return recurse(s, strip_metadata)
   542|         0|            0|            0|  0.00%|
   543|         0|            0|            0|  0.00%|    return walk_core_schema(schema, strip_metadata)
   544|         0|            0|            0|  0.00%|
   545|         0|            0|            0|  0.00%|
   546|         0|            0|            0|  0.00%|def pretty_print_core_schema(
   547|         0|            0|            0|  0.00%|    schema: CoreSchema,
   548|         0|            0|            0|  0.00%|    include_metadata: bool = False,
   549|         0|            0|            0|  0.00%|) -> None:
   550|         0|            0|            0|  0.00%|    """Pretty print a CoreSchema using rich.
   551|         0|            0|            0|  0.00%|    This is intended for debugging purposes.
   552|         0|            0|            0|  0.00%|
   553|         0|            0|            0|  0.00%|    Args:
   554|         0|            0|            0|  0.00%|        schema: The CoreSchema to print.
   555|         0|            0|            0|  0.00%|        include_metadata: Whether to include metadata in the output. Defaults to `False`.
   556|         0|            0|            0|  0.00%|    """
   557|         0|            0|            0|  0.00%|    from rich import print  # type: ignore  # install it manually in your dev env
   558|         0|            0|            0|  0.00%|
   559|         0|            0|            0|  0.00%|    if not include_metadata:
   560|         0|            0|            0|  0.00%|        schema = _strip_metadata(schema)
   561|         0|            0|            0|  0.00%|
   562|         0|            0|            0|  0.00%|    return print(schema)
   563|         0|            0|            0|  0.00%|
   564|         0|            0|            0|  0.00%|
   565|         2|  4.52995e-06|  2.26498e-06|  0.00%|def validate_core_schema(schema: CoreSchema) -> CoreSchema:
   566|         2|  1.88351e-05|  9.41753e-06|  0.02%|    if 'PYDANTIC_SKIP_VALIDATING_CORE_SCHEMAS' in os.environ:
(call)|         2|  0.000118256|  5.91278e-05|  0.12%|# <frozen _collections_abc>:811 __contains__
   567|         0|            0|            0|  0.00%|        return schema
   568|         2|  3.95775e-05|  1.97887e-05|  0.04%|    return _validate_core_schema(schema)
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/params.py
File duration: 0.000950098s (0.98%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|import warnings
     2|         0|            0|            0|  0.00%|from enum import Enum
     3|         0|            0|            0|  0.00%|from typing import Any, Callable, Dict, List, Optional, Sequence, Union
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|from fastapi.openapi.models import Example
     6|         0|            0|            0|  0.00%|from pydantic.fields import FieldInfo
     7|         0|            0|            0|  0.00%|from typing_extensions import Annotated, deprecated
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|from ._compat import PYDANTIC_V2, PYDANTIC_VERSION, Undefined
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|_Unset: Any = Undefined
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|class ParamTypes(Enum):
    15|         0|            0|            0|  0.00%|    query = "query"
    16|         0|            0|            0|  0.00%|    header = "header"
    17|         0|            0|            0|  0.00%|    path = "path"
    18|         0|            0|            0|  0.00%|    cookie = "cookie"
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|class Param(FieldInfo):
    22|         0|            0|            0|  0.00%|    in_: ParamTypes
    23|         0|            0|            0|  0.00%|
    24|         2|  2.67029e-05|  1.33514e-05|  0.03%|    def __init__(
    25|         0|            0|            0|  0.00%|        self,
    26|         0|            0|            0|  0.00%|        default: Any = Undefined,
    27|         0|            0|            0|  0.00%|        *,
    28|         0|            0|            0|  0.00%|        default_factory: Union[Callable[[], Any], None] = _Unset,
    29|         0|            0|            0|  0.00%|        annotation: Optional[Any] = None,
    30|         0|            0|            0|  0.00%|        alias: Optional[str] = None,
    31|         0|            0|            0|  0.00%|        alias_priority: Union[int, None] = _Unset,
    32|         0|            0|            0|  0.00%|        # TODO: update when deprecating Pydantic v1, import these types
    33|         0|            0|            0|  0.00%|        # validation_alias: str | AliasPath | AliasChoices | None
    34|         0|            0|            0|  0.00%|        validation_alias: Union[str, None] = None,
    35|         0|            0|            0|  0.00%|        serialization_alias: Union[str, None] = None,
    36|         0|            0|            0|  0.00%|        title: Optional[str] = None,
    37|         0|            0|            0|  0.00%|        description: Optional[str] = None,
    38|         0|            0|            0|  0.00%|        gt: Optional[float] = None,
    39|         0|            0|            0|  0.00%|        ge: Optional[float] = None,
    40|         0|            0|            0|  0.00%|        lt: Optional[float] = None,
    41|         0|            0|            0|  0.00%|        le: Optional[float] = None,
    42|         0|            0|            0|  0.00%|        min_length: Optional[int] = None,
    43|         0|            0|            0|  0.00%|        max_length: Optional[int] = None,
    44|         0|            0|            0|  0.00%|        pattern: Optional[str] = None,
    45|         0|            0|            0|  0.00%|        regex: Annotated[
    46|         0|            0|            0|  0.00%|            Optional[str],
    47|         0|            0|            0|  0.00%|            deprecated(
    48|         0|            0|            0|  0.00%|                "Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
    49|         0|            0|            0|  0.00%|            ),
    50|         0|            0|            0|  0.00%|        ] = None,
    51|         0|            0|            0|  0.00%|        discriminator: Union[str, None] = None,
    52|         0|            0|            0|  0.00%|        strict: Union[bool, None] = _Unset,
    53|         0|            0|            0|  0.00%|        multiple_of: Union[float, None] = _Unset,
    54|         0|            0|            0|  0.00%|        allow_inf_nan: Union[bool, None] = _Unset,
    55|         0|            0|            0|  0.00%|        max_digits: Union[int, None] = _Unset,
    56|         0|            0|            0|  0.00%|        decimal_places: Union[int, None] = _Unset,
    57|         0|            0|            0|  0.00%|        examples: Optional[List[Any]] = None,
    58|         0|            0|            0|  0.00%|        example: Annotated[
    59|         0|            0|            0|  0.00%|            Optional[Any],
    60|         0|            0|            0|  0.00%|            deprecated(
    61|         0|            0|            0|  0.00%|                "Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
    62|         0|            0|            0|  0.00%|                "although still supported. Use examples instead."
    63|         0|            0|            0|  0.00%|            ),
    64|         0|            0|            0|  0.00%|        ] = _Unset,
    65|         0|            0|            0|  0.00%|        openapi_examples: Optional[Dict[str, Example]] = None,
    66|         0|            0|            0|  0.00%|        deprecated: Union[deprecated, str, bool, None] = None,
    67|         0|            0|            0|  0.00%|        include_in_schema: bool = True,
    68|         0|            0|            0|  0.00%|        json_schema_extra: Union[Dict[str, Any], None] = None,
    69|         0|            0|            0|  0.00%|        **extra: Any,
    70|         0|            0|            0|  0.00%|    ):
    71|         2|  9.29832e-06|  4.64916e-06|  0.01%|        if example is not _Unset:
    72|         0|            0|            0|  0.00%|            warnings.warn(
    73|         0|            0|            0|  0.00%|                "`example` has been deprecated, please use `examples` instead",
    74|         0|            0|            0|  0.00%|                category=DeprecationWarning,
    75|         0|            0|            0|  0.00%|                stacklevel=4,
    76|         0|            0|            0|  0.00%|            )
    77|         2|  8.58307e-06|  4.29153e-06|  0.01%|        self.example = example
    78|         2|  7.15256e-06|  3.57628e-06|  0.01%|        self.include_in_schema = include_in_schema
    79|         2|  7.62939e-06|   3.8147e-06|  0.01%|        self.openapi_examples = openapi_examples
    80|        34|   0.00011611|    3.415e-06|  0.12%|        kwargs = dict(
    81|         2|  6.19888e-06|  3.09944e-06|  0.01%|            default=default,
    82|         2|  4.29153e-06|  2.14577e-06|  0.00%|            default_factory=default_factory,
    83|         2|  4.52995e-06|  2.26498e-06|  0.00%|            alias=alias,
    84|         2|  4.52995e-06|  2.26498e-06|  0.00%|            title=title,
    85|         2|  4.29153e-06|  2.14577e-06|  0.00%|            description=description,
    86|         2|  4.76837e-06|  2.38419e-06|  0.00%|            gt=gt,
    87|         2|  4.29153e-06|  2.14577e-06|  0.00%|            ge=ge,
    88|         2|  4.52995e-06|  2.26498e-06|  0.00%|            lt=lt,
    89|         2|  4.76837e-06|  2.38419e-06|  0.00%|            le=le,
    90|         2|  4.05312e-06|  2.02656e-06|  0.00%|            min_length=min_length,
    91|         2|  4.76837e-06|  2.38419e-06|  0.00%|            max_length=max_length,
    92|         2|  4.05312e-06|  2.02656e-06|  0.00%|            discriminator=discriminator,
    93|         2|  4.05312e-06|  2.02656e-06|  0.00%|            multiple_of=multiple_of,
    94|         2|  4.29153e-06|  2.14577e-06|  0.00%|            allow_inf_nan=allow_inf_nan,
    95|         2|  4.29153e-06|  2.14577e-06|  0.00%|            max_digits=max_digits,
    96|         2|  4.29153e-06|  2.14577e-06|  0.00%|            decimal_places=decimal_places,
    97|         2|  5.96046e-06|  2.98023e-06|  0.01%|            **extra,
    98|         0|            0|            0|  0.00%|        )
    99|         2|  4.05312e-06|  2.02656e-06|  0.00%|        if examples is not None:
   100|         0|            0|            0|  0.00%|            kwargs["examples"] = examples
   101|         2|  5.96046e-06|  2.98023e-06|  0.01%|        if regex is not None:
   102|         0|            0|            0|  0.00%|            warnings.warn(
   103|         0|            0|            0|  0.00%|                "`regex` has been deprecated, please use `pattern` instead",
   104|         0|            0|            0|  0.00%|                category=DeprecationWarning,
   105|         0|            0|            0|  0.00%|                stacklevel=4,
   106|         0|            0|            0|  0.00%|            )
   107|         2|  6.67572e-06|  3.33786e-06|  0.01%|        current_json_schema_extra = json_schema_extra or extra
   108|         2|  8.10623e-06|  4.05312e-06|  0.01%|        if PYDANTIC_VERSION < "2.7.0":
   109|         0|            0|            0|  0.00%|            self.deprecated = deprecated
   110|         0|            0|            0|  0.00%|        else:
   111|         2|  6.67572e-06|  3.33786e-06|  0.01%|            kwargs["deprecated"] = deprecated
   112|         2|  5.96046e-06|  2.98023e-06|  0.01%|        if PYDANTIC_V2:
   113|         4|  1.50204e-05|  3.75509e-06|  0.02%|            kwargs.update(
   114|         2|  6.91414e-06|  3.45707e-06|  0.01%|                {
   115|         2|  5.96046e-06|  2.98023e-06|  0.01%|                    "annotation": annotation,
   116|         2|  5.72205e-06|  2.86102e-06|  0.01%|                    "alias_priority": alias_priority,
   117|         2|  5.48363e-06|  2.74181e-06|  0.01%|                    "validation_alias": validation_alias,
   118|         2|  5.72205e-06|  2.86102e-06|  0.01%|                    "serialization_alias": serialization_alias,
   119|         2|  5.96046e-06|  2.98023e-06|  0.01%|                    "strict": strict,
   120|         2|  5.96046e-06|  2.98023e-06|  0.01%|                    "json_schema_extra": current_json_schema_extra,
   121|         0|            0|            0|  0.00%|                }
   122|         0|            0|            0|  0.00%|            )
   123|         2|  5.00679e-06|   2.5034e-06|  0.01%|            kwargs["pattern"] = pattern or regex
   124|         0|            0|            0|  0.00%|        else:
   125|         0|            0|            0|  0.00%|            kwargs["regex"] = pattern or regex
   126|         0|            0|            0|  0.00%|            kwargs.update(**current_json_schema_extra)
   127|        50|  0.000121355|   2.4271e-06|  0.12%|        use_kwargs = {k: v for k, v in kwargs.items() if v is not _Unset}
   128|         0|            0|            0|  0.00%|
   129|         2|  5.67436e-05|  2.83718e-05|  0.06%|        super().__init__(**use_kwargs)
(call)|         2|  0.000873566|  0.000436783|  0.90%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/fields.py:198 __init__
   130|         0|            0|            0|  0.00%|
   131|         4|  9.77516e-06|  2.44379e-06|  0.01%|    def __repr__(self) -> str:
   132|         4|  1.78814e-05|  4.47035e-06|  0.02%|        return f"{self.__class__.__name__}({self.default})"
   133|         0|            0|            0|  0.00%|
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|class Path(Param):
   136|         0|            0|            0|  0.00%|    in_ = ParamTypes.path
   137|         0|            0|            0|  0.00%|
   138|         1|  1.04904e-05|  1.04904e-05|  0.01%|    def __init__(
   139|         0|            0|            0|  0.00%|        self,
   140|         0|            0|            0|  0.00%|        default: Any = ...,
   141|         0|            0|            0|  0.00%|        *,
   142|         0|            0|            0|  0.00%|        default_factory: Union[Callable[[], Any], None] = _Unset,
   143|         0|            0|            0|  0.00%|        annotation: Optional[Any] = None,
   144|         0|            0|            0|  0.00%|        alias: Optional[str] = None,
   145|         0|            0|            0|  0.00%|        alias_priority: Union[int, None] = _Unset,
   146|         0|            0|            0|  0.00%|        # TODO: update when deprecating Pydantic v1, import these types
   147|         0|            0|            0|  0.00%|        # validation_alias: str | AliasPath | AliasChoices | None
   148|         0|            0|            0|  0.00%|        validation_alias: Union[str, None] = None,
   149|         0|            0|            0|  0.00%|        serialization_alias: Union[str, None] = None,
   150|         0|            0|            0|  0.00%|        title: Optional[str] = None,
   151|         0|            0|            0|  0.00%|        description: Optional[str] = None,
   152|         0|            0|            0|  0.00%|        gt: Optional[float] = None,
   153|         0|            0|            0|  0.00%|        ge: Optional[float] = None,
   154|         0|            0|            0|  0.00%|        lt: Optional[float] = None,
   155|         0|            0|            0|  0.00%|        le: Optional[float] = None,
   156|         0|            0|            0|  0.00%|        min_length: Optional[int] = None,
   157|         0|            0|            0|  0.00%|        max_length: Optional[int] = None,
   158|         0|            0|            0|  0.00%|        pattern: Optional[str] = None,
   159|         0|            0|            0|  0.00%|        regex: Annotated[
   160|         0|            0|            0|  0.00%|            Optional[str],
   161|         0|            0|            0|  0.00%|            deprecated(
   162|         0|            0|            0|  0.00%|                "Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
   163|         0|            0|            0|  0.00%|            ),
   164|         0|            0|            0|  0.00%|        ] = None,
   165|         0|            0|            0|  0.00%|        discriminator: Union[str, None] = None,
   166|         0|            0|            0|  0.00%|        strict: Union[bool, None] = _Unset,
   167|         0|            0|            0|  0.00%|        multiple_of: Union[float, None] = _Unset,
   168|         0|            0|            0|  0.00%|        allow_inf_nan: Union[bool, None] = _Unset,
   169|         0|            0|            0|  0.00%|        max_digits: Union[int, None] = _Unset,
   170|         0|            0|            0|  0.00%|        decimal_places: Union[int, None] = _Unset,
   171|         0|            0|            0|  0.00%|        examples: Optional[List[Any]] = None,
   172|         0|            0|            0|  0.00%|        example: Annotated[
   173|         0|            0|            0|  0.00%|            Optional[Any],
   174|         0|            0|            0|  0.00%|            deprecated(
   175|         0|            0|            0|  0.00%|                "Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
   176|         0|            0|            0|  0.00%|                "although still supported. Use examples instead."
   177|         0|            0|            0|  0.00%|            ),
   178|         0|            0|            0|  0.00%|        ] = _Unset,
   179|         0|            0|            0|  0.00%|        openapi_examples: Optional[Dict[str, Example]] = None,
   180|         0|            0|            0|  0.00%|        deprecated: Union[deprecated, str, bool, None] = None,
   181|         0|            0|            0|  0.00%|        include_in_schema: bool = True,
   182|         0|            0|            0|  0.00%|        json_schema_extra: Union[Dict[str, Any], None] = None,
   183|         0|            0|            0|  0.00%|        **extra: Any,
   184|         0|            0|            0|  0.00%|    ):
   185|         1|  8.34465e-06|  8.34465e-06|  0.01%|        assert default is ..., "Path parameters cannot have a default value"
   186|         1|  4.52995e-06|  4.52995e-06|  0.00%|        self.in_ = self.in_
   187|        30|  0.000134706|  4.49022e-06|  0.14%|        super().__init__(
(call)|         1|  0.000845194|  0.000845194|  0.87%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/params.py:24 __init__
   188|         1|  3.33786e-06|  3.33786e-06|  0.00%|            default=default,
   189|         1|  2.38419e-06|  2.38419e-06|  0.00%|            default_factory=default_factory,
   190|         1|  1.66893e-06|  1.66893e-06|  0.00%|            annotation=annotation,
   191|         1|  1.66893e-06|  1.66893e-06|  0.00%|            alias=alias,
   192|         1|  1.43051e-06|  1.43051e-06|  0.00%|            alias_priority=alias_priority,
   193|         1|  2.14577e-06|  2.14577e-06|  0.00%|            validation_alias=validation_alias,
   194|         1|  1.66893e-06|  1.66893e-06|  0.00%|            serialization_alias=serialization_alias,
   195|         1|  1.90735e-06|  1.90735e-06|  0.00%|            title=title,
   196|         1|  1.66893e-06|  1.66893e-06|  0.00%|            description=description,
   197|         1|  1.66893e-06|  1.66893e-06|  0.00%|            gt=gt,
   198|         1|   2.6226e-06|   2.6226e-06|  0.00%|            ge=ge,
   199|         1|  1.66893e-06|  1.66893e-06|  0.00%|            lt=lt,
   200|         1|  1.66893e-06|  1.66893e-06|  0.00%|            le=le,
   201|         1|  1.90735e-06|  1.90735e-06|  0.00%|            min_length=min_length,
   202|         1|  1.43051e-06|  1.43051e-06|  0.00%|            max_length=max_length,
   203|         1|  1.66893e-06|  1.66893e-06|  0.00%|            pattern=pattern,
   204|         1|  1.43051e-06|  1.43051e-06|  0.00%|            regex=regex,
   205|         1|  1.66893e-06|  1.66893e-06|  0.00%|            discriminator=discriminator,
   206|         1|  1.90735e-06|  1.90735e-06|  0.00%|            strict=strict,
   207|         1|  1.66893e-06|  1.66893e-06|  0.00%|            multiple_of=multiple_of,
   208|         1|  1.90735e-06|  1.90735e-06|  0.00%|            allow_inf_nan=allow_inf_nan,
   209|         1|  2.14577e-06|  2.14577e-06|  0.00%|            max_digits=max_digits,
   210|         1|  1.66893e-06|  1.66893e-06|  0.00%|            decimal_places=decimal_places,
   211|         1|  1.66893e-06|  1.66893e-06|  0.00%|            deprecated=deprecated,
   212|         1|  1.90735e-06|  1.90735e-06|  0.00%|            example=example,
   213|         1|  1.43051e-06|  1.43051e-06|  0.00%|            examples=examples,
   214|         1|  1.66893e-06|  1.66893e-06|  0.00%|            openapi_examples=openapi_examples,
   215|         1|  1.90735e-06|  1.90735e-06|  0.00%|            include_in_schema=include_in_schema,
   216|         1|  1.43051e-06|  1.43051e-06|  0.00%|            json_schema_extra=json_schema_extra,
   217|         1|  3.33786e-06|  3.33786e-06|  0.00%|            **extra,
   218|         0|            0|            0|  0.00%|        )
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|
   221|         0|            0|            0|  0.00%|class Query(Param):
   222|         0|            0|            0|  0.00%|    in_ = ParamTypes.query
   223|         0|            0|            0|  0.00%|
   224|         1|  8.34465e-06|  8.34465e-06|  0.01%|    def __init__(
   225|         0|            0|            0|  0.00%|        self,
   226|         0|            0|            0|  0.00%|        default: Any = Undefined,
   227|         0|            0|            0|  0.00%|        *,
   228|         0|            0|            0|  0.00%|        default_factory: Union[Callable[[], Any], None] = _Unset,
   229|         0|            0|            0|  0.00%|        annotation: Optional[Any] = None,
   230|         0|            0|            0|  0.00%|        alias: Optional[str] = None,
   231|         0|            0|            0|  0.00%|        alias_priority: Union[int, None] = _Unset,
   232|         0|            0|            0|  0.00%|        # TODO: update when deprecating Pydantic v1, import these types
   233|         0|            0|            0|  0.00%|        # validation_alias: str | AliasPath | AliasChoices | None
   234|         0|            0|            0|  0.00%|        validation_alias: Union[str, None] = None,
   235|         0|            0|            0|  0.00%|        serialization_alias: Union[str, None] = None,
   236|         0|            0|            0|  0.00%|        title: Optional[str] = None,
   237|         0|            0|            0|  0.00%|        description: Optional[str] = None,
   238|         0|            0|            0|  0.00%|        gt: Optional[float] = None,
   239|         0|            0|            0|  0.00%|        ge: Optional[float] = None,
   240|         0|            0|            0|  0.00%|        lt: Optional[float] = None,
   241|         0|            0|            0|  0.00%|        le: Optional[float] = None,
   242|         0|            0|            0|  0.00%|        min_length: Optional[int] = None,
   243|         0|            0|            0|  0.00%|        max_length: Optional[int] = None,
   244|         0|            0|            0|  0.00%|        pattern: Optional[str] = None,
   245|         0|            0|            0|  0.00%|        regex: Annotated[
   246|         0|            0|            0|  0.00%|            Optional[str],
   247|         0|            0|            0|  0.00%|            deprecated(
   248|         0|            0|            0|  0.00%|                "Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
   249|         0|            0|            0|  0.00%|            ),
   250|         0|            0|            0|  0.00%|        ] = None,
   251|         0|            0|            0|  0.00%|        discriminator: Union[str, None] = None,
   252|         0|            0|            0|  0.00%|        strict: Union[bool, None] = _Unset,
   253|         0|            0|            0|  0.00%|        multiple_of: Union[float, None] = _Unset,
   254|         0|            0|            0|  0.00%|        allow_inf_nan: Union[bool, None] = _Unset,
   255|         0|            0|            0|  0.00%|        max_digits: Union[int, None] = _Unset,
   256|         0|            0|            0|  0.00%|        decimal_places: Union[int, None] = _Unset,
   257|         0|            0|            0|  0.00%|        examples: Optional[List[Any]] = None,
   258|         0|            0|            0|  0.00%|        example: Annotated[
   259|         0|            0|            0|  0.00%|            Optional[Any],
   260|         0|            0|            0|  0.00%|            deprecated(
   261|         0|            0|            0|  0.00%|                "Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
   262|         0|            0|            0|  0.00%|                "although still supported. Use examples instead."
   263|         0|            0|            0|  0.00%|            ),
   264|         0|            0|            0|  0.00%|        ] = _Unset,
   265|         0|            0|            0|  0.00%|        openapi_examples: Optional[Dict[str, Example]] = None,
   266|         0|            0|            0|  0.00%|        deprecated: Union[deprecated, str, bool, None] = None,
   267|         0|            0|            0|  0.00%|        include_in_schema: bool = True,
   268|         0|            0|            0|  0.00%|        json_schema_extra: Union[Dict[str, Any], None] = None,
   269|         0|            0|            0|  0.00%|        **extra: Any,
   270|         0|            0|            0|  0.00%|    ):
   271|        30|   0.00011301|  3.76701e-06|  0.12%|        super().__init__(
(call)|         1|  0.000559092|  0.000559092|  0.57%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/params.py:24 __init__
   272|         1|  7.39098e-06|  7.39098e-06|  0.01%|            default=default,
   273|         1|  1.43051e-06|  1.43051e-06|  0.00%|            default_factory=default_factory,
   274|         1|  1.90735e-06|  1.90735e-06|  0.00%|            annotation=annotation,
   275|         1|  1.66893e-06|  1.66893e-06|  0.00%|            alias=alias,
   276|         1|  1.43051e-06|  1.43051e-06|  0.00%|            alias_priority=alias_priority,
   277|         1|  1.66893e-06|  1.66893e-06|  0.00%|            validation_alias=validation_alias,
   278|         1|  1.66893e-06|  1.66893e-06|  0.00%|            serialization_alias=serialization_alias,
   279|         1|  1.66893e-06|  1.66893e-06|  0.00%|            title=title,
   280|         1|  1.90735e-06|  1.90735e-06|  0.00%|            description=description,
   281|         1|  1.43051e-06|  1.43051e-06|  0.00%|            gt=gt,
   282|         1|  2.14577e-06|  2.14577e-06|  0.00%|            ge=ge,
   283|         1|  1.66893e-06|  1.66893e-06|  0.00%|            lt=lt,
   284|         1|  1.43051e-06|  1.43051e-06|  0.00%|            le=le,
   285|         1|  1.43051e-06|  1.43051e-06|  0.00%|            min_length=min_length,
   286|         1|  1.43051e-06|  1.43051e-06|  0.00%|            max_length=max_length,
   287|         1|  1.43051e-06|  1.43051e-06|  0.00%|            pattern=pattern,
   288|         1|  1.66893e-06|  1.66893e-06|  0.00%|            regex=regex,
   289|         1|  1.66893e-06|  1.66893e-06|  0.00%|            discriminator=discriminator,
   290|         1|  1.43051e-06|  1.43051e-06|  0.00%|            strict=strict,
   291|         1|  1.43051e-06|  1.43051e-06|  0.00%|            multiple_of=multiple_of,
   292|         1|  1.66893e-06|  1.66893e-06|  0.00%|            allow_inf_nan=allow_inf_nan,
   293|         1|  2.14577e-06|  2.14577e-06|  0.00%|            max_digits=max_digits,
   294|         1|  1.43051e-06|  1.43051e-06|  0.00%|            decimal_places=decimal_places,
   295|         1|  1.66893e-06|  1.66893e-06|  0.00%|            deprecated=deprecated,
   296|         1|  2.14577e-06|  2.14577e-06|  0.00%|            example=example,
   297|         1|  1.66893e-06|  1.66893e-06|  0.00%|            examples=examples,
   298|         1|  1.66893e-06|  1.66893e-06|  0.00%|            openapi_examples=openapi_examples,
   299|         1|  1.43051e-06|  1.43051e-06|  0.00%|            include_in_schema=include_in_schema,
   300|         1|  1.43051e-06|  1.43051e-06|  0.00%|            json_schema_extra=json_schema_extra,
   301|         1|  2.86102e-06|  2.86102e-06|  0.00%|            **extra,
   302|         0|            0|            0|  0.00%|        )
   303|         0|            0|            0|  0.00%|
   304|         0|            0|            0|  0.00%|
   305|         0|            0|            0|  0.00%|class Header(Param):
   306|         0|            0|            0|  0.00%|    in_ = ParamTypes.header
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|    def __init__(
   309|         0|            0|            0|  0.00%|        self,
   310|         0|            0|            0|  0.00%|        default: Any = Undefined,
   311|         0|            0|            0|  0.00%|        *,
   312|         0|            0|            0|  0.00%|        default_factory: Union[Callable[[], Any], None] = _Unset,
   313|         0|            0|            0|  0.00%|        annotation: Optional[Any] = None,
   314|         0|            0|            0|  0.00%|        alias: Optional[str] = None,
   315|         0|            0|            0|  0.00%|        alias_priority: Union[int, None] = _Unset,
   316|         0|            0|            0|  0.00%|        # TODO: update when deprecating Pydantic v1, import these types
   317|         0|            0|            0|  0.00%|        # validation_alias: str | AliasPath | AliasChoices | None
   318|         0|            0|            0|  0.00%|        validation_alias: Union[str, None] = None,
   319|         0|            0|            0|  0.00%|        serialization_alias: Union[str, None] = None,
   320|         0|            0|            0|  0.00%|        convert_underscores: bool = True,
   321|         0|            0|            0|  0.00%|        title: Optional[str] = None,
   322|         0|            0|            0|  0.00%|        description: Optional[str] = None,
   323|         0|            0|            0|  0.00%|        gt: Optional[float] = None,
   324|         0|            0|            0|  0.00%|        ge: Optional[float] = None,
   325|         0|            0|            0|  0.00%|        lt: Optional[float] = None,
   326|         0|            0|            0|  0.00%|        le: Optional[float] = None,
   327|         0|            0|            0|  0.00%|        min_length: Optional[int] = None,
   328|         0|            0|            0|  0.00%|        max_length: Optional[int] = None,
   329|         0|            0|            0|  0.00%|        pattern: Optional[str] = None,
   330|         0|            0|            0|  0.00%|        regex: Annotated[
   331|         0|            0|            0|  0.00%|            Optional[str],
   332|         0|            0|            0|  0.00%|            deprecated(
   333|         0|            0|            0|  0.00%|                "Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
   334|         0|            0|            0|  0.00%|            ),
   335|         0|            0|            0|  0.00%|        ] = None,
   336|         0|            0|            0|  0.00%|        discriminator: Union[str, None] = None,
   337|         0|            0|            0|  0.00%|        strict: Union[bool, None] = _Unset,
   338|         0|            0|            0|  0.00%|        multiple_of: Union[float, None] = _Unset,
   339|         0|            0|            0|  0.00%|        allow_inf_nan: Union[bool, None] = _Unset,
   340|         0|            0|            0|  0.00%|        max_digits: Union[int, None] = _Unset,
   341|         0|            0|            0|  0.00%|        decimal_places: Union[int, None] = _Unset,
   342|         0|            0|            0|  0.00%|        examples: Optional[List[Any]] = None,
   343|         0|            0|            0|  0.00%|        example: Annotated[
   344|         0|            0|            0|  0.00%|            Optional[Any],
   345|         0|            0|            0|  0.00%|            deprecated(
   346|         0|            0|            0|  0.00%|                "Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
   347|         0|            0|            0|  0.00%|                "although still supported. Use examples instead."
   348|         0|            0|            0|  0.00%|            ),
   349|         0|            0|            0|  0.00%|        ] = _Unset,
   350|         0|            0|            0|  0.00%|        openapi_examples: Optional[Dict[str, Example]] = None,
   351|         0|            0|            0|  0.00%|        deprecated: Union[deprecated, str, bool, None] = None,
   352|         0|            0|            0|  0.00%|        include_in_schema: bool = True,
   353|         0|            0|            0|  0.00%|        json_schema_extra: Union[Dict[str, Any], None] = None,
   354|         0|            0|            0|  0.00%|        **extra: Any,
   355|         0|            0|            0|  0.00%|    ):
   356|         0|            0|            0|  0.00%|        self.convert_underscores = convert_underscores
   357|         0|            0|            0|  0.00%|        super().__init__(
   358|         0|            0|            0|  0.00%|            default=default,
   359|         0|            0|            0|  0.00%|            default_factory=default_factory,
   360|         0|            0|            0|  0.00%|            annotation=annotation,
   361|         0|            0|            0|  0.00%|            alias=alias,
   362|         0|            0|            0|  0.00%|            alias_priority=alias_priority,
   363|         0|            0|            0|  0.00%|            validation_alias=validation_alias,
   364|         0|            0|            0|  0.00%|            serialization_alias=serialization_alias,
   365|         0|            0|            0|  0.00%|            title=title,
   366|         0|            0|            0|  0.00%|            description=description,
   367|         0|            0|            0|  0.00%|            gt=gt,
   368|         0|            0|            0|  0.00%|            ge=ge,
   369|         0|            0|            0|  0.00%|            lt=lt,
   370|         0|            0|            0|  0.00%|            le=le,
   371|         0|            0|            0|  0.00%|            min_length=min_length,
   372|         0|            0|            0|  0.00%|            max_length=max_length,
   373|         0|            0|            0|  0.00%|            pattern=pattern,
   374|         0|            0|            0|  0.00%|            regex=regex,
   375|         0|            0|            0|  0.00%|            discriminator=discriminator,
   376|         0|            0|            0|  0.00%|            strict=strict,
   377|         0|            0|            0|  0.00%|            multiple_of=multiple_of,
   378|         0|            0|            0|  0.00%|            allow_inf_nan=allow_inf_nan,
   379|         0|            0|            0|  0.00%|            max_digits=max_digits,
   380|         0|            0|            0|  0.00%|            decimal_places=decimal_places,
   381|         0|            0|            0|  0.00%|            deprecated=deprecated,
   382|         0|            0|            0|  0.00%|            example=example,
   383|         0|            0|            0|  0.00%|            examples=examples,
   384|         0|            0|            0|  0.00%|            openapi_examples=openapi_examples,
   385|         0|            0|            0|  0.00%|            include_in_schema=include_in_schema,
   386|         0|            0|            0|  0.00%|            json_schema_extra=json_schema_extra,
   387|         0|            0|            0|  0.00%|            **extra,
   388|         0|            0|            0|  0.00%|        )
   389|         0|            0|            0|  0.00%|
   390|         0|            0|            0|  0.00%|
   391|         0|            0|            0|  0.00%|class Cookie(Param):
   392|         0|            0|            0|  0.00%|    in_ = ParamTypes.cookie
   393|         0|            0|            0|  0.00%|
   394|         0|            0|            0|  0.00%|    def __init__(
   395|         0|            0|            0|  0.00%|        self,
   396|         0|            0|            0|  0.00%|        default: Any = Undefined,
   397|         0|            0|            0|  0.00%|        *,
   398|         0|            0|            0|  0.00%|        default_factory: Union[Callable[[], Any], None] = _Unset,
   399|         0|            0|            0|  0.00%|        annotation: Optional[Any] = None,
   400|         0|            0|            0|  0.00%|        alias: Optional[str] = None,
   401|         0|            0|            0|  0.00%|        alias_priority: Union[int, None] = _Unset,
   402|         0|            0|            0|  0.00%|        # TODO: update when deprecating Pydantic v1, import these types
   403|         0|            0|            0|  0.00%|        # validation_alias: str | AliasPath | AliasChoices | None
   404|         0|            0|            0|  0.00%|        validation_alias: Union[str, None] = None,
   405|         0|            0|            0|  0.00%|        serialization_alias: Union[str, None] = None,
   406|         0|            0|            0|  0.00%|        title: Optional[str] = None,
   407|         0|            0|            0|  0.00%|        description: Optional[str] = None,
   408|         0|            0|            0|  0.00%|        gt: Optional[float] = None,
   409|         0|            0|            0|  0.00%|        ge: Optional[float] = None,
   410|         0|            0|            0|  0.00%|        lt: Optional[float] = None,
   411|         0|            0|            0|  0.00%|        le: Optional[float] = None,
   412|         0|            0|            0|  0.00%|        min_length: Optional[int] = None,
   413|         0|            0|            0|  0.00%|        max_length: Optional[int] = None,
   414|         0|            0|            0|  0.00%|        pattern: Optional[str] = None,
   415|         0|            0|            0|  0.00%|        regex: Annotated[
   416|         0|            0|            0|  0.00%|            Optional[str],
   417|         0|            0|            0|  0.00%|            deprecated(
   418|         0|            0|            0|  0.00%|                "Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
   419|         0|            0|            0|  0.00%|            ),
   420|         0|            0|            0|  0.00%|        ] = None,
   421|         0|            0|            0|  0.00%|        discriminator: Union[str, None] = None,
   422|         0|            0|            0|  0.00%|        strict: Union[bool, None] = _Unset,
   423|         0|            0|            0|  0.00%|        multiple_of: Union[float, None] = _Unset,
   424|         0|            0|            0|  0.00%|        allow_inf_nan: Union[bool, None] = _Unset,
   425|         0|            0|            0|  0.00%|        max_digits: Union[int, None] = _Unset,
   426|         0|            0|            0|  0.00%|        decimal_places: Union[int, None] = _Unset,
   427|         0|            0|            0|  0.00%|        examples: Optional[List[Any]] = None,
   428|         0|            0|            0|  0.00%|        example: Annotated[
   429|         0|            0|            0|  0.00%|            Optional[Any],
   430|         0|            0|            0|  0.00%|            deprecated(
   431|         0|            0|            0|  0.00%|                "Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
   432|         0|            0|            0|  0.00%|                "although still supported. Use examples instead."
   433|         0|            0|            0|  0.00%|            ),
   434|         0|            0|            0|  0.00%|        ] = _Unset,
   435|         0|            0|            0|  0.00%|        openapi_examples: Optional[Dict[str, Example]] = None,
   436|         0|            0|            0|  0.00%|        deprecated: Union[deprecated, str, bool, None] = None,
   437|         0|            0|            0|  0.00%|        include_in_schema: bool = True,
   438|         0|            0|            0|  0.00%|        json_schema_extra: Union[Dict[str, Any], None] = None,
   439|         0|            0|            0|  0.00%|        **extra: Any,
   440|         0|            0|            0|  0.00%|    ):
   441|         0|            0|            0|  0.00%|        super().__init__(
   442|         0|            0|            0|  0.00%|            default=default,
   443|         0|            0|            0|  0.00%|            default_factory=default_factory,
   444|         0|            0|            0|  0.00%|            annotation=annotation,
   445|         0|            0|            0|  0.00%|            alias=alias,
   446|         0|            0|            0|  0.00%|            alias_priority=alias_priority,
   447|         0|            0|            0|  0.00%|            validation_alias=validation_alias,
   448|         0|            0|            0|  0.00%|            serialization_alias=serialization_alias,
   449|         0|            0|            0|  0.00%|            title=title,
   450|         0|            0|            0|  0.00%|            description=description,
   451|         0|            0|            0|  0.00%|            gt=gt,
   452|         0|            0|            0|  0.00%|            ge=ge,
   453|         0|            0|            0|  0.00%|            lt=lt,
   454|         0|            0|            0|  0.00%|            le=le,
   455|         0|            0|            0|  0.00%|            min_length=min_length,
   456|         0|            0|            0|  0.00%|            max_length=max_length,
   457|         0|            0|            0|  0.00%|            pattern=pattern,
   458|         0|            0|            0|  0.00%|            regex=regex,
   459|         0|            0|            0|  0.00%|            discriminator=discriminator,
   460|         0|            0|            0|  0.00%|            strict=strict,
   461|         0|            0|            0|  0.00%|            multiple_of=multiple_of,
   462|         0|            0|            0|  0.00%|            allow_inf_nan=allow_inf_nan,
   463|         0|            0|            0|  0.00%|            max_digits=max_digits,
   464|         0|            0|            0|  0.00%|            decimal_places=decimal_places,
   465|         0|            0|            0|  0.00%|            deprecated=deprecated,
   466|         0|            0|            0|  0.00%|            example=example,
   467|         0|            0|            0|  0.00%|            examples=examples,
   468|         0|            0|            0|  0.00%|            openapi_examples=openapi_examples,
   469|         0|            0|            0|  0.00%|            include_in_schema=include_in_schema,
   470|         0|            0|            0|  0.00%|            json_schema_extra=json_schema_extra,
   471|         0|            0|            0|  0.00%|            **extra,
   472|         0|            0|            0|  0.00%|        )
   473|         0|            0|            0|  0.00%|
   474|         0|            0|            0|  0.00%|
   475|         0|            0|            0|  0.00%|class Body(FieldInfo):
   476|         0|            0|            0|  0.00%|    def __init__(
   477|         0|            0|            0|  0.00%|        self,
   478|         0|            0|            0|  0.00%|        default: Any = Undefined,
   479|         0|            0|            0|  0.00%|        *,
   480|         0|            0|            0|  0.00%|        default_factory: Union[Callable[[], Any], None] = _Unset,
   481|         0|            0|            0|  0.00%|        annotation: Optional[Any] = None,
   482|         0|            0|            0|  0.00%|        embed: bool = False,
   483|         0|            0|            0|  0.00%|        media_type: str = "application/json",
   484|         0|            0|            0|  0.00%|        alias: Optional[str] = None,
   485|         0|            0|            0|  0.00%|        alias_priority: Union[int, None] = _Unset,
   486|         0|            0|            0|  0.00%|        # TODO: update when deprecating Pydantic v1, import these types
   487|         0|            0|            0|  0.00%|        # validation_alias: str | AliasPath | AliasChoices | None
   488|         0|            0|            0|  0.00%|        validation_alias: Union[str, None] = None,
   489|         0|            0|            0|  0.00%|        serialization_alias: Union[str, None] = None,
   490|         0|            0|            0|  0.00%|        title: Optional[str] = None,
   491|         0|            0|            0|  0.00%|        description: Optional[str] = None,
   492|         0|            0|            0|  0.00%|        gt: Optional[float] = None,
   493|         0|            0|            0|  0.00%|        ge: Optional[float] = None,
   494|         0|            0|            0|  0.00%|        lt: Optional[float] = None,
   495|         0|            0|            0|  0.00%|        le: Optional[float] = None,
   496|         0|            0|            0|  0.00%|        min_length: Optional[int] = None,
   497|         0|            0|            0|  0.00%|        max_length: Optional[int] = None,
   498|         0|            0|            0|  0.00%|        pattern: Optional[str] = None,
   499|         0|            0|            0|  0.00%|        regex: Annotated[
   500|         0|            0|            0|  0.00%|            Optional[str],
   501|         0|            0|            0|  0.00%|            deprecated(
   502|         0|            0|            0|  0.00%|                "Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
   503|         0|            0|            0|  0.00%|            ),
   504|         0|            0|            0|  0.00%|        ] = None,
   505|         0|            0|            0|  0.00%|        discriminator: Union[str, None] = None,
   506|         0|            0|            0|  0.00%|        strict: Union[bool, None] = _Unset,
   507|         0|            0|            0|  0.00%|        multiple_of: Union[float, None] = _Unset,
   508|         0|            0|            0|  0.00%|        allow_inf_nan: Union[bool, None] = _Unset,
   509|         0|            0|            0|  0.00%|        max_digits: Union[int, None] = _Unset,
   510|         0|            0|            0|  0.00%|        decimal_places: Union[int, None] = _Unset,
   511|         0|            0|            0|  0.00%|        examples: Optional[List[Any]] = None,
   512|         0|            0|            0|  0.00%|        example: Annotated[
   513|         0|            0|            0|  0.00%|            Optional[Any],
   514|         0|            0|            0|  0.00%|            deprecated(
   515|         0|            0|            0|  0.00%|                "Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
   516|         0|            0|            0|  0.00%|                "although still supported. Use examples instead."
   517|         0|            0|            0|  0.00%|            ),
   518|         0|            0|            0|  0.00%|        ] = _Unset,
   519|         0|            0|            0|  0.00%|        openapi_examples: Optional[Dict[str, Example]] = None,
   520|         0|            0|            0|  0.00%|        deprecated: Union[deprecated, str, bool, None] = None,
   521|         0|            0|            0|  0.00%|        include_in_schema: bool = True,
   522|         0|            0|            0|  0.00%|        json_schema_extra: Union[Dict[str, Any], None] = None,
   523|         0|            0|            0|  0.00%|        **extra: Any,
   524|         0|            0|            0|  0.00%|    ):
   525|         0|            0|            0|  0.00%|        self.embed = embed
   526|         0|            0|            0|  0.00%|        self.media_type = media_type
   527|         0|            0|            0|  0.00%|        if example is not _Unset:
   528|         0|            0|            0|  0.00%|            warnings.warn(
   529|         0|            0|            0|  0.00%|                "`example` has been deprecated, please use `examples` instead",
   530|         0|            0|            0|  0.00%|                category=DeprecationWarning,
   531|         0|            0|            0|  0.00%|                stacklevel=4,
   532|         0|            0|            0|  0.00%|            )
   533|         0|            0|            0|  0.00%|        self.example = example
   534|         0|            0|            0|  0.00%|        self.include_in_schema = include_in_schema
   535|         0|            0|            0|  0.00%|        self.openapi_examples = openapi_examples
   536|         0|            0|            0|  0.00%|        kwargs = dict(
   537|         0|            0|            0|  0.00%|            default=default,
   538|         0|            0|            0|  0.00%|            default_factory=default_factory,
   539|         0|            0|            0|  0.00%|            alias=alias,
   540|         0|            0|            0|  0.00%|            title=title,
   541|         0|            0|            0|  0.00%|            description=description,
   542|         0|            0|            0|  0.00%|            gt=gt,
   543|         0|            0|            0|  0.00%|            ge=ge,
   544|         0|            0|            0|  0.00%|            lt=lt,
   545|         0|            0|            0|  0.00%|            le=le,
   546|         0|            0|            0|  0.00%|            min_length=min_length,
   547|         0|            0|            0|  0.00%|            max_length=max_length,
   548|         0|            0|            0|  0.00%|            discriminator=discriminator,
   549|         0|            0|            0|  0.00%|            multiple_of=multiple_of,
   550|         0|            0|            0|  0.00%|            allow_inf_nan=allow_inf_nan,
   551|         0|            0|            0|  0.00%|            max_digits=max_digits,
   552|         0|            0|            0|  0.00%|            decimal_places=decimal_places,
   553|         0|            0|            0|  0.00%|            **extra,
   554|         0|            0|            0|  0.00%|        )
   555|         0|            0|            0|  0.00%|        if examples is not None:
   556|         0|            0|            0|  0.00%|            kwargs["examples"] = examples
   557|         0|            0|            0|  0.00%|        if regex is not None:
   558|         0|            0|            0|  0.00%|            warnings.warn(
   559|         0|            0|            0|  0.00%|                "`regex` has been depreacated, please use `pattern` instead",
   560|         0|            0|            0|  0.00%|                category=DeprecationWarning,
   561|         0|            0|            0|  0.00%|                stacklevel=4,
   562|         0|            0|            0|  0.00%|            )
   563|         0|            0|            0|  0.00%|        current_json_schema_extra = json_schema_extra or extra
   564|         0|            0|            0|  0.00%|        if PYDANTIC_VERSION < "2.7.0":
   565|         0|            0|            0|  0.00%|            self.deprecated = deprecated
   566|         0|            0|            0|  0.00%|        else:
   567|         0|            0|            0|  0.00%|            kwargs["deprecated"] = deprecated
   568|         0|            0|            0|  0.00%|        if PYDANTIC_V2:
   569|         0|            0|            0|  0.00%|            kwargs.update(
   570|         0|            0|            0|  0.00%|                {
   571|         0|            0|            0|  0.00%|                    "annotation": annotation,
   572|         0|            0|            0|  0.00%|                    "alias_priority": alias_priority,
   573|         0|            0|            0|  0.00%|                    "validation_alias": validation_alias,
   574|         0|            0|            0|  0.00%|                    "serialization_alias": serialization_alias,
   575|         0|            0|            0|  0.00%|                    "strict": strict,
   576|         0|            0|            0|  0.00%|                    "json_schema_extra": current_json_schema_extra,
   577|         0|            0|            0|  0.00%|                }
   578|         0|            0|            0|  0.00%|            )
   579|         0|            0|            0|  0.00%|            kwargs["pattern"] = pattern or regex
   580|         0|            0|            0|  0.00%|        else:
   581|         0|            0|            0|  0.00%|            kwargs["regex"] = pattern or regex
   582|         0|            0|            0|  0.00%|            kwargs.update(**current_json_schema_extra)
   583|         0|            0|            0|  0.00%|
   584|         0|            0|            0|  0.00%|        use_kwargs = {k: v for k, v in kwargs.items() if v is not _Unset}
   585|         0|            0|            0|  0.00%|
   586|         0|            0|            0|  0.00%|        super().__init__(**use_kwargs)
   587|         0|            0|            0|  0.00%|
   588|         0|            0|            0|  0.00%|    def __repr__(self) -> str:
   589|         0|            0|            0|  0.00%|        return f"{self.__class__.__name__}({self.default})"
   590|         0|            0|            0|  0.00%|
   591|         0|            0|            0|  0.00%|
   592|         0|            0|            0|  0.00%|class Form(Body):
   593|         0|            0|            0|  0.00%|    def __init__(
   594|         0|            0|            0|  0.00%|        self,
   595|         0|            0|            0|  0.00%|        default: Any = Undefined,
   596|         0|            0|            0|  0.00%|        *,
   597|         0|            0|            0|  0.00%|        default_factory: Union[Callable[[], Any], None] = _Unset,
   598|         0|            0|            0|  0.00%|        annotation: Optional[Any] = None,
   599|         0|            0|            0|  0.00%|        media_type: str = "application/x-www-form-urlencoded",
   600|         0|            0|            0|  0.00%|        alias: Optional[str] = None,
   601|         0|            0|            0|  0.00%|        alias_priority: Union[int, None] = _Unset,
   602|         0|            0|            0|  0.00%|        # TODO: update when deprecating Pydantic v1, import these types
   603|         0|            0|            0|  0.00%|        # validation_alias: str | AliasPath | AliasChoices | None
   604|         0|            0|            0|  0.00%|        validation_alias: Union[str, None] = None,
   605|         0|            0|            0|  0.00%|        serialization_alias: Union[str, None] = None,
   606|         0|            0|            0|  0.00%|        title: Optional[str] = None,
   607|         0|            0|            0|  0.00%|        description: Optional[str] = None,
   608|         0|            0|            0|  0.00%|        gt: Optional[float] = None,
   609|         0|            0|            0|  0.00%|        ge: Optional[float] = None,
   610|         0|            0|            0|  0.00%|        lt: Optional[float] = None,
   611|         0|            0|            0|  0.00%|        le: Optional[float] = None,
   612|         0|            0|            0|  0.00%|        min_length: Optional[int] = None,
   613|         0|            0|            0|  0.00%|        max_length: Optional[int] = None,
   614|         0|            0|            0|  0.00%|        pattern: Optional[str] = None,
   615|         0|            0|            0|  0.00%|        regex: Annotated[
   616|         0|            0|            0|  0.00%|            Optional[str],
   617|         0|            0|            0|  0.00%|            deprecated(
   618|         0|            0|            0|  0.00%|                "Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
   619|         0|            0|            0|  0.00%|            ),
   620|         0|            0|            0|  0.00%|        ] = None,
   621|         0|            0|            0|  0.00%|        discriminator: Union[str, None] = None,
   622|         0|            0|            0|  0.00%|        strict: Union[bool, None] = _Unset,
   623|         0|            0|            0|  0.00%|        multiple_of: Union[float, None] = _Unset,
   624|         0|            0|            0|  0.00%|        allow_inf_nan: Union[bool, None] = _Unset,
   625|         0|            0|            0|  0.00%|        max_digits: Union[int, None] = _Unset,
   626|         0|            0|            0|  0.00%|        decimal_places: Union[int, None] = _Unset,
   627|         0|            0|            0|  0.00%|        examples: Optional[List[Any]] = None,
   628|         0|            0|            0|  0.00%|        example: Annotated[
   629|         0|            0|            0|  0.00%|            Optional[Any],
   630|         0|            0|            0|  0.00%|            deprecated(
   631|         0|            0|            0|  0.00%|                "Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
   632|         0|            0|            0|  0.00%|                "although still supported. Use examples instead."
   633|         0|            0|            0|  0.00%|            ),
   634|         0|            0|            0|  0.00%|        ] = _Unset,
   635|         0|            0|            0|  0.00%|        openapi_examples: Optional[Dict[str, Example]] = None,
   636|         0|            0|            0|  0.00%|        deprecated: Union[deprecated, str, bool, None] = None,
   637|         0|            0|            0|  0.00%|        include_in_schema: bool = True,
   638|         0|            0|            0|  0.00%|        json_schema_extra: Union[Dict[str, Any], None] = None,
   639|         0|            0|            0|  0.00%|        **extra: Any,
   640|         0|            0|            0|  0.00%|    ):
   641|         0|            0|            0|  0.00%|        super().__init__(
   642|         0|            0|            0|  0.00%|            default=default,
   643|         0|            0|            0|  0.00%|            default_factory=default_factory,
   644|         0|            0|            0|  0.00%|            annotation=annotation,
   645|         0|            0|            0|  0.00%|            embed=True,
   646|         0|            0|            0|  0.00%|            media_type=media_type,
   647|         0|            0|            0|  0.00%|            alias=alias,
   648|         0|            0|            0|  0.00%|            alias_priority=alias_priority,
   649|         0|            0|            0|  0.00%|            validation_alias=validation_alias,
   650|         0|            0|            0|  0.00%|            serialization_alias=serialization_alias,
   651|         0|            0|            0|  0.00%|            title=title,
   652|         0|            0|            0|  0.00%|            description=description,
   653|         0|            0|            0|  0.00%|            gt=gt,
   654|         0|            0|            0|  0.00%|            ge=ge,
   655|         0|            0|            0|  0.00%|            lt=lt,
   656|         0|            0|            0|  0.00%|            le=le,
   657|         0|            0|            0|  0.00%|            min_length=min_length,
   658|         0|            0|            0|  0.00%|            max_length=max_length,
   659|         0|            0|            0|  0.00%|            pattern=pattern,
   660|         0|            0|            0|  0.00%|            regex=regex,
   661|         0|            0|            0|  0.00%|            discriminator=discriminator,
   662|         0|            0|            0|  0.00%|            strict=strict,
   663|         0|            0|            0|  0.00%|            multiple_of=multiple_of,
   664|         0|            0|            0|  0.00%|            allow_inf_nan=allow_inf_nan,
   665|         0|            0|            0|  0.00%|            max_digits=max_digits,
   666|         0|            0|            0|  0.00%|            decimal_places=decimal_places,
   667|         0|            0|            0|  0.00%|            deprecated=deprecated,
   668|         0|            0|            0|  0.00%|            example=example,
   669|         0|            0|            0|  0.00%|            examples=examples,
   670|         0|            0|            0|  0.00%|            openapi_examples=openapi_examples,
   671|         0|            0|            0|  0.00%|            include_in_schema=include_in_schema,
   672|         0|            0|            0|  0.00%|            json_schema_extra=json_schema_extra,
   673|         0|            0|            0|  0.00%|            **extra,
   674|         0|            0|            0|  0.00%|        )
   675|         0|            0|            0|  0.00%|
   676|         0|            0|            0|  0.00%|
   677|         0|            0|            0|  0.00%|class File(Form):
   678|         0|            0|            0|  0.00%|    def __init__(
   679|         0|            0|            0|  0.00%|        self,
   680|         0|            0|            0|  0.00%|        default: Any = Undefined,
   681|         0|            0|            0|  0.00%|        *,
   682|         0|            0|            0|  0.00%|        default_factory: Union[Callable[[], Any], None] = _Unset,
   683|         0|            0|            0|  0.00%|        annotation: Optional[Any] = None,
   684|         0|            0|            0|  0.00%|        media_type: str = "multipart/form-data",
   685|         0|            0|            0|  0.00%|        alias: Optional[str] = None,
   686|         0|            0|            0|  0.00%|        alias_priority: Union[int, None] = _Unset,
   687|         0|            0|            0|  0.00%|        # TODO: update when deprecating Pydantic v1, import these types
   688|         0|            0|            0|  0.00%|        # validation_alias: str | AliasPath | AliasChoices | None
   689|         0|            0|            0|  0.00%|        validation_alias: Union[str, None] = None,
   690|         0|            0|            0|  0.00%|        serialization_alias: Union[str, None] = None,
   691|         0|            0|            0|  0.00%|        title: Optional[str] = None,
   692|         0|            0|            0|  0.00%|        description: Optional[str] = None,
   693|         0|            0|            0|  0.00%|        gt: Optional[float] = None,
   694|         0|            0|            0|  0.00%|        ge: Optional[float] = None,
   695|         0|            0|            0|  0.00%|        lt: Optional[float] = None,
   696|         0|            0|            0|  0.00%|        le: Optional[float] = None,
   697|         0|            0|            0|  0.00%|        min_length: Optional[int] = None,
   698|         0|            0|            0|  0.00%|        max_length: Optional[int] = None,
   699|         0|            0|            0|  0.00%|        pattern: Optional[str] = None,
   700|         0|            0|            0|  0.00%|        regex: Annotated[
   701|         0|            0|            0|  0.00%|            Optional[str],
   702|         0|            0|            0|  0.00%|            deprecated(
   703|         0|            0|            0|  0.00%|                "Deprecated in FastAPI 0.100.0 and Pydantic v2, use `pattern` instead."
   704|         0|            0|            0|  0.00%|            ),
   705|         0|            0|            0|  0.00%|        ] = None,
   706|         0|            0|            0|  0.00%|        discriminator: Union[str, None] = None,
   707|         0|            0|            0|  0.00%|        strict: Union[bool, None] = _Unset,
   708|         0|            0|            0|  0.00%|        multiple_of: Union[float, None] = _Unset,
   709|         0|            0|            0|  0.00%|        allow_inf_nan: Union[bool, None] = _Unset,
   710|         0|            0|            0|  0.00%|        max_digits: Union[int, None] = _Unset,
   711|         0|            0|            0|  0.00%|        decimal_places: Union[int, None] = _Unset,
   712|         0|            0|            0|  0.00%|        examples: Optional[List[Any]] = None,
   713|         0|            0|            0|  0.00%|        example: Annotated[
   714|         0|            0|            0|  0.00%|            Optional[Any],
   715|         0|            0|            0|  0.00%|            deprecated(
   716|         0|            0|            0|  0.00%|                "Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, "
   717|         0|            0|            0|  0.00%|                "although still supported. Use examples instead."
   718|         0|            0|            0|  0.00%|            ),
   719|         0|            0|            0|  0.00%|        ] = _Unset,
   720|         0|            0|            0|  0.00%|        openapi_examples: Optional[Dict[str, Example]] = None,
   721|         0|            0|            0|  0.00%|        deprecated: Union[deprecated, str, bool, None] = None,
   722|         0|            0|            0|  0.00%|        include_in_schema: bool = True,
   723|         0|            0|            0|  0.00%|        json_schema_extra: Union[Dict[str, Any], None] = None,
   724|         0|            0|            0|  0.00%|        **extra: Any,
   725|         0|            0|            0|  0.00%|    ):
   726|         0|            0|            0|  0.00%|        super().__init__(
   727|         0|            0|            0|  0.00%|            default=default,
   728|         0|            0|            0|  0.00%|            default_factory=default_factory,
   729|         0|            0|            0|  0.00%|            annotation=annotation,
   730|         0|            0|            0|  0.00%|            media_type=media_type,
   731|         0|            0|            0|  0.00%|            alias=alias,
   732|         0|            0|            0|  0.00%|            alias_priority=alias_priority,
   733|         0|            0|            0|  0.00%|            validation_alias=validation_alias,
   734|         0|            0|            0|  0.00%|            serialization_alias=serialization_alias,
   735|         0|            0|            0|  0.00%|            title=title,
   736|         0|            0|            0|  0.00%|            description=description,
   737|         0|            0|            0|  0.00%|            gt=gt,
   738|         0|            0|            0|  0.00%|            ge=ge,
   739|         0|            0|            0|  0.00%|            lt=lt,
   740|         0|            0|            0|  0.00%|            le=le,
   741|         0|            0|            0|  0.00%|            min_length=min_length,
   742|         0|            0|            0|  0.00%|            max_length=max_length,
   743|         0|            0|            0|  0.00%|            pattern=pattern,
   744|         0|            0|            0|  0.00%|            regex=regex,
   745|         0|            0|            0|  0.00%|            discriminator=discriminator,
   746|         0|            0|            0|  0.00%|            strict=strict,
   747|         0|            0|            0|  0.00%|            multiple_of=multiple_of,
   748|         0|            0|            0|  0.00%|            allow_inf_nan=allow_inf_nan,
   749|         0|            0|            0|  0.00%|            max_digits=max_digits,
   750|         0|            0|            0|  0.00%|            decimal_places=decimal_places,
   751|         0|            0|            0|  0.00%|            deprecated=deprecated,
   752|         0|            0|            0|  0.00%|            example=example,
   753|         0|            0|            0|  0.00%|            examples=examples,
   754|         0|            0|            0|  0.00%|            openapi_examples=openapi_examples,
   755|         0|            0|            0|  0.00%|            include_in_schema=include_in_schema,
   756|         0|            0|            0|  0.00%|            json_schema_extra=json_schema_extra,
   757|         0|            0|            0|  0.00%|            **extra,
   758|         0|            0|            0|  0.00%|        )
   759|         0|            0|            0|  0.00%|
   760|         0|            0|            0|  0.00%|
   761|         0|            0|            0|  0.00%|class Depends:
   762|         0|            0|            0|  0.00%|    def __init__(
   763|         0|            0|            0|  0.00%|        self, dependency: Optional[Callable[..., Any]] = None, *, use_cache: bool = True
   764|         0|            0|            0|  0.00%|    ):
   765|         0|            0|            0|  0.00%|        self.dependency = dependency
   766|         0|            0|            0|  0.00%|        self.use_cache = use_cache
   767|         0|            0|            0|  0.00%|
   768|         0|            0|            0|  0.00%|    def __repr__(self) -> str:
   769|         0|            0|            0|  0.00%|        attr = getattr(self.dependency, "__name__", type(self.dependency).__name__)
   770|         0|            0|            0|  0.00%|        cache = "" if self.use_cache else ", use_cache=False"
   771|         0|            0|            0|  0.00%|        return f"{self.__class__.__name__}({attr}{cache})"
   772|         0|            0|            0|  0.00%|
   773|         0|            0|            0|  0.00%|
   774|         0|            0|            0|  0.00%|class Security(Depends):
   775|         0|            0|            0|  0.00%|    def __init__(
   776|         0|            0|            0|  0.00%|        self,
   777|         0|            0|            0|  0.00%|        dependency: Optional[Callable[..., Any]] = None,
   778|         0|            0|            0|  0.00%|        *,
   779|         0|            0|            0|  0.00%|        scopes: Optional[Sequence[str]] = None,
   780|         0|            0|            0|  0.00%|        use_cache: bool = True,
   781|         0|            0|            0|  0.00%|    ):
   782|         0|            0|            0|  0.00%|        super().__init__(dependency=dependency, use_cache=use_cache)
   783|         0|            0|            0|  0.00%|        self.scopes = scopes or []
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/copy.py
File duration: 0.000873566s (0.90%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Generic (shallow and deep) copying operations.
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|Interface summary:
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|        import copy
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|        x = copy.copy(y)        # make a shallow copy of y
     8|         0|            0|            0|  0.00%|        x = copy.deepcopy(y)    # make a deep copy of y
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|For module specific errors, copy.Error is raised.
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|The difference between shallow and deep copying is only relevant for
    13|         0|            0|            0|  0.00%|compound objects (objects that contain other objects, like lists or
    14|         0|            0|            0|  0.00%|class instances).
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|- A shallow copy constructs a new compound object and then (to the
    17|         0|            0|            0|  0.00%|  extent possible) inserts *the same objects* into it that the
    18|         0|            0|            0|  0.00%|  original contains.
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|- A deep copy constructs a new compound object and then, recursively,
    21|         0|            0|            0|  0.00%|  inserts *copies* into it of the objects found in the original.
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|Two problems often exist with deep copy operations that don't exist
    24|         0|            0|            0|  0.00%|with shallow copy operations:
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%| a) recursive objects (compound objects that, directly or indirectly,
    27|         0|            0|            0|  0.00%|    contain a reference to themselves) may cause a recursive loop
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%| b) because deep copy copies *everything* it may copy too much, e.g.
    30|         0|            0|            0|  0.00%|    administrative data structures that should be shared even between
    31|         0|            0|            0|  0.00%|    copies
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|Python's deep copy operation avoids these problems by:
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%| a) keeping a table of objects already copied during the current
    36|         0|            0|            0|  0.00%|    copying pass
    37|         0|            0|            0|  0.00%|
    38|         0|            0|            0|  0.00%| b) letting user-defined classes override the copying operation or the
    39|         0|            0|            0|  0.00%|    set of components copied
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|This version does not copy types like module, class, function, method,
    42|         0|            0|            0|  0.00%|nor stack trace, stack frame, nor file, socket, window, nor any
    43|         0|            0|            0|  0.00%|similar types.
    44|         0|            0|            0|  0.00%|
    45|         0|            0|            0|  0.00%|Classes can use the same interfaces to control copying that they use
    46|         0|            0|            0|  0.00%|to control pickling: they can define methods called __getinitargs__(),
    47|         0|            0|            0|  0.00%|__getstate__() and __setstate__().  See the documentation for module
    48|         0|            0|            0|  0.00%|"pickle" for information on these methods.
    49|         0|            0|            0|  0.00%|"""
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|import types
    52|         0|            0|            0|  0.00%|import weakref
    53|         0|            0|            0|  0.00%|from copyreg import dispatch_table
    54|         0|            0|            0|  0.00%|
    55|         0|            0|            0|  0.00%|class Error(Exception):
    56|         0|            0|            0|  0.00%|    pass
    57|         0|            0|            0|  0.00%|error = Error   # backward compatibility
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|__all__ = ["Error", "copy", "deepcopy"]
    60|         0|            0|            0|  0.00%|
    61|         4|  1.19209e-05|  2.98023e-06|  0.01%|def copy(x):
    62|         0|            0|            0|  0.00%|    """Shallow copy operation on arbitrary Python objects.
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|    See the module's __doc__ string for more info.
    65|         0|            0|            0|  0.00%|    """
    66|         0|            0|            0|  0.00%|
    67|         4|  1.09673e-05|  2.74181e-06|  0.01%|    cls = type(x)
    68|         0|            0|            0|  0.00%|
    69|         4|  7.86781e-06|  1.96695e-06|  0.01%|    copier = _copy_dispatch.get(cls)
    70|         4|  6.67572e-06|  1.66893e-06|  0.01%|    if copier:
    71|         0|            0|            0|  0.00%|        return copier(x)
    72|         0|            0|            0|  0.00%|
    73|         4|  7.86781e-06|  1.96695e-06|  0.01%|    if issubclass(cls, type):
    74|         0|            0|            0|  0.00%|        # treat it as a regular class:
    75|         0|            0|            0|  0.00%|        return _copy_immutable(x)
    76|         0|            0|            0|  0.00%|
    77|         4|  8.58307e-06|  2.14577e-06|  0.01%|    copier = getattr(cls, "__copy__", None)
    78|         4|  7.39098e-06|  1.84774e-06|  0.01%|    if copier is not None:
    79|         0|            0|            0|  0.00%|        return copier(x)
    80|         0|            0|            0|  0.00%|
    81|         4|  7.62939e-06|  1.90735e-06|  0.01%|    reductor = dispatch_table.get(cls)
    82|         4|  9.53674e-06|  2.38419e-06|  0.01%|    if reductor is not None:
    83|         0|            0|            0|  0.00%|        rv = reductor(x)
    84|         0|            0|            0|  0.00%|    else:
    85|         4|  8.58307e-06|  2.14577e-06|  0.01%|        reductor = getattr(x, "__reduce_ex__", None)
    86|         4|  7.86781e-06|  1.96695e-06|  0.01%|        if reductor is not None:
    87|         4|  5.65052e-05|  1.41263e-05|  0.06%|            rv = reductor(4)
(call)|         1|  0.000216722|  0.000216722|  0.22%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/copyreg.py:107 _slotnames
    88|         0|            0|            0|  0.00%|        else:
    89|         0|            0|            0|  0.00%|            reductor = getattr(x, "__reduce__", None)
    90|         0|            0|            0|  0.00%|            if reductor:
    91|         0|            0|            0|  0.00%|                rv = reductor()
    92|         0|            0|            0|  0.00%|            else:
    93|         0|            0|            0|  0.00%|                raise Error("un(shallow)copyable object of type %s" % cls)
    94|         0|            0|            0|  0.00%|
    95|         4|   1.0252e-05|    2.563e-06|  0.01%|    if isinstance(rv, str):
    96|         0|            0|            0|  0.00%|        return x
    97|         4|  7.31945e-05|  1.82986e-05|  0.08%|    return _reconstruct(x, None, *rv)
(call)|         4|  0.000663042|  0.000165761|  0.68%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/copy.py:247 _reconstruct
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|
   100|         0|            0|            0|  0.00%|_copy_dispatch = d = {}
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|def _copy_immutable(x):
   103|         0|            0|            0|  0.00%|    return x
   104|         0|            0|            0|  0.00%|for t in (types.NoneType, int, float, bool, complex, str, tuple,
   105|         0|            0|            0|  0.00%|          bytes, frozenset, type, range, slice, property,
   106|         0|            0|            0|  0.00%|          types.BuiltinFunctionType, types.EllipsisType,
   107|         0|            0|            0|  0.00%|          types.NotImplementedType, types.FunctionType, types.CodeType,
   108|         0|            0|            0|  0.00%|          weakref.ref):
   109|         0|            0|            0|  0.00%|    d[t] = _copy_immutable
   110|         0|            0|            0|  0.00%|
   111|         0|            0|            0|  0.00%|d[list] = list.copy
   112|         0|            0|            0|  0.00%|d[dict] = dict.copy
   113|         0|            0|            0|  0.00%|d[set] = set.copy
   114|         0|            0|            0|  0.00%|d[bytearray] = bytearray.copy
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|del d, t
   117|         0|            0|            0|  0.00%|
   118|         0|            0|            0|  0.00%|def deepcopy(x, memo=None, _nil=[]):
   119|         0|            0|            0|  0.00%|    """Deep copy operation on arbitrary Python objects.
   120|         0|            0|            0|  0.00%|
   121|         0|            0|            0|  0.00%|    See the module's __doc__ string for more info.
   122|         0|            0|            0|  0.00%|    """
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|    if memo is None:
   125|         0|            0|            0|  0.00%|        memo = {}
   126|         0|            0|            0|  0.00%|
   127|         0|            0|            0|  0.00%|    d = id(x)
   128|         0|            0|            0|  0.00%|    y = memo.get(d, _nil)
   129|         0|            0|            0|  0.00%|    if y is not _nil:
   130|         0|            0|            0|  0.00%|        return y
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|    cls = type(x)
   133|         0|            0|            0|  0.00%|
   134|         0|            0|            0|  0.00%|    copier = _deepcopy_dispatch.get(cls)
   135|         0|            0|            0|  0.00%|    if copier is not None:
   136|         0|            0|            0|  0.00%|        y = copier(x, memo)
   137|         0|            0|            0|  0.00%|    else:
   138|         0|            0|            0|  0.00%|        if issubclass(cls, type):
   139|         0|            0|            0|  0.00%|            y = _deepcopy_atomic(x, memo)
   140|         0|            0|            0|  0.00%|        else:
   141|         0|            0|            0|  0.00%|            copier = getattr(x, "__deepcopy__", None)
   142|         0|            0|            0|  0.00%|            if copier is not None:
   143|         0|            0|            0|  0.00%|                y = copier(memo)
   144|         0|            0|            0|  0.00%|            else:
   145|         0|            0|            0|  0.00%|                reductor = dispatch_table.get(cls)
   146|         0|            0|            0|  0.00%|                if reductor:
   147|         0|            0|            0|  0.00%|                    rv = reductor(x)
   148|         0|            0|            0|  0.00%|                else:
   149|         0|            0|            0|  0.00%|                    reductor = getattr(x, "__reduce_ex__", None)
   150|         0|            0|            0|  0.00%|                    if reductor is not None:
   151|         0|            0|            0|  0.00%|                        rv = reductor(4)
   152|         0|            0|            0|  0.00%|                    else:
   153|         0|            0|            0|  0.00%|                        reductor = getattr(x, "__reduce__", None)
   154|         0|            0|            0|  0.00%|                        if reductor:
   155|         0|            0|            0|  0.00%|                            rv = reductor()
   156|         0|            0|            0|  0.00%|                        else:
   157|         0|            0|            0|  0.00%|                            raise Error(
   158|         0|            0|            0|  0.00%|                                "un(deep)copyable object of type %s" % cls)
   159|         0|            0|            0|  0.00%|                if isinstance(rv, str):
   160|         0|            0|            0|  0.00%|                    y = x
   161|         0|            0|            0|  0.00%|                else:
   162|         0|            0|            0|  0.00%|                    y = _reconstruct(x, memo, *rv)
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|    # If is its own copy, don't memoize.
   165|         0|            0|            0|  0.00%|    if y is not x:
   166|         0|            0|            0|  0.00%|        memo[d] = y
   167|         0|            0|            0|  0.00%|        _keep_alive(x, memo) # Make sure x lives at least as long as d
   168|         0|            0|            0|  0.00%|    return y
   169|         0|            0|            0|  0.00%|
   170|         0|            0|            0|  0.00%|_deepcopy_dispatch = d = {}
   171|         0|            0|            0|  0.00%|
   172|         0|            0|            0|  0.00%|def _deepcopy_atomic(x, memo):
   173|         0|            0|            0|  0.00%|    return x
   174|         0|            0|            0|  0.00%|d[types.NoneType] = _deepcopy_atomic
   175|         0|            0|            0|  0.00%|d[types.EllipsisType] = _deepcopy_atomic
   176|         0|            0|            0|  0.00%|d[types.NotImplementedType] = _deepcopy_atomic
   177|         0|            0|            0|  0.00%|d[int] = _deepcopy_atomic
   178|         0|            0|            0|  0.00%|d[float] = _deepcopy_atomic
   179|         0|            0|            0|  0.00%|d[bool] = _deepcopy_atomic
   180|         0|            0|            0|  0.00%|d[complex] = _deepcopy_atomic
   181|         0|            0|            0|  0.00%|d[bytes] = _deepcopy_atomic
   182|         0|            0|            0|  0.00%|d[str] = _deepcopy_atomic
   183|         0|            0|            0|  0.00%|d[types.CodeType] = _deepcopy_atomic
   184|         0|            0|            0|  0.00%|d[type] = _deepcopy_atomic
   185|         0|            0|            0|  0.00%|d[range] = _deepcopy_atomic
   186|         0|            0|            0|  0.00%|d[types.BuiltinFunctionType] = _deepcopy_atomic
   187|         0|            0|            0|  0.00%|d[types.FunctionType] = _deepcopy_atomic
   188|         0|            0|            0|  0.00%|d[weakref.ref] = _deepcopy_atomic
   189|         0|            0|            0|  0.00%|d[property] = _deepcopy_atomic
   190|         0|            0|            0|  0.00%|
   191|         0|            0|            0|  0.00%|def _deepcopy_list(x, memo, deepcopy=deepcopy):
   192|         0|            0|            0|  0.00%|    y = []
   193|         0|            0|            0|  0.00%|    memo[id(x)] = y
   194|         0|            0|            0|  0.00%|    append = y.append
   195|         0|            0|            0|  0.00%|    for a in x:
   196|         0|            0|            0|  0.00%|        append(deepcopy(a, memo))
   197|         0|            0|            0|  0.00%|    return y
   198|         0|            0|            0|  0.00%|d[list] = _deepcopy_list
   199|         0|            0|            0|  0.00%|
   200|         0|            0|            0|  0.00%|def _deepcopy_tuple(x, memo, deepcopy=deepcopy):
   201|         0|            0|            0|  0.00%|    y = [deepcopy(a, memo) for a in x]
   202|         0|            0|            0|  0.00%|    # We're not going to put the tuple in the memo, but it's still important we
   203|         0|            0|            0|  0.00%|    # check for it, in case the tuple contains recursive mutable structures.
   204|         0|            0|            0|  0.00%|    try:
   205|         0|            0|            0|  0.00%|        return memo[id(x)]
   206|         0|            0|            0|  0.00%|    except KeyError:
   207|         0|            0|            0|  0.00%|        pass
   208|         0|            0|            0|  0.00%|    for k, j in zip(x, y):
   209|         0|            0|            0|  0.00%|        if k is not j:
   210|         0|            0|            0|  0.00%|            y = tuple(y)
   211|         0|            0|            0|  0.00%|            break
   212|         0|            0|            0|  0.00%|    else:
   213|         0|            0|            0|  0.00%|        y = x
   214|         0|            0|            0|  0.00%|    return y
   215|         0|            0|            0|  0.00%|d[tuple] = _deepcopy_tuple
   216|         0|            0|            0|  0.00%|
   217|         0|            0|            0|  0.00%|def _deepcopy_dict(x, memo, deepcopy=deepcopy):
   218|         0|            0|            0|  0.00%|    y = {}
   219|         0|            0|            0|  0.00%|    memo[id(x)] = y
   220|         0|            0|            0|  0.00%|    for key, value in x.items():
   221|         0|            0|            0|  0.00%|        y[deepcopy(key, memo)] = deepcopy(value, memo)
   222|         0|            0|            0|  0.00%|    return y
   223|         0|            0|            0|  0.00%|d[dict] = _deepcopy_dict
   224|         0|            0|            0|  0.00%|
   225|         0|            0|            0|  0.00%|def _deepcopy_method(x, memo): # Copy instance methods
   226|         0|            0|            0|  0.00%|    return type(x)(x.__func__, deepcopy(x.__self__, memo))
   227|         0|            0|            0|  0.00%|d[types.MethodType] = _deepcopy_method
   228|         0|            0|            0|  0.00%|
   229|         0|            0|            0|  0.00%|del d
   230|         0|            0|            0|  0.00%|
   231|         0|            0|            0|  0.00%|def _keep_alive(x, memo):
   232|         0|            0|            0|  0.00%|    """Keeps a reference to the object x in the memo.
   233|         0|            0|            0|  0.00%|
   234|         0|            0|            0|  0.00%|    Because we remember objects by their id, we have
   235|         0|            0|            0|  0.00%|    to assure that possibly temporary objects are kept
   236|         0|            0|            0|  0.00%|    alive by referencing them.
   237|         0|            0|            0|  0.00%|    We store a reference at the id of the memo, which should
   238|         0|            0|            0|  0.00%|    normally not be used unless someone tries to deepcopy
   239|         0|            0|            0|  0.00%|    the memo itself...
   240|         0|            0|            0|  0.00%|    """
   241|         0|            0|            0|  0.00%|    try:
   242|         0|            0|            0|  0.00%|        memo[id(memo)].append(x)
   243|         0|            0|            0|  0.00%|    except KeyError:
   244|         0|            0|            0|  0.00%|        # aha, this is the first one :-)
   245|         0|            0|            0|  0.00%|        memo[id(memo)]=[x]
   246|         0|            0|            0|  0.00%|
   247|         4|  1.97887e-05|  4.94719e-06|  0.02%|def _reconstruct(x, memo, func, args,
   248|         0|            0|            0|  0.00%|                 state=None, listiter=None, dictiter=None,
   249|         0|            0|            0|  0.00%|                 *, deepcopy=deepcopy):
   250|         4|  1.12057e-05|  2.80142e-06|  0.01%|    deep = memo is not None
   251|         4|  1.00136e-05|   2.5034e-06|  0.01%|    if deep and args:
   252|         0|            0|            0|  0.00%|        args = (deepcopy(arg, memo) for arg in args)
   253|         4|  3.50475e-05|  8.76188e-06|  0.04%|    y = func(*args)
(call)|         4|  2.43187e-05|  6.07967e-06|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/copyreg.py:98 __newobj__
   254|         4|  1.28746e-05|  3.21865e-06|  0.01%|    if deep:
   255|         0|            0|            0|  0.00%|        memo[id(x)] = y
   256|         0|            0|            0|  0.00%|
   257|         4|   1.0252e-05|    2.563e-06|  0.01%|    if state is not None:
   258|         4|   1.0252e-05|    2.563e-06|  0.01%|        if deep:
   259|         0|            0|            0|  0.00%|            state = deepcopy(state, memo)
   260|         4|  1.19209e-05|  2.98023e-06|  0.01%|        if hasattr(y, '__setstate__'):
   261|         0|            0|            0|  0.00%|            y.__setstate__(state)
   262|         0|            0|            0|  0.00%|        else:
   263|         4|   1.3113e-05|  3.27826e-06|  0.01%|            if isinstance(state, tuple) and len(state) == 2:
   264|         4|  1.04904e-05|   2.6226e-06|  0.01%|                state, slotstate = state
   265|         0|            0|            0|  0.00%|            else:
   266|         0|            0|            0|  0.00%|                slotstate = None
   267|         4|  1.00136e-05|   2.5034e-06|  0.01%|            if state is not None:
   268|         4|  1.43051e-05|  3.57628e-06|  0.01%|                y.__dict__.update(state)
   269|         4|  9.05991e-06|  2.26498e-06|  0.01%|            if slotstate is not None:
   270|        96|  0.000206232|  2.14825e-06|  0.21%|                for key, value in slotstate.items():
   271|        92|  0.000202417|  2.20019e-06|  0.21%|                    setattr(y, key, value)
   272|         0|            0|            0|  0.00%|
   273|         4|  8.34465e-06|  2.08616e-06|  0.01%|    if listiter is not None:
   274|         0|            0|            0|  0.00%|        if deep:
   275|         0|            0|            0|  0.00%|            for item in listiter:
   276|         0|            0|            0|  0.00%|                item = deepcopy(item, memo)
   277|         0|            0|            0|  0.00%|                y.append(item)
   278|         0|            0|            0|  0.00%|        else:
   279|         0|            0|            0|  0.00%|            for item in listiter:
   280|         0|            0|            0|  0.00%|                y.append(item)
   281|         4|  3.33786e-05|  8.34465e-06|  0.03%|    if dictiter is not None:
   282|         0|            0|            0|  0.00%|        if deep:
   283|         0|            0|            0|  0.00%|            for key, value in dictiter:
   284|         0|            0|            0|  0.00%|                key = deepcopy(key, memo)
   285|         0|            0|            0|  0.00%|                value = deepcopy(value, memo)
   286|         0|            0|            0|  0.00%|                y[key] = value
   287|         0|            0|            0|  0.00%|        else:
   288|         0|            0|            0|  0.00%|            for key, value in dictiter:
   289|         0|            0|            0|  0.00%|                y[key] = value
   290|         4|  1.00136e-05|   2.5034e-06|  0.01%|    return y
   291|         0|            0|            0|  0.00%|
   292|         0|            0|            0|  0.00%|del types, weakref
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/type_adapter.py
File duration: 0.000870466s (0.89%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Type adapter specification."""
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|from __future__ import annotations as _annotations
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|import sys
     6|         0|            0|            0|  0.00%|from contextlib import contextmanager
     7|         0|            0|            0|  0.00%|from dataclasses import is_dataclass
     8|         0|            0|            0|  0.00%|from functools import cached_property, wraps
     9|         0|            0|            0|  0.00%|from typing import (
    10|         0|            0|            0|  0.00%|    TYPE_CHECKING,
    11|         0|            0|            0|  0.00%|    Any,
    12|         0|            0|            0|  0.00%|    Callable,
    13|         0|            0|            0|  0.00%|    Dict,
    14|         0|            0|            0|  0.00%|    Generic,
    15|         0|            0|            0|  0.00%|    Iterable,
    16|         0|            0|            0|  0.00%|    Iterator,
    17|         0|            0|            0|  0.00%|    Literal,
    18|         0|            0|            0|  0.00%|    Set,
    19|         0|            0|            0|  0.00%|    TypeVar,
    20|         0|            0|            0|  0.00%|    Union,
    21|         0|            0|            0|  0.00%|    cast,
    22|         0|            0|            0|  0.00%|    final,
    23|         0|            0|            0|  0.00%|    overload,
    24|         0|            0|            0|  0.00%|)
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|from pydantic_core import CoreSchema, SchemaSerializer, SchemaValidator, Some
    27|         0|            0|            0|  0.00%|from typing_extensions import Concatenate, ParamSpec, is_typeddict
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|from pydantic.errors import PydanticUserError
    30|         0|            0|            0|  0.00%|from pydantic.main import BaseModel
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|from ._internal import _config, _generate_schema, _mock_val_ser, _typing_extra, _utils
    33|         0|            0|            0|  0.00%|from .config import ConfigDict
    34|         0|            0|            0|  0.00%|from .json_schema import (
    35|         0|            0|            0|  0.00%|    DEFAULT_REF_TEMPLATE,
    36|         0|            0|            0|  0.00%|    GenerateJsonSchema,
    37|         0|            0|            0|  0.00%|    JsonSchemaKeyT,
    38|         0|            0|            0|  0.00%|    JsonSchemaMode,
    39|         0|            0|            0|  0.00%|    JsonSchemaValue,
    40|         0|            0|            0|  0.00%|)
    41|         0|            0|            0|  0.00%|from .plugin._schema_validator import PluggableSchemaValidator, create_schema_validator
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|T = TypeVar('T')
    44|         0|            0|            0|  0.00%|R = TypeVar('R')
    45|         0|            0|            0|  0.00%|P = ParamSpec('P')
    46|         0|            0|            0|  0.00%|TypeAdapterT = TypeVar('TypeAdapterT', bound='TypeAdapter')
    47|         0|            0|            0|  0.00%|
    48|         0|            0|            0|  0.00%|
    49|         0|            0|            0|  0.00%|if TYPE_CHECKING:
    50|         0|            0|            0|  0.00%|    # should be `set[int] | set[str] | dict[int, IncEx] | dict[str, IncEx] | None`, but mypy can't cope
    51|         0|            0|            0|  0.00%|    IncEx = Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any]]
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|
    54|         2|  8.34465e-06|  4.17233e-06|  0.01%|def _get_schema(type_: Any, config_wrapper: _config.ConfigWrapper, parent_depth: int) -> CoreSchema:
    55|         0|            0|            0|  0.00%|    """`BaseModel` uses its own `__module__` to find out where it was defined
    56|         0|            0|            0|  0.00%|    and then looks for symbols to resolve forward references in those globals.
    57|         0|            0|            0|  0.00%|    On the other hand this function can be called with arbitrary objects,
    58|         0|            0|            0|  0.00%|    including type aliases, where `__module__` (always `typing.py`) is not useful.
    59|         0|            0|            0|  0.00%|    So instead we look at the globals in our parent stack frame.
    60|         0|            0|            0|  0.00%|
    61|         0|            0|            0|  0.00%|    This works for the case where this function is called in a module that
    62|         0|            0|            0|  0.00%|    has the target of forward references in its scope, but
    63|         0|            0|            0|  0.00%|    does not always work for more complex cases.
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|    For example, take the following:
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|    a.py
    68|         0|            0|            0|  0.00%|    ```python
    69|         0|            0|            0|  0.00%|    from typing import Dict, List
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|    IntList = List[int]
    72|         0|            0|            0|  0.00%|    OuterDict = Dict[str, 'IntList']
    73|         0|            0|            0|  0.00%|    ```
    74|         0|            0|            0|  0.00%|
    75|         0|            0|            0|  0.00%|    b.py
    76|         0|            0|            0|  0.00%|    ```python test="skip"
    77|         0|            0|            0|  0.00%|    from a import OuterDict
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|    from pydantic import TypeAdapter
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|    IntList = int  # replaces the symbol the forward reference is looking for
    82|         0|            0|            0|  0.00%|    v = TypeAdapter(OuterDict)
    83|         0|            0|            0|  0.00%|    v({'x': 1})  # should fail but doesn't
    84|         0|            0|            0|  0.00%|    ```
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|    If `OuterDict` were a `BaseModel`, this would work because it would resolve
    87|         0|            0|            0|  0.00%|    the forward reference within the `a.py` namespace.
    88|         0|            0|            0|  0.00%|    But `TypeAdapter(OuterDict)` can't determine what module `OuterDict` came from.
    89|         0|            0|            0|  0.00%|
    90|         0|            0|            0|  0.00%|    In other words, the assumption that _all_ forward references exist in the
    91|         0|            0|            0|  0.00%|    module we are being called from is not technically always true.
    92|         0|            0|            0|  0.00%|    Although most of the time it is and it works fine for recursive models and such,
    93|         0|            0|            0|  0.00%|    `BaseModel`'s behavior isn't perfect either and _can_ break in similar ways,
    94|         0|            0|            0|  0.00%|    so there is no right or wrong between the two.
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|    But at the very least this behavior is _subtly_ different from `BaseModel`'s.
    97|         0|            0|            0|  0.00%|    """
    98|         2|  1.40667e-05|  7.03335e-06|  0.01%|    local_ns = _typing_extra.parent_frame_namespace(parent_depth=parent_depth)
(call)|         2|  2.36034e-05|  1.18017e-05|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_typing_extra.py:173 parent_frame_namespace
    99|         2|  9.77516e-06|  4.88758e-06|  0.01%|    global_ns = sys._getframe(max(parent_depth - 1, 1)).f_globals.copy()
   100|         2|  5.24521e-06|   2.6226e-06|  0.01%|    global_ns.update(local_ns or {})
   101|         2|  2.26498e-05|  1.13249e-05|  0.02%|    gen = _generate_schema.GenerateSchema(config_wrapper, types_namespace=global_ns, typevars_map={})
(call)|         2|  0.000150442|  7.52211e-05|  0.15%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:329 __init__
   102|         2|  2.47955e-05|  1.23978e-05|  0.03%|    schema = gen.generate_schema(type_)
(call)|         2|   0.00710011|   0.00355005|  7.30%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:477 generate_schema
   103|         2|  2.81334e-05|  1.40667e-05|  0.03%|    schema = gen.clean_schema(schema)
(call)|         2|   0.00151181|  0.000755906|  1.55%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:446 clean_schema
   104|         2|  6.67572e-06|  3.33786e-06|  0.01%|    return schema
   105|         0|            0|            0|  0.00%|
   106|         0|            0|            0|  0.00%|
   107|         2|  8.34465e-06|  4.17233e-06|  0.01%|def _getattr_no_parents(obj: Any, attribute: str) -> Any:
   108|         0|            0|            0|  0.00%|    """Returns the attribute value without attempting to look up attributes from parent types."""
   109|         2|   6.4373e-06|  3.21865e-06|  0.01%|    if hasattr(obj, '__dict__'):
   110|         2|  3.33786e-06|  1.66893e-06|  0.00%|        try:
   111|         2|  4.76837e-06|  2.38419e-06|  0.00%|            return obj.__dict__[attribute]
   112|         2|  3.33786e-06|  1.66893e-06|  0.00%|        except KeyError:
   113|         2|  3.57628e-06|  1.78814e-06|  0.00%|            pass
   114|         0|            0|            0|  0.00%|
   115|         2|  3.57628e-06|  1.78814e-06|  0.00%|    slots = getattr(obj, '__slots__', None)
   116|         2|  2.86102e-06|  1.43051e-06|  0.00%|    if slots is not None and attribute in slots:
   117|         0|            0|            0|  0.00%|        return getattr(obj, attribute)
   118|         0|            0|            0|  0.00%|    else:
   119|         2|  5.00679e-06|   2.5034e-06|  0.01%|        raise AttributeError(attribute)
   120|         0|            0|            0|  0.00%|
   121|         0|            0|            0|  0.00%|
   122|         2|  6.19888e-06|  3.09944e-06|  0.01%|def _type_has_config(type_: Any) -> bool:
   123|         0|            0|            0|  0.00%|    """Returns whether the type has config."""
   124|         2|   1.4782e-05|  7.39098e-06|  0.02%|    type_ = _typing_extra.annotated_type(type_) or type_
(call)|         2|  5.79357e-05|  2.89679e-05|  0.06%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_typing_extra.py:115 annotated_type
   125|         2|  5.00679e-06|   2.5034e-06|  0.01%|    try:
   126|         4|  4.36306e-05|  1.09076e-05|  0.04%|        return issubclass(type_, BaseModel) or is_dataclass(type_) or is_typeddict(type_)
(call)|         2|   0.00135112|  0.000675559|  1.39%|# <frozen abc>:121 __subclasscheck__
(call)|         2|  2.21729e-05|  1.10865e-05|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/dataclasses.py:1294 is_dataclass
(call)|         2|  1.35899e-05|  6.79493e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/typing_extensions.py:1132 is_typeddict
   127|         0|            0|            0|  0.00%|    except TypeError:
   128|         0|            0|            0|  0.00%|        # type is not a class
   129|         0|            0|            0|  0.00%|        return False
   130|         0|            0|            0|  0.00%|
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|# This is keeping track of the frame depth for the TypeAdapter functions. This is required for _parent_depth used for
   133|         0|            0|            0|  0.00%|# ForwardRef resolution. We may enter the TypeAdapter schema building via different TypeAdapter functions. Hence, we
   134|         0|            0|            0|  0.00%|# need to keep track of the frame depth relative to the originally provided _parent_depth.
   135|         0|            0|            0|  0.00%|def _frame_depth(
   136|         0|            0|            0|  0.00%|    depth: int,
   137|         0|            0|            0|  0.00%|) -> Callable[[Callable[Concatenate[TypeAdapterT, P], R]], Callable[Concatenate[TypeAdapterT, P], R]]:
   138|         0|            0|            0|  0.00%|    def wrapper(func: Callable[Concatenate[TypeAdapterT, P], R]) -> Callable[Concatenate[TypeAdapterT, P], R]:
   139|         2|  4.76837e-06|  2.38419e-06|  0.00%|        @wraps(func)
   140|         0|            0|            0|  0.00%|        def wrapped(self: TypeAdapterT, *args: P.args, **kwargs: P.kwargs) -> R:
   141|         4|   3.6478e-05|  9.11951e-06|  0.04%|            with self._with_frame_depth(depth + 1):  # depth + 1 for the wrapper function
(call)|         2|  2.74181e-05|  1.37091e-05|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/contextlib.py:299 helper
(call)|         2|  2.55108e-05|  1.27554e-05|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/contextlib.py:132 __enter__
(call)|         2|  6.41346e-05|  3.20673e-05|  0.07%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/contextlib.py:141 __exit__
   142|         2|  3.05176e-05|  1.52588e-05|  0.03%|                return func(self, *args, **kwargs)
(call)|         2|    0.0101142|    0.0050571| 10.40%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/type_adapter.py:274 _init_core_attrs
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|        return wrapped
   145|         0|            0|            0|  0.00%|
   146|         0|            0|            0|  0.00%|    return wrapper
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|
   149|         0|            0|            0|  0.00%|@final
   150|         0|            0|            0|  0.00%|class TypeAdapter(Generic[T]):
   151|         0|            0|            0|  0.00%|    """Usage docs: https://docs.pydantic.dev/2.8/concepts/type_adapter/
   152|         0|            0|            0|  0.00%|
   153|         0|            0|            0|  0.00%|    Type adapters provide a flexible way to perform validation and serialization based on a Python type.
   154|         0|            0|            0|  0.00%|
   155|         0|            0|            0|  0.00%|    A `TypeAdapter` instance exposes some of the functionality from `BaseModel` instance methods
   156|         0|            0|            0|  0.00%|    for types that do not have such methods (such as dataclasses, primitive types, and more).
   157|         0|            0|            0|  0.00%|
   158|         0|            0|            0|  0.00%|    **Note:** `TypeAdapter` instances are not types, and cannot be used as type annotations for fields.
   159|         0|            0|            0|  0.00%|
   160|         0|            0|            0|  0.00%|    **Note:** By default, `TypeAdapter` does not respect the
   161|         0|            0|            0|  0.00%|    [`defer_build=True`][pydantic.config.ConfigDict.defer_build] setting in the
   162|         0|            0|            0|  0.00%|    [`model_config`][pydantic.BaseModel.model_config] or in the `TypeAdapter` constructor `config`. You need to also
   163|         0|            0|            0|  0.00%|    explicitly set [`experimental_defer_build_mode=('model', 'type_adapter')`][pydantic.config.ConfigDict.experimental_defer_build_mode] of the
   164|         0|            0|            0|  0.00%|    config to defer the model validator and serializer construction. Thus, this feature is opt-in to ensure backwards
   165|         0|            0|            0|  0.00%|    compatibility.
   166|         0|            0|            0|  0.00%|
   167|         0|            0|            0|  0.00%|    Attributes:
   168|         0|            0|            0|  0.00%|        core_schema: The core schema for the type.
   169|         0|            0|            0|  0.00%|        validator (SchemaValidator): The schema validator for the type.
   170|         0|            0|            0|  0.00%|        serializer: The schema serializer for the type.
   171|         0|            0|            0|  0.00%|    """
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|    @overload
   174|         0|            0|            0|  0.00%|    def __init__(
   175|         0|            0|            0|  0.00%|        self,
   176|         0|            0|            0|  0.00%|        type: type[T],
   177|         0|            0|            0|  0.00%|        *,
   178|         0|            0|            0|  0.00%|        config: ConfigDict | None = ...,
   179|         0|            0|            0|  0.00%|        _parent_depth: int = ...,
   180|         0|            0|            0|  0.00%|        module: str | None = ...,
   181|         0|            0|            0|  0.00%|    ) -> None: ...
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|    # This second overload is for unsupported special forms (such as Annotated, Union, etc.)
   184|         0|            0|            0|  0.00%|    # Currently there is no way to type this correctly
   185|         0|            0|            0|  0.00%|    # See https://github.com/python/typing/pull/1618
   186|         0|            0|            0|  0.00%|    @overload
   187|         0|            0|            0|  0.00%|    def __init__(
   188|         0|            0|            0|  0.00%|        self,
   189|         0|            0|            0|  0.00%|        type: Any,
   190|         0|            0|            0|  0.00%|        *,
   191|         0|            0|            0|  0.00%|        config: ConfigDict | None = ...,
   192|         0|            0|            0|  0.00%|        _parent_depth: int = ...,
   193|         0|            0|            0|  0.00%|        module: str | None = ...,
   194|         0|            0|            0|  0.00%|    ) -> None: ...
   195|         0|            0|            0|  0.00%|
   196|         2|  7.62939e-06|   3.8147e-06|  0.01%|    def __init__(
   197|         0|            0|            0|  0.00%|        self,
   198|         0|            0|            0|  0.00%|        type: Any,
   199|         0|            0|            0|  0.00%|        *,
   200|         0|            0|            0|  0.00%|        config: ConfigDict | None = None,
   201|         0|            0|            0|  0.00%|        _parent_depth: int = 2,
   202|         0|            0|            0|  0.00%|        module: str | None = None,
   203|         0|            0|            0|  0.00%|    ) -> None:
   204|         0|            0|            0|  0.00%|        """Initializes the TypeAdapter object.
   205|         0|            0|            0|  0.00%|
   206|         0|            0|            0|  0.00%|        Args:
   207|         0|            0|            0|  0.00%|            type: The type associated with the `TypeAdapter`.
   208|         0|            0|            0|  0.00%|            config: Configuration for the `TypeAdapter`, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].
   209|         0|            0|            0|  0.00%|            _parent_depth: depth at which to search the parent namespace to construct the local namespace.
   210|         0|            0|            0|  0.00%|            module: The module that passes to plugin if provided.
   211|         0|            0|            0|  0.00%|
   212|         0|            0|            0|  0.00%|        !!! note
   213|         0|            0|            0|  0.00%|            You cannot use the `config` argument when instantiating a `TypeAdapter` if the type you're using has its own
   214|         0|            0|            0|  0.00%|            config that cannot be overridden (ex: `BaseModel`, `TypedDict`, and `dataclass`). A
   215|         0|            0|            0|  0.00%|            [`type-adapter-config-unused`](../errors/usage_errors.md#type-adapter-config-unused) error will be raised in this case.
   216|         0|            0|            0|  0.00%|
   217|         0|            0|            0|  0.00%|        !!! note
   218|         0|            0|            0|  0.00%|            The `_parent_depth` argument is named with an underscore to suggest its private nature and discourage use.
   219|         0|            0|            0|  0.00%|            It may be deprecated in a minor version, so we only recommend using it if you're
   220|         0|            0|            0|  0.00%|            comfortable with potential change in behavior / support.
   221|         0|            0|            0|  0.00%|
   222|         0|            0|            0|  0.00%|        ??? tip "Compatibility with `mypy`"
   223|         0|            0|            0|  0.00%|            Depending on the type used, `mypy` might raise an error when instantiating a `TypeAdapter`. As a workaround, you can explicitly
   224|         0|            0|            0|  0.00%|            annotate your variable:
   225|         0|            0|            0|  0.00%|
   226|         0|            0|            0|  0.00%|            ```py
   227|         0|            0|            0|  0.00%|            from typing import Union
   228|         0|            0|            0|  0.00%|
   229|         0|            0|            0|  0.00%|            from pydantic import TypeAdapter
   230|         0|            0|            0|  0.00%|
   231|         0|            0|            0|  0.00%|            ta: TypeAdapter[Union[str, int]] = TypeAdapter(Union[str, int])  # type: ignore[arg-type]
   232|         0|            0|            0|  0.00%|            ```
   233|         0|            0|            0|  0.00%|
   234|         0|            0|            0|  0.00%|        Returns:
   235|         0|            0|            0|  0.00%|            A type adapter configured for the specified `type`.
   236|         0|            0|            0|  0.00%|        """
   237|         2|  2.12193e-05|  1.06096e-05|  0.02%|        if _type_has_config(type) and config is not None:
(call)|         2|   0.00151443|  0.000757217|  1.56%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/type_adapter.py:122 _type_has_config
   238|         0|            0|            0|  0.00%|            raise PydanticUserError(
   239|         0|            0|            0|  0.00%|                'Cannot use `config` when the type is a BaseModel, dataclass or TypedDict.'
   240|         0|            0|            0|  0.00%|                ' These types can have their own config and setting the config via the `config`'
   241|         0|            0|            0|  0.00%|                ' parameter to TypeAdapter will not override it, thus the `config` you passed to'
   242|         0|            0|            0|  0.00%|                ' TypeAdapter becomes meaningless, which is probably not what you want.',
   243|         0|            0|            0|  0.00%|                code='type-adapter-config-unused',
   244|         0|            0|            0|  0.00%|            )
   245|         0|            0|            0|  0.00%|
   246|         2|  5.24521e-06|   2.6226e-06|  0.01%|        self._type = type
   247|         2|  4.76837e-06|  2.38419e-06|  0.00%|        self._config = config
   248|         2|  4.29153e-06|  2.14577e-06|  0.00%|        self._parent_depth = _parent_depth
   249|         2|  4.29153e-06|  2.14577e-06|  0.00%|        if module is None:
   250|         2|  4.76837e-06|  2.38419e-06|  0.00%|            f = sys._getframe(1)
   251|         2|  1.69277e-05|  8.46386e-06|  0.02%|            self._module_name = cast(str, f.f_globals.get('__name__', ''))
(call)|         2|  8.34465e-06|  4.17233e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:2154 cast
   252|         0|            0|            0|  0.00%|        else:
   253|         0|            0|            0|  0.00%|            self._module_name = module
   254|         0|            0|            0|  0.00%|
   255|         2|  4.29153e-06|  2.14577e-06|  0.00%|        self._core_schema: CoreSchema | None = None
   256|         2|  4.29153e-06|  2.14577e-06|  0.00%|        self._validator: SchemaValidator | PluggableSchemaValidator | None = None
   257|         2|  4.52995e-06|  2.26498e-06|  0.00%|        self._serializer: SchemaSerializer | None = None
   258|         0|            0|            0|  0.00%|
   259|         2|  1.74046e-05|  8.70228e-06|  0.02%|        if not self._defer_build():
(call)|         2|  0.000124454|  6.22272e-05|  0.13%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/type_adapter.py:330 _defer_build
   260|         0|            0|            0|  0.00%|            # Immediately initialize the core schema, validator and serializer
   261|         4|  5.62668e-05|  1.40667e-05|  0.06%|            with self._with_frame_depth(1):  # +1 frame depth for this __init__
(call)|         2|  4.74453e-05|  2.37226e-05|  0.05%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/contextlib.py:299 helper
(call)|         2|  4.52995e-05|  2.26498e-05|  0.05%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/contextlib.py:132 __enter__
(call)|         2|  5.38826e-05|  2.69413e-05|  0.06%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/contextlib.py:141 __exit__
   262|         0|            0|            0|  0.00%|                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks
   263|         0|            0|            0|  0.00%|                # here as part of __init__ even though TypeAdapter itself is not using deferred building.
   264|         2|  2.71797e-05|  1.35899e-05|  0.03%|                self._init_core_attrs(rebuild_mocks=False)
(call)|         2|     0.010303|   0.00515151| 10.59%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/type_adapter.py:139 wrapped
   265|         0|            0|            0|  0.00%|
   266|         4|  1.00136e-05|   2.5034e-06|  0.01%|    @contextmanager
   267|         0|            0|            0|  0.00%|    def _with_frame_depth(self, depth: int) -> Iterator[None]:
   268|         4|  6.19888e-06|  1.54972e-06|  0.01%|        self._parent_depth += depth
   269|         4|  5.48363e-06|  1.37091e-06|  0.01%|        try:
   270|         8|  1.64509e-05|  2.05636e-06|  0.02%|            yield
   271|         0|            0|            0|  0.00%|        finally:
   272|         4|  7.62939e-06|  1.90735e-06|  0.01%|            self._parent_depth -= depth
   273|         0|            0|            0|  0.00%|
   274|         2|  8.34465e-06|  4.17233e-06|  0.01%|    @_frame_depth(1)
   275|         0|            0|            0|  0.00%|    def _init_core_attrs(self, rebuild_mocks: bool) -> None:
   276|         2|  5.24521e-06|   2.6226e-06|  0.01%|        try:
   277|         2|  2.19345e-05|  1.09673e-05|  0.02%|            self._core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')
(call)|         2|  4.12464e-05|  2.06232e-05|  0.04%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/type_adapter.py:107 _getattr_no_parents
   278|         0|            0|            0|  0.00%|            self._validator = _getattr_no_parents(self._type, '__pydantic_validator__')
   279|         0|            0|            0|  0.00%|            self._serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')
   280|         2|  5.48363e-06|  2.74181e-06|  0.01%|        except AttributeError:
   281|         2|  3.12328e-05|  1.56164e-05|  0.03%|            config_wrapper = _config.ConfigWrapper(self._config)
(call)|         2|  4.50611e-05|  2.25306e-05|  0.05%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_config.py:92 __init__
   282|         2|  3.71933e-05|  1.85966e-05|  0.04%|            core_config = config_wrapper.core_config(None)
(call)|         2|  0.000384569|  0.000192285|  0.40%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_config.py:156 core_config
   283|         0|            0|            0|  0.00%|
   284|         2|  4.86374e-05|  2.43187e-05|  0.05%|            self._core_schema = _get_schema(self._type, config_wrapper, parent_depth=self._parent_depth)
(call)|         2|   0.00890565|   0.00445282|  9.16%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/type_adapter.py:54 _get_schema
   285|         4|  3.93391e-05|  9.83477e-06|  0.04%|            self._validator = create_schema_validator(
(call)|         2|  0.000311136|  0.000155568|  0.32%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/plugin/_schema_validator.py:21 create_schema_validator
   286|         2|  7.15256e-06|  3.57628e-06|  0.01%|                schema=self._core_schema,
   287|         2|  5.24521e-06|   2.6226e-06|  0.01%|                schema_type=self._type,
   288|         2|  5.00679e-06|   2.5034e-06|  0.01%|                schema_type_module=self._module_name,
   289|         2|  2.36034e-05|  1.18017e-05|  0.02%|                schema_type_name=str(self._type),
(call)|         2|  0.000119209|  5.96046e-05|  0.12%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:2005 __repr__
   290|         2|  5.48363e-06|  2.74181e-06|  0.01%|                schema_kind='TypeAdapter',
   291|         2|  5.00679e-06|   2.5034e-06|  0.01%|                config=core_config,
   292|         2|  1.90735e-05|  9.53674e-06|  0.02%|                plugin_settings=config_wrapper.plugin_settings,
(call)|         2|  2.12193e-05|  1.06096e-05|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_config.py:147 __getattr__
   293|         0|            0|            0|  0.00%|            )
   294|         2|  1.16825e-05|  5.84126e-06|  0.01%|            self._serializer = SchemaSerializer(self._core_schema, core_config)
   295|         0|            0|            0|  0.00%|
   296|         2|   6.4373e-06|  3.21865e-06|  0.01%|        if rebuild_mocks and isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):
   297|         0|            0|            0|  0.00%|            self._core_schema.rebuild()
   298|         0|            0|            0|  0.00%|            self._init_core_attrs(rebuild_mocks=False)
   299|         0|            0|            0|  0.00%|            assert not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)
   300|         0|            0|            0|  0.00%|            assert not isinstance(self._validator, _mock_val_ser.MockValSer)
   301|         0|            0|            0|  0.00%|            assert not isinstance(self._serializer, _mock_val_ser.MockValSer)
   302|         0|            0|            0|  0.00%|
   303|         0|            0|            0|  0.00%|    @cached_property
   304|         0|            0|            0|  0.00%|    @_frame_depth(2)  # +2 for @cached_property and core_schema(self)
   305|         0|            0|            0|  0.00%|    def core_schema(self) -> CoreSchema:
   306|         0|            0|            0|  0.00%|        """The pydantic-core schema used to build the SchemaValidator and SchemaSerializer."""
   307|         0|            0|            0|  0.00%|        if self._core_schema is None or isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):
   308|         0|            0|            0|  0.00%|            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockCoreSchema from public function
   309|         0|            0|            0|  0.00%|        assert self._core_schema is not None and not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)
   310|         0|            0|            0|  0.00%|        return self._core_schema
   311|         0|            0|            0|  0.00%|
   312|         0|            0|            0|  0.00%|    @cached_property
   313|         0|            0|            0|  0.00%|    @_frame_depth(2)  # +2 for @cached_property + validator(self)
   314|         0|            0|            0|  0.00%|    def validator(self) -> SchemaValidator | PluggableSchemaValidator:
   315|         0|            0|            0|  0.00%|        """The pydantic-core SchemaValidator used to validate instances of the model."""
   316|         0|            0|            0|  0.00%|        if not isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator)):
   317|         0|            0|            0|  0.00%|            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function
   318|         0|            0|            0|  0.00%|        assert isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator))
   319|         0|            0|            0|  0.00%|        return self._validator
   320|         0|            0|            0|  0.00%|
   321|         0|            0|            0|  0.00%|    @cached_property
   322|         0|            0|            0|  0.00%|    @_frame_depth(2)  # +2 for @cached_property + serializer(self)
   323|         0|            0|            0|  0.00%|    def serializer(self) -> SchemaSerializer:
   324|         0|            0|            0|  0.00%|        """The pydantic-core SchemaSerializer used to dump instances of the model."""
   325|         0|            0|            0|  0.00%|        if not isinstance(self._serializer, SchemaSerializer):
   326|         0|            0|            0|  0.00%|            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function
   327|         0|            0|            0|  0.00%|        assert isinstance(self._serializer, SchemaSerializer)
   328|         0|            0|            0|  0.00%|        return self._serializer
   329|         0|            0|            0|  0.00%|
   330|         2|  4.76837e-06|  2.38419e-06|  0.00%|    def _defer_build(self) -> bool:
   331|         4|  1.62125e-05|  4.05312e-06|  0.02%|        config = self._config if self._config is not None else self._model_config()
(call)|         2|  0.000101089|  5.05447e-05|  0.10%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/type_adapter.py:334 _model_config
   332|         2|  2.38419e-06|  1.19209e-06|  0.00%|        return self._is_defer_build_config(config) if config is not None else False
   333|         0|            0|            0|  0.00%|
   334|         2|   3.8147e-06|  1.90735e-06|  0.00%|    def _model_config(self) -> ConfigDict | None:
   335|         2|  1.07288e-05|  5.36442e-06|  0.01%|        type_: Any = _typing_extra.annotated_type(self._type) or self._type  # Eg FastAPI heavily uses Annotated
(call)|         2|  4.95911e-05|  2.47955e-05|  0.05%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_typing_extra.py:115 annotated_type
   336|         2|  1.12057e-05|  5.60284e-06|  0.01%|        if _utils.lenient_issubclass(type_, BaseModel):
(call)|         2|  2.16961e-05|   1.0848e-05|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_utils.py:75 lenient_issubclass
   337|         0|            0|            0|  0.00%|            return type_.model_config
   338|         2|  4.05312e-06|  2.02656e-06|  0.00%|        return getattr(type_, '__pydantic_config__', None)
   339|         0|            0|            0|  0.00%|
   340|         0|            0|            0|  0.00%|    @staticmethod
   341|         0|            0|            0|  0.00%|    def _is_defer_build_config(config: ConfigDict) -> bool:
   342|         0|            0|            0|  0.00%|        # TODO reevaluate this logic when we have a better understanding of how defer_build should work with TypeAdapter
   343|         0|            0|            0|  0.00%|        # Should we drop the special experimental_defer_build_mode check?
   344|         0|            0|            0|  0.00%|        return config.get('defer_build', False) is True and 'type_adapter' in config.get(
   345|         0|            0|            0|  0.00%|            'experimental_defer_build_mode', tuple()
   346|         0|            0|            0|  0.00%|        )
   347|         0|            0|            0|  0.00%|
   348|         0|            0|            0|  0.00%|    @_frame_depth(1)
   349|         0|            0|            0|  0.00%|    def validate_python(
   350|         0|            0|            0|  0.00%|        self,
   351|         0|            0|            0|  0.00%|        object: Any,
   352|         0|            0|            0|  0.00%|        /,
   353|         0|            0|            0|  0.00%|        *,
   354|         0|            0|            0|  0.00%|        strict: bool | None = None,
   355|         0|            0|            0|  0.00%|        from_attributes: bool | None = None,
   356|         0|            0|            0|  0.00%|        context: dict[str, Any] | None = None,
   357|         0|            0|            0|  0.00%|    ) -> T:
   358|         0|            0|            0|  0.00%|        """Validate a Python object against the model.
   359|         0|            0|            0|  0.00%|
   360|         0|            0|            0|  0.00%|        Args:
   361|         0|            0|            0|  0.00%|            object: The Python object to validate against the model.
   362|         0|            0|            0|  0.00%|            strict: Whether to strictly check types.
   363|         0|            0|            0|  0.00%|            from_attributes: Whether to extract data from object attributes.
   364|         0|            0|            0|  0.00%|            context: Additional context to pass to the validator.
   365|         0|            0|            0|  0.00%|
   366|         0|            0|            0|  0.00%|        !!! note
   367|         0|            0|            0|  0.00%|            When using `TypeAdapter` with a Pydantic `dataclass`, the use of the `from_attributes`
   368|         0|            0|            0|  0.00%|            argument is not supported.
   369|         0|            0|            0|  0.00%|
   370|         0|            0|            0|  0.00%|        Returns:
   371|         0|            0|            0|  0.00%|            The validated object.
   372|         0|            0|            0|  0.00%|        """
   373|         0|            0|            0|  0.00%|        return self.validator.validate_python(object, strict=strict, from_attributes=from_attributes, context=context)
   374|         0|            0|            0|  0.00%|
   375|         0|            0|            0|  0.00%|    @_frame_depth(1)
   376|         0|            0|            0|  0.00%|    def validate_json(
   377|         0|            0|            0|  0.00%|        self, data: str | bytes, /, *, strict: bool | None = None, context: dict[str, Any] | None = None
   378|         0|            0|            0|  0.00%|    ) -> T:
   379|         0|            0|            0|  0.00%|        """Usage docs: https://docs.pydantic.dev/2.8/concepts/json/#json-parsing
   380|         0|            0|            0|  0.00%|
   381|         0|            0|            0|  0.00%|        Validate a JSON string or bytes against the model.
   382|         0|            0|            0|  0.00%|
   383|         0|            0|            0|  0.00%|        Args:
   384|         0|            0|            0|  0.00%|            data: The JSON data to validate against the model.
   385|         0|            0|            0|  0.00%|            strict: Whether to strictly check types.
   386|         0|            0|            0|  0.00%|            context: Additional context to use during validation.
   387|         0|            0|            0|  0.00%|
   388|         0|            0|            0|  0.00%|        Returns:
   389|         0|            0|            0|  0.00%|            The validated object.
   390|         0|            0|            0|  0.00%|        """
   391|         0|            0|            0|  0.00%|        return self.validator.validate_json(data, strict=strict, context=context)
   392|         0|            0|            0|  0.00%|
   393|         0|            0|            0|  0.00%|    @_frame_depth(1)
   394|         0|            0|            0|  0.00%|    def validate_strings(self, obj: Any, /, *, strict: bool | None = None, context: dict[str, Any] | None = None) -> T:
   395|         0|            0|            0|  0.00%|        """Validate object contains string data against the model.
   396|         0|            0|            0|  0.00%|
   397|         0|            0|            0|  0.00%|        Args:
   398|         0|            0|            0|  0.00%|            obj: The object contains string data to validate.
   399|         0|            0|            0|  0.00%|            strict: Whether to strictly check types.
   400|         0|            0|            0|  0.00%|            context: Additional context to use during validation.
   401|         0|            0|            0|  0.00%|
   402|         0|            0|            0|  0.00%|        Returns:
   403|         0|            0|            0|  0.00%|            The validated object.
   404|         0|            0|            0|  0.00%|        """
   405|         0|            0|            0|  0.00%|        return self.validator.validate_strings(obj, strict=strict, context=context)
   406|         0|            0|            0|  0.00%|
   407|         0|            0|            0|  0.00%|    @_frame_depth(1)
   408|         0|            0|            0|  0.00%|    def get_default_value(self, *, strict: bool | None = None, context: dict[str, Any] | None = None) -> Some[T] | None:
   409|         0|            0|            0|  0.00%|        """Get the default value for the wrapped type.
   410|         0|            0|            0|  0.00%|
   411|         0|            0|            0|  0.00%|        Args:
   412|         0|            0|            0|  0.00%|            strict: Whether to strictly check types.
   413|         0|            0|            0|  0.00%|            context: Additional context to pass to the validator.
   414|         0|            0|            0|  0.00%|
   415|         0|            0|            0|  0.00%|        Returns:
   416|         0|            0|            0|  0.00%|            The default value wrapped in a `Some` if there is one or None if not.
   417|         0|            0|            0|  0.00%|        """
   418|         0|            0|            0|  0.00%|        return self.validator.get_default_value(strict=strict, context=context)
   419|         0|            0|            0|  0.00%|
   420|         0|            0|            0|  0.00%|    @_frame_depth(1)
   421|         0|            0|            0|  0.00%|    def dump_python(
   422|         0|            0|            0|  0.00%|        self,
   423|         0|            0|            0|  0.00%|        instance: T,
   424|         0|            0|            0|  0.00%|        /,
   425|         0|            0|            0|  0.00%|        *,
   426|         0|            0|            0|  0.00%|        mode: Literal['json', 'python'] = 'python',
   427|         0|            0|            0|  0.00%|        include: IncEx | None = None,
   428|         0|            0|            0|  0.00%|        exclude: IncEx | None = None,
   429|         0|            0|            0|  0.00%|        by_alias: bool = False,
   430|         0|            0|            0|  0.00%|        exclude_unset: bool = False,
   431|         0|            0|            0|  0.00%|        exclude_defaults: bool = False,
   432|         0|            0|            0|  0.00%|        exclude_none: bool = False,
   433|         0|            0|            0|  0.00%|        round_trip: bool = False,
   434|         0|            0|            0|  0.00%|        warnings: bool | Literal['none', 'warn', 'error'] = True,
   435|         0|            0|            0|  0.00%|        serialize_as_any: bool = False,
   436|         0|            0|            0|  0.00%|        context: dict[str, Any] | None = None,
   437|         0|            0|            0|  0.00%|    ) -> Any:
   438|         0|            0|            0|  0.00%|        """Dump an instance of the adapted type to a Python object.
   439|         0|            0|            0|  0.00%|
   440|         0|            0|            0|  0.00%|        Args:
   441|         0|            0|            0|  0.00%|            instance: The Python object to serialize.
   442|         0|            0|            0|  0.00%|            mode: The output format.
   443|         0|            0|            0|  0.00%|            include: Fields to include in the output.
   444|         0|            0|            0|  0.00%|            exclude: Fields to exclude from the output.
   445|         0|            0|            0|  0.00%|            by_alias: Whether to use alias names for field names.
   446|         0|            0|            0|  0.00%|            exclude_unset: Whether to exclude unset fields.
   447|         0|            0|            0|  0.00%|            exclude_defaults: Whether to exclude fields with default values.
   448|         0|            0|            0|  0.00%|            exclude_none: Whether to exclude fields with None values.
   449|         0|            0|            0|  0.00%|            round_trip: Whether to output the serialized data in a way that is compatible with deserialization.
   450|         0|            0|            0|  0.00%|            warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
   451|         0|            0|            0|  0.00%|                "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
   452|         0|            0|            0|  0.00%|            serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
   453|         0|            0|            0|  0.00%|            context: Additional context to pass to the serializer.
   454|         0|            0|            0|  0.00%|
   455|         0|            0|            0|  0.00%|        Returns:
   456|         0|            0|            0|  0.00%|            The serialized object.
   457|         0|            0|            0|  0.00%|        """
   458|         0|            0|            0|  0.00%|        return self.serializer.to_python(
   459|         0|            0|            0|  0.00%|            instance,
   460|         0|            0|            0|  0.00%|            mode=mode,
   461|         0|            0|            0|  0.00%|            by_alias=by_alias,
   462|         0|            0|            0|  0.00%|            include=include,
   463|         0|            0|            0|  0.00%|            exclude=exclude,
   464|         0|            0|            0|  0.00%|            exclude_unset=exclude_unset,
   465|         0|            0|            0|  0.00%|            exclude_defaults=exclude_defaults,
   466|         0|            0|            0|  0.00%|            exclude_none=exclude_none,
   467|         0|            0|            0|  0.00%|            round_trip=round_trip,
   468|         0|            0|            0|  0.00%|            warnings=warnings,
   469|         0|            0|            0|  0.00%|            serialize_as_any=serialize_as_any,
   470|         0|            0|            0|  0.00%|            context=context,
   471|         0|            0|            0|  0.00%|        )
   472|         0|            0|            0|  0.00%|
   473|         0|            0|            0|  0.00%|    @_frame_depth(1)
   474|         0|            0|            0|  0.00%|    def dump_json(
   475|         0|            0|            0|  0.00%|        self,
   476|         0|            0|            0|  0.00%|        instance: T,
   477|         0|            0|            0|  0.00%|        /,
   478|         0|            0|            0|  0.00%|        *,
   479|         0|            0|            0|  0.00%|        indent: int | None = None,
   480|         0|            0|            0|  0.00%|        include: IncEx | None = None,
   481|         0|            0|            0|  0.00%|        exclude: IncEx | None = None,
   482|         0|            0|            0|  0.00%|        by_alias: bool = False,
   483|         0|            0|            0|  0.00%|        exclude_unset: bool = False,
   484|         0|            0|            0|  0.00%|        exclude_defaults: bool = False,
   485|         0|            0|            0|  0.00%|        exclude_none: bool = False,
   486|         0|            0|            0|  0.00%|        round_trip: bool = False,
   487|         0|            0|            0|  0.00%|        warnings: bool | Literal['none', 'warn', 'error'] = True,
   488|         0|            0|            0|  0.00%|        serialize_as_any: bool = False,
   489|         0|            0|            0|  0.00%|        context: dict[str, Any] | None = None,
   490|         0|            0|            0|  0.00%|    ) -> bytes:
   491|         0|            0|            0|  0.00%|        """Usage docs: https://docs.pydantic.dev/2.8/concepts/json/#json-serialization
   492|         0|            0|            0|  0.00%|
   493|         0|            0|            0|  0.00%|        Serialize an instance of the adapted type to JSON.
   494|         0|            0|            0|  0.00%|
   495|         0|            0|            0|  0.00%|        Args:
   496|         0|            0|            0|  0.00%|            instance: The instance to be serialized.
   497|         0|            0|            0|  0.00%|            indent: Number of spaces for JSON indentation.
   498|         0|            0|            0|  0.00%|            include: Fields to include.
   499|         0|            0|            0|  0.00%|            exclude: Fields to exclude.
   500|         0|            0|            0|  0.00%|            by_alias: Whether to use alias names for field names.
   501|         0|            0|            0|  0.00%|            exclude_unset: Whether to exclude unset fields.
   502|         0|            0|            0|  0.00%|            exclude_defaults: Whether to exclude fields with default values.
   503|         0|            0|            0|  0.00%|            exclude_none: Whether to exclude fields with a value of `None`.
   504|         0|            0|            0|  0.00%|            round_trip: Whether to serialize and deserialize the instance to ensure round-tripping.
   505|         0|            0|            0|  0.00%|            warnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,
   506|         0|            0|            0|  0.00%|                "error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].
   507|         0|            0|            0|  0.00%|            serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.
   508|         0|            0|            0|  0.00%|            context: Additional context to pass to the serializer.
   509|         0|            0|            0|  0.00%|
   510|         0|            0|            0|  0.00%|        Returns:
   511|         0|            0|            0|  0.00%|            The JSON representation of the given instance as bytes.
   512|         0|            0|            0|  0.00%|        """
   513|         0|            0|            0|  0.00%|        return self.serializer.to_json(
   514|         0|            0|            0|  0.00%|            instance,
   515|         0|            0|            0|  0.00%|            indent=indent,
   516|         0|            0|            0|  0.00%|            include=include,
   517|         0|            0|            0|  0.00%|            exclude=exclude,
   518|         0|            0|            0|  0.00%|            by_alias=by_alias,
   519|         0|            0|            0|  0.00%|            exclude_unset=exclude_unset,
   520|         0|            0|            0|  0.00%|            exclude_defaults=exclude_defaults,
   521|         0|            0|            0|  0.00%|            exclude_none=exclude_none,
   522|         0|            0|            0|  0.00%|            round_trip=round_trip,
   523|         0|            0|            0|  0.00%|            warnings=warnings,
   524|         0|            0|            0|  0.00%|            serialize_as_any=serialize_as_any,
   525|         0|            0|            0|  0.00%|            context=context,
   526|         0|            0|            0|  0.00%|        )
   527|         0|            0|            0|  0.00%|
   528|         0|            0|            0|  0.00%|    @_frame_depth(1)
   529|         0|            0|            0|  0.00%|    def json_schema(
   530|         0|            0|            0|  0.00%|        self,
   531|         0|            0|            0|  0.00%|        *,
   532|         0|            0|            0|  0.00%|        by_alias: bool = True,
   533|         0|            0|            0|  0.00%|        ref_template: str = DEFAULT_REF_TEMPLATE,
   534|         0|            0|            0|  0.00%|        schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,
   535|         0|            0|            0|  0.00%|        mode: JsonSchemaMode = 'validation',
   536|         0|            0|            0|  0.00%|    ) -> dict[str, Any]:
   537|         0|            0|            0|  0.00%|        """Generate a JSON schema for the adapted type.
   538|         0|            0|            0|  0.00%|
   539|         0|            0|            0|  0.00%|        Args:
   540|         0|            0|            0|  0.00%|            by_alias: Whether to use alias names for field names.
   541|         0|            0|            0|  0.00%|            ref_template: The format string used for generating $ref strings.
   542|         0|            0|            0|  0.00%|            schema_generator: The generator class used for creating the schema.
   543|         0|            0|            0|  0.00%|            mode: The mode to use for schema generation.
   544|         0|            0|            0|  0.00%|
   545|         0|            0|            0|  0.00%|        Returns:
   546|         0|            0|            0|  0.00%|            The JSON schema for the model as a dictionary.
   547|         0|            0|            0|  0.00%|        """
   548|         0|            0|            0|  0.00%|        schema_generator_instance = schema_generator(by_alias=by_alias, ref_template=ref_template)
   549|         0|            0|            0|  0.00%|        return schema_generator_instance.generate(self.core_schema, mode=mode)
   550|         0|            0|            0|  0.00%|
   551|         0|            0|            0|  0.00%|    @staticmethod
   552|         0|            0|            0|  0.00%|    def json_schemas(
   553|         0|            0|            0|  0.00%|        inputs: Iterable[tuple[JsonSchemaKeyT, JsonSchemaMode, TypeAdapter[Any]]],
   554|         0|            0|            0|  0.00%|        /,
   555|         0|            0|            0|  0.00%|        *,
   556|         0|            0|            0|  0.00%|        by_alias: bool = True,
   557|         0|            0|            0|  0.00%|        title: str | None = None,
   558|         0|            0|            0|  0.00%|        description: str | None = None,
   559|         0|            0|            0|  0.00%|        ref_template: str = DEFAULT_REF_TEMPLATE,
   560|         0|            0|            0|  0.00%|        schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,
   561|         0|            0|            0|  0.00%|    ) -> tuple[dict[tuple[JsonSchemaKeyT, JsonSchemaMode], JsonSchemaValue], JsonSchemaValue]:
   562|         0|            0|            0|  0.00%|        """Generate a JSON schema including definitions from multiple type adapters.
   563|         0|            0|            0|  0.00%|
   564|         0|            0|            0|  0.00%|        Args:
   565|         0|            0|            0|  0.00%|            inputs: Inputs to schema generation. The first two items will form the keys of the (first)
   566|         0|            0|            0|  0.00%|                output mapping; the type adapters will provide the core schemas that get converted into
   567|         0|            0|            0|  0.00%|                definitions in the output JSON schema.
   568|         0|            0|            0|  0.00%|            by_alias: Whether to use alias names.
   569|         0|            0|            0|  0.00%|            title: The title for the schema.
   570|         0|            0|            0|  0.00%|            description: The description for the schema.
   571|         0|            0|            0|  0.00%|            ref_template: The format string used for generating $ref strings.
   572|         0|            0|            0|  0.00%|            schema_generator: The generator class used for creating the schema.
   573|         0|            0|            0|  0.00%|
   574|         0|            0|            0|  0.00%|        Returns:
   575|         0|            0|            0|  0.00%|            A tuple where:
   576|         0|            0|            0|  0.00%|
   577|         0|            0|            0|  0.00%|                - The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and
   578|         0|            0|            0|  0.00%|                    whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have
   579|         0|            0|            0|  0.00%|                    JsonRef references to definitions that are defined in the second returned element.)
   580|         0|            0|            0|  0.00%|                - The second element is a JSON schema containing all definitions referenced in the first returned
   581|         0|            0|            0|  0.00%|                    element, along with the optional title and description keys.
   582|         0|            0|            0|  0.00%|
   583|         0|            0|            0|  0.00%|        """
   584|         0|            0|            0|  0.00%|        schema_generator_instance = schema_generator(by_alias=by_alias, ref_template=ref_template)
   585|         0|            0|            0|  0.00%|
   586|         0|            0|            0|  0.00%|        inputs_ = []
   587|         0|            0|            0|  0.00%|        for key, mode, adapter in inputs:
   588|         0|            0|            0|  0.00%|            with adapter._with_frame_depth(1):  # +1 for json_schemas staticmethod
   589|         0|            0|            0|  0.00%|                inputs_.append((key, mode, adapter.core_schema))
   590|         0|            0|            0|  0.00%|
   591|         0|            0|            0|  0.00%|        json_schemas_map, definitions = schema_generator_instance.generate_definitions(inputs_)
   592|         0|            0|            0|  0.00%|
   593|         0|            0|            0|  0.00%|        json_schema: dict[str, Any] = {}
   594|         0|            0|            0|  0.00%|        if definitions:
   595|         0|            0|            0|  0.00%|            json_schema['$defs'] = definitions
   596|         0|            0|            0|  0.00%|        if title:
   597|         0|            0|            0|  0.00%|            json_schema['title'] = title
   598|         0|            0|            0|  0.00%|        if description:
   599|         0|            0|            0|  0.00%|            json_schema['description'] = description
   600|         0|            0|            0|  0.00%|
   601|         0|            0|            0|  0.00%|        return json_schemas_map, json_schema
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/fields.py
File duration: 0.000830412s (0.85%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Defining fields on models."""
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|from __future__ import annotations as _annotations
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|import dataclasses
     6|         0|            0|            0|  0.00%|import inspect
     7|         0|            0|            0|  0.00%|import sys
     8|         0|            0|            0|  0.00%|import typing
     9|         0|            0|            0|  0.00%|from copy import copy
    10|         0|            0|            0|  0.00%|from dataclasses import Field as DataclassField
    11|         0|            0|            0|  0.00%|from functools import cached_property
    12|         0|            0|            0|  0.00%|from typing import Any, ClassVar
    13|         0|            0|            0|  0.00%|from warnings import warn
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|import annotated_types
    16|         0|            0|            0|  0.00%|import typing_extensions
    17|         0|            0|            0|  0.00%|from pydantic_core import PydanticUndefined
    18|         0|            0|            0|  0.00%|from typing_extensions import Literal, TypeAlias, Unpack, deprecated
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|from . import types
    21|         0|            0|            0|  0.00%|from ._internal import _decorators, _fields, _generics, _internal_dataclass, _repr, _typing_extra, _utils
    22|         0|            0|            0|  0.00%|from .aliases import AliasChoices, AliasPath
    23|         0|            0|            0|  0.00%|from .config import JsonDict
    24|         0|            0|            0|  0.00%|from .errors import PydanticUserError
    25|         0|            0|            0|  0.00%|from .warnings import PydanticDeprecatedSince20
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|if typing.TYPE_CHECKING:
    28|         0|            0|            0|  0.00%|    from ._internal._repr import ReprArgs
    29|         0|            0|            0|  0.00%|else:
    30|         0|            0|            0|  0.00%|    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915
    31|         0|            0|            0|  0.00%|    # and https://youtrack.jetbrains.com/issue/PY-51428
    32|         0|            0|            0|  0.00%|    DeprecationWarning = PydanticDeprecatedSince20
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|__all__ = 'Field', 'PrivateAttr', 'computed_field'
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|_Unset: Any = PydanticUndefined
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|if sys.version_info >= (3, 13):
    40|         0|            0|            0|  0.00%|    import warnings
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|    Deprecated: TypeAlias = warnings.deprecated | deprecated
    43|         0|            0|            0|  0.00%|else:
    44|         0|            0|            0|  0.00%|    Deprecated: TypeAlias = deprecated
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|class _FromFieldInfoInputs(typing_extensions.TypedDict, total=False):
    48|         0|            0|            0|  0.00%|    """This class exists solely to add type checking for the `**kwargs` in `FieldInfo.from_field`."""
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|    annotation: type[Any] | None
    51|         0|            0|            0|  0.00%|    default_factory: typing.Callable[[], Any] | None
    52|         0|            0|            0|  0.00%|    alias: str | None
    53|         0|            0|            0|  0.00%|    alias_priority: int | None
    54|         0|            0|            0|  0.00%|    validation_alias: str | AliasPath | AliasChoices | None
    55|         0|            0|            0|  0.00%|    serialization_alias: str | None
    56|         0|            0|            0|  0.00%|    title: str | None
    57|         0|            0|            0|  0.00%|    field_title_generator: typing_extensions.Callable[[str, FieldInfo], str] | None
    58|         0|            0|            0|  0.00%|    description: str | None
    59|         0|            0|            0|  0.00%|    examples: list[Any] | None
    60|         0|            0|            0|  0.00%|    exclude: bool | None
    61|         0|            0|            0|  0.00%|    gt: annotated_types.SupportsGt | None
    62|         0|            0|            0|  0.00%|    ge: annotated_types.SupportsGe | None
    63|         0|            0|            0|  0.00%|    lt: annotated_types.SupportsLt | None
    64|         0|            0|            0|  0.00%|    le: annotated_types.SupportsLe | None
    65|         0|            0|            0|  0.00%|    multiple_of: float | None
    66|         0|            0|            0|  0.00%|    strict: bool | None
    67|         0|            0|            0|  0.00%|    min_length: int | None
    68|         0|            0|            0|  0.00%|    max_length: int | None
    69|         0|            0|            0|  0.00%|    pattern: str | typing.Pattern[str] | None
    70|         0|            0|            0|  0.00%|    allow_inf_nan: bool | None
    71|         0|            0|            0|  0.00%|    max_digits: int | None
    72|         0|            0|            0|  0.00%|    decimal_places: int | None
    73|         0|            0|            0|  0.00%|    union_mode: Literal['smart', 'left_to_right'] | None
    74|         0|            0|            0|  0.00%|    discriminator: str | types.Discriminator | None
    75|         0|            0|            0|  0.00%|    deprecated: Deprecated | str | bool | None
    76|         0|            0|            0|  0.00%|    json_schema_extra: JsonDict | typing.Callable[[JsonDict], None] | None
    77|         0|            0|            0|  0.00%|    frozen: bool | None
    78|         0|            0|            0|  0.00%|    validate_default: bool | None
    79|         0|            0|            0|  0.00%|    repr: bool
    80|         0|            0|            0|  0.00%|    init: bool | None
    81|         0|            0|            0|  0.00%|    init_var: bool | None
    82|         0|            0|            0|  0.00%|    kw_only: bool | None
    83|         0|            0|            0|  0.00%|    coerce_numbers_to_str: bool | None
    84|         0|            0|            0|  0.00%|    fail_fast: bool | None
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|
    87|         0|            0|            0|  0.00%|class _FieldInfoInputs(_FromFieldInfoInputs, total=False):
    88|         0|            0|            0|  0.00%|    """This class exists solely to add type checking for the `**kwargs` in `FieldInfo.__init__`."""
    89|         0|            0|            0|  0.00%|
    90|         0|            0|            0|  0.00%|    default: Any
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|class FieldInfo(_repr.Representation):
    94|         0|            0|            0|  0.00%|    """This class holds information about a field.
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|    `FieldInfo` is used for any field definition regardless of whether the [`Field()`][pydantic.fields.Field]
    97|         0|            0|            0|  0.00%|    function is explicitly used.
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|    !!! warning
   100|         0|            0|            0|  0.00%|        You generally shouldn't be creating `FieldInfo` directly, you'll only need to use it when accessing
   101|         0|            0|            0|  0.00%|        [`BaseModel`][pydantic.main.BaseModel] `.model_fields` internals.
   102|         0|            0|            0|  0.00%|
   103|         0|            0|            0|  0.00%|    Attributes:
   104|         0|            0|            0|  0.00%|        annotation: The type annotation of the field.
   105|         0|            0|            0|  0.00%|        default: The default value of the field.
   106|         0|            0|            0|  0.00%|        default_factory: The factory function used to construct the default for the field.
   107|         0|            0|            0|  0.00%|        alias: The alias name of the field.
   108|         0|            0|            0|  0.00%|        alias_priority: The priority of the field's alias.
   109|         0|            0|            0|  0.00%|        validation_alias: The validation alias of the field.
   110|         0|            0|            0|  0.00%|        serialization_alias: The serialization alias of the field.
   111|         0|            0|            0|  0.00%|        title: The title of the field.
   112|         0|            0|            0|  0.00%|        field_title_generator: A callable that takes a field name and returns title for it.
   113|         0|            0|            0|  0.00%|        description: The description of the field.
   114|         0|            0|            0|  0.00%|        examples: List of examples of the field.
   115|         0|            0|            0|  0.00%|        exclude: Whether to exclude the field from the model serialization.
   116|         0|            0|            0|  0.00%|        discriminator: Field name or Discriminator for discriminating the type in a tagged union.
   117|         0|            0|            0|  0.00%|        deprecated: A deprecation message, an instance of `warnings.deprecated` or the `typing_extensions.deprecated` backport,
   118|         0|            0|            0|  0.00%|            or a boolean. If `True`, a default deprecation message will be emitted when accessing the field.
   119|         0|            0|            0|  0.00%|        json_schema_extra: A dict or callable to provide extra JSON schema properties.
   120|         0|            0|            0|  0.00%|        frozen: Whether the field is frozen.
   121|         0|            0|            0|  0.00%|        validate_default: Whether to validate the default value of the field.
   122|         0|            0|            0|  0.00%|        repr: Whether to include the field in representation of the model.
   123|         0|            0|            0|  0.00%|        init: Whether the field should be included in the constructor of the dataclass.
   124|         0|            0|            0|  0.00%|        init_var: Whether the field should _only_ be included in the constructor of the dataclass, and not stored.
   125|         0|            0|            0|  0.00%|        kw_only: Whether the field should be a keyword-only argument in the constructor of the dataclass.
   126|         0|            0|            0|  0.00%|        metadata: List of metadata constraints.
   127|         0|            0|            0|  0.00%|    """
   128|         0|            0|            0|  0.00%|
   129|         0|            0|            0|  0.00%|    annotation: type[Any] | None
   130|         0|            0|            0|  0.00%|    default: Any
   131|         0|            0|            0|  0.00%|    default_factory: typing.Callable[[], Any] | None
   132|         0|            0|            0|  0.00%|    alias: str | None
   133|         0|            0|            0|  0.00%|    alias_priority: int | None
   134|         0|            0|            0|  0.00%|    validation_alias: str | AliasPath | AliasChoices | None
   135|         0|            0|            0|  0.00%|    serialization_alias: str | None
   136|         0|            0|            0|  0.00%|    title: str | None
   137|         0|            0|            0|  0.00%|    field_title_generator: typing.Callable[[str, FieldInfo], str] | None
   138|         0|            0|            0|  0.00%|    description: str | None
   139|         0|            0|            0|  0.00%|    examples: list[Any] | None
   140|         0|            0|            0|  0.00%|    exclude: bool | None
   141|         0|            0|            0|  0.00%|    discriminator: str | types.Discriminator | None
   142|         0|            0|            0|  0.00%|    deprecated: Deprecated | str | bool | None
   143|         0|            0|            0|  0.00%|    json_schema_extra: JsonDict | typing.Callable[[JsonDict], None] | None
   144|         0|            0|            0|  0.00%|    frozen: bool | None
   145|         0|            0|            0|  0.00%|    validate_default: bool | None
   146|         0|            0|            0|  0.00%|    repr: bool
   147|         0|            0|            0|  0.00%|    init: bool | None
   148|         0|            0|            0|  0.00%|    init_var: bool | None
   149|         0|            0|            0|  0.00%|    kw_only: bool | None
   150|         0|            0|            0|  0.00%|    metadata: list[Any]
   151|         0|            0|            0|  0.00%|
   152|         0|            0|            0|  0.00%|    __slots__ = (
   153|         0|            0|            0|  0.00%|        'annotation',
   154|         0|            0|            0|  0.00%|        'default',
   155|         0|            0|            0|  0.00%|        'default_factory',
   156|         0|            0|            0|  0.00%|        'alias',
   157|         0|            0|            0|  0.00%|        'alias_priority',
   158|         0|            0|            0|  0.00%|        'validation_alias',
   159|         0|            0|            0|  0.00%|        'serialization_alias',
   160|         0|            0|            0|  0.00%|        'title',
   161|         0|            0|            0|  0.00%|        'field_title_generator',
   162|         0|            0|            0|  0.00%|        'description',
   163|         0|            0|            0|  0.00%|        'examples',
   164|         0|            0|            0|  0.00%|        'exclude',
   165|         0|            0|            0|  0.00%|        'discriminator',
   166|         0|            0|            0|  0.00%|        'deprecated',
   167|         0|            0|            0|  0.00%|        'json_schema_extra',
   168|         0|            0|            0|  0.00%|        'frozen',
   169|         0|            0|            0|  0.00%|        'validate_default',
   170|         0|            0|            0|  0.00%|        'repr',
   171|         0|            0|            0|  0.00%|        'init',
   172|         0|            0|            0|  0.00%|        'init_var',
   173|         0|            0|            0|  0.00%|        'kw_only',
   174|         0|            0|            0|  0.00%|        'metadata',
   175|         0|            0|            0|  0.00%|        '_attributes_set',
   176|         0|            0|            0|  0.00%|    )
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|    # used to convert kwargs to metadata/constraints,
   179|         0|            0|            0|  0.00%|    # None has a special meaning - these items are collected into a `PydanticGeneralMetadata`
   180|         0|            0|            0|  0.00%|    metadata_lookup: ClassVar[dict[str, typing.Callable[[Any], Any] | None]] = {
   181|         0|            0|            0|  0.00%|        'strict': types.Strict,
   182|         0|            0|            0|  0.00%|        'gt': annotated_types.Gt,
   183|         0|            0|            0|  0.00%|        'ge': annotated_types.Ge,
   184|         0|            0|            0|  0.00%|        'lt': annotated_types.Lt,
   185|         0|            0|            0|  0.00%|        'le': annotated_types.Le,
   186|         0|            0|            0|  0.00%|        'multiple_of': annotated_types.MultipleOf,
   187|         0|            0|            0|  0.00%|        'min_length': annotated_types.MinLen,
   188|         0|            0|            0|  0.00%|        'max_length': annotated_types.MaxLen,
   189|         0|            0|            0|  0.00%|        'pattern': None,
   190|         0|            0|            0|  0.00%|        'allow_inf_nan': None,
   191|         0|            0|            0|  0.00%|        'max_digits': None,
   192|         0|            0|            0|  0.00%|        'decimal_places': None,
   193|         0|            0|            0|  0.00%|        'union_mode': None,
   194|         0|            0|            0|  0.00%|        'coerce_numbers_to_str': None,
   195|         0|            0|            0|  0.00%|        'fail_fast': types.FailFast,
   196|         0|            0|            0|  0.00%|    }
   197|         0|            0|            0|  0.00%|
   198|         2|  1.66893e-05|  8.34465e-06|  0.02%|    def __init__(self, **kwargs: Unpack[_FieldInfoInputs]) -> None:
   199|         0|            0|            0|  0.00%|        """This class should generally not be initialized directly; instead, use the `pydantic.fields.Field` function
   200|         0|            0|            0|  0.00%|        or one of the constructor classmethods.
   201|         0|            0|            0|  0.00%|
   202|         0|            0|            0|  0.00%|        See the signature of `pydantic.fields.Field` for more details about the expected arguments.
   203|         0|            0|            0|  0.00%|        """
   204|        35|  0.000105381|  3.01089e-06|  0.11%|        self._attributes_set = {k: v for k, v in kwargs.items() if v is not _Unset}
   205|        35|  0.000102282|  2.92233e-06|  0.11%|        kwargs = {k: _DefaultValues.get(k) if v is _Unset else v for k, v in kwargs.items()}  # type: ignore
   206|         2|  2.69413e-05|  1.34706e-05|  0.03%|        self.annotation, annotation_metadata = self._extract_metadata(kwargs.get('annotation'))
(call)|         2|  0.000115871|  5.79357e-05|  0.12%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/fields.py:485 _extract_metadata
   207|         0|            0|            0|  0.00%|
   208|         2|  1.04904e-05|  5.24521e-06|  0.01%|        default = kwargs.pop('default', PydanticUndefined)
   209|         2|  8.10623e-06|  4.05312e-06|  0.01%|        if default is Ellipsis:
   210|         1|  5.48363e-06|  5.48363e-06|  0.01%|            self.default = PydanticUndefined
   211|         0|            0|            0|  0.00%|        else:
   212|         1|   2.6226e-06|   2.6226e-06|  0.00%|            self.default = default
   213|         0|            0|            0|  0.00%|
   214|         2|  1.14441e-05|  5.72205e-06|  0.01%|        self.default_factory = kwargs.pop('default_factory', None)
   215|         0|            0|            0|  0.00%|
   216|         2|  1.00136e-05|  5.00679e-06|  0.01%|        if self.default is not PydanticUndefined and self.default_factory is not None:
   217|         0|            0|            0|  0.00%|            raise TypeError('cannot specify both default and default_factory')
   218|         0|            0|            0|  0.00%|
   219|         2|  1.00136e-05|  5.00679e-06|  0.01%|        self.alias = kwargs.pop('alias', None)
   220|         2|  7.86781e-06|  3.93391e-06|  0.01%|        self.validation_alias = kwargs.pop('validation_alias', None)
   221|         2|  8.10623e-06|  4.05312e-06|  0.01%|        self.serialization_alias = kwargs.pop('serialization_alias', None)
   222|        18|  0.000101805|  5.65582e-06|  0.10%|        alias_is_set = any(alias is not None for alias in (self.alias, self.validation_alias, self.serialization_alias))
(call)|         8|  3.45707e-05|  4.32134e-06|  0.04%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/fields.py:222 <genexpr>
   223|         2|  8.34465e-06|  4.17233e-06|  0.01%|        self.alias_priority = kwargs.pop('alias_priority', None) or 2 if alias_is_set else None
   224|         2|  8.10623e-06|  4.05312e-06|  0.01%|        self.title = kwargs.pop('title', None)
   225|         2|  7.86781e-06|  3.93391e-06|  0.01%|        self.field_title_generator = kwargs.pop('field_title_generator', None)
   226|         2|  1.12057e-05|  5.60284e-06|  0.01%|        self.description = kwargs.pop('description', None)
   227|         2|  8.34465e-06|  4.17233e-06|  0.01%|        self.examples = kwargs.pop('examples', None)
   228|         2|  8.10623e-06|  4.05312e-06|  0.01%|        self.exclude = kwargs.pop('exclude', None)
   229|         2|  8.10623e-06|  4.05312e-06|  0.01%|        self.discriminator = kwargs.pop('discriminator', None)
   230|         0|            0|            0|  0.00%|        # For compatibility with FastAPI<=0.110.0, we preserve the existing value if it is not overridden
   231|         2|  1.40667e-05|  7.03335e-06|  0.01%|        self.deprecated = kwargs.pop('deprecated', getattr(self, 'deprecated', None))
   232|         2|  8.34465e-06|  4.17233e-06|  0.01%|        self.repr = kwargs.pop('repr', True)
   233|         2|  7.86781e-06|  3.93391e-06|  0.01%|        self.json_schema_extra = kwargs.pop('json_schema_extra', None)
   234|         2|  7.86781e-06|  3.93391e-06|  0.01%|        self.validate_default = kwargs.pop('validate_default', None)
   235|         2|  8.10623e-06|  4.05312e-06|  0.01%|        self.frozen = kwargs.pop('frozen', None)
   236|         0|            0|            0|  0.00%|        # currently only used on dataclasses
   237|         2|  7.86781e-06|  3.93391e-06|  0.01%|        self.init = kwargs.pop('init', None)
   238|         2|  7.39098e-06|  3.69549e-06|  0.01%|        self.init_var = kwargs.pop('init_var', None)
   239|         2|  8.10623e-06|  4.05312e-06|  0.01%|        self.kw_only = kwargs.pop('kw_only', None)
   240|         0|            0|            0|  0.00%|
   241|         2|  3.60012e-05|  1.80006e-05|  0.04%|        self.metadata = self._collect_metadata(kwargs) + annotation_metadata  # type: ignore
(call)|         2|  0.000164747|  8.23736e-05|  0.17%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/fields.py:502 _collect_metadata
   242|         0|            0|            0|  0.00%|
   243|         0|            0|            0|  0.00%|    @staticmethod
   244|         0|            0|            0|  0.00%|    def from_field(default: Any = PydanticUndefined, **kwargs: Unpack[_FromFieldInfoInputs]) -> FieldInfo:
   245|         0|            0|            0|  0.00%|        """Create a new `FieldInfo` object with the `Field` function.
   246|         0|            0|            0|  0.00%|
   247|         0|            0|            0|  0.00%|        Args:
   248|         0|            0|            0|  0.00%|            default: The default value for the field. Defaults to Undefined.
   249|         0|            0|            0|  0.00%|            **kwargs: Additional arguments dictionary.
   250|         0|            0|            0|  0.00%|
   251|         0|            0|            0|  0.00%|        Raises:
   252|         0|            0|            0|  0.00%|            TypeError: If 'annotation' is passed as a keyword argument.
   253|         0|            0|            0|  0.00%|
   254|         0|            0|            0|  0.00%|        Returns:
   255|         0|            0|            0|  0.00%|            A new FieldInfo object with the given parameters.
   256|         0|            0|            0|  0.00%|
   257|         0|            0|            0|  0.00%|        Example:
   258|         0|            0|            0|  0.00%|            This is how you can create a field with default value like this:
   259|         0|            0|            0|  0.00%|
   260|         0|            0|            0|  0.00%|            ```python
   261|         0|            0|            0|  0.00%|            import pydantic
   262|         0|            0|            0|  0.00%|
   263|         0|            0|            0|  0.00%|            class MyModel(pydantic.BaseModel):
   264|         0|            0|            0|  0.00%|                foo: int = pydantic.Field(4)
   265|         0|            0|            0|  0.00%|            ```
   266|         0|            0|            0|  0.00%|        """
   267|         0|            0|            0|  0.00%|        if 'annotation' in kwargs:
   268|         0|            0|            0|  0.00%|            raise TypeError('"annotation" is not permitted as a Field keyword argument')
   269|         0|            0|            0|  0.00%|        return FieldInfo(default=default, **kwargs)
   270|         0|            0|            0|  0.00%|
   271|         0|            0|            0|  0.00%|    @staticmethod
   272|         0|            0|            0|  0.00%|    def from_annotation(annotation: type[Any]) -> FieldInfo:
   273|         0|            0|            0|  0.00%|        """Creates a `FieldInfo` instance from a bare annotation.
   274|         0|            0|            0|  0.00%|
   275|         0|            0|            0|  0.00%|        This function is used internally to create a `FieldInfo` from a bare annotation like this:
   276|         0|            0|            0|  0.00%|
   277|         0|            0|            0|  0.00%|        ```python
   278|         0|            0|            0|  0.00%|        import pydantic
   279|         0|            0|            0|  0.00%|
   280|         0|            0|            0|  0.00%|        class MyModel(pydantic.BaseModel):
   281|         0|            0|            0|  0.00%|            foo: int  # <-- like this
   282|         0|            0|            0|  0.00%|        ```
   283|         0|            0|            0|  0.00%|
   284|         0|            0|            0|  0.00%|        We also account for the case where the annotation can be an instance of `Annotated` and where
   285|         0|            0|            0|  0.00%|        one of the (not first) arguments in `Annotated` is an instance of `FieldInfo`, e.g.:
   286|         0|            0|            0|  0.00%|
   287|         0|            0|            0|  0.00%|        ```python
   288|         0|            0|            0|  0.00%|        import annotated_types
   289|         0|            0|            0|  0.00%|        from typing_extensions import Annotated
   290|         0|            0|            0|  0.00%|
   291|         0|            0|            0|  0.00%|        import pydantic
   292|         0|            0|            0|  0.00%|
   293|         0|            0|            0|  0.00%|        class MyModel(pydantic.BaseModel):
   294|         0|            0|            0|  0.00%|            foo: Annotated[int, annotated_types.Gt(42)]
   295|         0|            0|            0|  0.00%|            bar: Annotated[int, pydantic.Field(gt=42)]
   296|         0|            0|            0|  0.00%|        ```
   297|         0|            0|            0|  0.00%|
   298|         0|            0|            0|  0.00%|        Args:
   299|         0|            0|            0|  0.00%|            annotation: An annotation object.
   300|         0|            0|            0|  0.00%|
   301|         0|            0|            0|  0.00%|        Returns:
   302|         0|            0|            0|  0.00%|            An instance of the field metadata.
   303|         0|            0|            0|  0.00%|        """
   304|         0|            0|            0|  0.00%|        final = False
   305|         0|            0|            0|  0.00%|        if _typing_extra.is_finalvar(annotation):
   306|         0|            0|            0|  0.00%|            final = True
   307|         0|            0|            0|  0.00%|            if annotation is not typing_extensions.Final:
   308|         0|            0|            0|  0.00%|                annotation = typing_extensions.get_args(annotation)[0]
   309|         0|            0|            0|  0.00%|
   310|         0|            0|            0|  0.00%|        if _typing_extra.is_annotated(annotation):
   311|         0|            0|            0|  0.00%|            first_arg, *extra_args = typing_extensions.get_args(annotation)
   312|         0|            0|            0|  0.00%|            if _typing_extra.is_finalvar(first_arg):
   313|         0|            0|            0|  0.00%|                final = True
   314|         0|            0|            0|  0.00%|            field_info_annotations = [a for a in extra_args if isinstance(a, FieldInfo)]
   315|         0|            0|            0|  0.00%|            field_info = FieldInfo.merge_field_infos(*field_info_annotations, annotation=first_arg)
   316|         0|            0|            0|  0.00%|            if field_info:
   317|         0|            0|            0|  0.00%|                new_field_info = copy(field_info)
   318|         0|            0|            0|  0.00%|                new_field_info.annotation = first_arg
   319|         0|            0|            0|  0.00%|                new_field_info.frozen = final or field_info.frozen
   320|         0|            0|            0|  0.00%|                metadata: list[Any] = []
   321|         0|            0|            0|  0.00%|                for a in extra_args:
   322|         0|            0|            0|  0.00%|                    if _typing_extra.is_deprecated_instance(a):
   323|         0|            0|            0|  0.00%|                        new_field_info.deprecated = a.message
   324|         0|            0|            0|  0.00%|                    elif not isinstance(a, FieldInfo):
   325|         0|            0|            0|  0.00%|                        metadata.append(a)
   326|         0|            0|            0|  0.00%|                    else:
   327|         0|            0|            0|  0.00%|                        metadata.extend(a.metadata)
   328|         0|            0|            0|  0.00%|                new_field_info.metadata = metadata
   329|         0|            0|            0|  0.00%|                return new_field_info
   330|         0|            0|            0|  0.00%|
   331|         0|            0|            0|  0.00%|        return FieldInfo(annotation=annotation, frozen=final or None)  # pyright: ignore[reportArgumentType]
   332|         0|            0|            0|  0.00%|
   333|         0|            0|            0|  0.00%|    @staticmethod
   334|         0|            0|            0|  0.00%|    def from_annotated_attribute(annotation: type[Any], default: Any) -> FieldInfo:
   335|         0|            0|            0|  0.00%|        """Create `FieldInfo` from an annotation with a default value.
   336|         0|            0|            0|  0.00%|
   337|         0|            0|            0|  0.00%|        This is used in cases like the following:
   338|         0|            0|            0|  0.00%|
   339|         0|            0|            0|  0.00%|        ```python
   340|         0|            0|            0|  0.00%|        import annotated_types
   341|         0|            0|            0|  0.00%|        from typing_extensions import Annotated
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|        import pydantic
   344|         0|            0|            0|  0.00%|
   345|         0|            0|            0|  0.00%|        class MyModel(pydantic.BaseModel):
   346|         0|            0|            0|  0.00%|            foo: int = 4  # <-- like this
   347|         0|            0|            0|  0.00%|            bar: Annotated[int, annotated_types.Gt(4)] = 4  # <-- or this
   348|         0|            0|            0|  0.00%|            spam: Annotated[int, pydantic.Field(gt=4)] = 4  # <-- or this
   349|         0|            0|            0|  0.00%|        ```
   350|         0|            0|            0|  0.00%|
   351|         0|            0|            0|  0.00%|        Args:
   352|         0|            0|            0|  0.00%|            annotation: The type annotation of the field.
   353|         0|            0|            0|  0.00%|            default: The default value of the field.
   354|         0|            0|            0|  0.00%|
   355|         0|            0|            0|  0.00%|        Returns:
   356|         0|            0|            0|  0.00%|            A field object with the passed values.
   357|         0|            0|            0|  0.00%|        """
   358|         0|            0|            0|  0.00%|        if annotation is default:
   359|         0|            0|            0|  0.00%|            raise PydanticUserError(
   360|         0|            0|            0|  0.00%|                'Error when building FieldInfo from annotated attribute. '
   361|         0|            0|            0|  0.00%|                "Make sure you don't have any field name clashing with a type annotation ",
   362|         0|            0|            0|  0.00%|                code='unevaluable-type-annotation',
   363|         0|            0|            0|  0.00%|            )
   364|         0|            0|            0|  0.00%|
   365|         0|            0|            0|  0.00%|        final = False
   366|         0|            0|            0|  0.00%|        if _typing_extra.is_finalvar(annotation):
   367|         0|            0|            0|  0.00%|            final = True
   368|         0|            0|            0|  0.00%|            if annotation is not typing_extensions.Final:
   369|         0|            0|            0|  0.00%|                annotation = typing_extensions.get_args(annotation)[0]
   370|         0|            0|            0|  0.00%|
   371|         0|            0|            0|  0.00%|        if isinstance(default, FieldInfo):
   372|         0|            0|            0|  0.00%|            default.annotation, annotation_metadata = FieldInfo._extract_metadata(annotation)  # pyright: ignore[reportArgumentType]
   373|         0|            0|            0|  0.00%|            default.metadata += annotation_metadata
   374|         0|            0|            0|  0.00%|            default = default.merge_field_infos(
   375|         0|            0|            0|  0.00%|                *[x for x in annotation_metadata if isinstance(x, FieldInfo)], default, annotation=default.annotation
   376|         0|            0|            0|  0.00%|            )
   377|         0|            0|            0|  0.00%|            default.frozen = final or default.frozen
   378|         0|            0|            0|  0.00%|            return default
   379|         0|            0|            0|  0.00%|        elif isinstance(default, dataclasses.Field):
   380|         0|            0|            0|  0.00%|            init_var = False
   381|         0|            0|            0|  0.00%|            if annotation is dataclasses.InitVar:
   382|         0|            0|            0|  0.00%|                init_var = True
   383|         0|            0|            0|  0.00%|                annotation = typing.cast(Any, Any)
   384|         0|            0|            0|  0.00%|            elif isinstance(annotation, dataclasses.InitVar):
   385|         0|            0|            0|  0.00%|                init_var = True
   386|         0|            0|            0|  0.00%|                annotation = annotation.type
   387|         0|            0|            0|  0.00%|            pydantic_field = FieldInfo._from_dataclass_field(default)
   388|         0|            0|            0|  0.00%|            pydantic_field.annotation, annotation_metadata = FieldInfo._extract_metadata(annotation)  # pyright: ignore[reportArgumentType]
   389|         0|            0|            0|  0.00%|            pydantic_field.metadata += annotation_metadata
   390|         0|            0|            0|  0.00%|            pydantic_field = pydantic_field.merge_field_infos(
   391|         0|            0|            0|  0.00%|                *[x for x in annotation_metadata if isinstance(x, FieldInfo)],
   392|         0|            0|            0|  0.00%|                pydantic_field,
   393|         0|            0|            0|  0.00%|                annotation=pydantic_field.annotation,
   394|         0|            0|            0|  0.00%|            )
   395|         0|            0|            0|  0.00%|            pydantic_field.frozen = final or pydantic_field.frozen
   396|         0|            0|            0|  0.00%|            pydantic_field.init_var = init_var
   397|         0|            0|            0|  0.00%|            pydantic_field.init = getattr(default, 'init', None)
   398|         0|            0|            0|  0.00%|            pydantic_field.kw_only = getattr(default, 'kw_only', None)
   399|         0|            0|            0|  0.00%|            return pydantic_field
   400|         0|            0|            0|  0.00%|        else:
   401|         0|            0|            0|  0.00%|            if _typing_extra.is_annotated(annotation):
   402|         0|            0|            0|  0.00%|                first_arg, *extra_args = typing_extensions.get_args(annotation)
   403|         0|            0|            0|  0.00%|                field_infos = [a for a in extra_args if isinstance(a, FieldInfo)]
   404|         0|            0|            0|  0.00%|                field_info = FieldInfo.merge_field_infos(*field_infos, annotation=first_arg, default=default)
   405|         0|            0|            0|  0.00%|                metadata: list[Any] = []
   406|         0|            0|            0|  0.00%|                for a in extra_args:
   407|         0|            0|            0|  0.00%|                    if _typing_extra.is_deprecated_instance(a):
   408|         0|            0|            0|  0.00%|                        field_info.deprecated = a.message
   409|         0|            0|            0|  0.00%|                    elif not isinstance(a, FieldInfo):
   410|         0|            0|            0|  0.00%|                        metadata.append(a)
   411|         0|            0|            0|  0.00%|                    else:
   412|         0|            0|            0|  0.00%|                        metadata.extend(a.metadata)
   413|         0|            0|            0|  0.00%|                field_info.metadata = metadata
   414|         0|            0|            0|  0.00%|                return field_info
   415|         0|            0|            0|  0.00%|
   416|         0|            0|            0|  0.00%|            return FieldInfo(annotation=annotation, default=default, frozen=final or None)  # pyright: ignore[reportArgumentType]
   417|         0|            0|            0|  0.00%|
   418|         0|            0|            0|  0.00%|    @staticmethod
   419|         0|            0|            0|  0.00%|    def merge_field_infos(*field_infos: FieldInfo, **overrides: Any) -> FieldInfo:
   420|         0|            0|            0|  0.00%|        """Merge `FieldInfo` instances keeping only explicitly set attributes.
   421|         0|            0|            0|  0.00%|
   422|         0|            0|            0|  0.00%|        Later `FieldInfo` instances override earlier ones.
   423|         0|            0|            0|  0.00%|
   424|         0|            0|            0|  0.00%|        Returns:
   425|         0|            0|            0|  0.00%|            FieldInfo: A merged FieldInfo instance.
   426|         0|            0|            0|  0.00%|        """
   427|         0|            0|            0|  0.00%|        flattened_field_infos: list[FieldInfo] = []
   428|         0|            0|            0|  0.00%|        for field_info in field_infos:
   429|         0|            0|            0|  0.00%|            flattened_field_infos.extend(x for x in field_info.metadata if isinstance(x, FieldInfo))
   430|         0|            0|            0|  0.00%|            flattened_field_infos.append(field_info)
   431|         0|            0|            0|  0.00%|        field_infos = tuple(flattened_field_infos)
   432|         0|            0|            0|  0.00%|        if len(field_infos) == 1:
   433|         0|            0|            0|  0.00%|            # No merging necessary, but we still need to make a copy and apply the overrides
   434|         0|            0|            0|  0.00%|            field_info = copy(field_infos[0])
   435|         0|            0|            0|  0.00%|            field_info._attributes_set.update(overrides)
   436|         0|            0|            0|  0.00%|
   437|         0|            0|            0|  0.00%|            default_override = overrides.pop('default', PydanticUndefined)
   438|         0|            0|            0|  0.00%|            if default_override is Ellipsis:
   439|         0|            0|            0|  0.00%|                default_override = PydanticUndefined
   440|         0|            0|            0|  0.00%|            if default_override is not PydanticUndefined:
   441|         0|            0|            0|  0.00%|                field_info.default = default_override
   442|         0|            0|            0|  0.00%|
   443|         0|            0|            0|  0.00%|            for k, v in overrides.items():
   444|         0|            0|            0|  0.00%|                setattr(field_info, k, v)
   445|         0|            0|            0|  0.00%|            return field_info  # type: ignore
   446|         0|            0|            0|  0.00%|
   447|         0|            0|            0|  0.00%|        new_kwargs: dict[str, Any] = {}
   448|         0|            0|            0|  0.00%|        metadata = {}
   449|         0|            0|            0|  0.00%|        for field_info in field_infos:
   450|         0|            0|            0|  0.00%|            new_kwargs.update(field_info._attributes_set)
   451|         0|            0|            0|  0.00%|            for x in field_info.metadata:
   452|         0|            0|            0|  0.00%|                if not isinstance(x, FieldInfo):
   453|         0|            0|            0|  0.00%|                    metadata[type(x)] = x
   454|         0|            0|            0|  0.00%|        new_kwargs.update(overrides)
   455|         0|            0|            0|  0.00%|        field_info = FieldInfo(**new_kwargs)
   456|         0|            0|            0|  0.00%|        field_info.metadata = list(metadata.values())
   457|         0|            0|            0|  0.00%|        return field_info
   458|         0|            0|            0|  0.00%|
   459|         0|            0|            0|  0.00%|    @staticmethod
   460|         0|            0|            0|  0.00%|    def _from_dataclass_field(dc_field: DataclassField[Any]) -> FieldInfo:
   461|         0|            0|            0|  0.00%|        """Return a new `FieldInfo` instance from a `dataclasses.Field` instance.
   462|         0|            0|            0|  0.00%|
   463|         0|            0|            0|  0.00%|        Args:
   464|         0|            0|            0|  0.00%|            dc_field: The `dataclasses.Field` instance to convert.
   465|         0|            0|            0|  0.00%|
   466|         0|            0|            0|  0.00%|        Returns:
   467|         0|            0|            0|  0.00%|            The corresponding `FieldInfo` instance.
   468|         0|            0|            0|  0.00%|
   469|         0|            0|            0|  0.00%|        Raises:
   470|         0|            0|            0|  0.00%|            TypeError: If any of the `FieldInfo` kwargs does not match the `dataclass.Field` kwargs.
   471|         0|            0|            0|  0.00%|        """
   472|         0|            0|            0|  0.00%|        default = dc_field.default
   473|         0|            0|            0|  0.00%|        if default is dataclasses.MISSING:
   474|         0|            0|            0|  0.00%|            default = PydanticUndefined
   475|         0|            0|            0|  0.00%|
   476|         0|            0|            0|  0.00%|        if dc_field.default_factory is dataclasses.MISSING:
   477|         0|            0|            0|  0.00%|            default_factory: typing.Callable[[], Any] | None = None
   478|         0|            0|            0|  0.00%|        else:
   479|         0|            0|            0|  0.00%|            default_factory = dc_field.default_factory
   480|         0|            0|            0|  0.00%|
   481|         0|            0|            0|  0.00%|        # use the `Field` function so in correct kwargs raise the correct `TypeError`
   482|         0|            0|            0|  0.00%|        dc_field_metadata = {k: v for k, v in dc_field.metadata.items() if k in _FIELD_ARG_NAMES}
   483|         0|            0|            0|  0.00%|        return Field(default=default, default_factory=default_factory, repr=dc_field.repr, **dc_field_metadata)
   484|         0|            0|            0|  0.00%|
   485|         2|  9.53674e-06|  4.76837e-06|  0.01%|    @staticmethod
   486|         0|            0|            0|  0.00%|    def _extract_metadata(annotation: type[Any] | None) -> tuple[type[Any] | None, list[Any]]:
   487|         0|            0|            0|  0.00%|        """Tries to extract metadata/constraints from an annotation if it uses `Annotated`.
   488|         0|            0|            0|  0.00%|
   489|         0|            0|            0|  0.00%|        Args:
   490|         0|            0|            0|  0.00%|            annotation: The type hint annotation for which metadata has to be extracted.
   491|         0|            0|            0|  0.00%|
   492|         0|            0|            0|  0.00%|        Returns:
   493|         0|            0|            0|  0.00%|            A tuple containing the extracted metadata type and the list of extra arguments.
   494|         0|            0|            0|  0.00%|        """
   495|         2|  4.62532e-05|  2.31266e-05|  0.05%|        if annotation is not None:
   496|         2|   1.3113e-05|  6.55651e-06|  0.01%|            if _typing_extra.is_annotated(annotation):
(call)|         2|  4.31538e-05|  2.15769e-05|  0.04%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_typing_extra.py:111 is_annotated
   497|         0|            0|            0|  0.00%|                first_arg, *extra_args = typing_extensions.get_args(annotation)
   498|         0|            0|            0|  0.00%|                return first_arg, list(extra_args)
   499|         0|            0|            0|  0.00%|
   500|         2|   3.8147e-06|  1.90735e-06|  0.00%|        return annotation, []
   501|         0|            0|            0|  0.00%|
   502|         2|  1.04904e-05|  5.24521e-06|  0.01%|    @staticmethod
   503|         0|            0|            0|  0.00%|    def _collect_metadata(kwargs: dict[str, Any]) -> list[Any]:
   504|         0|            0|            0|  0.00%|        """Collect annotations from kwargs.
   505|         0|            0|            0|  0.00%|
   506|         0|            0|            0|  0.00%|        Args:
   507|         0|            0|            0|  0.00%|            kwargs: Keyword arguments passed to the function.
   508|         0|            0|            0|  0.00%|
   509|         0|            0|            0|  0.00%|        Returns:
   510|         0|            0|            0|  0.00%|            A list of metadata objects - a combination of `annotated_types.BaseMetadata` and
   511|         0|            0|            0|  0.00%|                `PydanticMetadata`.
   512|         0|            0|            0|  0.00%|        """
   513|         2|  6.19888e-06|  3.09944e-06|  0.01%|        metadata: list[Any] = []
   514|         2|  4.05312e-06|  2.02656e-06|  0.00%|        general_metadata = {}
   515|        18|  3.67165e-05|   2.0398e-06|  0.04%|        for key, value in list(kwargs.items()):
   516|        16|  2.76566e-05|  1.72853e-06|  0.03%|            try:
   517|        16|  2.52724e-05|  1.57952e-06|  0.03%|                marker = FieldInfo.metadata_lookup[key]
   518|         2|  3.09944e-06|  1.54972e-06|  0.00%|            except KeyError:
   519|         2|   3.8147e-06|  1.90735e-06|  0.00%|                continue
   520|         0|            0|            0|  0.00%|
   521|        14|  2.00272e-05|  1.43051e-06|  0.02%|            del kwargs[key]
   522|        14|  1.83582e-05|   1.3113e-06|  0.02%|            if value is not None:
   523|         0|            0|            0|  0.00%|                if marker is None:
   524|         0|            0|            0|  0.00%|                    general_metadata[key] = value
   525|         0|            0|            0|  0.00%|                else:
   526|         0|            0|            0|  0.00%|                    metadata.append(marker(value))
   527|         2|  3.09944e-06|  1.54972e-06|  0.00%|        if general_metadata:
   528|         0|            0|            0|  0.00%|            metadata.append(_fields.pydantic_general_metadata(**general_metadata))
   529|         2|  5.96046e-06|  2.98023e-06|  0.01%|        return metadata
   530|         0|            0|            0|  0.00%|
   531|         0|            0|            0|  0.00%|    @property
   532|         0|            0|            0|  0.00%|    def deprecation_message(self) -> str | None:
   533|         0|            0|            0|  0.00%|        """The deprecation message to be emitted, or `None` if not set."""
   534|         0|            0|            0|  0.00%|        if self.deprecated is None:
   535|         0|            0|            0|  0.00%|            return None
   536|         0|            0|            0|  0.00%|        if isinstance(self.deprecated, bool):
   537|         0|            0|            0|  0.00%|            return 'deprecated' if self.deprecated else None
   538|         0|            0|            0|  0.00%|        return self.deprecated if isinstance(self.deprecated, str) else self.deprecated.message
   539|         0|            0|            0|  0.00%|
   540|         0|            0|            0|  0.00%|    def get_default(self, *, call_default_factory: bool = False) -> Any:
   541|         0|            0|            0|  0.00%|        """Get the default value.
   542|         0|            0|            0|  0.00%|
   543|         0|            0|            0|  0.00%|        We expose an option for whether to call the default_factory (if present), as calling it may
   544|         0|            0|            0|  0.00%|        result in side effects that we want to avoid. However, there are times when it really should
   545|         0|            0|            0|  0.00%|        be called (namely, when instantiating a model via `model_construct`).
   546|         0|            0|            0|  0.00%|
   547|         0|            0|            0|  0.00%|        Args:
   548|         0|            0|            0|  0.00%|            call_default_factory: Whether to call the default_factory or not. Defaults to `False`.
   549|         0|            0|            0|  0.00%|
   550|         0|            0|            0|  0.00%|        Returns:
   551|         0|            0|            0|  0.00%|            The default value, calling the default factory if requested or `None` if not set.
   552|         0|            0|            0|  0.00%|        """
   553|         0|            0|            0|  0.00%|        if self.default_factory is None:
   554|         0|            0|            0|  0.00%|            return _utils.smart_deepcopy(self.default)
   555|         0|            0|            0|  0.00%|        elif call_default_factory:
   556|         0|            0|            0|  0.00%|            return self.default_factory()
   557|         0|            0|            0|  0.00%|        else:
   558|         0|            0|            0|  0.00%|            return None
   559|         0|            0|            0|  0.00%|
   560|         0|            0|            0|  0.00%|    def is_required(self) -> bool:
   561|         0|            0|            0|  0.00%|        """Check if the field is required (i.e., does not have a default value or factory).
   562|         0|            0|            0|  0.00%|
   563|         0|            0|            0|  0.00%|        Returns:
   564|         0|            0|            0|  0.00%|            `True` if the field is required, `False` otherwise.
   565|         0|            0|            0|  0.00%|        """
   566|         0|            0|            0|  0.00%|        return self.default is PydanticUndefined and self.default_factory is None
   567|         0|            0|            0|  0.00%|
   568|         0|            0|            0|  0.00%|    def rebuild_annotation(self) -> Any:
   569|         0|            0|            0|  0.00%|        """Attempts to rebuild the original annotation for use in function signatures.
   570|         0|            0|            0|  0.00%|
   571|         0|            0|            0|  0.00%|        If metadata is present, it adds it to the original annotation using
   572|         0|            0|            0|  0.00%|        `Annotated`. Otherwise, it returns the original annotation as-is.
   573|         0|            0|            0|  0.00%|
   574|         0|            0|            0|  0.00%|        Note that because the metadata has been flattened, the original annotation
   575|         0|            0|            0|  0.00%|        may not be reconstructed exactly as originally provided, e.g. if the original
   576|         0|            0|            0|  0.00%|        type had unrecognized annotations, or was annotated with a call to `pydantic.Field`.
   577|         0|            0|            0|  0.00%|
   578|         0|            0|            0|  0.00%|        Returns:
   579|         0|            0|            0|  0.00%|            The rebuilt annotation.
   580|         0|            0|            0|  0.00%|        """
   581|         0|            0|            0|  0.00%|        if not self.metadata:
   582|         0|            0|            0|  0.00%|            return self.annotation
   583|         0|            0|            0|  0.00%|        else:
   584|         0|            0|            0|  0.00%|            # Annotated arguments must be a tuple
   585|         0|            0|            0|  0.00%|            return typing_extensions.Annotated[(self.annotation, *self.metadata)]  # type: ignore
   586|         0|            0|            0|  0.00%|
   587|         0|            0|            0|  0.00%|    def apply_typevars_map(self, typevars_map: dict[Any, Any] | None, types_namespace: dict[str, Any] | None) -> None:
   588|         0|            0|            0|  0.00%|        """Apply a `typevars_map` to the annotation.
   589|         0|            0|            0|  0.00%|
   590|         0|            0|            0|  0.00%|        This method is used when analyzing parametrized generic types to replace typevars with their concrete types.
   591|         0|            0|            0|  0.00%|
   592|         0|            0|            0|  0.00%|        This method applies the `typevars_map` to the annotation in place.
   593|         0|            0|            0|  0.00%|
   594|         0|            0|            0|  0.00%|        Args:
   595|         0|            0|            0|  0.00%|            typevars_map: A dictionary mapping type variables to their concrete types.
   596|         0|            0|            0|  0.00%|            types_namespace (dict | None): A dictionary containing related types to the annotated type.
   597|         0|            0|            0|  0.00%|
   598|         0|            0|            0|  0.00%|        See Also:
   599|         0|            0|            0|  0.00%|            pydantic._internal._generics.replace_types is used for replacing the typevars with
   600|         0|            0|            0|  0.00%|                their concrete types.
   601|         0|            0|            0|  0.00%|        """
   602|         0|            0|            0|  0.00%|        annotation = _typing_extra.eval_type_lenient(self.annotation, types_namespace)
   603|         0|            0|            0|  0.00%|        self.annotation = _generics.replace_types(annotation, typevars_map)
   604|         0|            0|            0|  0.00%|
   605|         0|            0|            0|  0.00%|    def __repr_args__(self) -> ReprArgs:
   606|         0|            0|            0|  0.00%|        yield 'annotation', _repr.PlainRepr(_repr.display_as_type(self.annotation))
   607|         0|            0|            0|  0.00%|        yield 'required', self.is_required()
   608|         0|            0|            0|  0.00%|
   609|         0|            0|            0|  0.00%|        for s in self.__slots__:
   610|         0|            0|            0|  0.00%|            if s == '_attributes_set':
   611|         0|            0|            0|  0.00%|                continue
   612|         0|            0|            0|  0.00%|            if s == 'annotation':
   613|         0|            0|            0|  0.00%|                continue
   614|         0|            0|            0|  0.00%|            elif s == 'metadata' and not self.metadata:
   615|         0|            0|            0|  0.00%|                continue
   616|         0|            0|            0|  0.00%|            elif s == 'repr' and self.repr is True:
   617|         0|            0|            0|  0.00%|                continue
   618|         0|            0|            0|  0.00%|            if s == 'frozen' and self.frozen is False:
   619|         0|            0|            0|  0.00%|                continue
   620|         0|            0|            0|  0.00%|            if s == 'validation_alias' and self.validation_alias == self.alias:
   621|         0|            0|            0|  0.00%|                continue
   622|         0|            0|            0|  0.00%|            if s == 'serialization_alias' and self.serialization_alias == self.alias:
   623|         0|            0|            0|  0.00%|                continue
   624|         0|            0|            0|  0.00%|            if s == 'default' and self.default is not PydanticUndefined:
   625|         0|            0|            0|  0.00%|                yield 'default', self.default
   626|         0|            0|            0|  0.00%|            elif s == 'default_factory' and self.default_factory is not None:
   627|         0|            0|            0|  0.00%|                yield 'default_factory', _repr.PlainRepr(_repr.display_as_type(self.default_factory))
   628|         0|            0|            0|  0.00%|            else:
   629|         0|            0|            0|  0.00%|                value = getattr(self, s)
   630|         0|            0|            0|  0.00%|                if value is not None and value is not PydanticUndefined:
   631|         0|            0|            0|  0.00%|                    yield s, value
   632|         0|            0|            0|  0.00%|
   633|         0|            0|            0|  0.00%|
   634|         0|            0|            0|  0.00%|class _EmptyKwargs(typing_extensions.TypedDict):
   635|         0|            0|            0|  0.00%|    """This class exists solely to ensure that type checking warns about passing `**extra` in `Field`."""
   636|         0|            0|            0|  0.00%|
   637|         0|            0|            0|  0.00%|
   638|         0|            0|            0|  0.00%|_DefaultValues = dict(
   639|         0|            0|            0|  0.00%|    default=...,
   640|         0|            0|            0|  0.00%|    default_factory=None,
   641|         0|            0|            0|  0.00%|    alias=None,
   642|         0|            0|            0|  0.00%|    alias_priority=None,
   643|         0|            0|            0|  0.00%|    validation_alias=None,
   644|         0|            0|            0|  0.00%|    serialization_alias=None,
   645|         0|            0|            0|  0.00%|    title=None,
   646|         0|            0|            0|  0.00%|    description=None,
   647|         0|            0|            0|  0.00%|    examples=None,
   648|         0|            0|            0|  0.00%|    exclude=None,
   649|         0|            0|            0|  0.00%|    discriminator=None,
   650|         0|            0|            0|  0.00%|    json_schema_extra=None,
   651|         0|            0|            0|  0.00%|    frozen=None,
   652|         0|            0|            0|  0.00%|    validate_default=None,
   653|         0|            0|            0|  0.00%|    repr=True,
   654|         0|            0|            0|  0.00%|    init=None,
   655|         0|            0|            0|  0.00%|    init_var=None,
   656|         0|            0|            0|  0.00%|    kw_only=None,
   657|         0|            0|            0|  0.00%|    pattern=None,
   658|         0|            0|            0|  0.00%|    strict=None,
   659|         0|            0|            0|  0.00%|    gt=None,
   660|         0|            0|            0|  0.00%|    ge=None,
   661|         0|            0|            0|  0.00%|    lt=None,
   662|         0|            0|            0|  0.00%|    le=None,
   663|         0|            0|            0|  0.00%|    multiple_of=None,
   664|         0|            0|            0|  0.00%|    allow_inf_nan=None,
   665|         0|            0|            0|  0.00%|    max_digits=None,
   666|         0|            0|            0|  0.00%|    decimal_places=None,
   667|         0|            0|            0|  0.00%|    min_length=None,
   668|         0|            0|            0|  0.00%|    max_length=None,
   669|         0|            0|            0|  0.00%|    coerce_numbers_to_str=None,
   670|         0|            0|            0|  0.00%|)
   671|         0|            0|            0|  0.00%|
   672|         0|            0|            0|  0.00%|
   673|         0|            0|            0|  0.00%|def Field(  # noqa: C901
   674|         0|            0|            0|  0.00%|    default: Any = PydanticUndefined,
   675|         0|            0|            0|  0.00%|    *,
   676|         0|            0|            0|  0.00%|    default_factory: typing.Callable[[], Any] | None = _Unset,
   677|         0|            0|            0|  0.00%|    alias: str | None = _Unset,
   678|         0|            0|            0|  0.00%|    alias_priority: int | None = _Unset,
   679|         0|            0|            0|  0.00%|    validation_alias: str | AliasPath | AliasChoices | None = _Unset,
   680|         0|            0|            0|  0.00%|    serialization_alias: str | None = _Unset,
   681|         0|            0|            0|  0.00%|    title: str | None = _Unset,
   682|         0|            0|            0|  0.00%|    field_title_generator: typing_extensions.Callable[[str, FieldInfo], str] | None = _Unset,
   683|         0|            0|            0|  0.00%|    description: str | None = _Unset,
   684|         0|            0|            0|  0.00%|    examples: list[Any] | None = _Unset,
   685|         0|            0|            0|  0.00%|    exclude: bool | None = _Unset,
   686|         0|            0|            0|  0.00%|    discriminator: str | types.Discriminator | None = _Unset,
   687|         0|            0|            0|  0.00%|    deprecated: Deprecated | str | bool | None = _Unset,
   688|         0|            0|            0|  0.00%|    json_schema_extra: JsonDict | typing.Callable[[JsonDict], None] | None = _Unset,
   689|         0|            0|            0|  0.00%|    frozen: bool | None = _Unset,
   690|         0|            0|            0|  0.00%|    validate_default: bool | None = _Unset,
   691|         0|            0|            0|  0.00%|    repr: bool = _Unset,
   692|         0|            0|            0|  0.00%|    init: bool | None = _Unset,
   693|         0|            0|            0|  0.00%|    init_var: bool | None = _Unset,
   694|         0|            0|            0|  0.00%|    kw_only: bool | None = _Unset,
   695|         0|            0|            0|  0.00%|    pattern: str | typing.Pattern[str] | None = _Unset,
   696|         0|            0|            0|  0.00%|    strict: bool | None = _Unset,
   697|         0|            0|            0|  0.00%|    coerce_numbers_to_str: bool | None = _Unset,
   698|         0|            0|            0|  0.00%|    gt: annotated_types.SupportsGt | None = _Unset,
   699|         0|            0|            0|  0.00%|    ge: annotated_types.SupportsGe | None = _Unset,
   700|         0|            0|            0|  0.00%|    lt: annotated_types.SupportsLt | None = _Unset,
   701|         0|            0|            0|  0.00%|    le: annotated_types.SupportsLe | None = _Unset,
   702|         0|            0|            0|  0.00%|    multiple_of: float | None = _Unset,
   703|         0|            0|            0|  0.00%|    allow_inf_nan: bool | None = _Unset,
   704|         0|            0|            0|  0.00%|    max_digits: int | None = _Unset,
   705|         0|            0|            0|  0.00%|    decimal_places: int | None = _Unset,
   706|         0|            0|            0|  0.00%|    min_length: int | None = _Unset,
   707|         0|            0|            0|  0.00%|    max_length: int | None = _Unset,
   708|         0|            0|            0|  0.00%|    union_mode: Literal['smart', 'left_to_right'] = _Unset,
   709|         0|            0|            0|  0.00%|    fail_fast: bool | None = _Unset,
   710|         0|            0|            0|  0.00%|    **extra: Unpack[_EmptyKwargs],
   711|         0|            0|            0|  0.00%|) -> Any:
   712|         0|            0|            0|  0.00%|    """Usage docs: https://docs.pydantic.dev/2.8/concepts/fields
   713|         0|            0|            0|  0.00%|
   714|         0|            0|            0|  0.00%|    Create a field for objects that can be configured.
   715|         0|            0|            0|  0.00%|
   716|         0|            0|            0|  0.00%|    Used to provide extra information about a field, either for the model schema or complex validation. Some arguments
   717|         0|            0|            0|  0.00%|    apply only to number fields (`int`, `float`, `Decimal`) and some apply only to `str`.
   718|         0|            0|            0|  0.00%|
   719|         0|            0|            0|  0.00%|    Note:
   720|         0|            0|            0|  0.00%|        - Any `_Unset` objects will be replaced by the corresponding value defined in the `_DefaultValues` dictionary. If a key for the `_Unset` object is not found in the `_DefaultValues` dictionary, it will default to `None`
   721|         0|            0|            0|  0.00%|
   722|         0|            0|            0|  0.00%|    Args:
   723|         0|            0|            0|  0.00%|        default: Default value if the field is not set.
   724|         0|            0|            0|  0.00%|        default_factory: A callable to generate the default value, such as :func:`~datetime.utcnow`.
   725|         0|            0|            0|  0.00%|        alias: The name to use for the attribute when validating or serializing by alias.
   726|         0|            0|            0|  0.00%|            This is often used for things like converting between snake and camel case.
   727|         0|            0|            0|  0.00%|        alias_priority: Priority of the alias. This affects whether an alias generator is used.
   728|         0|            0|            0|  0.00%|        validation_alias: Like `alias`, but only affects validation, not serialization.
   729|         0|            0|            0|  0.00%|        serialization_alias: Like `alias`, but only affects serialization, not validation.
   730|         0|            0|            0|  0.00%|        title: Human-readable title.
   731|         0|            0|            0|  0.00%|        field_title_generator: A callable that takes a field name and returns title for it.
   732|         0|            0|            0|  0.00%|        description: Human-readable description.
   733|         0|            0|            0|  0.00%|        examples: Example values for this field.
   734|         0|            0|            0|  0.00%|        exclude: Whether to exclude the field from the model serialization.
   735|         0|            0|            0|  0.00%|        discriminator: Field name or Discriminator for discriminating the type in a tagged union.
   736|         0|            0|            0|  0.00%|        deprecated: A deprecation message, an instance of `warnings.deprecated` or the `typing_extensions.deprecated` backport,
   737|         0|            0|            0|  0.00%|            or a boolean. If `True`, a default deprecation message will be emitted when accessing the field.
   738|         0|            0|            0|  0.00%|        json_schema_extra: A dict or callable to provide extra JSON schema properties.
   739|         0|            0|            0|  0.00%|        frozen: Whether the field is frozen. If true, attempts to change the value on an instance will raise an error.
   740|         0|            0|            0|  0.00%|        validate_default: If `True`, apply validation to the default value every time you create an instance.
   741|         0|            0|            0|  0.00%|            Otherwise, for performance reasons, the default value of the field is trusted and not validated.
   742|         0|            0|            0|  0.00%|        repr: A boolean indicating whether to include the field in the `__repr__` output.
   743|         0|            0|            0|  0.00%|        init: Whether the field should be included in the constructor of the dataclass.
   744|         0|            0|            0|  0.00%|            (Only applies to dataclasses.)
   745|         0|            0|            0|  0.00%|        init_var: Whether the field should _only_ be included in the constructor of the dataclass.
   746|         0|            0|            0|  0.00%|            (Only applies to dataclasses.)
   747|         0|            0|            0|  0.00%|        kw_only: Whether the field should be a keyword-only argument in the constructor of the dataclass.
   748|         0|            0|            0|  0.00%|            (Only applies to dataclasses.)
   749|         0|            0|            0|  0.00%|        coerce_numbers_to_str: Whether to enable coercion of any `Number` type to `str` (not applicable in `strict` mode).
   750|         0|            0|            0|  0.00%|        strict: If `True`, strict validation is applied to the field.
   751|         0|            0|            0|  0.00%|            See [Strict Mode](../concepts/strict_mode.md) for details.
   752|         0|            0|            0|  0.00%|        gt: Greater than. If set, value must be greater than this. Only applicable to numbers.
   753|         0|            0|            0|  0.00%|        ge: Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers.
   754|         0|            0|            0|  0.00%|        lt: Less than. If set, value must be less than this. Only applicable to numbers.
   755|         0|            0|            0|  0.00%|        le: Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers.
   756|         0|            0|            0|  0.00%|        multiple_of: Value must be a multiple of this. Only applicable to numbers.
   757|         0|            0|            0|  0.00%|        min_length: Minimum length for iterables.
   758|         0|            0|            0|  0.00%|        max_length: Maximum length for iterables.
   759|         0|            0|            0|  0.00%|        pattern: Pattern for strings (a regular expression).
   760|         0|            0|            0|  0.00%|        allow_inf_nan: Allow `inf`, `-inf`, `nan`. Only applicable to numbers.
   761|         0|            0|            0|  0.00%|        max_digits: Maximum number of allow digits for strings.
   762|         0|            0|            0|  0.00%|        decimal_places: Maximum number of decimal places allowed for numbers.
   763|         0|            0|            0|  0.00%|        union_mode: The strategy to apply when validating a union. Can be `smart` (the default), or `left_to_right`.
   764|         0|            0|            0|  0.00%|            See [Union Mode](../concepts/unions.md#union-modes) for details.
   765|         0|            0|            0|  0.00%|        fail_fast: If `True`, validation will stop on the first error. If `False`, all validation errors will be collected.
   766|         0|            0|            0|  0.00%|            This option can be applied only to iterable types (list, tuple, set, and frozenset).
   767|         0|            0|            0|  0.00%|        extra: (Deprecated) Extra fields that will be included in the JSON schema.
   768|         0|            0|            0|  0.00%|
   769|         0|            0|            0|  0.00%|            !!! warning Deprecated
   770|         0|            0|            0|  0.00%|                The `extra` kwargs is deprecated. Use `json_schema_extra` instead.
   771|         0|            0|            0|  0.00%|
   772|         0|            0|            0|  0.00%|    Returns:
   773|         0|            0|            0|  0.00%|        A new [`FieldInfo`][pydantic.fields.FieldInfo]. The return annotation is `Any` so `Field` can be used on
   774|         0|            0|            0|  0.00%|            type-annotated fields without causing a type error.
   775|         0|            0|            0|  0.00%|    """
   776|         0|            0|            0|  0.00%|    # Check deprecated and removed params from V1. This logic should eventually be removed.
   777|         0|            0|            0|  0.00%|    const = extra.pop('const', None)  # type: ignore
   778|         0|            0|            0|  0.00%|    if const is not None:
   779|         0|            0|            0|  0.00%|        raise PydanticUserError('`const` is removed, use `Literal` instead', code='removed-kwargs')
   780|         0|            0|            0|  0.00%|
   781|         0|            0|            0|  0.00%|    min_items = extra.pop('min_items', None)  # type: ignore
   782|         0|            0|            0|  0.00%|    if min_items is not None:
   783|         0|            0|            0|  0.00%|        warn('`min_items` is deprecated and will be removed, use `min_length` instead', DeprecationWarning)
   784|         0|            0|            0|  0.00%|        if min_length in (None, _Unset):
   785|         0|            0|            0|  0.00%|            min_length = min_items  # type: ignore
   786|         0|            0|            0|  0.00%|
   787|         0|            0|            0|  0.00%|    max_items = extra.pop('max_items', None)  # type: ignore
   788|         0|            0|            0|  0.00%|    if max_items is not None:
   789|         0|            0|            0|  0.00%|        warn('`max_items` is deprecated and will be removed, use `max_length` instead', DeprecationWarning)
   790|         0|            0|            0|  0.00%|        if max_length in (None, _Unset):
   791|         0|            0|            0|  0.00%|            max_length = max_items  # type: ignore
   792|         0|            0|            0|  0.00%|
   793|         0|            0|            0|  0.00%|    unique_items = extra.pop('unique_items', None)  # type: ignore
   794|         0|            0|            0|  0.00%|    if unique_items is not None:
   795|         0|            0|            0|  0.00%|        raise PydanticUserError(
   796|         0|            0|            0|  0.00%|            (
   797|         0|            0|            0|  0.00%|                '`unique_items` is removed, use `Set` instead'
   798|         0|            0|            0|  0.00%|                '(this feature is discussed in https://github.com/pydantic/pydantic-core/issues/296)'
   799|         0|            0|            0|  0.00%|            ),
   800|         0|            0|            0|  0.00%|            code='removed-kwargs',
   801|         0|            0|            0|  0.00%|        )
   802|         0|            0|            0|  0.00%|
   803|         0|            0|            0|  0.00%|    allow_mutation = extra.pop('allow_mutation', None)  # type: ignore
   804|         0|            0|            0|  0.00%|    if allow_mutation is not None:
   805|         0|            0|            0|  0.00%|        warn('`allow_mutation` is deprecated and will be removed. use `frozen` instead', DeprecationWarning)
   806|         0|            0|            0|  0.00%|        if allow_mutation is False:
   807|         0|            0|            0|  0.00%|            frozen = True
   808|         0|            0|            0|  0.00%|
   809|         0|            0|            0|  0.00%|    regex = extra.pop('regex', None)  # type: ignore
   810|         0|            0|            0|  0.00%|    if regex is not None:
   811|         0|            0|            0|  0.00%|        raise PydanticUserError('`regex` is removed. use `pattern` instead', code='removed-kwargs')
   812|         0|            0|            0|  0.00%|
   813|         0|            0|            0|  0.00%|    if extra:
   814|         0|            0|            0|  0.00%|        warn(
   815|         0|            0|            0|  0.00%|            'Using extra keyword arguments on `Field` is deprecated and will be removed.'
   816|         0|            0|            0|  0.00%|            ' Use `json_schema_extra` instead.'
   817|         0|            0|            0|  0.00%|            f' (Extra keys: {", ".join(k.__repr__() for k in extra.keys())})',
   818|         0|            0|            0|  0.00%|            DeprecationWarning,
   819|         0|            0|            0|  0.00%|        )
   820|         0|            0|            0|  0.00%|        if not json_schema_extra or json_schema_extra is _Unset:
   821|         0|            0|            0|  0.00%|            json_schema_extra = extra  # type: ignore
   822|         0|            0|            0|  0.00%|
   823|         0|            0|            0|  0.00%|    if (
   824|         0|            0|            0|  0.00%|        validation_alias
   825|         0|            0|            0|  0.00%|        and validation_alias is not _Unset
   826|         0|            0|            0|  0.00%|        and not isinstance(validation_alias, (str, AliasChoices, AliasPath))
   827|         0|            0|            0|  0.00%|    ):
   828|         0|            0|            0|  0.00%|        raise TypeError('Invalid `validation_alias` type. it should be `str`, `AliasChoices`, or `AliasPath`')
   829|         0|            0|            0|  0.00%|
   830|         0|            0|            0|  0.00%|    if serialization_alias in (_Unset, None) and isinstance(alias, str):
   831|         0|            0|            0|  0.00%|        serialization_alias = alias
   832|         0|            0|            0|  0.00%|
   833|         0|            0|            0|  0.00%|    if validation_alias in (_Unset, None):
   834|         0|            0|            0|  0.00%|        validation_alias = alias
   835|         0|            0|            0|  0.00%|
   836|         0|            0|            0|  0.00%|    include = extra.pop('include', None)  # type: ignore
   837|         0|            0|            0|  0.00%|    if include is not None:
   838|         0|            0|            0|  0.00%|        warn('`include` is deprecated and does nothing. It will be removed, use `exclude` instead', DeprecationWarning)
   839|         0|            0|            0|  0.00%|
   840|         0|            0|            0|  0.00%|    return FieldInfo.from_field(
   841|         0|            0|            0|  0.00%|        default,
   842|         0|            0|            0|  0.00%|        default_factory=default_factory,
   843|         0|            0|            0|  0.00%|        alias=alias,
   844|         0|            0|            0|  0.00%|        alias_priority=alias_priority,
   845|         0|            0|            0|  0.00%|        validation_alias=validation_alias,
   846|         0|            0|            0|  0.00%|        serialization_alias=serialization_alias,
   847|         0|            0|            0|  0.00%|        title=title,
   848|         0|            0|            0|  0.00%|        field_title_generator=field_title_generator,
   849|         0|            0|            0|  0.00%|        description=description,
   850|         0|            0|            0|  0.00%|        examples=examples,
   851|         0|            0|            0|  0.00%|        exclude=exclude,
   852|         0|            0|            0|  0.00%|        discriminator=discriminator,
   853|         0|            0|            0|  0.00%|        deprecated=deprecated,
   854|         0|            0|            0|  0.00%|        json_schema_extra=json_schema_extra,
   855|         0|            0|            0|  0.00%|        frozen=frozen,
   856|         0|            0|            0|  0.00%|        pattern=pattern,
   857|         0|            0|            0|  0.00%|        validate_default=validate_default,
   858|         0|            0|            0|  0.00%|        repr=repr,
   859|         0|            0|            0|  0.00%|        init=init,
   860|         0|            0|            0|  0.00%|        init_var=init_var,
   861|         0|            0|            0|  0.00%|        kw_only=kw_only,
   862|         0|            0|            0|  0.00%|        coerce_numbers_to_str=coerce_numbers_to_str,
   863|         0|            0|            0|  0.00%|        strict=strict,
   864|         0|            0|            0|  0.00%|        gt=gt,
   865|         0|            0|            0|  0.00%|        ge=ge,
   866|         0|            0|            0|  0.00%|        lt=lt,
   867|         0|            0|            0|  0.00%|        le=le,
   868|         0|            0|            0|  0.00%|        multiple_of=multiple_of,
   869|         0|            0|            0|  0.00%|        min_length=min_length,
   870|         0|            0|            0|  0.00%|        max_length=max_length,
   871|         0|            0|            0|  0.00%|        allow_inf_nan=allow_inf_nan,
   872|         0|            0|            0|  0.00%|        max_digits=max_digits,
   873|         0|            0|            0|  0.00%|        decimal_places=decimal_places,
   874|         0|            0|            0|  0.00%|        union_mode=union_mode,
   875|         0|            0|            0|  0.00%|        fail_fast=fail_fast,
   876|         0|            0|            0|  0.00%|    )
   877|         0|            0|            0|  0.00%|
   878|         0|            0|            0|  0.00%|
   879|         0|            0|            0|  0.00%|_FIELD_ARG_NAMES = set(inspect.signature(Field).parameters)
   880|         0|            0|            0|  0.00%|_FIELD_ARG_NAMES.remove('extra')  # do not include the varkwargs parameter
   881|         0|            0|            0|  0.00%|
   882|         0|            0|            0|  0.00%|
   883|         0|            0|            0|  0.00%|class ModelPrivateAttr(_repr.Representation):
   884|         0|            0|            0|  0.00%|    """A descriptor for private attributes in class models.
   885|         0|            0|            0|  0.00%|
   886|         0|            0|            0|  0.00%|    !!! warning
   887|         0|            0|            0|  0.00%|        You generally shouldn't be creating `ModelPrivateAttr` instances directly, instead use
   888|         0|            0|            0|  0.00%|        `pydantic.fields.PrivateAttr`. (This is similar to `FieldInfo` vs. `Field`.)
   889|         0|            0|            0|  0.00%|
   890|         0|            0|            0|  0.00%|    Attributes:
   891|         0|            0|            0|  0.00%|        default: The default value of the attribute if not provided.
   892|         0|            0|            0|  0.00%|        default_factory: A callable function that generates the default value of the
   893|         0|            0|            0|  0.00%|            attribute if not provided.
   894|         0|            0|            0|  0.00%|    """
   895|         0|            0|            0|  0.00%|
   896|         0|            0|            0|  0.00%|    __slots__ = 'default', 'default_factory'
   897|         0|            0|            0|  0.00%|
   898|         0|            0|            0|  0.00%|    def __init__(
   899|         0|            0|            0|  0.00%|        self, default: Any = PydanticUndefined, *, default_factory: typing.Callable[[], Any] | None = None
   900|         0|            0|            0|  0.00%|    ) -> None:
   901|         0|            0|            0|  0.00%|        self.default = default
   902|         0|            0|            0|  0.00%|        self.default_factory = default_factory
   903|         0|            0|            0|  0.00%|
   904|         0|            0|            0|  0.00%|    if not typing.TYPE_CHECKING:
   905|         0|            0|            0|  0.00%|        # We put `__getattr__` in a non-TYPE_CHECKING block because otherwise, mypy allows arbitrary attribute access
   906|         0|            0|            0|  0.00%|
   907|         0|            0|            0|  0.00%|        def __getattr__(self, item: str) -> Any:
   908|         0|            0|            0|  0.00%|            """This function improves compatibility with custom descriptors by ensuring delegation happens
   909|         0|            0|            0|  0.00%|            as expected when the default value of a private attribute is a descriptor.
   910|         0|            0|            0|  0.00%|            """
   911|         0|            0|            0|  0.00%|            if item in {'__get__', '__set__', '__delete__'}:
   912|         0|            0|            0|  0.00%|                if hasattr(self.default, item):
   913|         0|            0|            0|  0.00%|                    return getattr(self.default, item)
   914|         0|            0|            0|  0.00%|            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
   915|         0|            0|            0|  0.00%|
   916|         0|            0|            0|  0.00%|    def __set_name__(self, cls: type[Any], name: str) -> None:
   917|         0|            0|            0|  0.00%|        """Preserve `__set_name__` protocol defined in https://peps.python.org/pep-0487."""
   918|         0|            0|            0|  0.00%|        if self.default is PydanticUndefined:
   919|         0|            0|            0|  0.00%|            return
   920|         0|            0|            0|  0.00%|        if not hasattr(self.default, '__set_name__'):
   921|         0|            0|            0|  0.00%|            return
   922|         0|            0|            0|  0.00%|        set_name = self.default.__set_name__
   923|         0|            0|            0|  0.00%|        if callable(set_name):
   924|         0|            0|            0|  0.00%|            set_name(cls, name)
   925|         0|            0|            0|  0.00%|
   926|         0|            0|            0|  0.00%|    def get_default(self) -> Any:
   927|         0|            0|            0|  0.00%|        """Retrieve the default value of the object.
   928|         0|            0|            0|  0.00%|
   929|         0|            0|            0|  0.00%|        If `self.default_factory` is `None`, the method will return a deep copy of the `self.default` object.
   930|         0|            0|            0|  0.00%|
   931|         0|            0|            0|  0.00%|        If `self.default_factory` is not `None`, it will call `self.default_factory` and return the value returned.
   932|         0|            0|            0|  0.00%|
   933|         0|            0|            0|  0.00%|        Returns:
   934|         0|            0|            0|  0.00%|            The default value of the object.
   935|         0|            0|            0|  0.00%|        """
   936|         0|            0|            0|  0.00%|        return _utils.smart_deepcopy(self.default) if self.default_factory is None else self.default_factory()
   937|         0|            0|            0|  0.00%|
   938|         0|            0|            0|  0.00%|    def __eq__(self, other: Any) -> bool:
   939|         0|            0|            0|  0.00%|        return isinstance(other, self.__class__) and (self.default, self.default_factory) == (
   940|         0|            0|            0|  0.00%|            other.default,
   941|         0|            0|            0|  0.00%|            other.default_factory,
   942|         0|            0|            0|  0.00%|        )
   943|         0|            0|            0|  0.00%|
   944|         0|            0|            0|  0.00%|
   945|         0|            0|            0|  0.00%|def PrivateAttr(
   946|         0|            0|            0|  0.00%|    default: Any = PydanticUndefined,
   947|         0|            0|            0|  0.00%|    *,
   948|         0|            0|            0|  0.00%|    default_factory: typing.Callable[[], Any] | None = None,
   949|         0|            0|            0|  0.00%|    init: Literal[False] = False,
   950|         0|            0|            0|  0.00%|) -> Any:
   951|         0|            0|            0|  0.00%|    """Usage docs: https://docs.pydantic.dev/2.8/concepts/models/#private-model-attributes
   952|         0|            0|            0|  0.00%|
   953|         0|            0|            0|  0.00%|    Indicates that an attribute is intended for private use and not handled during normal validation/serialization.
   954|         0|            0|            0|  0.00%|
   955|         0|            0|            0|  0.00%|    Private attributes are not validated by Pydantic, so it's up to you to ensure they are used in a type-safe manner.
   956|         0|            0|            0|  0.00%|
   957|         0|            0|            0|  0.00%|    Private attributes are stored in `__private_attributes__` on the model.
   958|         0|            0|            0|  0.00%|
   959|         0|            0|            0|  0.00%|    Args:
   960|         0|            0|            0|  0.00%|        default: The attribute's default value. Defaults to Undefined.
   961|         0|            0|            0|  0.00%|        default_factory: Callable that will be
   962|         0|            0|            0|  0.00%|            called when a default value is needed for this attribute.
   963|         0|            0|            0|  0.00%|            If both `default` and `default_factory` are set, an error will be raised.
   964|         0|            0|            0|  0.00%|        init: Whether the attribute should be included in the constructor of the dataclass. Always `False`.
   965|         0|            0|            0|  0.00%|
   966|         0|            0|            0|  0.00%|    Returns:
   967|         0|            0|            0|  0.00%|        An instance of [`ModelPrivateAttr`][pydantic.fields.ModelPrivateAttr] class.
   968|         0|            0|            0|  0.00%|
   969|         0|            0|            0|  0.00%|    Raises:
   970|         0|            0|            0|  0.00%|        ValueError: If both `default` and `default_factory` are set.
   971|         0|            0|            0|  0.00%|    """
   972|         0|            0|            0|  0.00%|    if default is not PydanticUndefined and default_factory is not None:
   973|         0|            0|            0|  0.00%|        raise TypeError('cannot specify both default and default_factory')
   974|         0|            0|            0|  0.00%|
   975|         0|            0|            0|  0.00%|    return ModelPrivateAttr(
   976|         0|            0|            0|  0.00%|        default,
   977|         0|            0|            0|  0.00%|        default_factory=default_factory,
   978|         0|            0|            0|  0.00%|    )
   979|         0|            0|            0|  0.00%|
   980|         0|            0|            0|  0.00%|
   981|         0|            0|            0|  0.00%|@dataclasses.dataclass(**_internal_dataclass.slots_true)
   982|         0|            0|            0|  0.00%|class ComputedFieldInfo:
   983|         0|            0|            0|  0.00%|    """A container for data from `@computed_field` so that we can access it while building the pydantic-core schema.
   984|         0|            0|            0|  0.00%|
   985|         0|            0|            0|  0.00%|    Attributes:
   986|         0|            0|            0|  0.00%|        decorator_repr: A class variable representing the decorator string, '@computed_field'.
   987|         0|            0|            0|  0.00%|        wrapped_property: The wrapped computed field property.
   988|         0|            0|            0|  0.00%|        return_type: The type of the computed field property's return value.
   989|         0|            0|            0|  0.00%|        alias: The alias of the property to be used during serialization.
   990|         0|            0|            0|  0.00%|        alias_priority: The priority of the alias. This affects whether an alias generator is used.
   991|         0|            0|            0|  0.00%|        title: Title of the computed field to include in the serialization JSON schema.
   992|         0|            0|            0|  0.00%|        field_title_generator: A callable that takes a field name and returns title for it.
   993|         0|            0|            0|  0.00%|        description: Description of the computed field to include in the serialization JSON schema.
   994|         0|            0|            0|  0.00%|        deprecated: A deprecation message, an instance of `warnings.deprecated` or the `typing_extensions.deprecated` backport,
   995|         0|            0|            0|  0.00%|            or a boolean. If `True`, a default deprecation message will be emitted when accessing the field.
   996|         0|            0|            0|  0.00%|        examples: Example values of the computed field to include in the serialization JSON schema.
   997|         0|            0|            0|  0.00%|        json_schema_extra: A dict or callable to provide extra JSON schema properties.
   998|         0|            0|            0|  0.00%|        repr: A boolean indicating whether to include the field in the __repr__ output.
   999|         0|            0|            0|  0.00%|    """
  1000|         0|            0|            0|  0.00%|
  1001|         0|            0|            0|  0.00%|    decorator_repr: ClassVar[str] = '@computed_field'
  1002|         0|            0|            0|  0.00%|    wrapped_property: property
  1003|         0|            0|            0|  0.00%|    return_type: Any
  1004|         0|            0|            0|  0.00%|    alias: str | None
  1005|         0|            0|            0|  0.00%|    alias_priority: int | None
  1006|         0|            0|            0|  0.00%|    title: str | None
  1007|         0|            0|            0|  0.00%|    field_title_generator: typing.Callable[[str, ComputedFieldInfo], str] | None
  1008|         0|            0|            0|  0.00%|    description: str | None
  1009|         0|            0|            0|  0.00%|    deprecated: Deprecated | str | bool | None
  1010|         0|            0|            0|  0.00%|    examples: list[Any] | None
  1011|         0|            0|            0|  0.00%|    json_schema_extra: JsonDict | typing.Callable[[JsonDict], None] | None
  1012|         0|            0|            0|  0.00%|    repr: bool
  1013|         0|            0|            0|  0.00%|
  1014|         0|            0|            0|  0.00%|    @property
  1015|         0|            0|            0|  0.00%|    def deprecation_message(self) -> str | None:
  1016|         0|            0|            0|  0.00%|        """The deprecation message to be emitted, or `None` if not set."""
  1017|         0|            0|            0|  0.00%|        if self.deprecated is None:
  1018|         0|            0|            0|  0.00%|            return None
  1019|         0|            0|            0|  0.00%|        if isinstance(self.deprecated, bool):
  1020|         0|            0|            0|  0.00%|            return 'deprecated' if self.deprecated else None
  1021|         0|            0|            0|  0.00%|        return self.deprecated if isinstance(self.deprecated, str) else self.deprecated.message
  1022|         0|            0|            0|  0.00%|
  1023|         0|            0|            0|  0.00%|
  1024|         0|            0|            0|  0.00%|def _wrapped_property_is_private(property_: cached_property | property) -> bool:  # type: ignore
  1025|         0|            0|            0|  0.00%|    """Returns true if provided property is private, False otherwise."""
  1026|         0|            0|            0|  0.00%|    wrapped_name: str = ''
  1027|         0|            0|            0|  0.00%|
  1028|         0|            0|            0|  0.00%|    if isinstance(property_, property):
  1029|         0|            0|            0|  0.00%|        wrapped_name = getattr(property_.fget, '__name__', '')
  1030|         0|            0|            0|  0.00%|    elif isinstance(property_, cached_property):  # type: ignore
  1031|         0|            0|            0|  0.00%|        wrapped_name = getattr(property_.func, '__name__', '')  # type: ignore
  1032|         0|            0|            0|  0.00%|
  1033|         0|            0|            0|  0.00%|    return wrapped_name.startswith('_') and not wrapped_name.startswith('__')
  1034|         0|            0|            0|  0.00%|
  1035|         0|            0|            0|  0.00%|
  1036|         0|            0|            0|  0.00%|# this should really be `property[T], cached_property[T]` but property is not generic unlike cached_property
  1037|         0|            0|            0|  0.00%|# See https://github.com/python/typing/issues/985 and linked issues
  1038|         0|            0|            0|  0.00%|PropertyT = typing.TypeVar('PropertyT')
  1039|         0|            0|            0|  0.00%|
  1040|         0|            0|            0|  0.00%|
  1041|         0|            0|            0|  0.00%|@typing.overload
  1042|         0|            0|            0|  0.00%|def computed_field(
  1043|         0|            0|            0|  0.00%|    *,
  1044|         0|            0|            0|  0.00%|    alias: str | None = None,
  1045|         0|            0|            0|  0.00%|    alias_priority: int | None = None,
  1046|         0|            0|            0|  0.00%|    title: str | None = None,
  1047|         0|            0|            0|  0.00%|    field_title_generator: typing.Callable[[str, ComputedFieldInfo], str] | None = None,
  1048|         0|            0|            0|  0.00%|    description: str | None = None,
  1049|         0|            0|            0|  0.00%|    deprecated: Deprecated | str | bool | None = None,
  1050|         0|            0|            0|  0.00%|    examples: list[Any] | None = None,
  1051|         0|            0|            0|  0.00%|    json_schema_extra: JsonDict | typing.Callable[[JsonDict], None] | None = None,
  1052|         0|            0|            0|  0.00%|    repr: bool = True,
  1053|         0|            0|            0|  0.00%|    return_type: Any = PydanticUndefined,
  1054|         0|            0|            0|  0.00%|) -> typing.Callable[[PropertyT], PropertyT]: ...
  1055|         0|            0|            0|  0.00%|
  1056|         0|            0|            0|  0.00%|
  1057|         0|            0|            0|  0.00%|@typing.overload
  1058|         0|            0|            0|  0.00%|def computed_field(__func: PropertyT) -> PropertyT: ...
  1059|         0|            0|            0|  0.00%|
  1060|         0|            0|            0|  0.00%|
  1061|         0|            0|            0|  0.00%|def computed_field(
  1062|         0|            0|            0|  0.00%|    func: PropertyT | None = None,
  1063|         0|            0|            0|  0.00%|    /,
  1064|         0|            0|            0|  0.00%|    *,
  1065|         0|            0|            0|  0.00%|    alias: str | None = None,
  1066|         0|            0|            0|  0.00%|    alias_priority: int | None = None,
  1067|         0|            0|            0|  0.00%|    title: str | None = None,
  1068|         0|            0|            0|  0.00%|    field_title_generator: typing.Callable[[str, ComputedFieldInfo], str] | None = None,
  1069|         0|            0|            0|  0.00%|    description: str | None = None,
  1070|         0|            0|            0|  0.00%|    deprecated: Deprecated | str | bool | None = None,
  1071|         0|            0|            0|  0.00%|    examples: list[Any] | None = None,
  1072|         0|            0|            0|  0.00%|    json_schema_extra: JsonDict | typing.Callable[[JsonDict], None] | None = None,
  1073|         0|            0|            0|  0.00%|    repr: bool | None = None,
  1074|         0|            0|            0|  0.00%|    return_type: Any = PydanticUndefined,
  1075|         0|            0|            0|  0.00%|) -> PropertyT | typing.Callable[[PropertyT], PropertyT]:
  1076|         0|            0|            0|  0.00%|    """Usage docs: https://docs.pydantic.dev/2.8/concepts/fields#the-computed_field-decorator
  1077|         0|            0|            0|  0.00%|
  1078|         0|            0|            0|  0.00%|    Decorator to include `property` and `cached_property` when serializing models or dataclasses.
  1079|         0|            0|            0|  0.00%|
  1080|         0|            0|            0|  0.00%|    This is useful for fields that are computed from other fields, or for fields that are expensive to compute and should be cached.
  1081|         0|            0|            0|  0.00%|
  1082|         0|            0|            0|  0.00%|    ```py
  1083|         0|            0|            0|  0.00%|    from pydantic import BaseModel, computed_field
  1084|         0|            0|            0|  0.00%|
  1085|         0|            0|            0|  0.00%|    class Rectangle(BaseModel):
  1086|         0|            0|            0|  0.00%|        width: int
  1087|         0|            0|            0|  0.00%|        length: int
  1088|         0|            0|            0|  0.00%|
  1089|         0|            0|            0|  0.00%|        @computed_field
  1090|         0|            0|            0|  0.00%|        @property
  1091|         0|            0|            0|  0.00%|        def area(self) -> int:
  1092|         0|            0|            0|  0.00%|            return self.width * self.length
  1093|         0|            0|            0|  0.00%|
  1094|         0|            0|            0|  0.00%|    print(Rectangle(width=3, length=2).model_dump())
  1095|         0|            0|            0|  0.00%|    #> {'width': 3, 'length': 2, 'area': 6}
  1096|         0|            0|            0|  0.00%|    ```
  1097|         0|            0|            0|  0.00%|
  1098|         0|            0|            0|  0.00%|    If applied to functions not yet decorated with `@property` or `@cached_property`, the function is
  1099|         0|            0|            0|  0.00%|    automatically wrapped with `property`. Although this is more concise, you will lose IntelliSense in your IDE,
  1100|         0|            0|            0|  0.00%|    and confuse static type checkers, thus explicit use of `@property` is recommended.
  1101|         0|            0|            0|  0.00%|
  1102|         0|            0|            0|  0.00%|    !!! warning "Mypy Warning"
  1103|         0|            0|            0|  0.00%|        Even with the `@property` or `@cached_property` applied to your function before `@computed_field`,
  1104|         0|            0|            0|  0.00%|        mypy may throw a `Decorated property not supported` error.
  1105|         0|            0|            0|  0.00%|        See [mypy issue #1362](https://github.com/python/mypy/issues/1362), for more information.
  1106|         0|            0|            0|  0.00%|        To avoid this error message, add `# type: ignore[misc]` to the `@computed_field` line.
  1107|         0|            0|            0|  0.00%|
  1108|         0|            0|            0|  0.00%|        [pyright](https://github.com/microsoft/pyright) supports `@computed_field` without error.
  1109|         0|            0|            0|  0.00%|
  1110|         0|            0|            0|  0.00%|    ```py
  1111|         0|            0|            0|  0.00%|    import random
  1112|         0|            0|            0|  0.00%|
  1113|         0|            0|            0|  0.00%|    from pydantic import BaseModel, computed_field
  1114|         0|            0|            0|  0.00%|
  1115|         0|            0|            0|  0.00%|    class Square(BaseModel):
  1116|         0|            0|            0|  0.00%|        width: float
  1117|         0|            0|            0|  0.00%|
  1118|         0|            0|            0|  0.00%|        @computed_field
  1119|         0|            0|            0|  0.00%|        def area(self) -> float:  # converted to a `property` by `computed_field`
  1120|         0|            0|            0|  0.00%|            return round(self.width**2, 2)
  1121|         0|            0|            0|  0.00%|
  1122|         0|            0|            0|  0.00%|        @area.setter
  1123|         0|            0|            0|  0.00%|        def area(self, new_area: float) -> None:
  1124|         0|            0|            0|  0.00%|            self.width = new_area**0.5
  1125|         0|            0|            0|  0.00%|
  1126|         0|            0|            0|  0.00%|        @computed_field(alias='the magic number', repr=False)
  1127|         0|            0|            0|  0.00%|        def random_number(self) -> int:
  1128|         0|            0|            0|  0.00%|            return random.randint(0, 1_000)
  1129|         0|            0|            0|  0.00%|
  1130|         0|            0|            0|  0.00%|    square = Square(width=1.3)
  1131|         0|            0|            0|  0.00%|
  1132|         0|            0|            0|  0.00%|    # `random_number` does not appear in representation
  1133|         0|            0|            0|  0.00%|    print(repr(square))
  1134|         0|            0|            0|  0.00%|    #> Square(width=1.3, area=1.69)
  1135|         0|            0|            0|  0.00%|
  1136|         0|            0|            0|  0.00%|    print(square.random_number)
  1137|         0|            0|            0|  0.00%|    #> 3
  1138|         0|            0|            0|  0.00%|
  1139|         0|            0|            0|  0.00%|    square.area = 4
  1140|         0|            0|            0|  0.00%|
  1141|         0|            0|            0|  0.00%|    print(square.model_dump_json(by_alias=True))
  1142|         0|            0|            0|  0.00%|    #> {"width":2.0,"area":4.0,"the magic number":3}
  1143|         0|            0|            0|  0.00%|    ```
  1144|         0|            0|            0|  0.00%|
  1145|         0|            0|            0|  0.00%|    !!! warning "Overriding with `computed_field`"
  1146|         0|            0|            0|  0.00%|        You can't override a field from a parent class with a `computed_field` in the child class.
  1147|         0|            0|            0|  0.00%|        `mypy` complains about this behavior if allowed, and `dataclasses` doesn't allow this pattern either.
  1148|         0|            0|            0|  0.00%|        See the example below:
  1149|         0|            0|            0|  0.00%|
  1150|         0|            0|            0|  0.00%|    ```py
  1151|         0|            0|            0|  0.00%|    from pydantic import BaseModel, computed_field
  1152|         0|            0|            0|  0.00%|
  1153|         0|            0|            0|  0.00%|    class Parent(BaseModel):
  1154|         0|            0|            0|  0.00%|        a: str
  1155|         0|            0|            0|  0.00%|
  1156|         0|            0|            0|  0.00%|    try:
  1157|         0|            0|            0|  0.00%|
  1158|         0|            0|            0|  0.00%|        class Child(Parent):
  1159|         0|            0|            0|  0.00%|            @computed_field
  1160|         0|            0|            0|  0.00%|            @property
  1161|         0|            0|            0|  0.00%|            def a(self) -> str:
  1162|         0|            0|            0|  0.00%|                return 'new a'
  1163|         0|            0|            0|  0.00%|
  1164|         0|            0|            0|  0.00%|    except ValueError as e:
  1165|         0|            0|            0|  0.00%|        print(repr(e))
  1166|         0|            0|            0|  0.00%|        #> ValueError("you can't override a field with a computed field")
  1167|         0|            0|            0|  0.00%|    ```
  1168|         0|            0|            0|  0.00%|
  1169|         0|            0|            0|  0.00%|    Private properties decorated with `@computed_field` have `repr=False` by default.
  1170|         0|            0|            0|  0.00%|
  1171|         0|            0|            0|  0.00%|    ```py
  1172|         0|            0|            0|  0.00%|    from functools import cached_property
  1173|         0|            0|            0|  0.00%|
  1174|         0|            0|            0|  0.00%|    from pydantic import BaseModel, computed_field
  1175|         0|            0|            0|  0.00%|
  1176|         0|            0|            0|  0.00%|    class Model(BaseModel):
  1177|         0|            0|            0|  0.00%|        foo: int
  1178|         0|            0|            0|  0.00%|
  1179|         0|            0|            0|  0.00%|        @computed_field
  1180|         0|            0|            0|  0.00%|        @cached_property
  1181|         0|            0|            0|  0.00%|        def _private_cached_property(self) -> int:
  1182|         0|            0|            0|  0.00%|            return -self.foo
  1183|         0|            0|            0|  0.00%|
  1184|         0|            0|            0|  0.00%|        @computed_field
  1185|         0|            0|            0|  0.00%|        @property
  1186|         0|            0|            0|  0.00%|        def _private_property(self) -> int:
  1187|         0|            0|            0|  0.00%|            return -self.foo
  1188|         0|            0|            0|  0.00%|
  1189|         0|            0|            0|  0.00%|    m = Model(foo=1)
  1190|         0|            0|            0|  0.00%|    print(repr(m))
  1191|         0|            0|            0|  0.00%|    #> M(foo=1)
  1192|         0|            0|            0|  0.00%|    ```
  1193|         0|            0|            0|  0.00%|
  1194|         0|            0|            0|  0.00%|    Args:
  1195|         0|            0|            0|  0.00%|        func: the function to wrap.
  1196|         0|            0|            0|  0.00%|        alias: alias to use when serializing this computed field, only used when `by_alias=True`
  1197|         0|            0|            0|  0.00%|        alias_priority: priority of the alias. This affects whether an alias generator is used
  1198|         0|            0|            0|  0.00%|        title: Title to use when including this computed field in JSON Schema
  1199|         0|            0|            0|  0.00%|        field_title_generator: A callable that takes a field name and returns title for it.
  1200|         0|            0|            0|  0.00%|        description: Description to use when including this computed field in JSON Schema, defaults to the function's
  1201|         0|            0|            0|  0.00%|            docstring
  1202|         0|            0|            0|  0.00%|        deprecated: A deprecation message (or an instance of `warnings.deprecated` or the `typing_extensions.deprecated` backport).
  1203|         0|            0|            0|  0.00%|            to be emitted when accessing the field. Or a boolean. This will automatically be set if the property is decorated with the
  1204|         0|            0|            0|  0.00%|            `deprecated` decorator.
  1205|         0|            0|            0|  0.00%|        examples: Example values to use when including this computed field in JSON Schema
  1206|         0|            0|            0|  0.00%|        json_schema_extra: A dict or callable to provide extra JSON schema properties.
  1207|         0|            0|            0|  0.00%|        repr: whether to include this computed field in model repr.
  1208|         0|            0|            0|  0.00%|            Default is `False` for private properties and `True` for public properties.
  1209|         0|            0|            0|  0.00%|        return_type: optional return for serialization logic to expect when serializing to JSON, if included
  1210|         0|            0|            0|  0.00%|            this must be correct, otherwise a `TypeError` is raised.
  1211|         0|            0|            0|  0.00%|            If you don't include a return type Any is used, which does runtime introspection to handle arbitrary
  1212|         0|            0|            0|  0.00%|            objects.
  1213|         0|            0|            0|  0.00%|
  1214|         0|            0|            0|  0.00%|    Returns:
  1215|         0|            0|            0|  0.00%|        A proxy wrapper for the property.
  1216|         0|            0|            0|  0.00%|    """
  1217|         0|            0|            0|  0.00%|
  1218|         0|            0|            0|  0.00%|    def dec(f: Any) -> Any:
  1219|         0|            0|            0|  0.00%|        nonlocal description, deprecated, return_type, alias_priority
  1220|         0|            0|            0|  0.00%|        unwrapped = _decorators.unwrap_wrapped_function(f)
  1221|         0|            0|            0|  0.00%|
  1222|         0|            0|            0|  0.00%|        if description is None and unwrapped.__doc__:
  1223|         0|            0|            0|  0.00%|            description = inspect.cleandoc(unwrapped.__doc__)
  1224|         0|            0|            0|  0.00%|
  1225|         0|            0|            0|  0.00%|        if deprecated is None and hasattr(unwrapped, '__deprecated__'):
  1226|         0|            0|            0|  0.00%|            deprecated = unwrapped.__deprecated__
  1227|         0|            0|            0|  0.00%|
  1228|         0|            0|            0|  0.00%|        # if the function isn't already decorated with `@property` (or another descriptor), then we wrap it now
  1229|         0|            0|            0|  0.00%|        f = _decorators.ensure_property(f)
  1230|         0|            0|            0|  0.00%|        alias_priority = (alias_priority or 2) if alias is not None else None
  1231|         0|            0|            0|  0.00%|
  1232|         0|            0|            0|  0.00%|        if repr is None:
  1233|         0|            0|            0|  0.00%|            repr_: bool = not _wrapped_property_is_private(property_=f)
  1234|         0|            0|            0|  0.00%|        else:
  1235|         0|            0|            0|  0.00%|            repr_ = repr
  1236|         0|            0|            0|  0.00%|
  1237|         0|            0|            0|  0.00%|        dec_info = ComputedFieldInfo(
  1238|         0|            0|            0|  0.00%|            f,
  1239|         0|            0|            0|  0.00%|            return_type,
  1240|         0|            0|            0|  0.00%|            alias,
  1241|         0|            0|            0|  0.00%|            alias_priority,
  1242|         0|            0|            0|  0.00%|            title,
  1243|         0|            0|            0|  0.00%|            field_title_generator,
  1244|         0|            0|            0|  0.00%|            description,
  1245|         0|            0|            0|  0.00%|            deprecated,
  1246|         0|            0|            0|  0.00%|            examples,
  1247|         0|            0|            0|  0.00%|            json_schema_extra,
  1248|         0|            0|            0|  0.00%|            repr_,
  1249|         0|            0|            0|  0.00%|        )
  1250|         0|            0|            0|  0.00%|        return _decorators.PydanticDescriptorProxy(f, dec_info)
  1251|         0|            0|            0|  0.00%|
  1252|         0|            0|            0|  0.00%|    if func is None:
  1253|         0|            0|            0|  0.00%|        return dec
  1254|         0|            0|            0|  0.00%|    else:
  1255|         0|            0|            0|  0.00%|        return dec(func)
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/_compat.py
File duration: 0.000635147s (0.65%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|from collections import deque
     2|         2|  5.00679e-06|   2.5034e-06|  0.01%|from copy import copy
     3|         2|  3.09944e-06|  1.54972e-06|  0.00%|from dataclasses import dataclass, is_dataclass
     4|         2|   2.6226e-06|   1.3113e-06|  0.00%|from enum import Enum
     5|         2|  2.86102e-06|  1.43051e-06|  0.00%|from typing import (
     6|         2|  1.66893e-05|  8.34465e-06|  0.02%|    Any,
(call)|         2|    0.0130608|    0.0065304| 13.43%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/_compat.py:108 __post_init__
     7|         0|            0|            0|  0.00%|    Callable,
     8|         0|            0|            0|  0.00%|    Deque,
     9|         0|            0|            0|  0.00%|    Dict,
    10|         0|            0|            0|  0.00%|    FrozenSet,
    11|         0|            0|            0|  0.00%|    List,
    12|         0|            0|            0|  0.00%|    Mapping,
    13|         0|            0|            0|  0.00%|    Sequence,
    14|         0|            0|            0|  0.00%|    Set,
    15|         0|            0|            0|  0.00%|    Tuple,
    16|         0|            0|            0|  0.00%|    Type,
    17|         0|            0|            0|  0.00%|    Union,
    18|         0|            0|            0|  0.00%|)
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|from fastapi.exceptions import RequestErrorModel
    21|         0|            0|            0|  0.00%|from fastapi.types import IncEx, ModelNameMap, UnionType
    22|         0|            0|            0|  0.00%|from pydantic import BaseModel, create_model
    23|         0|            0|            0|  0.00%|from pydantic.version import VERSION as P_VERSION
    24|         0|            0|            0|  0.00%|from starlette.datastructures import UploadFile
    25|         0|            0|            0|  0.00%|from typing_extensions import Annotated, Literal, get_args, get_origin
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|# Reassign variable to make it reexported for mypy
    28|         0|            0|            0|  0.00%|PYDANTIC_VERSION = P_VERSION
    29|         0|            0|            0|  0.00%|PYDANTIC_V2 = PYDANTIC_VERSION.startswith("2.")
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|sequence_annotation_to_type = {
    33|         0|            0|            0|  0.00%|    Sequence: list,
    34|         0|            0|            0|  0.00%|    List: list,
    35|         0|            0|            0|  0.00%|    list: list,
    36|         0|            0|            0|  0.00%|    Tuple: tuple,
    37|         0|            0|            0|  0.00%|    tuple: tuple,
    38|         0|            0|            0|  0.00%|    Set: set,
    39|         0|            0|            0|  0.00%|    set: set,
    40|         0|            0|            0|  0.00%|    FrozenSet: frozenset,
    41|         0|            0|            0|  0.00%|    frozenset: frozenset,
    42|         0|            0|            0|  0.00%|    Deque: deque,
    43|         0|            0|            0|  0.00%|    deque: deque,
    44|         0|            0|            0|  0.00%|}
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|sequence_types = tuple(sequence_annotation_to_type.keys())
    47|         0|            0|            0|  0.00%|
    48|         0|            0|            0|  0.00%|if PYDANTIC_V2:
    49|         0|            0|            0|  0.00%|    from pydantic import PydanticSchemaGenerationError as PydanticSchemaGenerationError
    50|         0|            0|            0|  0.00%|    from pydantic import TypeAdapter
    51|         0|            0|            0|  0.00%|    from pydantic import ValidationError as ValidationError
    52|         0|            0|            0|  0.00%|    from pydantic._internal._schema_generation_shared import (  # type: ignore[attr-defined]
    53|         0|            0|            0|  0.00%|        GetJsonSchemaHandler as GetJsonSchemaHandler,
    54|         0|            0|            0|  0.00%|    )
    55|         0|            0|            0|  0.00%|    from pydantic._internal._typing_extra import eval_type_lenient
    56|         0|            0|            0|  0.00%|    from pydantic._internal._utils import lenient_issubclass as lenient_issubclass
    57|         0|            0|            0|  0.00%|    from pydantic.fields import FieldInfo
    58|         0|            0|            0|  0.00%|    from pydantic.json_schema import GenerateJsonSchema as GenerateJsonSchema
    59|         0|            0|            0|  0.00%|    from pydantic.json_schema import JsonSchemaValue as JsonSchemaValue
    60|         0|            0|            0|  0.00%|    from pydantic_core import CoreSchema as CoreSchema
    61|         0|            0|            0|  0.00%|    from pydantic_core import PydanticUndefined, PydanticUndefinedType
    62|         0|            0|            0|  0.00%|    from pydantic_core import Url as Url
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|    try:
    65|         0|            0|            0|  0.00%|        from pydantic_core.core_schema import (
    66|         0|            0|            0|  0.00%|            with_info_plain_validator_function as with_info_plain_validator_function,
    67|         0|            0|            0|  0.00%|        )
    68|         0|            0|            0|  0.00%|    except ImportError:  # pragma: no cover
    69|         0|            0|            0|  0.00%|        from pydantic_core.core_schema import (
    70|         0|            0|            0|  0.00%|            general_plain_validator_function as with_info_plain_validator_function,  # noqa: F401
    71|         0|            0|            0|  0.00%|        )
    72|         0|            0|            0|  0.00%|
    73|         0|            0|            0|  0.00%|    Required = PydanticUndefined
    74|         0|            0|            0|  0.00%|    Undefined = PydanticUndefined
    75|         0|            0|            0|  0.00%|    UndefinedType = PydanticUndefinedType
    76|         0|            0|            0|  0.00%|    evaluate_forwardref = eval_type_lenient
    77|         0|            0|            0|  0.00%|    Validator = Any
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|    class BaseConfig:
    80|         0|            0|            0|  0.00%|        pass
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|    class ErrorWrapper(Exception):
    83|         0|            0|            0|  0.00%|        pass
    84|         0|            0|            0|  0.00%|
    85|         0|            0|            0|  0.00%|    @dataclass
    86|         0|            0|            0|  0.00%|    class ModelField:
    87|         0|            0|            0|  0.00%|        field_info: FieldInfo
    88|         0|            0|            0|  0.00%|        name: str
    89|         0|            0|            0|  0.00%|        mode: Literal["validation", "serialization"] = "validation"
    90|         0|            0|            0|  0.00%|
    91|         0|            0|            0|  0.00%|        @property
    92|         0|            0|            0|  0.00%|        def alias(self) -> str:
    93|         0|            0|            0|  0.00%|            a = self.field_info.alias
    94|         0|            0|            0|  0.00%|            return a if a is not None else self.name
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|        @property
    97|         0|            0|            0|  0.00%|        def required(self) -> bool:
    98|         0|            0|            0|  0.00%|            return self.field_info.is_required()
    99|         0|            0|            0|  0.00%|
   100|         0|            0|            0|  0.00%|        @property
   101|         0|            0|            0|  0.00%|        def default(self) -> Any:
   102|         0|            0|            0|  0.00%|            return self.get_default()
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|        @property
   105|         0|            0|            0|  0.00%|        def type_(self) -> Any:
   106|         0|            0|            0|  0.00%|            return self.field_info.annotation
   107|         0|            0|            0|  0.00%|
   108|         2|  5.48363e-06|  2.74181e-06|  0.01%|        def __post_init__(self) -> None:
   109|         4|  3.60012e-05|   9.0003e-06|  0.04%|            self._type_adapter: TypeAdapter[Any] = TypeAdapter(
(call)|         2|      0.01228|   0.00613999| 12.62%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/type_adapter.py:196 __init__
   110|         2|  1.54972e-05|   7.7486e-06|  0.02%|                Annotated[self.field_info.annotation, self.field_info]
(call)|         2|  0.000723839|  0.000361919|  0.74%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:2087 __class_getitem__
   111|         0|            0|            0|  0.00%|            )
   112|         0|            0|            0|  0.00%|
   113|         0|            0|            0|  0.00%|        def get_default(self) -> Any:
   114|         0|            0|            0|  0.00%|            if self.field_info.is_required():
   115|         0|            0|            0|  0.00%|                return Undefined
   116|         0|            0|            0|  0.00%|            return self.field_info.get_default(call_default_factory=True)
   117|         0|            0|            0|  0.00%|
   118|         0|            0|            0|  0.00%|        def validate(
   119|         0|            0|            0|  0.00%|            self,
   120|         0|            0|            0|  0.00%|            value: Any,
   121|         0|            0|            0|  0.00%|            values: Dict[str, Any] = {},  # noqa: B006
   122|         0|            0|            0|  0.00%|            *,
   123|         0|            0|            0|  0.00%|            loc: Tuple[Union[int, str], ...] = (),
   124|         0|            0|            0|  0.00%|        ) -> Tuple[Any, Union[List[Dict[str, Any]], None]]:
   125|         0|            0|            0|  0.00%|            try:
   126|         0|            0|            0|  0.00%|                return (
   127|         0|            0|            0|  0.00%|                    self._type_adapter.validate_python(value, from_attributes=True),
   128|         0|            0|            0|  0.00%|                    None,
   129|         0|            0|            0|  0.00%|                )
   130|         0|            0|            0|  0.00%|            except ValidationError as exc:
   131|         0|            0|            0|  0.00%|                return None, _regenerate_error_with_loc(
   132|         0|            0|            0|  0.00%|                    errors=exc.errors(include_url=False), loc_prefix=loc
   133|         0|            0|            0|  0.00%|                )
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|        def serialize(
   136|         0|            0|            0|  0.00%|            self,
   137|         0|            0|            0|  0.00%|            value: Any,
   138|         0|            0|            0|  0.00%|            *,
   139|         0|            0|            0|  0.00%|            mode: Literal["json", "python"] = "json",
   140|         0|            0|            0|  0.00%|            include: Union[IncEx, None] = None,
   141|         0|            0|            0|  0.00%|            exclude: Union[IncEx, None] = None,
   142|         0|            0|            0|  0.00%|            by_alias: bool = True,
   143|         0|            0|            0|  0.00%|            exclude_unset: bool = False,
   144|         0|            0|            0|  0.00%|            exclude_defaults: bool = False,
   145|         0|            0|            0|  0.00%|            exclude_none: bool = False,
   146|         0|            0|            0|  0.00%|        ) -> Any:
   147|         0|            0|            0|  0.00%|            # What calls this code passes a value that already called
   148|         0|            0|            0|  0.00%|            # self._type_adapter.validate_python(value)
   149|         0|            0|            0|  0.00%|            return self._type_adapter.dump_python(
   150|         0|            0|            0|  0.00%|                value,
   151|         0|            0|            0|  0.00%|                mode=mode,
   152|         0|            0|            0|  0.00%|                include=include,
   153|         0|            0|            0|  0.00%|                exclude=exclude,
   154|         0|            0|            0|  0.00%|                by_alias=by_alias,
   155|         0|            0|            0|  0.00%|                exclude_unset=exclude_unset,
   156|         0|            0|            0|  0.00%|                exclude_defaults=exclude_defaults,
   157|         0|            0|            0|  0.00%|                exclude_none=exclude_none,
   158|         0|            0|            0|  0.00%|            )
   159|         0|            0|            0|  0.00%|
   160|         0|            0|            0|  0.00%|        def __hash__(self) -> int:
   161|         0|            0|            0|  0.00%|            # Each ModelField is unique for our purposes, to allow making a dict from
   162|         0|            0|            0|  0.00%|            # ModelField to its JSON Schema.
   163|         0|            0|            0|  0.00%|            return id(self)
   164|         0|            0|            0|  0.00%|
   165|         2|  1.38283e-05|  6.91414e-06|  0.01%|    def get_annotation_from_field_info(
   166|         0|            0|            0|  0.00%|        annotation: Any, field_info: FieldInfo, field_name: str
   167|         0|            0|            0|  0.00%|    ) -> Any:
   168|         2|   6.4373e-06|  3.21865e-06|  0.01%|        return annotation
   169|         0|            0|            0|  0.00%|
   170|         0|            0|            0|  0.00%|    def _normalize_errors(errors: Sequence[Any]) -> List[Dict[str, Any]]:
   171|         0|            0|            0|  0.00%|        return errors  # type: ignore[return-value]
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|    def _model_rebuild(model: Type[BaseModel]) -> None:
   174|         0|            0|            0|  0.00%|        model.model_rebuild()
   175|         0|            0|            0|  0.00%|
   176|         0|            0|            0|  0.00%|    def _model_dump(
   177|         0|            0|            0|  0.00%|        model: BaseModel, mode: Literal["json", "python"] = "json", **kwargs: Any
   178|         0|            0|            0|  0.00%|    ) -> Any:
   179|         0|            0|            0|  0.00%|        return model.model_dump(mode=mode, **kwargs)
   180|         0|            0|            0|  0.00%|
   181|         0|            0|            0|  0.00%|    def _get_model_config(model: BaseModel) -> Any:
   182|         0|            0|            0|  0.00%|        return model.model_config
   183|         0|            0|            0|  0.00%|
   184|         0|            0|            0|  0.00%|    def get_schema_from_model_field(
   185|         0|            0|            0|  0.00%|        *,
   186|         0|            0|            0|  0.00%|        field: ModelField,
   187|         0|            0|            0|  0.00%|        schema_generator: GenerateJsonSchema,
   188|         0|            0|            0|  0.00%|        model_name_map: ModelNameMap,
   189|         0|            0|            0|  0.00%|        field_mapping: Dict[
   190|         0|            0|            0|  0.00%|            Tuple[ModelField, Literal["validation", "serialization"]], JsonSchemaValue
   191|         0|            0|            0|  0.00%|        ],
   192|         0|            0|            0|  0.00%|        separate_input_output_schemas: bool = True,
   193|         0|            0|            0|  0.00%|    ) -> Dict[str, Any]:
   194|         0|            0|            0|  0.00%|        override_mode: Union[Literal["validation"], None] = (
   195|         0|            0|            0|  0.00%|            None if separate_input_output_schemas else "validation"
   196|         0|            0|            0|  0.00%|        )
   197|         0|            0|            0|  0.00%|        # This expects that GenerateJsonSchema was already used to generate the definitions
   198|         0|            0|            0|  0.00%|        json_schema = field_mapping[(field, override_mode or field.mode)]
   199|         0|            0|            0|  0.00%|        if "$ref" not in json_schema:
   200|         0|            0|            0|  0.00%|            # TODO remove when deprecating Pydantic v1
   201|         0|            0|            0|  0.00%|            # Ref: https://github.com/pydantic/pydantic/blob/d61792cc42c80b13b23e3ffa74bc37ec7c77f7d1/pydantic/schema.py#L207
   202|         0|            0|            0|  0.00%|            json_schema["title"] = (
   203|         0|            0|            0|  0.00%|                field.field_info.title or field.alias.title().replace("_", " ")
   204|         0|            0|            0|  0.00%|            )
   205|         0|            0|            0|  0.00%|        return json_schema
   206|         0|            0|            0|  0.00%|
   207|         0|            0|            0|  0.00%|    def get_compat_model_name_map(fields: List[ModelField]) -> ModelNameMap:
   208|         0|            0|            0|  0.00%|        return {}
   209|         0|            0|            0|  0.00%|
   210|         0|            0|            0|  0.00%|    def get_definitions(
   211|         0|            0|            0|  0.00%|        *,
   212|         0|            0|            0|  0.00%|        fields: List[ModelField],
   213|         0|            0|            0|  0.00%|        schema_generator: GenerateJsonSchema,
   214|         0|            0|            0|  0.00%|        model_name_map: ModelNameMap,
   215|         0|            0|            0|  0.00%|        separate_input_output_schemas: bool = True,
   216|         0|            0|            0|  0.00%|    ) -> Tuple[
   217|         0|            0|            0|  0.00%|        Dict[
   218|         0|            0|            0|  0.00%|            Tuple[ModelField, Literal["validation", "serialization"]], JsonSchemaValue
   219|         0|            0|            0|  0.00%|        ],
   220|         0|            0|            0|  0.00%|        Dict[str, Dict[str, Any]],
   221|         0|            0|            0|  0.00%|    ]:
   222|         0|            0|            0|  0.00%|        override_mode: Union[Literal["validation"], None] = (
   223|         0|            0|            0|  0.00%|            None if separate_input_output_schemas else "validation"
   224|         0|            0|            0|  0.00%|        )
   225|         0|            0|            0|  0.00%|        inputs = [
   226|         0|            0|            0|  0.00%|            (field, override_mode or field.mode, field._type_adapter.core_schema)
   227|         0|            0|            0|  0.00%|            for field in fields
   228|         0|            0|            0|  0.00%|        ]
   229|         0|            0|            0|  0.00%|        field_mapping, definitions = schema_generator.generate_definitions(
   230|         0|            0|            0|  0.00%|            inputs=inputs
   231|         0|            0|            0|  0.00%|        )
   232|         0|            0|            0|  0.00%|        return field_mapping, definitions  # type: ignore[return-value]
   233|         0|            0|            0|  0.00%|
   234|         2|  2.67029e-05|  1.33514e-05|  0.03%|    def is_scalar_field(field: ModelField) -> bool:
   235|         2|  3.26633e-05|  1.63317e-05|  0.03%|        from fastapi import params
(call)|         2|  3.31402e-05|  1.65701e-05|  0.03%|# <frozen importlib._bootstrap>:1390 _handle_fromlist
   236|         0|            0|            0|  0.00%|
   237|         6|  2.09808e-05|  3.49681e-06|  0.02%|        return field_annotation_is_scalar(
(call)|         2|   0.00118995|  0.000594974|  1.22%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/_compat.py:565 field_annotation_is_scalar
   238|         2|  1.66893e-05|  8.34465e-06|  0.02%|            field.field_info.annotation
   239|         2|  4.29153e-06|  2.14577e-06|  0.00%|        ) and not isinstance(field.field_info, params.Body)
   240|         0|            0|            0|  0.00%|
   241|         0|            0|            0|  0.00%|    def is_sequence_field(field: ModelField) -> bool:
   242|         0|            0|            0|  0.00%|        return field_annotation_is_sequence(field.field_info.annotation)
   243|         0|            0|            0|  0.00%|
   244|         0|            0|            0|  0.00%|    def is_scalar_sequence_field(field: ModelField) -> bool:
   245|         0|            0|            0|  0.00%|        return field_annotation_is_scalar_sequence(field.field_info.annotation)
   246|         0|            0|            0|  0.00%|
   247|         0|            0|            0|  0.00%|    def is_bytes_field(field: ModelField) -> bool:
   248|         0|            0|            0|  0.00%|        return is_bytes_or_nonable_bytes_annotation(field.type_)
   249|         0|            0|            0|  0.00%|
   250|         0|            0|            0|  0.00%|    def is_bytes_sequence_field(field: ModelField) -> bool:
   251|         0|            0|            0|  0.00%|        return is_bytes_sequence_annotation(field.type_)
   252|         0|            0|            0|  0.00%|
   253|         0|            0|            0|  0.00%|    def copy_field_info(*, field_info: FieldInfo, annotation: Any) -> FieldInfo:
   254|         0|            0|            0|  0.00%|        cls = type(field_info)
   255|         0|            0|            0|  0.00%|        merged_field_info = cls.from_annotation(annotation)
   256|         0|            0|            0|  0.00%|        new_field_info = copy(field_info)
   257|         0|            0|            0|  0.00%|        new_field_info.metadata = merged_field_info.metadata
   258|         0|            0|            0|  0.00%|        new_field_info.annotation = merged_field_info.annotation
   259|         0|            0|            0|  0.00%|        return new_field_info
   260|         0|            0|            0|  0.00%|
   261|         0|            0|            0|  0.00%|    def serialize_sequence_value(*, field: ModelField, value: Any) -> Sequence[Any]:
   262|         0|            0|            0|  0.00%|        origin_type = (
   263|         0|            0|            0|  0.00%|            get_origin(field.field_info.annotation) or field.field_info.annotation
   264|         0|            0|            0|  0.00%|        )
   265|         0|            0|            0|  0.00%|        assert issubclass(origin_type, sequence_types)  # type: ignore[arg-type]
   266|         0|            0|            0|  0.00%|        return sequence_annotation_to_type[origin_type](value)  # type: ignore[no-any-return]
   267|         0|            0|            0|  0.00%|
   268|         0|            0|            0|  0.00%|    def get_missing_field_error(loc: Tuple[str, ...]) -> Dict[str, Any]:
   269|         0|            0|            0|  0.00%|        error = ValidationError.from_exception_data(
   270|         0|            0|            0|  0.00%|            "Field required", [{"type": "missing", "loc": loc, "input": {}}]
   271|         0|            0|            0|  0.00%|        ).errors(include_url=False)[0]
   272|         0|            0|            0|  0.00%|        error["input"] = None
   273|         0|            0|            0|  0.00%|        return error  # type: ignore[return-value]
   274|         0|            0|            0|  0.00%|
   275|         0|            0|            0|  0.00%|    def create_body_model(
   276|         0|            0|            0|  0.00%|        *, fields: Sequence[ModelField], model_name: str
   277|         0|            0|            0|  0.00%|    ) -> Type[BaseModel]:
   278|         0|            0|            0|  0.00%|        field_params = {f.name: (f.field_info.annotation, f.field_info) for f in fields}
   279|         0|            0|            0|  0.00%|        BodyModel: Type[BaseModel] = create_model(model_name, **field_params)  # type: ignore[call-overload]
   280|         0|            0|            0|  0.00%|        return BodyModel
   281|         0|            0|            0|  0.00%|
   282|         0|            0|            0|  0.00%|else:
   283|         0|            0|            0|  0.00%|    from fastapi.openapi.constants import REF_PREFIX as REF_PREFIX
   284|         0|            0|            0|  0.00%|    from pydantic import AnyUrl as Url  # noqa: F401
   285|         0|            0|            0|  0.00%|    from pydantic import (  # type: ignore[assignment]
   286|         0|            0|            0|  0.00%|        BaseConfig as BaseConfig,  # noqa: F401
   287|         0|            0|            0|  0.00%|    )
   288|         0|            0|            0|  0.00%|    from pydantic import ValidationError as ValidationError  # noqa: F401
   289|         0|            0|            0|  0.00%|    from pydantic.class_validators import (  # type: ignore[no-redef]
   290|         0|            0|            0|  0.00%|        Validator as Validator,  # noqa: F401
   291|         0|            0|            0|  0.00%|    )
   292|         0|            0|            0|  0.00%|    from pydantic.error_wrappers import (  # type: ignore[no-redef]
   293|         0|            0|            0|  0.00%|        ErrorWrapper as ErrorWrapper,  # noqa: F401
   294|         0|            0|            0|  0.00%|    )
   295|         0|            0|            0|  0.00%|    from pydantic.errors import MissingError
   296|         0|            0|            0|  0.00%|    from pydantic.fields import (  # type: ignore[attr-defined]
   297|         0|            0|            0|  0.00%|        SHAPE_FROZENSET,
   298|         0|            0|            0|  0.00%|        SHAPE_LIST,
   299|         0|            0|            0|  0.00%|        SHAPE_SEQUENCE,
   300|         0|            0|            0|  0.00%|        SHAPE_SET,
   301|         0|            0|            0|  0.00%|        SHAPE_SINGLETON,
   302|         0|            0|            0|  0.00%|        SHAPE_TUPLE,
   303|         0|            0|            0|  0.00%|        SHAPE_TUPLE_ELLIPSIS,
   304|         0|            0|            0|  0.00%|    )
   305|         0|            0|            0|  0.00%|    from pydantic.fields import FieldInfo as FieldInfo
   306|         0|            0|            0|  0.00%|    from pydantic.fields import (  # type: ignore[no-redef,attr-defined]
   307|         0|            0|            0|  0.00%|        ModelField as ModelField,  # noqa: F401
   308|         0|            0|            0|  0.00%|    )
   309|         0|            0|            0|  0.00%|    from pydantic.fields import (  # type: ignore[no-redef,attr-defined]
   310|         0|            0|            0|  0.00%|        Required as Required,  # noqa: F401
   311|         0|            0|            0|  0.00%|    )
   312|         0|            0|            0|  0.00%|    from pydantic.fields import (  # type: ignore[no-redef,attr-defined]
   313|         0|            0|            0|  0.00%|        Undefined as Undefined,
   314|         0|            0|            0|  0.00%|    )
   315|         0|            0|            0|  0.00%|    from pydantic.fields import (  # type: ignore[no-redef, attr-defined]
   316|         0|            0|            0|  0.00%|        UndefinedType as UndefinedType,  # noqa: F401
   317|         0|            0|            0|  0.00%|    )
   318|         0|            0|            0|  0.00%|    from pydantic.schema import (
   319|         0|            0|            0|  0.00%|        field_schema,
   320|         0|            0|            0|  0.00%|        get_flat_models_from_fields,
   321|         0|            0|            0|  0.00%|        get_model_name_map,
   322|         0|            0|            0|  0.00%|        model_process_schema,
   323|         0|            0|            0|  0.00%|    )
   324|         0|            0|            0|  0.00%|    from pydantic.schema import (  # type: ignore[no-redef]  # noqa: F401
   325|         0|            0|            0|  0.00%|        get_annotation_from_field_info as get_annotation_from_field_info,
   326|         0|            0|            0|  0.00%|    )
   327|         0|            0|            0|  0.00%|    from pydantic.typing import (  # type: ignore[no-redef]
   328|         0|            0|            0|  0.00%|        evaluate_forwardref as evaluate_forwardref,  # noqa: F401
   329|         0|            0|            0|  0.00%|    )
   330|         0|            0|            0|  0.00%|    from pydantic.utils import (  # type: ignore[no-redef]
   331|         0|            0|            0|  0.00%|        lenient_issubclass as lenient_issubclass,  # noqa: F401
   332|         0|            0|            0|  0.00%|    )
   333|         0|            0|            0|  0.00%|
   334|         0|            0|            0|  0.00%|    GetJsonSchemaHandler = Any  # type: ignore[assignment,misc]
   335|         0|            0|            0|  0.00%|    JsonSchemaValue = Dict[str, Any]  # type: ignore[misc]
   336|         0|            0|            0|  0.00%|    CoreSchema = Any  # type: ignore[assignment,misc]
   337|         0|            0|            0|  0.00%|
   338|         0|            0|            0|  0.00%|    sequence_shapes = {
   339|         0|            0|            0|  0.00%|        SHAPE_LIST,
   340|         0|            0|            0|  0.00%|        SHAPE_SET,
   341|         0|            0|            0|  0.00%|        SHAPE_FROZENSET,
   342|         0|            0|            0|  0.00%|        SHAPE_TUPLE,
   343|         0|            0|            0|  0.00%|        SHAPE_SEQUENCE,
   344|         0|            0|            0|  0.00%|        SHAPE_TUPLE_ELLIPSIS,
   345|         0|            0|            0|  0.00%|    }
   346|         0|            0|            0|  0.00%|    sequence_shape_to_type = {
   347|         0|            0|            0|  0.00%|        SHAPE_LIST: list,
   348|         0|            0|            0|  0.00%|        SHAPE_SET: set,
   349|         0|            0|            0|  0.00%|        SHAPE_TUPLE: tuple,
   350|         0|            0|            0|  0.00%|        SHAPE_SEQUENCE: list,
   351|         0|            0|            0|  0.00%|        SHAPE_TUPLE_ELLIPSIS: list,
   352|         0|            0|            0|  0.00%|    }
   353|         0|            0|            0|  0.00%|
   354|         0|            0|            0|  0.00%|    @dataclass
   355|         0|            0|            0|  0.00%|    class GenerateJsonSchema:  # type: ignore[no-redef]
   356|         0|            0|            0|  0.00%|        ref_template: str
   357|         0|            0|            0|  0.00%|
   358|         0|            0|            0|  0.00%|    class PydanticSchemaGenerationError(Exception):  # type: ignore[no-redef]
   359|         0|            0|            0|  0.00%|        pass
   360|         0|            0|            0|  0.00%|
   361|         0|            0|            0|  0.00%|    def with_info_plain_validator_function(  # type: ignore[misc]
   362|         0|            0|            0|  0.00%|        function: Callable[..., Any],
   363|         0|            0|            0|  0.00%|        *,
   364|         0|            0|            0|  0.00%|        ref: Union[str, None] = None,
   365|         0|            0|            0|  0.00%|        metadata: Any = None,
   366|         0|            0|            0|  0.00%|        serialization: Any = None,
   367|         0|            0|            0|  0.00%|    ) -> Any:
   368|         0|            0|            0|  0.00%|        return {}
   369|         0|            0|            0|  0.00%|
   370|         0|            0|            0|  0.00%|    def get_model_definitions(
   371|         0|            0|            0|  0.00%|        *,
   372|         0|            0|            0|  0.00%|        flat_models: Set[Union[Type[BaseModel], Type[Enum]]],
   373|         0|            0|            0|  0.00%|        model_name_map: Dict[Union[Type[BaseModel], Type[Enum]], str],
   374|         0|            0|            0|  0.00%|    ) -> Dict[str, Any]:
   375|         0|            0|            0|  0.00%|        definitions: Dict[str, Dict[str, Any]] = {}
   376|         0|            0|            0|  0.00%|        for model in flat_models:
   377|         0|            0|            0|  0.00%|            m_schema, m_definitions, m_nested_models = model_process_schema(
   378|         0|            0|            0|  0.00%|                model, model_name_map=model_name_map, ref_prefix=REF_PREFIX
   379|         0|            0|            0|  0.00%|            )
   380|         0|            0|            0|  0.00%|            definitions.update(m_definitions)
   381|         0|            0|            0|  0.00%|            model_name = model_name_map[model]
   382|         0|            0|            0|  0.00%|            if "description" in m_schema:
   383|         0|            0|            0|  0.00%|                m_schema["description"] = m_schema["description"].split("\f")[0]
   384|         0|            0|            0|  0.00%|            definitions[model_name] = m_schema
   385|         0|            0|            0|  0.00%|        return definitions
   386|         0|            0|            0|  0.00%|
   387|         0|            0|            0|  0.00%|    def is_pv1_scalar_field(field: ModelField) -> bool:
   388|         0|            0|            0|  0.00%|        from fastapi import params
   389|         0|            0|            0|  0.00%|
   390|         0|            0|            0|  0.00%|        field_info = field.field_info
   391|         0|            0|            0|  0.00%|        if not (
   392|         0|            0|            0|  0.00%|            field.shape == SHAPE_SINGLETON  # type: ignore[attr-defined]
   393|         0|            0|            0|  0.00%|            and not lenient_issubclass(field.type_, BaseModel)
   394|         0|            0|            0|  0.00%|            and not lenient_issubclass(field.type_, dict)
   395|         0|            0|            0|  0.00%|            and not field_annotation_is_sequence(field.type_)
   396|         0|            0|            0|  0.00%|            and not is_dataclass(field.type_)
   397|         0|            0|            0|  0.00%|            and not isinstance(field_info, params.Body)
   398|         0|            0|            0|  0.00%|        ):
   399|         0|            0|            0|  0.00%|            return False
   400|         0|            0|            0|  0.00%|        if field.sub_fields:  # type: ignore[attr-defined]
   401|         0|            0|            0|  0.00%|            if not all(
   402|         0|            0|            0|  0.00%|                is_pv1_scalar_field(f)
   403|         0|            0|            0|  0.00%|                for f in field.sub_fields  # type: ignore[attr-defined]
   404|         0|            0|            0|  0.00%|            ):
   405|         0|            0|            0|  0.00%|                return False
   406|         0|            0|            0|  0.00%|        return True
   407|         0|            0|            0|  0.00%|
   408|         0|            0|            0|  0.00%|    def is_pv1_scalar_sequence_field(field: ModelField) -> bool:
   409|         0|            0|            0|  0.00%|        if (field.shape in sequence_shapes) and not lenient_issubclass(  # type: ignore[attr-defined]
   410|         0|            0|            0|  0.00%|            field.type_, BaseModel
   411|         0|            0|            0|  0.00%|        ):
   412|         0|            0|            0|  0.00%|            if field.sub_fields is not None:  # type: ignore[attr-defined]
   413|         0|            0|            0|  0.00%|                for sub_field in field.sub_fields:  # type: ignore[attr-defined]
   414|         0|            0|            0|  0.00%|                    if not is_pv1_scalar_field(sub_field):
   415|         0|            0|            0|  0.00%|                        return False
   416|         0|            0|            0|  0.00%|            return True
   417|         0|            0|            0|  0.00%|        if _annotation_is_sequence(field.type_):
   418|         0|            0|            0|  0.00%|            return True
   419|         0|            0|            0|  0.00%|        return False
   420|         0|            0|            0|  0.00%|
   421|         0|            0|            0|  0.00%|    def _normalize_errors(errors: Sequence[Any]) -> List[Dict[str, Any]]:
   422|         0|            0|            0|  0.00%|        use_errors: List[Any] = []
   423|         0|            0|            0|  0.00%|        for error in errors:
   424|         0|            0|            0|  0.00%|            if isinstance(error, ErrorWrapper):
   425|         0|            0|            0|  0.00%|                new_errors = ValidationError(  # type: ignore[call-arg]
   426|         0|            0|            0|  0.00%|                    errors=[error], model=RequestErrorModel
   427|         0|            0|            0|  0.00%|                ).errors()
   428|         0|            0|            0|  0.00%|                use_errors.extend(new_errors)
   429|         0|            0|            0|  0.00%|            elif isinstance(error, list):
   430|         0|            0|            0|  0.00%|                use_errors.extend(_normalize_errors(error))
   431|         0|            0|            0|  0.00%|            else:
   432|         0|            0|            0|  0.00%|                use_errors.append(error)
   433|         0|            0|            0|  0.00%|        return use_errors
   434|         0|            0|            0|  0.00%|
   435|         0|            0|            0|  0.00%|    def _model_rebuild(model: Type[BaseModel]) -> None:
   436|         0|            0|            0|  0.00%|        model.update_forward_refs()
   437|         0|            0|            0|  0.00%|
   438|         0|            0|            0|  0.00%|    def _model_dump(
   439|         0|            0|            0|  0.00%|        model: BaseModel, mode: Literal["json", "python"] = "json", **kwargs: Any
   440|         0|            0|            0|  0.00%|    ) -> Any:
   441|         0|            0|            0|  0.00%|        return model.dict(**kwargs)
   442|         0|            0|            0|  0.00%|
   443|         0|            0|            0|  0.00%|    def _get_model_config(model: BaseModel) -> Any:
   444|         0|            0|            0|  0.00%|        return model.__config__  # type: ignore[attr-defined]
   445|         0|            0|            0|  0.00%|
   446|         0|            0|            0|  0.00%|    def get_schema_from_model_field(
   447|         0|            0|            0|  0.00%|        *,
   448|         0|            0|            0|  0.00%|        field: ModelField,
   449|         0|            0|            0|  0.00%|        schema_generator: GenerateJsonSchema,
   450|         0|            0|            0|  0.00%|        model_name_map: ModelNameMap,
   451|         0|            0|            0|  0.00%|        field_mapping: Dict[
   452|         0|            0|            0|  0.00%|            Tuple[ModelField, Literal["validation", "serialization"]], JsonSchemaValue
   453|         0|            0|            0|  0.00%|        ],
   454|         0|            0|            0|  0.00%|        separate_input_output_schemas: bool = True,
   455|         0|            0|            0|  0.00%|    ) -> Dict[str, Any]:
   456|         0|            0|            0|  0.00%|        # This expects that GenerateJsonSchema was already used to generate the definitions
   457|         0|            0|            0|  0.00%|        return field_schema(  # type: ignore[no-any-return]
   458|         0|            0|            0|  0.00%|            field, model_name_map=model_name_map, ref_prefix=REF_PREFIX
   459|         0|            0|            0|  0.00%|        )[0]
   460|         0|            0|            0|  0.00%|
   461|         0|            0|            0|  0.00%|    def get_compat_model_name_map(fields: List[ModelField]) -> ModelNameMap:
   462|         0|            0|            0|  0.00%|        models = get_flat_models_from_fields(fields, known_models=set())
   463|         0|            0|            0|  0.00%|        return get_model_name_map(models)  # type: ignore[no-any-return]
   464|         0|            0|            0|  0.00%|
   465|         0|            0|            0|  0.00%|    def get_definitions(
   466|         0|            0|            0|  0.00%|        *,
   467|         0|            0|            0|  0.00%|        fields: List[ModelField],
   468|         0|            0|            0|  0.00%|        schema_generator: GenerateJsonSchema,
   469|         0|            0|            0|  0.00%|        model_name_map: ModelNameMap,
   470|         0|            0|            0|  0.00%|        separate_input_output_schemas: bool = True,
   471|         0|            0|            0|  0.00%|    ) -> Tuple[
   472|         0|            0|            0|  0.00%|        Dict[
   473|         0|            0|            0|  0.00%|            Tuple[ModelField, Literal["validation", "serialization"]], JsonSchemaValue
   474|         0|            0|            0|  0.00%|        ],
   475|         0|            0|            0|  0.00%|        Dict[str, Dict[str, Any]],
   476|         0|            0|            0|  0.00%|    ]:
   477|         0|            0|            0|  0.00%|        models = get_flat_models_from_fields(fields, known_models=set())
   478|         0|            0|            0|  0.00%|        return {}, get_model_definitions(
   479|         0|            0|            0|  0.00%|            flat_models=models, model_name_map=model_name_map
   480|         0|            0|            0|  0.00%|        )
   481|         0|            0|            0|  0.00%|
   482|         0|            0|            0|  0.00%|    def is_scalar_field(field: ModelField) -> bool:
   483|         0|            0|            0|  0.00%|        return is_pv1_scalar_field(field)
   484|         0|            0|            0|  0.00%|
   485|         0|            0|            0|  0.00%|    def is_sequence_field(field: ModelField) -> bool:
   486|         0|            0|            0|  0.00%|        return field.shape in sequence_shapes or _annotation_is_sequence(field.type_)  # type: ignore[attr-defined]
   487|         0|            0|            0|  0.00%|
   488|         0|            0|            0|  0.00%|    def is_scalar_sequence_field(field: ModelField) -> bool:
   489|         0|            0|            0|  0.00%|        return is_pv1_scalar_sequence_field(field)
   490|         0|            0|            0|  0.00%|
   491|         0|            0|            0|  0.00%|    def is_bytes_field(field: ModelField) -> bool:
   492|         0|            0|            0|  0.00%|        return lenient_issubclass(field.type_, bytes)
   493|         0|            0|            0|  0.00%|
   494|         0|            0|            0|  0.00%|    def is_bytes_sequence_field(field: ModelField) -> bool:
   495|         0|            0|            0|  0.00%|        return field.shape in sequence_shapes and lenient_issubclass(field.type_, bytes)  # type: ignore[attr-defined]
   496|         0|            0|            0|  0.00%|
   497|         0|            0|            0|  0.00%|    def copy_field_info(*, field_info: FieldInfo, annotation: Any) -> FieldInfo:
   498|         0|            0|            0|  0.00%|        return copy(field_info)
   499|         0|            0|            0|  0.00%|
   500|         0|            0|            0|  0.00%|    def serialize_sequence_value(*, field: ModelField, value: Any) -> Sequence[Any]:
   501|         0|            0|            0|  0.00%|        return sequence_shape_to_type[field.shape](value)  # type: ignore[no-any-return,attr-defined]
   502|         0|            0|            0|  0.00%|
   503|         0|            0|            0|  0.00%|    def get_missing_field_error(loc: Tuple[str, ...]) -> Dict[str, Any]:
   504|         0|            0|            0|  0.00%|        missing_field_error = ErrorWrapper(MissingError(), loc=loc)  # type: ignore[call-arg]
   505|         0|            0|            0|  0.00%|        new_error = ValidationError([missing_field_error], RequestErrorModel)
   506|         0|            0|            0|  0.00%|        return new_error.errors()[0]  # type: ignore[return-value]
   507|         0|            0|            0|  0.00%|
   508|         0|            0|            0|  0.00%|    def create_body_model(
   509|         0|            0|            0|  0.00%|        *, fields: Sequence[ModelField], model_name: str
   510|         0|            0|            0|  0.00%|    ) -> Type[BaseModel]:
   511|         0|            0|            0|  0.00%|        BodyModel = create_model(model_name)
   512|         0|            0|            0|  0.00%|        for f in fields:
   513|         0|            0|            0|  0.00%|            BodyModel.__fields__[f.name] = f  # type: ignore[index]
   514|         0|            0|            0|  0.00%|        return BodyModel
   515|         0|            0|            0|  0.00%|
   516|         0|            0|            0|  0.00%|
   517|         0|            0|            0|  0.00%|def _regenerate_error_with_loc(
   518|         0|            0|            0|  0.00%|    *, errors: Sequence[Any], loc_prefix: Tuple[Union[str, int], ...]
   519|         0|            0|            0|  0.00%|) -> List[Dict[str, Any]]:
   520|         0|            0|            0|  0.00%|    updated_loc_errors: List[Any] = [
   521|         0|            0|            0|  0.00%|        {**err, "loc": loc_prefix + err.get("loc", ())}
   522|         0|            0|            0|  0.00%|        for err in _normalize_errors(errors)
   523|         0|            0|            0|  0.00%|    ]
   524|         0|            0|            0|  0.00%|
   525|         0|            0|            0|  0.00%|    return updated_loc_errors
   526|         0|            0|            0|  0.00%|
   527|         0|            0|            0|  0.00%|
   528|         8|  1.04904e-05|   1.3113e-06|  0.01%|def _annotation_is_sequence(annotation: Union[Type[Any], None]) -> bool:
   529|         8|  3.79086e-05|  4.73857e-06|  0.04%|    if lenient_issubclass(annotation, (str, bytes)):
(call)|         8|  4.12464e-05|   5.1558e-06|  0.04%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_utils.py:75 lenient_issubclass
   530|         4|  1.04904e-05|   2.6226e-06|  0.01%|        return False
   531|         4|  1.54972e-05|   3.8743e-06|  0.02%|    return lenient_issubclass(annotation, sequence_types)
(call)|         4|  1.23978e-05|  3.09944e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_utils.py:75 lenient_issubclass
   532|         0|            0|            0|  0.00%|
   533|         0|            0|            0|  0.00%|
   534|         1|  2.14577e-06|  2.14577e-06|  0.00%|def field_annotation_is_sequence(annotation: Union[Type[Any], None]) -> bool:
   535|         3|  1.97887e-05|  6.59625e-06|  0.02%|    return _annotation_is_sequence(annotation) or _annotation_is_sequence(
(call)|         2|  2.81334e-05|  1.40667e-05|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/_compat.py:528 _annotation_is_sequence
   536|         1|  5.00679e-06|  5.00679e-06|  0.01%|        get_origin(annotation)
(call)|         1|  1.00136e-05|  1.00136e-05|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:2310 get_origin
   537|         0|            0|            0|  0.00%|    )
   538|         0|            0|            0|  0.00%|
   539|         0|            0|            0|  0.00%|
   540|         0|            0|            0|  0.00%|def value_is_sequence(value: Any) -> bool:
   541|         0|            0|            0|  0.00%|    return isinstance(value, sequence_types) and not isinstance(value, (str, bytes))  # type: ignore[arg-type]
   542|         0|            0|            0|  0.00%|
   543|         0|            0|            0|  0.00%|
   544|         6|  1.26362e-05|  2.10603e-06|  0.01%|def _annotation_is_complex(annotation: Union[Type[Any], None]) -> bool:
   545|         6|  8.10623e-06|  1.35104e-06|  0.01%|    return (
   546|        12|  4.45843e-05|  3.71536e-06|  0.05%|        lenient_issubclass(annotation, (BaseModel, Mapping, UploadFile))
(call)|         6|  0.000883102|  0.000147184|  0.91%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_utils.py:75 lenient_issubclass
   547|         6|  3.33786e-05|   5.5631e-06|  0.03%|        or _annotation_is_sequence(annotation)
(call)|         6|  9.98974e-05|  1.66496e-05|  0.10%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/_compat.py:528 _annotation_is_sequence
   548|         6|  2.69413e-05|  4.49022e-06|  0.03%|        or is_dataclass(annotation)
(call)|         6|  2.86102e-05|  4.76837e-06|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/dataclasses.py:1294 is_dataclass
   549|         0|            0|            0|  0.00%|    )
   550|         0|            0|            0|  0.00%|
   551|         0|            0|            0|  0.00%|
   552|         3|  1.33514e-05|  4.45048e-06|  0.01%|def field_annotation_is_complex(annotation: Union[Type[Any], None]) -> bool:
   553|         3|  2.45571e-05|   8.1857e-06|  0.03%|    origin = get_origin(annotation)
(call)|         3|  3.93391e-05|   1.3113e-05|  0.04%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:2310 get_origin
   554|         3|   6.4373e-06|  2.14577e-06|  0.01%|    if origin is Union or origin is UnionType:
   555|         0|            0|            0|  0.00%|        return any(field_annotation_is_complex(arg) for arg in get_args(annotation))
   556|         0|            0|            0|  0.00%|
   557|         3|  5.24521e-06|   1.7484e-06|  0.01%|    return (
   558|         9|  3.33786e-05|  3.70873e-06|  0.03%|        _annotation_is_complex(annotation)
(call)|         3|   0.00101924|  0.000339746|  1.05%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/_compat.py:544 _annotation_is_complex
   559|         3|  2.00272e-05|  6.67572e-06|  0.02%|        or _annotation_is_complex(origin)
(call)|         3|  0.000118017|  3.93391e-05|  0.12%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/_compat.py:544 _annotation_is_complex
   560|         3|  4.76837e-06|  1.58946e-06|  0.00%|        or hasattr(origin, "__pydantic_core_schema__")
   561|         3|   3.8147e-06|  1.27157e-06|  0.00%|        or hasattr(origin, "__get_pydantic_core_schema__")
   562|         0|            0|            0|  0.00%|    )
   563|         0|            0|            0|  0.00%|
   564|         0|            0|            0|  0.00%|
   565|         3|  1.28746e-05|  4.29153e-06|  0.01%|def field_annotation_is_scalar(annotation: Any) -> bool:
   566|         0|            0|            0|  0.00%|    # handle Ellipsis here to make tuple[int, ...] work nicely
   567|         3|  2.16961e-05|  7.23203e-06|  0.02%|    return annotation is Ellipsis or not field_annotation_is_complex(annotation)
(call)|         3|   0.00128818|  0.000429392|  1.32%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/_compat.py:552 field_annotation_is_complex
   568|         0|            0|            0|  0.00%|
   569|         0|            0|            0|  0.00%|
   570|         0|            0|            0|  0.00%|def field_annotation_is_scalar_sequence(annotation: Union[Type[Any], None]) -> bool:
   571|         0|            0|            0|  0.00%|    origin = get_origin(annotation)
   572|         0|            0|            0|  0.00%|    if origin is Union or origin is UnionType:
   573|         0|            0|            0|  0.00%|        at_least_one_scalar_sequence = False
   574|         0|            0|            0|  0.00%|        for arg in get_args(annotation):
   575|         0|            0|            0|  0.00%|            if field_annotation_is_scalar_sequence(arg):
   576|         0|            0|            0|  0.00%|                at_least_one_scalar_sequence = True
   577|         0|            0|            0|  0.00%|                continue
   578|         0|            0|            0|  0.00%|            elif not field_annotation_is_scalar(arg):
   579|         0|            0|            0|  0.00%|                return False
   580|         0|            0|            0|  0.00%|        return at_least_one_scalar_sequence
   581|         0|            0|            0|  0.00%|    return field_annotation_is_sequence(annotation) and all(
   582|         0|            0|            0|  0.00%|        field_annotation_is_scalar(sub_annotation)
   583|         0|            0|            0|  0.00%|        for sub_annotation in get_args(annotation)
   584|         0|            0|            0|  0.00%|    )
   585|         0|            0|            0|  0.00%|
   586|         0|            0|            0|  0.00%|
   587|         0|            0|            0|  0.00%|def is_bytes_or_nonable_bytes_annotation(annotation: Any) -> bool:
   588|         0|            0|            0|  0.00%|    if lenient_issubclass(annotation, bytes):
   589|         0|            0|            0|  0.00%|        return True
   590|         0|            0|            0|  0.00%|    origin = get_origin(annotation)
   591|         0|            0|            0|  0.00%|    if origin is Union or origin is UnionType:
   592|         0|            0|            0|  0.00%|        for arg in get_args(annotation):
   593|         0|            0|            0|  0.00%|            if lenient_issubclass(arg, bytes):
   594|         0|            0|            0|  0.00%|                return True
   595|         0|            0|            0|  0.00%|    return False
   596|         0|            0|            0|  0.00%|
   597|         0|            0|            0|  0.00%|
   598|         1|  7.39098e-06|  7.39098e-06|  0.01%|def is_uploadfile_or_nonable_uploadfile_annotation(annotation: Any) -> bool:
   599|         1|  6.91414e-06|  6.91414e-06|  0.01%|    if lenient_issubclass(annotation, UploadFile):
(call)|         1|  1.40667e-05|  1.40667e-05|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_utils.py:75 lenient_issubclass
   600|         0|            0|            0|  0.00%|        return True
   601|         1|  6.67572e-06|  6.67572e-06|  0.01%|    origin = get_origin(annotation)
(call)|         1|  1.07288e-05|  1.07288e-05|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:2310 get_origin
   602|         1|  4.52995e-06|  4.52995e-06|  0.00%|    if origin is Union or origin is UnionType:
   603|         0|            0|            0|  0.00%|        for arg in get_args(annotation):
   604|         0|            0|            0|  0.00%|            if lenient_issubclass(arg, UploadFile):
   605|         0|            0|            0|  0.00%|                return True
   606|         1|  2.14577e-06|  2.14577e-06|  0.00%|    return False
   607|         0|            0|            0|  0.00%|
   608|         0|            0|            0|  0.00%|
   609|         0|            0|            0|  0.00%|def is_bytes_sequence_annotation(annotation: Any) -> bool:
   610|         0|            0|            0|  0.00%|    origin = get_origin(annotation)
   611|         0|            0|            0|  0.00%|    if origin is Union or origin is UnionType:
   612|         0|            0|            0|  0.00%|        at_least_one = False
   613|         0|            0|            0|  0.00%|        for arg in get_args(annotation):
   614|         0|            0|            0|  0.00%|            if is_bytes_sequence_annotation(arg):
   615|         0|            0|            0|  0.00%|                at_least_one = True
   616|         0|            0|            0|  0.00%|                continue
   617|         0|            0|            0|  0.00%|        return at_least_one
   618|         0|            0|            0|  0.00%|    return field_annotation_is_sequence(annotation) and all(
   619|         0|            0|            0|  0.00%|        is_bytes_or_nonable_bytes_annotation(sub_annotation)
   620|         0|            0|            0|  0.00%|        for sub_annotation in get_args(annotation)
   621|         0|            0|            0|  0.00%|    )
   622|         0|            0|            0|  0.00%|
   623|         0|            0|            0|  0.00%|
   624|         1|  7.86781e-06|  7.86781e-06|  0.01%|def is_uploadfile_sequence_annotation(annotation: Any) -> bool:
   625|         1|  7.15256e-06|  7.15256e-06|  0.01%|    origin = get_origin(annotation)
(call)|         1|  1.07288e-05|  1.07288e-05|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:2310 get_origin
   626|         1|  2.86102e-06|  2.86102e-06|  0.00%|    if origin is Union or origin is UnionType:
   627|         0|            0|            0|  0.00%|        at_least_one = False
   628|         0|            0|            0|  0.00%|        for arg in get_args(annotation):
   629|         0|            0|            0|  0.00%|            if is_uploadfile_sequence_annotation(arg):
   630|         0|            0|            0|  0.00%|                at_least_one = True
   631|         0|            0|            0|  0.00%|                continue
   632|         0|            0|            0|  0.00%|        return at_least_one
   633|         1|  7.62939e-06|  7.62939e-06|  0.01%|    return field_annotation_is_sequence(annotation) and all(
(call)|         1|  6.50883e-05|  6.50883e-05|  0.07%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/_compat.py:534 field_annotation_is_sequence
   634|         0|            0|            0|  0.00%|        is_uploadfile_or_nonable_uploadfile_annotation(sub_annotation)
   635|         0|            0|            0|  0.00%|        for sub_annotation in get_args(annotation)
   636|         0|            0|            0|  0.00%|    )
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_config.py
File duration: 0.000551224s (0.57%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|from __future__ import annotations as _annotations
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|import warnings
     4|         0|            0|            0|  0.00%|from contextlib import contextmanager
     5|         0|            0|            0|  0.00%|from typing import (
     6|         0|            0|            0|  0.00%|    TYPE_CHECKING,
     7|         0|            0|            0|  0.00%|    Any,
     8|         0|            0|            0|  0.00%|    Callable,
     9|         0|            0|            0|  0.00%|    cast,
    10|         0|            0|            0|  0.00%|)
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|from pydantic_core import core_schema
    13|         0|            0|            0|  0.00%|from typing_extensions import (
    14|         0|            0|            0|  0.00%|    Literal,
    15|         0|            0|            0|  0.00%|    Self,
    16|         0|            0|            0|  0.00%|)
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|from ..aliases import AliasGenerator
    19|         0|            0|            0|  0.00%|from ..config import ConfigDict, ExtraValues, JsonDict, JsonEncoder, JsonSchemaExtraCallable
    20|         0|            0|            0|  0.00%|from ..errors import PydanticUserError
    21|         0|            0|            0|  0.00%|from ..warnings import PydanticDeprecatedSince20
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|if not TYPE_CHECKING:
    24|         0|            0|            0|  0.00%|    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915
    25|         0|            0|            0|  0.00%|    # and https://youtrack.jetbrains.com/issue/PY-51428
    26|         0|            0|            0|  0.00%|    DeprecationWarning = PydanticDeprecatedSince20
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|if TYPE_CHECKING:
    29|         0|            0|            0|  0.00%|    from .._internal._schema_generation_shared import GenerateSchema
    30|         0|            0|            0|  0.00%|    from ..fields import ComputedFieldInfo, FieldInfo
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|DEPRECATION_MESSAGE = 'Support for class-based `config` is deprecated, use ConfigDict instead.'
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|class ConfigWrapper:
    36|         0|            0|            0|  0.00%|    """Internal wrapper for Config which exposes ConfigDict items as attributes."""
    37|         0|            0|            0|  0.00%|
    38|         0|            0|            0|  0.00%|    __slots__ = ('config_dict',)
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|    config_dict: ConfigDict
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|    # all annotations are copied directly from ConfigDict, and should be kept up to date, a test will fail if they
    43|         0|            0|            0|  0.00%|    # stop matching
    44|         0|            0|            0|  0.00%|    title: str | None
    45|         0|            0|            0|  0.00%|    str_to_lower: bool
    46|         0|            0|            0|  0.00%|    str_to_upper: bool
    47|         0|            0|            0|  0.00%|    str_strip_whitespace: bool
    48|         0|            0|            0|  0.00%|    str_min_length: int
    49|         0|            0|            0|  0.00%|    str_max_length: int | None
    50|         0|            0|            0|  0.00%|    extra: ExtraValues | None
    51|         0|            0|            0|  0.00%|    frozen: bool
    52|         0|            0|            0|  0.00%|    populate_by_name: bool
    53|         0|            0|            0|  0.00%|    use_enum_values: bool
    54|         0|            0|            0|  0.00%|    validate_assignment: bool
    55|         0|            0|            0|  0.00%|    arbitrary_types_allowed: bool
    56|         0|            0|            0|  0.00%|    from_attributes: bool
    57|         0|            0|            0|  0.00%|    # whether to use the actual key provided in the data (e.g. alias or first alias for "field required" errors) instead of field_names
    58|         0|            0|            0|  0.00%|    # to construct error `loc`s, default `True`
    59|         0|            0|            0|  0.00%|    loc_by_alias: bool
    60|         0|            0|            0|  0.00%|    alias_generator: Callable[[str], str] | AliasGenerator | None
    61|         0|            0|            0|  0.00%|    model_title_generator: Callable[[type], str] | None
    62|         0|            0|            0|  0.00%|    field_title_generator: Callable[[str, FieldInfo | ComputedFieldInfo], str] | None
    63|         0|            0|            0|  0.00%|    ignored_types: tuple[type, ...]
    64|         0|            0|            0|  0.00%|    allow_inf_nan: bool
    65|         0|            0|            0|  0.00%|    json_schema_extra: JsonDict | JsonSchemaExtraCallable | None
    66|         0|            0|            0|  0.00%|    json_encoders: dict[type[object], JsonEncoder] | None
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|    # new in V2
    69|         0|            0|            0|  0.00%|    strict: bool
    70|         0|            0|            0|  0.00%|    # whether instances of models and dataclasses (including subclass instances) should re-validate, default 'never'
    71|         0|            0|            0|  0.00%|    revalidate_instances: Literal['always', 'never', 'subclass-instances']
    72|         0|            0|            0|  0.00%|    ser_json_timedelta: Literal['iso8601', 'float']
    73|         0|            0|            0|  0.00%|    ser_json_bytes: Literal['utf8', 'base64']
    74|         0|            0|            0|  0.00%|    ser_json_inf_nan: Literal['null', 'constants', 'strings']
    75|         0|            0|            0|  0.00%|    # whether to validate default values during validation, default False
    76|         0|            0|            0|  0.00%|    validate_default: bool
    77|         0|            0|            0|  0.00%|    validate_return: bool
    78|         0|            0|            0|  0.00%|    protected_namespaces: tuple[str, ...]
    79|         0|            0|            0|  0.00%|    hide_input_in_errors: bool
    80|         0|            0|            0|  0.00%|    defer_build: bool
    81|         0|            0|            0|  0.00%|    experimental_defer_build_mode: tuple[Literal['model', 'type_adapter'], ...]
    82|         0|            0|            0|  0.00%|    plugin_settings: dict[str, object] | None
    83|         0|            0|            0|  0.00%|    schema_generator: type[GenerateSchema] | None
    84|         0|            0|            0|  0.00%|    json_schema_serialization_defaults_required: bool
    85|         0|            0|            0|  0.00%|    json_schema_mode_override: Literal['validation', 'serialization', None]
    86|         0|            0|            0|  0.00%|    coerce_numbers_to_str: bool
    87|         0|            0|            0|  0.00%|    regex_engine: Literal['rust-regex', 'python-re']
    88|         0|            0|            0|  0.00%|    validation_error_cause: bool
    89|         0|            0|            0|  0.00%|    use_attribute_docstrings: bool
    90|         0|            0|            0|  0.00%|    cache_strings: bool | Literal['all', 'keys', 'none']
    91|         0|            0|            0|  0.00%|
    92|         2|  8.10623e-06|  4.05312e-06|  0.01%|    def __init__(self, config: ConfigDict | dict[str, Any] | type[Any] | None, *, check: bool = True):
    93|         2|  6.19888e-06|  3.09944e-06|  0.01%|        if check:
    94|         2|  1.57356e-05|  7.86781e-06|  0.02%|            self.config_dict = prepare_config(config)
(call)|         2|  1.50204e-05|  7.51019e-06|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_config.py:278 prepare_config
    95|         0|            0|            0|  0.00%|        else:
    96|         0|            0|            0|  0.00%|            self.config_dict = cast(ConfigDict, config)
    97|         0|            0|            0|  0.00%|
    98|         0|            0|            0|  0.00%|    @classmethod
    99|         0|            0|            0|  0.00%|    def for_model(cls, bases: tuple[type[Any], ...], namespace: dict[str, Any], kwargs: dict[str, Any]) -> Self:
   100|         0|            0|            0|  0.00%|        """Build a new `ConfigWrapper` instance for a `BaseModel`.
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|        The config wrapper built based on (in descending order of priority):
   103|         0|            0|            0|  0.00%|        - options from `kwargs`
   104|         0|            0|            0|  0.00%|        - options from the `namespace`
   105|         0|            0|            0|  0.00%|        - options from the base classes (`bases`)
   106|         0|            0|            0|  0.00%|
   107|         0|            0|            0|  0.00%|        Args:
   108|         0|            0|            0|  0.00%|            bases: A tuple of base classes.
   109|         0|            0|            0|  0.00%|            namespace: The namespace of the class being created.
   110|         0|            0|            0|  0.00%|            kwargs: The kwargs passed to the class being created.
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|        Returns:
   113|         0|            0|            0|  0.00%|            A `ConfigWrapper` instance for `BaseModel`.
   114|         0|            0|            0|  0.00%|        """
   115|         0|            0|            0|  0.00%|        config_new = ConfigDict()
   116|         0|            0|            0|  0.00%|        for base in bases:
   117|         0|            0|            0|  0.00%|            config = getattr(base, 'model_config', None)
   118|         0|            0|            0|  0.00%|            if config:
   119|         0|            0|            0|  0.00%|                config_new.update(config.copy())
   120|         0|            0|            0|  0.00%|
   121|         0|            0|            0|  0.00%|        config_class_from_namespace = namespace.get('Config')
   122|         0|            0|            0|  0.00%|        config_dict_from_namespace = namespace.get('model_config')
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|        raw_annotations = namespace.get('__annotations__', {})
   125|         0|            0|            0|  0.00%|        if raw_annotations.get('model_config') and not config_dict_from_namespace:
   126|         0|            0|            0|  0.00%|            raise PydanticUserError(
   127|         0|            0|            0|  0.00%|                '`model_config` cannot be used as a model field name. Use `model_config` for model configuration.',
   128|         0|            0|            0|  0.00%|                code='model-config-invalid-field-name',
   129|         0|            0|            0|  0.00%|            )
   130|         0|            0|            0|  0.00%|
   131|         0|            0|            0|  0.00%|        if config_class_from_namespace and config_dict_from_namespace:
   132|         0|            0|            0|  0.00%|            raise PydanticUserError('"Config" and "model_config" cannot be used together', code='config-both')
   133|         0|            0|            0|  0.00%|
   134|         0|            0|            0|  0.00%|        config_from_namespace = config_dict_from_namespace or prepare_config(config_class_from_namespace)
   135|         0|            0|            0|  0.00%|
   136|         0|            0|            0|  0.00%|        config_new.update(config_from_namespace)
   137|         0|            0|            0|  0.00%|
   138|         0|            0|            0|  0.00%|        for k in list(kwargs.keys()):
   139|         0|            0|            0|  0.00%|            if k in config_keys:
   140|         0|            0|            0|  0.00%|                config_new[k] = kwargs.pop(k)
   141|         0|            0|            0|  0.00%|
   142|         0|            0|            0|  0.00%|        return cls(config_new)
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|    # we don't show `__getattr__` to type checkers so missing attributes cause errors
   145|         0|            0|            0|  0.00%|    if not TYPE_CHECKING:  # pragma: no branch
   146|         0|            0|            0|  0.00%|
   147|         6|  1.66893e-05|  2.78155e-06|  0.02%|        def __getattr__(self, name: str) -> Any:
   148|         6|  9.05991e-06|  1.50998e-06|  0.01%|            try:
   149|         6|  1.40667e-05|  2.34445e-06|  0.01%|                return self.config_dict[name]
   150|         6|  8.58307e-06|  1.43051e-06|  0.01%|            except KeyError:
   151|         6|  7.62939e-06|  1.27157e-06|  0.01%|                try:
   152|         6|  1.19209e-05|  1.98682e-06|  0.01%|                    return config_defaults[name]
   153|         0|            0|            0|  0.00%|                except KeyError:
   154|         0|            0|            0|  0.00%|                    raise AttributeError(f'Config has no attribute {name!r}') from None
   155|         0|            0|            0|  0.00%|
   156|         2|   1.3113e-05|  6.55651e-06|  0.01%|    def core_config(self, obj: Any) -> core_schema.CoreConfig:
   157|         0|            0|            0|  0.00%|        """Create a pydantic-core config, `obj` is just used to populate `title` if not set in config.
   158|         0|            0|            0|  0.00%|
   159|         0|            0|            0|  0.00%|        Pass `obj=None` if you do not want to attempt to infer the `title`.
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|        We don't use getattr here since we don't want to populate with defaults.
   162|         0|            0|            0|  0.00%|
   163|         0|            0|            0|  0.00%|        Args:
   164|         0|            0|            0|  0.00%|            obj: An object used to populate `title` if not set in config.
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|        Returns:
   167|         0|            0|            0|  0.00%|            A `CoreConfig` object created from config.
   168|         0|            0|            0|  0.00%|        """
   169|         0|            0|            0|  0.00%|
   170|         4|   1.4782e-05|  3.69549e-06|  0.02%|        def dict_not_none(**kwargs: Any) -> Any:
   171|        46|  5.26905e-05|  1.14545e-06|  0.05%|            return {k: v for k, v in kwargs.items() if v is not None}
   172|         0|            0|            0|  0.00%|
   173|         4|  1.40667e-05|  3.51667e-06|  0.01%|        core_config = core_schema.CoreConfig(
   174|        46|    0.0001719|  3.73695e-06|  0.18%|            **dict_not_none(
(call)|         2|  6.00815e-05|  3.00407e-05|  0.06%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_config.py:170 dict_not_none
   175|         2|  1.14441e-05|  5.72205e-06|  0.01%|                title=self.config_dict.get('title') or (obj and obj.__name__),
   176|         2|  4.29153e-06|  2.14577e-06|  0.00%|                extra_fields_behavior=self.config_dict.get('extra'),
   177|         2|  4.05312e-06|  2.02656e-06|  0.00%|                allow_inf_nan=self.config_dict.get('allow_inf_nan'),
   178|         2|  4.52995e-06|  2.26498e-06|  0.00%|                populate_by_name=self.config_dict.get('populate_by_name'),
   179|         2|  4.52995e-06|  2.26498e-06|  0.00%|                str_strip_whitespace=self.config_dict.get('str_strip_whitespace'),
   180|         2|  4.76837e-06|  2.38419e-06|  0.00%|                str_to_lower=self.config_dict.get('str_to_lower'),
   181|         2|   3.8147e-06|  1.90735e-06|  0.00%|                str_to_upper=self.config_dict.get('str_to_upper'),
   182|         2|  4.29153e-06|  2.14577e-06|  0.00%|                strict=self.config_dict.get('strict'),
   183|         2|  4.29153e-06|  2.14577e-06|  0.00%|                ser_json_timedelta=self.config_dict.get('ser_json_timedelta'),
   184|         2|  4.29153e-06|  2.14577e-06|  0.00%|                ser_json_bytes=self.config_dict.get('ser_json_bytes'),
   185|         2|  4.76837e-06|  2.38419e-06|  0.00%|                ser_json_inf_nan=self.config_dict.get('ser_json_inf_nan'),
   186|         2|  4.05312e-06|  2.02656e-06|  0.00%|                from_attributes=self.config_dict.get('from_attributes'),
   187|         2|  4.05312e-06|  2.02656e-06|  0.00%|                loc_by_alias=self.config_dict.get('loc_by_alias'),
   188|         2|  4.29153e-06|  2.14577e-06|  0.00%|                revalidate_instances=self.config_dict.get('revalidate_instances'),
   189|         2|  6.91414e-06|  3.45707e-06|  0.01%|                validate_default=self.config_dict.get('validate_default'),
   190|         2|  5.24521e-06|   2.6226e-06|  0.01%|                str_max_length=self.config_dict.get('str_max_length'),
   191|         2|  5.96046e-06|  2.98023e-06|  0.01%|                str_min_length=self.config_dict.get('str_min_length'),
   192|         2|   6.4373e-06|  3.21865e-06|  0.01%|                hide_input_in_errors=self.config_dict.get('hide_input_in_errors'),
   193|         2|   6.4373e-06|  3.21865e-06|  0.01%|                coerce_numbers_to_str=self.config_dict.get('coerce_numbers_to_str'),
   194|         2|  5.00679e-06|   2.5034e-06|  0.01%|                regex_engine=self.config_dict.get('regex_engine'),
   195|         2|  4.52995e-06|  2.26498e-06|  0.00%|                validation_error_cause=self.config_dict.get('validation_error_cause'),
   196|         2|  5.24521e-06|   2.6226e-06|  0.01%|                cache_strings=self.config_dict.get('cache_strings'),
   197|         0|            0|            0|  0.00%|            )
   198|         0|            0|            0|  0.00%|        )
   199|         2|  4.76837e-06|  2.38419e-06|  0.00%|        return core_config
   200|         0|            0|            0|  0.00%|
   201|         0|            0|            0|  0.00%|    def __repr__(self):
   202|         0|            0|            0|  0.00%|        c = ', '.join(f'{k}={v!r}' for k, v in self.config_dict.items())
   203|         0|            0|            0|  0.00%|        return f'ConfigWrapper({c})'
   204|         0|            0|            0|  0.00%|
   205|         0|            0|            0|  0.00%|
   206|         0|            0|            0|  0.00%|class ConfigWrapperStack:
   207|         0|            0|            0|  0.00%|    """A stack of `ConfigWrapper` instances."""
   208|         0|            0|            0|  0.00%|
   209|         2|  5.24521e-06|   2.6226e-06|  0.01%|    def __init__(self, config_wrapper: ConfigWrapper):
   210|         2|  3.57628e-06|  1.78814e-06|  0.00%|        self._config_wrapper_stack: list[ConfigWrapper] = [config_wrapper]
   211|         0|            0|            0|  0.00%|
   212|        20|  2.07424e-05|  1.03712e-06|  0.02%|    @property
   213|         0|            0|            0|  0.00%|    def tail(self) -> ConfigWrapper:
   214|        20|  2.40803e-05|  1.20401e-06|  0.02%|        return self._config_wrapper_stack[-1]
   215|         0|            0|            0|  0.00%|
   216|         0|            0|            0|  0.00%|    @contextmanager
   217|         0|            0|            0|  0.00%|    def push(self, config_wrapper: ConfigWrapper | ConfigDict | None):
   218|         0|            0|            0|  0.00%|        if config_wrapper is None:
   219|         0|            0|            0|  0.00%|            yield
   220|         0|            0|            0|  0.00%|            return
   221|         0|            0|            0|  0.00%|
   222|         0|            0|            0|  0.00%|        if not isinstance(config_wrapper, ConfigWrapper):
   223|         0|            0|            0|  0.00%|            config_wrapper = ConfigWrapper(config_wrapper, check=False)
   224|         0|            0|            0|  0.00%|
   225|         0|            0|            0|  0.00%|        self._config_wrapper_stack.append(config_wrapper)
   226|         0|            0|            0|  0.00%|        try:
   227|         0|            0|            0|  0.00%|            yield
   228|         0|            0|            0|  0.00%|        finally:
   229|         0|            0|            0|  0.00%|            self._config_wrapper_stack.pop()
   230|         0|            0|            0|  0.00%|
   231|         0|            0|            0|  0.00%|
   232|         0|            0|            0|  0.00%|config_defaults = ConfigDict(
   233|         0|            0|            0|  0.00%|    title=None,
   234|         0|            0|            0|  0.00%|    str_to_lower=False,
   235|         0|            0|            0|  0.00%|    str_to_upper=False,
   236|         0|            0|            0|  0.00%|    str_strip_whitespace=False,
   237|         0|            0|            0|  0.00%|    str_min_length=0,
   238|         0|            0|            0|  0.00%|    str_max_length=None,
   239|         0|            0|            0|  0.00%|    # let the model / dataclass decide how to handle it
   240|         0|            0|            0|  0.00%|    extra=None,
   241|         0|            0|            0|  0.00%|    frozen=False,
   242|         0|            0|            0|  0.00%|    populate_by_name=False,
   243|         0|            0|            0|  0.00%|    use_enum_values=False,
   244|         0|            0|            0|  0.00%|    validate_assignment=False,
   245|         0|            0|            0|  0.00%|    arbitrary_types_allowed=False,
   246|         0|            0|            0|  0.00%|    from_attributes=False,
   247|         0|            0|            0|  0.00%|    loc_by_alias=True,
   248|         0|            0|            0|  0.00%|    alias_generator=None,
   249|         0|            0|            0|  0.00%|    model_title_generator=None,
   250|         0|            0|            0|  0.00%|    field_title_generator=None,
   251|         0|            0|            0|  0.00%|    ignored_types=(),
   252|         0|            0|            0|  0.00%|    allow_inf_nan=True,
   253|         0|            0|            0|  0.00%|    json_schema_extra=None,
   254|         0|            0|            0|  0.00%|    strict=False,
   255|         0|            0|            0|  0.00%|    revalidate_instances='never',
   256|         0|            0|            0|  0.00%|    ser_json_timedelta='iso8601',
   257|         0|            0|            0|  0.00%|    ser_json_bytes='utf8',
   258|         0|            0|            0|  0.00%|    ser_json_inf_nan='null',
   259|         0|            0|            0|  0.00%|    validate_default=False,
   260|         0|            0|            0|  0.00%|    validate_return=False,
   261|         0|            0|            0|  0.00%|    protected_namespaces=('model_',),
   262|         0|            0|            0|  0.00%|    hide_input_in_errors=False,
   263|         0|            0|            0|  0.00%|    json_encoders=None,
   264|         0|            0|            0|  0.00%|    defer_build=False,
   265|         0|            0|            0|  0.00%|    experimental_defer_build_mode=('model',),
   266|         0|            0|            0|  0.00%|    plugin_settings=None,
   267|         0|            0|            0|  0.00%|    schema_generator=None,
   268|         0|            0|            0|  0.00%|    json_schema_serialization_defaults_required=False,
   269|         0|            0|            0|  0.00%|    json_schema_mode_override=None,
   270|         0|            0|            0|  0.00%|    coerce_numbers_to_str=False,
   271|         0|            0|            0|  0.00%|    regex_engine='rust-regex',
   272|         0|            0|            0|  0.00%|    validation_error_cause=False,
   273|         0|            0|            0|  0.00%|    use_attribute_docstrings=False,
   274|         0|            0|            0|  0.00%|    cache_strings=True,
   275|         0|            0|            0|  0.00%|)
   276|         0|            0|            0|  0.00%|
   277|         0|            0|            0|  0.00%|
   278|         2|  5.48363e-06|  2.74181e-06|  0.01%|def prepare_config(config: ConfigDict | dict[str, Any] | type[Any] | None) -> ConfigDict:
   279|         0|            0|            0|  0.00%|    """Create a `ConfigDict` instance from an existing dict, a class (e.g. old class-based config) or None.
   280|         0|            0|            0|  0.00%|
   281|         0|            0|            0|  0.00%|    Args:
   282|         0|            0|            0|  0.00%|        config: The input config.
   283|         0|            0|            0|  0.00%|
   284|         0|            0|            0|  0.00%|    Returns:
   285|         0|            0|            0|  0.00%|        A ConfigDict object created from config.
   286|         0|            0|            0|  0.00%|    """
   287|         2|  3.57628e-06|  1.78814e-06|  0.00%|    if config is None:
   288|         2|  5.96046e-06|  2.98023e-06|  0.01%|        return ConfigDict()
   289|         0|            0|            0|  0.00%|
   290|         0|            0|            0|  0.00%|    if not isinstance(config, dict):
   291|         0|            0|            0|  0.00%|        warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)
   292|         0|            0|            0|  0.00%|        config = {k: getattr(config, k) for k in dir(config) if not k.startswith('__')}
   293|         0|            0|            0|  0.00%|
   294|         0|            0|            0|  0.00%|    config_dict = cast(ConfigDict, config)
   295|         0|            0|            0|  0.00%|    check_deprecated(config_dict)
   296|         0|            0|            0|  0.00%|    return config_dict
   297|         0|            0|            0|  0.00%|
   298|         0|            0|            0|  0.00%|
   299|         0|            0|            0|  0.00%|config_keys = set(ConfigDict.__annotations__.keys())
   300|         0|            0|            0|  0.00%|
   301|         0|            0|            0|  0.00%|
   302|         0|            0|            0|  0.00%|V2_REMOVED_KEYS = {
   303|         0|            0|            0|  0.00%|    'allow_mutation',
   304|         0|            0|            0|  0.00%|    'error_msg_templates',
   305|         0|            0|            0|  0.00%|    'fields',
   306|         0|            0|            0|  0.00%|    'getter_dict',
   307|         0|            0|            0|  0.00%|    'smart_union',
   308|         0|            0|            0|  0.00%|    'underscore_attrs_are_private',
   309|         0|            0|            0|  0.00%|    'json_loads',
   310|         0|            0|            0|  0.00%|    'json_dumps',
   311|         0|            0|            0|  0.00%|    'copy_on_model_validation',
   312|         0|            0|            0|  0.00%|    'post_init_call',
   313|         0|            0|            0|  0.00%|}
   314|         0|            0|            0|  0.00%|V2_RENAMED_KEYS = {
   315|         0|            0|            0|  0.00%|    'allow_population_by_field_name': 'populate_by_name',
   316|         0|            0|            0|  0.00%|    'anystr_lower': 'str_to_lower',
   317|         0|            0|            0|  0.00%|    'anystr_strip_whitespace': 'str_strip_whitespace',
   318|         0|            0|            0|  0.00%|    'anystr_upper': 'str_to_upper',
   319|         0|            0|            0|  0.00%|    'keep_untouched': 'ignored_types',
   320|         0|            0|            0|  0.00%|    'max_anystr_length': 'str_max_length',
   321|         0|            0|            0|  0.00%|    'min_anystr_length': 'str_min_length',
   322|         0|            0|            0|  0.00%|    'orm_mode': 'from_attributes',
   323|         0|            0|            0|  0.00%|    'schema_extra': 'json_schema_extra',
   324|         0|            0|            0|  0.00%|    'validate_all': 'validate_default',
   325|         0|            0|            0|  0.00%|}
   326|         0|            0|            0|  0.00%|
   327|         0|            0|            0|  0.00%|
   328|         0|            0|            0|  0.00%|def check_deprecated(config_dict: ConfigDict) -> None:
   329|         0|            0|            0|  0.00%|    """Check for deprecated config keys and warn the user.
   330|         0|            0|            0|  0.00%|
   331|         0|            0|            0|  0.00%|    Args:
   332|         0|            0|            0|  0.00%|        config_dict: The input config.
   333|         0|            0|            0|  0.00%|    """
   334|         0|            0|            0|  0.00%|    deprecated_removed_keys = V2_REMOVED_KEYS & config_dict.keys()
   335|         0|            0|            0|  0.00%|    deprecated_renamed_keys = V2_RENAMED_KEYS.keys() & config_dict.keys()
   336|         0|            0|            0|  0.00%|    if deprecated_removed_keys or deprecated_renamed_keys:
   337|         0|            0|            0|  0.00%|        renamings = {k: V2_RENAMED_KEYS[k] for k in sorted(deprecated_renamed_keys)}
   338|         0|            0|            0|  0.00%|        renamed_bullets = [f'* {k!r} has been renamed to {v!r}' for k, v in renamings.items()]
   339|         0|            0|            0|  0.00%|        removed_bullets = [f'* {k!r} has been removed' for k in sorted(deprecated_removed_keys)]
   340|         0|            0|            0|  0.00%|        message = '\n'.join(['Valid config keys have changed in V2:'] + renamed_bullets + removed_bullets)
   341|         0|            0|            0|  0.00%|        warnings.warn(message, UserWarning)
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/contextlib.py
File duration: 0.000466824s (0.48%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Utilities for with-statement contexts.  See PEP 343."""
     2|         0|            0|            0|  0.00%|import abc
     3|         0|            0|            0|  0.00%|import os
     4|         0|            0|            0|  0.00%|import sys
     5|         0|            0|            0|  0.00%|import _collections_abc
     6|         0|            0|            0|  0.00%|from collections import deque
     7|         0|            0|            0|  0.00%|from functools import wraps
     8|         0|            0|            0|  0.00%|from types import MethodType, GenericAlias
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|__all__ = ["asynccontextmanager", "contextmanager", "closing", "nullcontext",
    11|         0|            0|            0|  0.00%|           "AbstractContextManager", "AbstractAsyncContextManager",
    12|         0|            0|            0|  0.00%|           "AsyncExitStack", "ContextDecorator", "ExitStack",
    13|         0|            0|            0|  0.00%|           "redirect_stdout", "redirect_stderr", "suppress", "aclosing",
    14|         0|            0|            0|  0.00%|           "chdir"]
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|class AbstractContextManager(abc.ABC):
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|    """An abstract base class for context managers."""
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|    __class_getitem__ = classmethod(GenericAlias)
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|    def __enter__(self):
    24|         0|            0|            0|  0.00%|        """Return `self` upon entering the runtime context."""
    25|         0|            0|            0|  0.00%|        return self
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|    @abc.abstractmethod
    28|         0|            0|            0|  0.00%|    def __exit__(self, exc_type, exc_value, traceback):
    29|         0|            0|            0|  0.00%|        """Raise any exception triggered within the runtime context."""
    30|         0|            0|            0|  0.00%|        return None
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|    @classmethod
    33|         0|            0|            0|  0.00%|    def __subclasshook__(cls, C):
    34|         0|            0|            0|  0.00%|        if cls is AbstractContextManager:
    35|         0|            0|            0|  0.00%|            return _collections_abc._check_methods(C, "__enter__", "__exit__")
    36|         0|            0|            0|  0.00%|        return NotImplemented
    37|         0|            0|            0|  0.00%|
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|class AbstractAsyncContextManager(abc.ABC):
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|    """An abstract base class for asynchronous context managers."""
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|    __class_getitem__ = classmethod(GenericAlias)
    44|         0|            0|            0|  0.00%|
    45|         0|            0|            0|  0.00%|    async def __aenter__(self):
    46|         0|            0|            0|  0.00%|        """Return `self` upon entering the runtime context."""
    47|         0|            0|            0|  0.00%|        return self
    48|         0|            0|            0|  0.00%|
    49|         0|            0|            0|  0.00%|    @abc.abstractmethod
    50|         0|            0|            0|  0.00%|    async def __aexit__(self, exc_type, exc_value, traceback):
    51|         0|            0|            0|  0.00%|        """Raise any exception triggered within the runtime context."""
    52|         0|            0|            0|  0.00%|        return None
    53|         0|            0|            0|  0.00%|
    54|         0|            0|            0|  0.00%|    @classmethod
    55|         0|            0|            0|  0.00%|    def __subclasshook__(cls, C):
    56|         0|            0|            0|  0.00%|        if cls is AbstractAsyncContextManager:
    57|         0|            0|            0|  0.00%|            return _collections_abc._check_methods(C, "__aenter__",
    58|         0|            0|            0|  0.00%|                                                   "__aexit__")
    59|         0|            0|            0|  0.00%|        return NotImplemented
    60|         0|            0|            0|  0.00%|
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|class ContextDecorator(object):
    63|         0|            0|            0|  0.00%|    "A base class or mixin that enables context managers to work as decorators."
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|    def _recreate_cm(self):
    66|         0|            0|            0|  0.00%|        """Return a recreated instance of self.
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|        Allows an otherwise one-shot context manager like
    69|         0|            0|            0|  0.00%|        _GeneratorContextManager to support use as
    70|         0|            0|            0|  0.00%|        a decorator via implicit recreation.
    71|         0|            0|            0|  0.00%|
    72|         0|            0|            0|  0.00%|        This is a private interface just for _GeneratorContextManager.
    73|         0|            0|            0|  0.00%|        See issue #11647 for details.
    74|         0|            0|            0|  0.00%|        """
    75|         0|            0|            0|  0.00%|        return self
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|    def __call__(self, func):
    78|         0|            0|            0|  0.00%|        @wraps(func)
    79|         0|            0|            0|  0.00%|        def inner(*args, **kwds):
    80|         0|            0|            0|  0.00%|            with self._recreate_cm():
    81|         0|            0|            0|  0.00%|                return func(*args, **kwds)
    82|         0|            0|            0|  0.00%|        return inner
    83|         0|            0|            0|  0.00%|
    84|         0|            0|            0|  0.00%|
    85|         0|            0|            0|  0.00%|class AsyncContextDecorator(object):
    86|         0|            0|            0|  0.00%|    "A base class or mixin that enables async context managers to work as decorators."
    87|         0|            0|            0|  0.00%|
    88|         0|            0|            0|  0.00%|    def _recreate_cm(self):
    89|         0|            0|            0|  0.00%|        """Return a recreated instance of self.
    90|         0|            0|            0|  0.00%|        """
    91|         0|            0|            0|  0.00%|        return self
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|    def __call__(self, func):
    94|         0|            0|            0|  0.00%|        @wraps(func)
    95|         0|            0|            0|  0.00%|        async def inner(*args, **kwds):
    96|         0|            0|            0|  0.00%|            async with self._recreate_cm():
    97|         0|            0|            0|  0.00%|                return await func(*args, **kwds)
    98|         0|            0|            0|  0.00%|        return inner
    99|         0|            0|            0|  0.00%|
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|class _GeneratorContextManagerBase:
   102|         0|            0|            0|  0.00%|    """Shared functionality for @contextmanager and @asynccontextmanager."""
   103|         0|            0|            0|  0.00%|
   104|         8|  1.28746e-05|  1.60933e-06|  0.01%|    def __init__(self, func, args, kwds):
   105|         8|   1.5974e-05|  1.99676e-06|  0.02%|        self.gen = func(*args, **kwds)
   106|         8|  1.04904e-05|   1.3113e-06|  0.01%|        self.func, self.args, self.kwds = func, args, kwds
   107|         0|            0|            0|  0.00%|        # Issue 19330: ensure context manager instances have good docstrings
   108|         8|  1.26362e-05|  1.57952e-06|  0.01%|        doc = getattr(func, "__doc__", None)
   109|         8|  9.77516e-06|   1.2219e-06|  0.01%|        if doc is None:
   110|         4|  5.96046e-06|  1.49012e-06|  0.01%|            doc = type(self).__doc__
   111|         8|  1.21593e-05|  1.51992e-06|  0.01%|        self.__doc__ = doc
   112|         0|            0|            0|  0.00%|        # Unfortunately, this still doesn't provide good help output when
   113|         0|            0|            0|  0.00%|        # inspecting the created context manager instances, since pydoc
   114|         0|            0|            0|  0.00%|        # currently bypasses the instance docstring and shows the docstring
   115|         0|            0|            0|  0.00%|        # for the class instead.
   116|         0|            0|            0|  0.00%|        # See http://bugs.python.org/issue19404 for more details.
   117|         0|            0|            0|  0.00%|
   118|         0|            0|            0|  0.00%|    def _recreate_cm(self):
   119|         0|            0|            0|  0.00%|        # _GCMB instances are one-shot context managers, so the
   120|         0|            0|            0|  0.00%|        # CM must be recreated each time a decorated function is
   121|         0|            0|            0|  0.00%|        # called
   122|         0|            0|            0|  0.00%|        return self.__class__(self.func, self.args, self.kwds)
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|
   125|         0|            0|            0|  0.00%|class _GeneratorContextManager(
   126|         0|            0|            0|  0.00%|    _GeneratorContextManagerBase,
   127|         0|            0|            0|  0.00%|    AbstractContextManager,
   128|         0|            0|            0|  0.00%|    ContextDecorator,
   129|         0|            0|            0|  0.00%|):
   130|         0|            0|            0|  0.00%|    """Helper for @contextmanager decorator."""
   131|         0|            0|            0|  0.00%|
   132|         8|  2.28882e-05|  2.86102e-06|  0.02%|    def __enter__(self):
   133|         0|            0|            0|  0.00%|        # do not keep args and kwds alive unnecessarily
   134|         0|            0|            0|  0.00%|        # they are only needed for recreation, which is not possible anymore
   135|         8|   1.3113e-05|  1.63913e-06|  0.01%|        del self.args, self.kwds, self.func
   136|         8|  1.00136e-05|   1.2517e-06|  0.01%|        try:
   137|         8|  5.07832e-05|  6.34789e-06|  0.05%|            return next(self.gen)
(call)|         4|  2.64645e-05|  6.61612e-06|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/type_adapter.py:266 _with_frame_depth
(call)|         4|  0.000860214|  0.000215054|  0.88%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:2300 get_schema_or_ref
   138|         0|            0|            0|  0.00%|        except StopIteration:
   139|         0|            0|            0|  0.00%|            raise RuntimeError("generator didn't yield") from None
   140|         0|            0|            0|  0.00%|
   141|         8|  4.79221e-05|  5.99027e-06|  0.05%|    def __exit__(self, typ, value, traceback):
   142|         8|  2.40803e-05|  3.01003e-06|  0.02%|        if typ is None:
   143|         8|  1.85966e-05|  2.32458e-06|  0.02%|            try:
   144|         8|  8.27312e-05|  1.03414e-05|  0.09%|                next(self.gen)
(call)|         4|  2.45571e-05|  6.13928e-06|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:2300 get_schema_or_ref
(call)|         4|  1.93119e-05|  4.82798e-06|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/type_adapter.py:266 _with_frame_depth
   145|         8|  2.07424e-05|   2.5928e-06|  0.02%|            except StopIteration:
   146|         8|  2.07424e-05|   2.5928e-06|  0.02%|                return False
   147|         0|            0|            0|  0.00%|            else:
   148|         0|            0|            0|  0.00%|                try:
   149|         0|            0|            0|  0.00%|                    raise RuntimeError("generator didn't stop")
   150|         0|            0|            0|  0.00%|                finally:
   151|         0|            0|            0|  0.00%|                    self.gen.close()
   152|         0|            0|            0|  0.00%|        else:
   153|         0|            0|            0|  0.00%|            if value is None:
   154|         0|            0|            0|  0.00%|                # Need to force instantiation so we can reliably
   155|         0|            0|            0|  0.00%|                # tell if we get the same exception back
   156|         0|            0|            0|  0.00%|                value = typ()
   157|         0|            0|            0|  0.00%|            try:
   158|         0|            0|            0|  0.00%|                self.gen.throw(value)
   159|         0|            0|            0|  0.00%|            except StopIteration as exc:
   160|         0|            0|            0|  0.00%|                # Suppress StopIteration *unless* it's the same exception that
   161|         0|            0|            0|  0.00%|                # was passed to throw().  This prevents a StopIteration
   162|         0|            0|            0|  0.00%|                # raised inside the "with" statement from being suppressed.
   163|         0|            0|            0|  0.00%|                return exc is not value
   164|         0|            0|            0|  0.00%|            except RuntimeError as exc:
   165|         0|            0|            0|  0.00%|                # Don't re-raise the passed in exception. (issue27122)
   166|         0|            0|            0|  0.00%|                if exc is value:
   167|         0|            0|            0|  0.00%|                    exc.__traceback__ = traceback
   168|         0|            0|            0|  0.00%|                    return False
   169|         0|            0|            0|  0.00%|                # Avoid suppressing if a StopIteration exception
   170|         0|            0|            0|  0.00%|                # was passed to throw() and later wrapped into a RuntimeError
   171|         0|            0|            0|  0.00%|                # (see PEP 479 for sync generators; async generators also
   172|         0|            0|            0|  0.00%|                # have this behavior). But do this only if the exception wrapped
   173|         0|            0|            0|  0.00%|                # by the RuntimeError is actually Stop(Async)Iteration (see
   174|         0|            0|            0|  0.00%|                # issue29692).
   175|         0|            0|            0|  0.00%|                if (
   176|         0|            0|            0|  0.00%|                    isinstance(value, StopIteration)
   177|         0|            0|            0|  0.00%|                    and exc.__cause__ is value
   178|         0|            0|            0|  0.00%|                ):
   179|         0|            0|            0|  0.00%|                    value.__traceback__ = traceback
   180|         0|            0|            0|  0.00%|                    return False
   181|         0|            0|            0|  0.00%|                raise
   182|         0|            0|            0|  0.00%|            except BaseException as exc:
   183|         0|            0|            0|  0.00%|                # only re-raise if it's *not* the exception that was
   184|         0|            0|            0|  0.00%|                # passed to throw(), because __exit__() must not raise
   185|         0|            0|            0|  0.00%|                # an exception unless __exit__() itself failed.  But throw()
   186|         0|            0|            0|  0.00%|                # has to raise the exception to signal propagation, so this
   187|         0|            0|            0|  0.00%|                # fixes the impedance mismatch between the throw() protocol
   188|         0|            0|            0|  0.00%|                # and the __exit__() protocol.
   189|         0|            0|            0|  0.00%|                if exc is not value:
   190|         0|            0|            0|  0.00%|                    raise
   191|         0|            0|            0|  0.00%|                exc.__traceback__ = traceback
   192|         0|            0|            0|  0.00%|                return False
   193|         0|            0|            0|  0.00%|            try:
   194|         0|            0|            0|  0.00%|                raise RuntimeError("generator didn't stop after throw()")
   195|         0|            0|            0|  0.00%|            finally:
   196|         0|            0|            0|  0.00%|                self.gen.close()
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|class _AsyncGeneratorContextManager(
   199|         0|            0|            0|  0.00%|    _GeneratorContextManagerBase,
   200|         0|            0|            0|  0.00%|    AbstractAsyncContextManager,
   201|         0|            0|            0|  0.00%|    AsyncContextDecorator,
   202|         0|            0|            0|  0.00%|):
   203|         0|            0|            0|  0.00%|    """Helper for @asynccontextmanager decorator."""
   204|         0|            0|            0|  0.00%|
   205|         0|            0|            0|  0.00%|    async def __aenter__(self):
   206|         0|            0|            0|  0.00%|        # do not keep args and kwds alive unnecessarily
   207|         0|            0|            0|  0.00%|        # they are only needed for recreation, which is not possible anymore
   208|         0|            0|            0|  0.00%|        del self.args, self.kwds, self.func
   209|         0|            0|            0|  0.00%|        try:
   210|         0|            0|            0|  0.00%|            return await anext(self.gen)
   211|         0|            0|            0|  0.00%|        except StopAsyncIteration:
   212|         0|            0|            0|  0.00%|            raise RuntimeError("generator didn't yield") from None
   213|         0|            0|            0|  0.00%|
   214|         0|            0|            0|  0.00%|    async def __aexit__(self, typ, value, traceback):
   215|         0|            0|            0|  0.00%|        if typ is None:
   216|         0|            0|            0|  0.00%|            try:
   217|         0|            0|            0|  0.00%|                await anext(self.gen)
   218|         0|            0|            0|  0.00%|            except StopAsyncIteration:
   219|         0|            0|            0|  0.00%|                return False
   220|         0|            0|            0|  0.00%|            else:
   221|         0|            0|            0|  0.00%|                try:
   222|         0|            0|            0|  0.00%|                    raise RuntimeError("generator didn't stop")
   223|         0|            0|            0|  0.00%|                finally:
   224|         0|            0|            0|  0.00%|                    await self.gen.aclose()
   225|         0|            0|            0|  0.00%|        else:
   226|         0|            0|            0|  0.00%|            if value is None:
   227|         0|            0|            0|  0.00%|                # Need to force instantiation so we can reliably
   228|         0|            0|            0|  0.00%|                # tell if we get the same exception back
   229|         0|            0|            0|  0.00%|                value = typ()
   230|         0|            0|            0|  0.00%|            try:
   231|         0|            0|            0|  0.00%|                await self.gen.athrow(value)
   232|         0|            0|            0|  0.00%|            except StopAsyncIteration as exc:
   233|         0|            0|            0|  0.00%|                # Suppress StopIteration *unless* it's the same exception that
   234|         0|            0|            0|  0.00%|                # was passed to throw().  This prevents a StopIteration
   235|         0|            0|            0|  0.00%|                # raised inside the "with" statement from being suppressed.
   236|         0|            0|            0|  0.00%|                return exc is not value
   237|         0|            0|            0|  0.00%|            except RuntimeError as exc:
   238|         0|            0|            0|  0.00%|                # Don't re-raise the passed in exception. (issue27122)
   239|         0|            0|            0|  0.00%|                if exc is value:
   240|         0|            0|            0|  0.00%|                    exc.__traceback__ = traceback
   241|         0|            0|            0|  0.00%|                    return False
   242|         0|            0|            0|  0.00%|                # Avoid suppressing if a Stop(Async)Iteration exception
   243|         0|            0|            0|  0.00%|                # was passed to athrow() and later wrapped into a RuntimeError
   244|         0|            0|            0|  0.00%|                # (see PEP 479 for sync generators; async generators also
   245|         0|            0|            0|  0.00%|                # have this behavior). But do this only if the exception wrapped
   246|         0|            0|            0|  0.00%|                # by the RuntimeError is actually Stop(Async)Iteration (see
   247|         0|            0|            0|  0.00%|                # issue29692).
   248|         0|            0|            0|  0.00%|                if (
   249|         0|            0|            0|  0.00%|                    isinstance(value, (StopIteration, StopAsyncIteration))
   250|         0|            0|            0|  0.00%|                    and exc.__cause__ is value
   251|         0|            0|            0|  0.00%|                ):
   252|         0|            0|            0|  0.00%|                    value.__traceback__ = traceback
   253|         0|            0|            0|  0.00%|                    return False
   254|         0|            0|            0|  0.00%|                raise
   255|         0|            0|            0|  0.00%|            except BaseException as exc:
   256|         0|            0|            0|  0.00%|                # only re-raise if it's *not* the exception that was
   257|         0|            0|            0|  0.00%|                # passed to throw(), because __exit__() must not raise
   258|         0|            0|            0|  0.00%|                # an exception unless __exit__() itself failed.  But throw()
   259|         0|            0|            0|  0.00%|                # has to raise the exception to signal propagation, so this
   260|         0|            0|            0|  0.00%|                # fixes the impedance mismatch between the throw() protocol
   261|         0|            0|            0|  0.00%|                # and the __exit__() protocol.
   262|         0|            0|            0|  0.00%|                if exc is not value:
   263|         0|            0|            0|  0.00%|                    raise
   264|         0|            0|            0|  0.00%|                exc.__traceback__ = traceback
   265|         0|            0|            0|  0.00%|                return False
   266|         0|            0|            0|  0.00%|            try:
   267|         0|            0|            0|  0.00%|                raise RuntimeError("generator didn't stop after athrow()")
   268|         0|            0|            0|  0.00%|            finally:
   269|         0|            0|            0|  0.00%|                await self.gen.aclose()
   270|         0|            0|            0|  0.00%|
   271|         0|            0|            0|  0.00%|
   272|         0|            0|            0|  0.00%|def contextmanager(func):
   273|         0|            0|            0|  0.00%|    """@contextmanager decorator.
   274|         0|            0|            0|  0.00%|
   275|         0|            0|            0|  0.00%|    Typical usage:
   276|         0|            0|            0|  0.00%|
   277|         0|            0|            0|  0.00%|        @contextmanager
   278|         0|            0|            0|  0.00%|        def some_generator(<arguments>):
   279|         0|            0|            0|  0.00%|            <setup>
   280|         0|            0|            0|  0.00%|            try:
   281|         0|            0|            0|  0.00%|                yield <value>
   282|         0|            0|            0|  0.00%|            finally:
   283|         0|            0|            0|  0.00%|                <cleanup>
   284|         0|            0|            0|  0.00%|
   285|         0|            0|            0|  0.00%|    This makes this:
   286|         0|            0|            0|  0.00%|
   287|         0|            0|            0|  0.00%|        with some_generator(<arguments>) as <variable>:
   288|         0|            0|            0|  0.00%|            <body>
   289|         0|            0|            0|  0.00%|
   290|         0|            0|            0|  0.00%|    equivalent to this:
   291|         0|            0|            0|  0.00%|
   292|         0|            0|            0|  0.00%|        <setup>
   293|         0|            0|            0|  0.00%|        try:
   294|         0|            0|            0|  0.00%|            <variable> = <value>
   295|         0|            0|            0|  0.00%|            <body>
   296|         0|            0|            0|  0.00%|        finally:
   297|         0|            0|            0|  0.00%|            <cleanup>
   298|         0|            0|            0|  0.00%|    """
   299|         8|  1.90735e-05|  2.38419e-06|  0.02%|    @wraps(func)
   300|         0|            0|            0|  0.00%|    def helper(*args, **kwds):
   301|         8|  5.62668e-05|  7.03335e-06|  0.06%|        return _GeneratorContextManager(func, args, kwds)
(call)|         8|  7.98702e-05|  9.98378e-06|  0.08%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/contextlib.py:104 __init__
   302|         0|            0|            0|  0.00%|    return helper
   303|         0|            0|            0|  0.00%|
   304|         0|            0|            0|  0.00%|
   305|         0|            0|            0|  0.00%|def asynccontextmanager(func):
   306|         0|            0|            0|  0.00%|    """@asynccontextmanager decorator.
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|    Typical usage:
   309|         0|            0|            0|  0.00%|
   310|         0|            0|            0|  0.00%|        @asynccontextmanager
   311|         0|            0|            0|  0.00%|        async def some_async_generator(<arguments>):
   312|         0|            0|            0|  0.00%|            <setup>
   313|         0|            0|            0|  0.00%|            try:
   314|         0|            0|            0|  0.00%|                yield <value>
   315|         0|            0|            0|  0.00%|            finally:
   316|         0|            0|            0|  0.00%|                <cleanup>
   317|         0|            0|            0|  0.00%|
   318|         0|            0|            0|  0.00%|    This makes this:
   319|         0|            0|            0|  0.00%|
   320|         0|            0|            0|  0.00%|        async with some_async_generator(<arguments>) as <variable>:
   321|         0|            0|            0|  0.00%|            <body>
   322|         0|            0|            0|  0.00%|
   323|         0|            0|            0|  0.00%|    equivalent to this:
   324|         0|            0|            0|  0.00%|
   325|         0|            0|            0|  0.00%|        <setup>
   326|         0|            0|            0|  0.00%|        try:
   327|         0|            0|            0|  0.00%|            <variable> = <value>
   328|         0|            0|            0|  0.00%|            <body>
   329|         0|            0|            0|  0.00%|        finally:
   330|         0|            0|            0|  0.00%|            <cleanup>
   331|         0|            0|            0|  0.00%|    """
   332|         0|            0|            0|  0.00%|    @wraps(func)
   333|         0|            0|            0|  0.00%|    def helper(*args, **kwds):
   334|         0|            0|            0|  0.00%|        return _AsyncGeneratorContextManager(func, args, kwds)
   335|         0|            0|            0|  0.00%|    return helper
   336|         0|            0|            0|  0.00%|
   337|         0|            0|            0|  0.00%|
   338|         0|            0|            0|  0.00%|class closing(AbstractContextManager):
   339|         0|            0|            0|  0.00%|    """Context to automatically close something at the end of a block.
   340|         0|            0|            0|  0.00%|
   341|         0|            0|            0|  0.00%|    Code like this:
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|        with closing(<module>.open(<arguments>)) as f:
   344|         0|            0|            0|  0.00%|            <block>
   345|         0|            0|            0|  0.00%|
   346|         0|            0|            0|  0.00%|    is equivalent to this:
   347|         0|            0|            0|  0.00%|
   348|         0|            0|            0|  0.00%|        f = <module>.open(<arguments>)
   349|         0|            0|            0|  0.00%|        try:
   350|         0|            0|            0|  0.00%|            <block>
   351|         0|            0|            0|  0.00%|        finally:
   352|         0|            0|            0|  0.00%|            f.close()
   353|         0|            0|            0|  0.00%|
   354|         0|            0|            0|  0.00%|    """
   355|         0|            0|            0|  0.00%|    def __init__(self, thing):
   356|         0|            0|            0|  0.00%|        self.thing = thing
   357|         0|            0|            0|  0.00%|    def __enter__(self):
   358|         0|            0|            0|  0.00%|        return self.thing
   359|         0|            0|            0|  0.00%|    def __exit__(self, *exc_info):
   360|         0|            0|            0|  0.00%|        self.thing.close()
   361|         0|            0|            0|  0.00%|
   362|         0|            0|            0|  0.00%|
   363|         0|            0|            0|  0.00%|class aclosing(AbstractAsyncContextManager):
   364|         0|            0|            0|  0.00%|    """Async context manager for safely finalizing an asynchronously cleaned-up
   365|         0|            0|            0|  0.00%|    resource such as an async generator, calling its ``aclose()`` method.
   366|         0|            0|            0|  0.00%|
   367|         0|            0|            0|  0.00%|    Code like this:
   368|         0|            0|            0|  0.00%|
   369|         0|            0|            0|  0.00%|        async with aclosing(<module>.fetch(<arguments>)) as agen:
   370|         0|            0|            0|  0.00%|            <block>
   371|         0|            0|            0|  0.00%|
   372|         0|            0|            0|  0.00%|    is equivalent to this:
   373|         0|            0|            0|  0.00%|
   374|         0|            0|            0|  0.00%|        agen = <module>.fetch(<arguments>)
   375|         0|            0|            0|  0.00%|        try:
   376|         0|            0|            0|  0.00%|            <block>
   377|         0|            0|            0|  0.00%|        finally:
   378|         0|            0|            0|  0.00%|            await agen.aclose()
   379|         0|            0|            0|  0.00%|
   380|         0|            0|            0|  0.00%|    """
   381|         0|            0|            0|  0.00%|    def __init__(self, thing):
   382|         0|            0|            0|  0.00%|        self.thing = thing
   383|         0|            0|            0|  0.00%|    async def __aenter__(self):
   384|         0|            0|            0|  0.00%|        return self.thing
   385|         0|            0|            0|  0.00%|    async def __aexit__(self, *exc_info):
   386|         0|            0|            0|  0.00%|        await self.thing.aclose()
   387|         0|            0|            0|  0.00%|
   388|         0|            0|            0|  0.00%|
   389|         0|            0|            0|  0.00%|class _RedirectStream(AbstractContextManager):
   390|         0|            0|            0|  0.00%|
   391|         0|            0|            0|  0.00%|    _stream = None
   392|         0|            0|            0|  0.00%|
   393|         0|            0|            0|  0.00%|    def __init__(self, new_target):
   394|         0|            0|            0|  0.00%|        self._new_target = new_target
   395|         0|            0|            0|  0.00%|        # We use a list of old targets to make this CM re-entrant
   396|         0|            0|            0|  0.00%|        self._old_targets = []
   397|         0|            0|            0|  0.00%|
   398|         0|            0|            0|  0.00%|    def __enter__(self):
   399|         0|            0|            0|  0.00%|        self._old_targets.append(getattr(sys, self._stream))
   400|         0|            0|            0|  0.00%|        setattr(sys, self._stream, self._new_target)
   401|         0|            0|            0|  0.00%|        return self._new_target
   402|         0|            0|            0|  0.00%|
   403|         0|            0|            0|  0.00%|    def __exit__(self, exctype, excinst, exctb):
   404|         0|            0|            0|  0.00%|        setattr(sys, self._stream, self._old_targets.pop())
   405|         0|            0|            0|  0.00%|
   406|         0|            0|            0|  0.00%|
   407|         0|            0|            0|  0.00%|class redirect_stdout(_RedirectStream):
   408|         0|            0|            0|  0.00%|    """Context manager for temporarily redirecting stdout to another file.
   409|         0|            0|            0|  0.00%|
   410|         0|            0|            0|  0.00%|        # How to send help() to stderr
   411|         0|            0|            0|  0.00%|        with redirect_stdout(sys.stderr):
   412|         0|            0|            0|  0.00%|            help(dir)
   413|         0|            0|            0|  0.00%|
   414|         0|            0|            0|  0.00%|        # How to write help() to a file
   415|         0|            0|            0|  0.00%|        with open('help.txt', 'w') as f:
   416|         0|            0|            0|  0.00%|            with redirect_stdout(f):
   417|         0|            0|            0|  0.00%|                help(pow)
   418|         0|            0|            0|  0.00%|    """
   419|         0|            0|            0|  0.00%|
   420|         0|            0|            0|  0.00%|    _stream = "stdout"
   421|         0|            0|            0|  0.00%|
   422|         0|            0|            0|  0.00%|
   423|         0|            0|            0|  0.00%|class redirect_stderr(_RedirectStream):
   424|         0|            0|            0|  0.00%|    """Context manager for temporarily redirecting stderr to another file."""
   425|         0|            0|            0|  0.00%|
   426|         0|            0|            0|  0.00%|    _stream = "stderr"
   427|         0|            0|            0|  0.00%|
   428|         0|            0|            0|  0.00%|
   429|         0|            0|            0|  0.00%|class suppress(AbstractContextManager):
   430|         0|            0|            0|  0.00%|    """Context manager to suppress specified exceptions
   431|         0|            0|            0|  0.00%|
   432|         0|            0|            0|  0.00%|    After the exception is suppressed, execution proceeds with the next
   433|         0|            0|            0|  0.00%|    statement following the with statement.
   434|         0|            0|            0|  0.00%|
   435|         0|            0|            0|  0.00%|         with suppress(FileNotFoundError):
   436|         0|            0|            0|  0.00%|             os.remove(somefile)
   437|         0|            0|            0|  0.00%|         # Execution still resumes here if the file was already removed
   438|         0|            0|            0|  0.00%|    """
   439|         0|            0|            0|  0.00%|
   440|         0|            0|            0|  0.00%|    def __init__(self, *exceptions):
   441|         0|            0|            0|  0.00%|        self._exceptions = exceptions
   442|         0|            0|            0|  0.00%|
   443|         0|            0|            0|  0.00%|    def __enter__(self):
   444|         0|            0|            0|  0.00%|        pass
   445|         0|            0|            0|  0.00%|
   446|         0|            0|            0|  0.00%|    def __exit__(self, exctype, excinst, exctb):
   447|         0|            0|            0|  0.00%|        # Unlike isinstance and issubclass, CPython exception handling
   448|         0|            0|            0|  0.00%|        # currently only looks at the concrete type hierarchy (ignoring
   449|         0|            0|            0|  0.00%|        # the instance and subclass checking hooks). While Guido considers
   450|         0|            0|            0|  0.00%|        # that a bug rather than a feature, it's a fairly hard one to fix
   451|         0|            0|            0|  0.00%|        # due to various internal implementation details. suppress provides
   452|         0|            0|            0|  0.00%|        # the simpler issubclass based semantics, rather than trying to
   453|         0|            0|            0|  0.00%|        # exactly reproduce the limitations of the CPython interpreter.
   454|         0|            0|            0|  0.00%|        #
   455|         0|            0|            0|  0.00%|        # See http://bugs.python.org/issue12029 for more details
   456|         0|            0|            0|  0.00%|        if exctype is None:
   457|         0|            0|            0|  0.00%|            return
   458|         0|            0|            0|  0.00%|        if issubclass(exctype, self._exceptions):
   459|         0|            0|            0|  0.00%|            return True
   460|         0|            0|            0|  0.00%|        if issubclass(exctype, BaseExceptionGroup):
   461|         0|            0|            0|  0.00%|            match, rest = excinst.split(self._exceptions)
   462|         0|            0|            0|  0.00%|            if rest is None:
   463|         0|            0|            0|  0.00%|                return True
   464|         0|            0|            0|  0.00%|            raise rest
   465|         0|            0|            0|  0.00%|        return False
   466|         0|            0|            0|  0.00%|
   467|         0|            0|            0|  0.00%|
   468|         0|            0|            0|  0.00%|class _BaseExitStack:
   469|         0|            0|            0|  0.00%|    """A base class for ExitStack and AsyncExitStack."""
   470|         0|            0|            0|  0.00%|
   471|         0|            0|            0|  0.00%|    @staticmethod
   472|         0|            0|            0|  0.00%|    def _create_exit_wrapper(cm, cm_exit):
   473|         0|            0|            0|  0.00%|        return MethodType(cm_exit, cm)
   474|         0|            0|            0|  0.00%|
   475|         0|            0|            0|  0.00%|    @staticmethod
   476|         0|            0|            0|  0.00%|    def _create_cb_wrapper(callback, /, *args, **kwds):
   477|         0|            0|            0|  0.00%|        def _exit_wrapper(exc_type, exc, tb):
   478|         0|            0|            0|  0.00%|            callback(*args, **kwds)
   479|         0|            0|            0|  0.00%|        return _exit_wrapper
   480|         0|            0|            0|  0.00%|
   481|         0|            0|            0|  0.00%|    def __init__(self):
   482|         0|            0|            0|  0.00%|        self._exit_callbacks = deque()
   483|         0|            0|            0|  0.00%|
   484|         0|            0|            0|  0.00%|    def pop_all(self):
   485|         0|            0|            0|  0.00%|        """Preserve the context stack by transferring it to a new instance."""
   486|         0|            0|            0|  0.00%|        new_stack = type(self)()
   487|         0|            0|            0|  0.00%|        new_stack._exit_callbacks = self._exit_callbacks
   488|         0|            0|            0|  0.00%|        self._exit_callbacks = deque()
   489|         0|            0|            0|  0.00%|        return new_stack
   490|         0|            0|            0|  0.00%|
   491|         0|            0|            0|  0.00%|    def push(self, exit):
   492|         0|            0|            0|  0.00%|        """Registers a callback with the standard __exit__ method signature.
   493|         0|            0|            0|  0.00%|
   494|         0|            0|            0|  0.00%|        Can suppress exceptions the same way __exit__ method can.
   495|         0|            0|            0|  0.00%|        Also accepts any object with an __exit__ method (registering a call
   496|         0|            0|            0|  0.00%|        to the method instead of the object itself).
   497|         0|            0|            0|  0.00%|        """
   498|         0|            0|            0|  0.00%|        # We use an unbound method rather than a bound method to follow
   499|         0|            0|            0|  0.00%|        # the standard lookup behaviour for special methods.
   500|         0|            0|            0|  0.00%|        _cb_type = type(exit)
   501|         0|            0|            0|  0.00%|
   502|         0|            0|            0|  0.00%|        try:
   503|         0|            0|            0|  0.00%|            exit_method = _cb_type.__exit__
   504|         0|            0|            0|  0.00%|        except AttributeError:
   505|         0|            0|            0|  0.00%|            # Not a context manager, so assume it's a callable.
   506|         0|            0|            0|  0.00%|            self._push_exit_callback(exit)
   507|         0|            0|            0|  0.00%|        else:
   508|         0|            0|            0|  0.00%|            self._push_cm_exit(exit, exit_method)
   509|         0|            0|            0|  0.00%|        return exit  # Allow use as a decorator.
   510|         0|            0|            0|  0.00%|
   511|         0|            0|            0|  0.00%|    def enter_context(self, cm):
   512|         0|            0|            0|  0.00%|        """Enters the supplied context manager.
   513|         0|            0|            0|  0.00%|
   514|         0|            0|            0|  0.00%|        If successful, also pushes its __exit__ method as a callback and
   515|         0|            0|            0|  0.00%|        returns the result of the __enter__ method.
   516|         0|            0|            0|  0.00%|        """
   517|         0|            0|            0|  0.00%|        # We look up the special methods on the type to match the with
   518|         0|            0|            0|  0.00%|        # statement.
   519|         0|            0|            0|  0.00%|        cls = type(cm)
   520|         0|            0|            0|  0.00%|        try:
   521|         0|            0|            0|  0.00%|            _enter = cls.__enter__
   522|         0|            0|            0|  0.00%|            _exit = cls.__exit__
   523|         0|            0|            0|  0.00%|        except AttributeError:
   524|         0|            0|            0|  0.00%|            raise TypeError(f"'{cls.__module__}.{cls.__qualname__}' object does "
   525|         0|            0|            0|  0.00%|                            f"not support the context manager protocol") from None
   526|         0|            0|            0|  0.00%|        result = _enter(cm)
   527|         0|            0|            0|  0.00%|        self._push_cm_exit(cm, _exit)
   528|         0|            0|            0|  0.00%|        return result
   529|         0|            0|            0|  0.00%|
   530|         0|            0|            0|  0.00%|    def callback(self, callback, /, *args, **kwds):
   531|         0|            0|            0|  0.00%|        """Registers an arbitrary callback and arguments.
   532|         0|            0|            0|  0.00%|
   533|         0|            0|            0|  0.00%|        Cannot suppress exceptions.
   534|         0|            0|            0|  0.00%|        """
   535|         0|            0|            0|  0.00%|        _exit_wrapper = self._create_cb_wrapper(callback, *args, **kwds)
   536|         0|            0|            0|  0.00%|
   537|         0|            0|            0|  0.00%|        # We changed the signature, so using @wraps is not appropriate, but
   538|         0|            0|            0|  0.00%|        # setting __wrapped__ may still help with introspection.
   539|         0|            0|            0|  0.00%|        _exit_wrapper.__wrapped__ = callback
   540|         0|            0|            0|  0.00%|        self._push_exit_callback(_exit_wrapper)
   541|         0|            0|            0|  0.00%|        return callback  # Allow use as a decorator
   542|         0|            0|            0|  0.00%|
   543|         0|            0|            0|  0.00%|    def _push_cm_exit(self, cm, cm_exit):
   544|         0|            0|            0|  0.00%|        """Helper to correctly register callbacks to __exit__ methods."""
   545|         0|            0|            0|  0.00%|        _exit_wrapper = self._create_exit_wrapper(cm, cm_exit)
   546|         0|            0|            0|  0.00%|        self._push_exit_callback(_exit_wrapper, True)
   547|         0|            0|            0|  0.00%|
   548|         0|            0|            0|  0.00%|    def _push_exit_callback(self, callback, is_sync=True):
   549|         0|            0|            0|  0.00%|        self._exit_callbacks.append((is_sync, callback))
   550|         0|            0|            0|  0.00%|
   551|         0|            0|            0|  0.00%|
   552|         0|            0|            0|  0.00%|# Inspired by discussions on http://bugs.python.org/issue13585
   553|         0|            0|            0|  0.00%|class ExitStack(_BaseExitStack, AbstractContextManager):
   554|         0|            0|            0|  0.00%|    """Context manager for dynamic management of a stack of exit callbacks.
   555|         0|            0|            0|  0.00%|
   556|         0|            0|            0|  0.00%|    For example:
   557|         0|            0|            0|  0.00%|        with ExitStack() as stack:
   558|         0|            0|            0|  0.00%|            files = [stack.enter_context(open(fname)) for fname in filenames]
   559|         0|            0|            0|  0.00%|            # All opened files will automatically be closed at the end of
   560|         0|            0|            0|  0.00%|            # the with statement, even if attempts to open files later
   561|         0|            0|            0|  0.00%|            # in the list raise an exception.
   562|         0|            0|            0|  0.00%|    """
   563|         0|            0|            0|  0.00%|
   564|         0|            0|            0|  0.00%|    def __enter__(self):
   565|         0|            0|            0|  0.00%|        return self
   566|         0|            0|            0|  0.00%|
   567|         0|            0|            0|  0.00%|    def __exit__(self, *exc_details):
   568|         0|            0|            0|  0.00%|        received_exc = exc_details[0] is not None
   569|         0|            0|            0|  0.00%|
   570|         0|            0|            0|  0.00%|        # We manipulate the exception state so it behaves as though
   571|         0|            0|            0|  0.00%|        # we were actually nesting multiple with statements
   572|         0|            0|            0|  0.00%|        frame_exc = sys.exc_info()[1]
   573|         0|            0|            0|  0.00%|        def _fix_exception_context(new_exc, old_exc):
   574|         0|            0|            0|  0.00%|            # Context may not be correct, so find the end of the chain
   575|         0|            0|            0|  0.00%|            while 1:
   576|         0|            0|            0|  0.00%|                exc_context = new_exc.__context__
   577|         0|            0|            0|  0.00%|                if exc_context is None or exc_context is old_exc:
   578|         0|            0|            0|  0.00%|                    # Context is already set correctly (see issue 20317)
   579|         0|            0|            0|  0.00%|                    return
   580|         0|            0|            0|  0.00%|                if exc_context is frame_exc:
   581|         0|            0|            0|  0.00%|                    break
   582|         0|            0|            0|  0.00%|                new_exc = exc_context
   583|         0|            0|            0|  0.00%|            # Change the end of the chain to point to the exception
   584|         0|            0|            0|  0.00%|            # we expect it to reference
   585|         0|            0|            0|  0.00%|            new_exc.__context__ = old_exc
   586|         0|            0|            0|  0.00%|
   587|         0|            0|            0|  0.00%|        # Callbacks are invoked in LIFO order to match the behaviour of
   588|         0|            0|            0|  0.00%|        # nested context managers
   589|         0|            0|            0|  0.00%|        suppressed_exc = False
   590|         0|            0|            0|  0.00%|        pending_raise = False
   591|         0|            0|            0|  0.00%|        while self._exit_callbacks:
   592|         0|            0|            0|  0.00%|            is_sync, cb = self._exit_callbacks.pop()
   593|         0|            0|            0|  0.00%|            assert is_sync
   594|         0|            0|            0|  0.00%|            try:
   595|         0|            0|            0|  0.00%|                if cb(*exc_details):
   596|         0|            0|            0|  0.00%|                    suppressed_exc = True
   597|         0|            0|            0|  0.00%|                    pending_raise = False
   598|         0|            0|            0|  0.00%|                    exc_details = (None, None, None)
   599|         0|            0|            0|  0.00%|            except:
   600|         0|            0|            0|  0.00%|                new_exc_details = sys.exc_info()
   601|         0|            0|            0|  0.00%|                # simulate the stack of exceptions by setting the context
   602|         0|            0|            0|  0.00%|                _fix_exception_context(new_exc_details[1], exc_details[1])
   603|         0|            0|            0|  0.00%|                pending_raise = True
   604|         0|            0|            0|  0.00%|                exc_details = new_exc_details
   605|         0|            0|            0|  0.00%|        if pending_raise:
   606|         0|            0|            0|  0.00%|            try:
   607|         0|            0|            0|  0.00%|                # bare "raise exc_details[1]" replaces our carefully
   608|         0|            0|            0|  0.00%|                # set-up context
   609|         0|            0|            0|  0.00%|                fixed_ctx = exc_details[1].__context__
   610|         0|            0|            0|  0.00%|                raise exc_details[1]
   611|         0|            0|            0|  0.00%|            except BaseException:
   612|         0|            0|            0|  0.00%|                exc_details[1].__context__ = fixed_ctx
   613|         0|            0|            0|  0.00%|                raise
   614|         0|            0|            0|  0.00%|        return received_exc and suppressed_exc
   615|         0|            0|            0|  0.00%|
   616|         0|            0|            0|  0.00%|    def close(self):
   617|         0|            0|            0|  0.00%|        """Immediately unwind the context stack."""
   618|         0|            0|            0|  0.00%|        self.__exit__(None, None, None)
   619|         0|            0|            0|  0.00%|
   620|         0|            0|            0|  0.00%|
   621|         0|            0|            0|  0.00%|# Inspired by discussions on https://bugs.python.org/issue29302
   622|         0|            0|            0|  0.00%|class AsyncExitStack(_BaseExitStack, AbstractAsyncContextManager):
   623|         0|            0|            0|  0.00%|    """Async context manager for dynamic management of a stack of exit
   624|         0|            0|            0|  0.00%|    callbacks.
   625|         0|            0|            0|  0.00%|
   626|         0|            0|            0|  0.00%|    For example:
   627|         0|            0|            0|  0.00%|        async with AsyncExitStack() as stack:
   628|         0|            0|            0|  0.00%|            connections = [await stack.enter_async_context(get_connection())
   629|         0|            0|            0|  0.00%|                for i in range(5)]
   630|         0|            0|            0|  0.00%|            # All opened connections will automatically be released at the
   631|         0|            0|            0|  0.00%|            # end of the async with statement, even if attempts to open a
   632|         0|            0|            0|  0.00%|            # connection later in the list raise an exception.
   633|         0|            0|            0|  0.00%|    """
   634|         0|            0|            0|  0.00%|
   635|         0|            0|            0|  0.00%|    @staticmethod
   636|         0|            0|            0|  0.00%|    def _create_async_exit_wrapper(cm, cm_exit):
   637|         0|            0|            0|  0.00%|        return MethodType(cm_exit, cm)
   638|         0|            0|            0|  0.00%|
   639|         0|            0|            0|  0.00%|    @staticmethod
   640|         0|            0|            0|  0.00%|    def _create_async_cb_wrapper(callback, /, *args, **kwds):
   641|         0|            0|            0|  0.00%|        async def _exit_wrapper(exc_type, exc, tb):
   642|         0|            0|            0|  0.00%|            await callback(*args, **kwds)
   643|         0|            0|            0|  0.00%|        return _exit_wrapper
   644|         0|            0|            0|  0.00%|
   645|         0|            0|            0|  0.00%|    async def enter_async_context(self, cm):
   646|         0|            0|            0|  0.00%|        """Enters the supplied async context manager.
   647|         0|            0|            0|  0.00%|
   648|         0|            0|            0|  0.00%|        If successful, also pushes its __aexit__ method as a callback and
   649|         0|            0|            0|  0.00%|        returns the result of the __aenter__ method.
   650|         0|            0|            0|  0.00%|        """
   651|         0|            0|            0|  0.00%|        cls = type(cm)
   652|         0|            0|            0|  0.00%|        try:
   653|         0|            0|            0|  0.00%|            _enter = cls.__aenter__
   654|         0|            0|            0|  0.00%|            _exit = cls.__aexit__
   655|         0|            0|            0|  0.00%|        except AttributeError:
   656|         0|            0|            0|  0.00%|            raise TypeError(f"'{cls.__module__}.{cls.__qualname__}' object does "
   657|         0|            0|            0|  0.00%|                            f"not support the asynchronous context manager protocol"
   658|         0|            0|            0|  0.00%|                           ) from None
   659|         0|            0|            0|  0.00%|        result = await _enter(cm)
   660|         0|            0|            0|  0.00%|        self._push_async_cm_exit(cm, _exit)
   661|         0|            0|            0|  0.00%|        return result
   662|         0|            0|            0|  0.00%|
   663|         0|            0|            0|  0.00%|    def push_async_exit(self, exit):
   664|         0|            0|            0|  0.00%|        """Registers a coroutine function with the standard __aexit__ method
   665|         0|            0|            0|  0.00%|        signature.
   666|         0|            0|            0|  0.00%|
   667|         0|            0|            0|  0.00%|        Can suppress exceptions the same way __aexit__ method can.
   668|         0|            0|            0|  0.00%|        Also accepts any object with an __aexit__ method (registering a call
   669|         0|            0|            0|  0.00%|        to the method instead of the object itself).
   670|         0|            0|            0|  0.00%|        """
   671|         0|            0|            0|  0.00%|        _cb_type = type(exit)
   672|         0|            0|            0|  0.00%|        try:
   673|         0|            0|            0|  0.00%|            exit_method = _cb_type.__aexit__
   674|         0|            0|            0|  0.00%|        except AttributeError:
   675|         0|            0|            0|  0.00%|            # Not an async context manager, so assume it's a coroutine function
   676|         0|            0|            0|  0.00%|            self._push_exit_callback(exit, False)
   677|         0|            0|            0|  0.00%|        else:
   678|         0|            0|            0|  0.00%|            self._push_async_cm_exit(exit, exit_method)
   679|         0|            0|            0|  0.00%|        return exit  # Allow use as a decorator
   680|         0|            0|            0|  0.00%|
   681|         0|            0|            0|  0.00%|    def push_async_callback(self, callback, /, *args, **kwds):
   682|         0|            0|            0|  0.00%|        """Registers an arbitrary coroutine function and arguments.
   683|         0|            0|            0|  0.00%|
   684|         0|            0|            0|  0.00%|        Cannot suppress exceptions.
   685|         0|            0|            0|  0.00%|        """
   686|         0|            0|            0|  0.00%|        _exit_wrapper = self._create_async_cb_wrapper(callback, *args, **kwds)
   687|         0|            0|            0|  0.00%|
   688|         0|            0|            0|  0.00%|        # We changed the signature, so using @wraps is not appropriate, but
   689|         0|            0|            0|  0.00%|        # setting __wrapped__ may still help with introspection.
   690|         0|            0|            0|  0.00%|        _exit_wrapper.__wrapped__ = callback
   691|         0|            0|            0|  0.00%|        self._push_exit_callback(_exit_wrapper, False)
   692|         0|            0|            0|  0.00%|        return callback  # Allow use as a decorator
   693|         0|            0|            0|  0.00%|
   694|         0|            0|            0|  0.00%|    async def aclose(self):
   695|         0|            0|            0|  0.00%|        """Immediately unwind the context stack."""
   696|         0|            0|            0|  0.00%|        await self.__aexit__(None, None, None)
   697|         0|            0|            0|  0.00%|
   698|         0|            0|            0|  0.00%|    def _push_async_cm_exit(self, cm, cm_exit):
   699|         0|            0|            0|  0.00%|        """Helper to correctly register coroutine function to __aexit__
   700|         0|            0|            0|  0.00%|        method."""
   701|         0|            0|            0|  0.00%|        _exit_wrapper = self._create_async_exit_wrapper(cm, cm_exit)
   702|         0|            0|            0|  0.00%|        self._push_exit_callback(_exit_wrapper, False)
   703|         0|            0|            0|  0.00%|
   704|         0|            0|            0|  0.00%|    async def __aenter__(self):
   705|         0|            0|            0|  0.00%|        return self
   706|         0|            0|            0|  0.00%|
   707|         0|            0|            0|  0.00%|    async def __aexit__(self, *exc_details):
   708|         0|            0|            0|  0.00%|        received_exc = exc_details[0] is not None
   709|         0|            0|            0|  0.00%|
   710|         0|            0|            0|  0.00%|        # We manipulate the exception state so it behaves as though
   711|         0|            0|            0|  0.00%|        # we were actually nesting multiple with statements
   712|         0|            0|            0|  0.00%|        frame_exc = sys.exc_info()[1]
   713|         0|            0|            0|  0.00%|        def _fix_exception_context(new_exc, old_exc):
   714|         0|            0|            0|  0.00%|            # Context may not be correct, so find the end of the chain
   715|         0|            0|            0|  0.00%|            while 1:
   716|         0|            0|            0|  0.00%|                exc_context = new_exc.__context__
   717|         0|            0|            0|  0.00%|                if exc_context is None or exc_context is old_exc:
   718|         0|            0|            0|  0.00%|                    # Context is already set correctly (see issue 20317)
   719|         0|            0|            0|  0.00%|                    return
   720|         0|            0|            0|  0.00%|                if exc_context is frame_exc:
   721|         0|            0|            0|  0.00%|                    break
   722|         0|            0|            0|  0.00%|                new_exc = exc_context
   723|         0|            0|            0|  0.00%|            # Change the end of the chain to point to the exception
   724|         0|            0|            0|  0.00%|            # we expect it to reference
   725|         0|            0|            0|  0.00%|            new_exc.__context__ = old_exc
   726|         0|            0|            0|  0.00%|
   727|         0|            0|            0|  0.00%|        # Callbacks are invoked in LIFO order to match the behaviour of
   728|         0|            0|            0|  0.00%|        # nested context managers
   729|         0|            0|            0|  0.00%|        suppressed_exc = False
   730|         0|            0|            0|  0.00%|        pending_raise = False
   731|         0|            0|            0|  0.00%|        while self._exit_callbacks:
   732|         0|            0|            0|  0.00%|            is_sync, cb = self._exit_callbacks.pop()
   733|         0|            0|            0|  0.00%|            try:
   734|         0|            0|            0|  0.00%|                if is_sync:
   735|         0|            0|            0|  0.00%|                    cb_suppress = cb(*exc_details)
   736|         0|            0|            0|  0.00%|                else:
   737|         0|            0|            0|  0.00%|                    cb_suppress = await cb(*exc_details)
   738|         0|            0|            0|  0.00%|
   739|         0|            0|            0|  0.00%|                if cb_suppress:
   740|         0|            0|            0|  0.00%|                    suppressed_exc = True
   741|         0|            0|            0|  0.00%|                    pending_raise = False
   742|         0|            0|            0|  0.00%|                    exc_details = (None, None, None)
   743|         0|            0|            0|  0.00%|            except:
   744|         0|            0|            0|  0.00%|                new_exc_details = sys.exc_info()
   745|         0|            0|            0|  0.00%|                # simulate the stack of exceptions by setting the context
   746|         0|            0|            0|  0.00%|                _fix_exception_context(new_exc_details[1], exc_details[1])
   747|         0|            0|            0|  0.00%|                pending_raise = True
   748|         0|            0|            0|  0.00%|                exc_details = new_exc_details
   749|         0|            0|            0|  0.00%|        if pending_raise:
   750|         0|            0|            0|  0.00%|            try:
   751|         0|            0|            0|  0.00%|                # bare "raise exc_details[1]" replaces our carefully
   752|         0|            0|            0|  0.00%|                # set-up context
   753|         0|            0|            0|  0.00%|                fixed_ctx = exc_details[1].__context__
   754|         0|            0|            0|  0.00%|                raise exc_details[1]
   755|         0|            0|            0|  0.00%|            except BaseException:
   756|         0|            0|            0|  0.00%|                exc_details[1].__context__ = fixed_ctx
   757|         0|            0|            0|  0.00%|                raise
   758|         0|            0|            0|  0.00%|        return received_exc and suppressed_exc
   759|         0|            0|            0|  0.00%|
   760|         0|            0|            0|  0.00%|
   761|         0|            0|            0|  0.00%|class nullcontext(AbstractContextManager, AbstractAsyncContextManager):
   762|         0|            0|            0|  0.00%|    """Context manager that does no additional processing.
   763|         0|            0|            0|  0.00%|
   764|         0|            0|            0|  0.00%|    Used as a stand-in for a normal context manager, when a particular
   765|         0|            0|            0|  0.00%|    block of code is only sometimes used with a normal context manager:
   766|         0|            0|            0|  0.00%|
   767|         0|            0|            0|  0.00%|    cm = optional_cm if condition else nullcontext()
   768|         0|            0|            0|  0.00%|    with cm:
   769|         0|            0|            0|  0.00%|        # Perform operation, using optional_cm if condition is True
   770|         0|            0|            0|  0.00%|    """
   771|         0|            0|            0|  0.00%|
   772|         0|            0|            0|  0.00%|    def __init__(self, enter_result=None):
   773|         0|            0|            0|  0.00%|        self.enter_result = enter_result
   774|         0|            0|            0|  0.00%|
   775|         0|            0|            0|  0.00%|    def __enter__(self):
   776|         0|            0|            0|  0.00%|        return self.enter_result
   777|         0|            0|            0|  0.00%|
   778|         0|            0|            0|  0.00%|    def __exit__(self, *excinfo):
   779|         0|            0|            0|  0.00%|        pass
   780|         0|            0|            0|  0.00%|
   781|         0|            0|            0|  0.00%|    async def __aenter__(self):
   782|         0|            0|            0|  0.00%|        return self.enter_result
   783|         0|            0|            0|  0.00%|
   784|         0|            0|            0|  0.00%|    async def __aexit__(self, *excinfo):
   785|         0|            0|            0|  0.00%|        pass
   786|         0|            0|            0|  0.00%|
   787|         0|            0|            0|  0.00%|
   788|         0|            0|            0|  0.00%|class chdir(AbstractContextManager):
   789|         0|            0|            0|  0.00%|    """Non thread-safe context manager to change the current working directory."""
   790|         0|            0|            0|  0.00%|
   791|         0|            0|            0|  0.00%|    def __init__(self, path):
   792|         0|            0|            0|  0.00%|        self.path = path
   793|         0|            0|            0|  0.00%|        self._old_cwd = []
   794|         0|            0|            0|  0.00%|
   795|         0|            0|            0|  0.00%|    def __enter__(self):
   796|         0|            0|            0|  0.00%|        self._old_cwd.append(os.getcwd())
   797|         0|            0|            0|  0.00%|        os.chdir(self.path)
   798|         0|            0|            0|  0.00%|
   799|         0|            0|            0|  0.00%|    def __exit__(self, *excinfo):
   800|         0|            0|            0|  0.00%|        os.chdir(self._old_cwd.pop())
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_std_types_schema.py
File duration: 0.000415087s (0.43%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Logic for generating pydantic-core schemas for standard library types.
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|Import of this module is deferred since it contains imports of many standard library modules.
     4|         0|            0|            0|  0.00%|"""
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|from __future__ import annotations as _annotations
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|import collections
     9|         0|            0|            0|  0.00%|import collections.abc
    10|         0|            0|            0|  0.00%|import dataclasses
    11|         0|            0|            0|  0.00%|import decimal
    12|         0|            0|            0|  0.00%|import inspect
    13|         0|            0|            0|  0.00%|import os
    14|         0|            0|            0|  0.00%|import typing
    15|         0|            0|            0|  0.00%|from enum import Enum
    16|         0|            0|            0|  0.00%|from functools import partial
    17|         0|            0|            0|  0.00%|from ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network
    18|         0|            0|            0|  0.00%|from operator import attrgetter
    19|         0|            0|            0|  0.00%|from typing import Any, Callable, Iterable, Literal, Tuple, TypeVar
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|import typing_extensions
    22|         0|            0|            0|  0.00%|from pydantic_core import (
    23|         0|            0|            0|  0.00%|    CoreSchema,
    24|         0|            0|            0|  0.00%|    MultiHostUrl,
    25|         0|            0|            0|  0.00%|    PydanticCustomError,
    26|         0|            0|            0|  0.00%|    PydanticOmit,
    27|         0|            0|            0|  0.00%|    Url,
    28|         0|            0|            0|  0.00%|    core_schema,
    29|         0|            0|            0|  0.00%|)
    30|         0|            0|            0|  0.00%|from typing_extensions import get_args, get_origin
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|from pydantic.errors import PydanticSchemaGenerationError
    33|         0|            0|            0|  0.00%|from pydantic.fields import FieldInfo
    34|         0|            0|            0|  0.00%|from pydantic.types import Strict
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|from ..config import ConfigDict
    37|         0|            0|            0|  0.00%|from ..json_schema import JsonSchemaValue
    38|         0|            0|            0|  0.00%|from . import _known_annotated_metadata, _typing_extra, _validators
    39|         0|            0|            0|  0.00%|from ._core_utils import get_type_ref
    40|         0|            0|            0|  0.00%|from ._internal_dataclass import slots_true
    41|         0|            0|            0|  0.00%|from ._schema_generation_shared import GetCoreSchemaHandler, GetJsonSchemaHandler
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|if typing.TYPE_CHECKING:
    44|         0|            0|            0|  0.00%|    from ._generate_schema import GenerateSchema
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|    StdSchemaFunction = Callable[[GenerateSchema, type[Any]], core_schema.CoreSchema]
    47|         0|            0|            0|  0.00%|
    48|         0|            0|            0|  0.00%|
    49|         0|            0|            0|  0.00%|@dataclasses.dataclass(**slots_true)
    50|         0|            0|            0|  0.00%|class SchemaTransformer:
    51|         0|            0|            0|  0.00%|    get_core_schema: Callable[[Any, GetCoreSchemaHandler], CoreSchema]
    52|         0|            0|            0|  0.00%|    get_json_schema: Callable[[CoreSchema, GetJsonSchemaHandler], JsonSchemaValue]
    53|         0|            0|            0|  0.00%|
    54|         0|            0|            0|  0.00%|    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> CoreSchema:
    55|         0|            0|            0|  0.00%|        return self.get_core_schema(source_type, handler)
    56|         0|            0|            0|  0.00%|
    57|         0|            0|            0|  0.00%|    def __get_pydantic_json_schema__(self, schema: CoreSchema, handler: GetJsonSchemaHandler) -> JsonSchemaValue:
    58|         0|            0|            0|  0.00%|        return self.get_json_schema(schema, handler)
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|
    61|         0|            0|            0|  0.00%|def get_enum_core_schema(enum_type: type[Enum], config: ConfigDict) -> CoreSchema:
    62|         0|            0|            0|  0.00%|    cases: list[Any] = list(enum_type.__members__.values())
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|    enum_ref = get_type_ref(enum_type)
    65|         0|            0|            0|  0.00%|    description = None if not enum_type.__doc__ else inspect.cleandoc(enum_type.__doc__)
    66|         0|            0|            0|  0.00%|    if description == 'An enumeration.':  # This is the default value provided by enum.EnumMeta.__new__; don't use it
    67|         0|            0|            0|  0.00%|        description = None
    68|         0|            0|            0|  0.00%|    js_updates = {'title': enum_type.__name__, 'description': description}
    69|         0|            0|            0|  0.00%|    js_updates = {k: v for k, v in js_updates.items() if v is not None}
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|    sub_type: Literal['str', 'int', 'float'] | None = None
    72|         0|            0|            0|  0.00%|    if issubclass(enum_type, int):
    73|         0|            0|            0|  0.00%|        sub_type = 'int'
    74|         0|            0|            0|  0.00%|        value_ser_type: core_schema.SerSchema = core_schema.simple_ser_schema('int')
    75|         0|            0|            0|  0.00%|    elif issubclass(enum_type, str):
    76|         0|            0|            0|  0.00%|        # this handles `StrEnum` (3.11 only), and also `Foobar(str, Enum)`
    77|         0|            0|            0|  0.00%|        sub_type = 'str'
    78|         0|            0|            0|  0.00%|        value_ser_type = core_schema.simple_ser_schema('str')
    79|         0|            0|            0|  0.00%|    elif issubclass(enum_type, float):
    80|         0|            0|            0|  0.00%|        sub_type = 'float'
    81|         0|            0|            0|  0.00%|        value_ser_type = core_schema.simple_ser_schema('float')
    82|         0|            0|            0|  0.00%|    else:
    83|         0|            0|            0|  0.00%|        # TODO this is an ugly hack, how do we trigger an Any schema for serialization?
    84|         0|            0|            0|  0.00%|        value_ser_type = core_schema.plain_serializer_function_ser_schema(lambda x: x)
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|    if cases:
    87|         0|            0|            0|  0.00%|
    88|         0|            0|            0|  0.00%|        def get_json_schema(schema: CoreSchema, handler: GetJsonSchemaHandler) -> JsonSchemaValue:
    89|         0|            0|            0|  0.00%|            json_schema = handler(schema)
    90|         0|            0|            0|  0.00%|            original_schema = handler.resolve_ref_schema(json_schema)
    91|         0|            0|            0|  0.00%|            original_schema.update(js_updates)
    92|         0|            0|            0|  0.00%|            return json_schema
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|        # we don't want to add the missing to the schema if it's the default one
    95|         0|            0|            0|  0.00%|        default_missing = getattr(enum_type._missing_, '__func__', None) == Enum._missing_.__func__  # type: ignore
    96|         0|            0|            0|  0.00%|        enum_schema = core_schema.enum_schema(
    97|         0|            0|            0|  0.00%|            enum_type,
    98|         0|            0|            0|  0.00%|            cases,
    99|         0|            0|            0|  0.00%|            sub_type=sub_type,
   100|         0|            0|            0|  0.00%|            missing=None if default_missing else enum_type._missing_,
   101|         0|            0|            0|  0.00%|            ref=enum_ref,
   102|         0|            0|            0|  0.00%|            metadata={'pydantic_js_functions': [get_json_schema]},
   103|         0|            0|            0|  0.00%|        )
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|        if config.get('use_enum_values', False):
   106|         0|            0|            0|  0.00%|            enum_schema = core_schema.no_info_after_validator_function(
   107|         0|            0|            0|  0.00%|                attrgetter('value'), enum_schema, serialization=value_ser_type
   108|         0|            0|            0|  0.00%|            )
   109|         0|            0|            0|  0.00%|
   110|         0|            0|            0|  0.00%|        return enum_schema
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|    else:
   113|         0|            0|            0|  0.00%|
   114|         0|            0|            0|  0.00%|        def get_json_schema_no_cases(_, handler: GetJsonSchemaHandler) -> JsonSchemaValue:
   115|         0|            0|            0|  0.00%|            json_schema = handler(core_schema.enum_schema(enum_type, cases, sub_type=sub_type, ref=enum_ref))
   116|         0|            0|            0|  0.00%|            original_schema = handler.resolve_ref_schema(json_schema)
   117|         0|            0|            0|  0.00%|            original_schema.update(js_updates)
   118|         0|            0|            0|  0.00%|            return json_schema
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|        # Use an isinstance check for enums with no cases.
   121|         0|            0|            0|  0.00%|        # The most important use case for this is creating TypeVar bounds for generics that should
   122|         0|            0|            0|  0.00%|        # be restricted to enums. This is more consistent than it might seem at first, since you can only
   123|         0|            0|            0|  0.00%|        # subclass enum.Enum (or subclasses of enum.Enum) if all parent classes have no cases.
   124|         0|            0|            0|  0.00%|        # We use the get_json_schema function when an Enum subclass has been declared with no cases
   125|         0|            0|            0|  0.00%|        # so that we can still generate a valid json schema.
   126|         0|            0|            0|  0.00%|        return core_schema.is_instance_schema(
   127|         0|            0|            0|  0.00%|            enum_type,
   128|         0|            0|            0|  0.00%|            metadata={'pydantic_js_functions': [get_json_schema_no_cases]},
   129|         0|            0|            0|  0.00%|        )
   130|         0|            0|            0|  0.00%|
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|@dataclasses.dataclass(**slots_true)
   133|         0|            0|            0|  0.00%|class InnerSchemaValidator:
   134|         0|            0|            0|  0.00%|    """Use a fixed CoreSchema, avoiding interference from outward annotations."""
   135|         0|            0|            0|  0.00%|
   136|         0|            0|            0|  0.00%|    core_schema: CoreSchema
   137|         0|            0|            0|  0.00%|    js_schema: JsonSchemaValue | None = None
   138|         0|            0|            0|  0.00%|    js_core_schema: CoreSchema | None = None
   139|         0|            0|            0|  0.00%|    js_schema_update: JsonSchemaValue | None = None
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|    def __get_pydantic_json_schema__(self, _schema: CoreSchema, handler: GetJsonSchemaHandler) -> JsonSchemaValue:
   142|         0|            0|            0|  0.00%|        if self.js_schema is not None:
   143|         0|            0|            0|  0.00%|            return self.js_schema
   144|         0|            0|            0|  0.00%|        js_schema = handler(self.js_core_schema or self.core_schema)
   145|         0|            0|            0|  0.00%|        if self.js_schema_update is not None:
   146|         0|            0|            0|  0.00%|            js_schema.update(self.js_schema_update)
   147|         0|            0|            0|  0.00%|        return js_schema
   148|         0|            0|            0|  0.00%|
   149|         0|            0|            0|  0.00%|    def __get_pydantic_core_schema__(self, _source_type: Any, _handler: GetCoreSchemaHandler) -> CoreSchema:
   150|         0|            0|            0|  0.00%|        return self.core_schema
   151|         0|            0|            0|  0.00%|
   152|         0|            0|            0|  0.00%|
   153|         2|  6.19888e-06|  3.09944e-06|  0.01%|def decimal_prepare_pydantic_annotations(
   154|         0|            0|            0|  0.00%|    source: Any, annotations: Iterable[Any], config: ConfigDict
   155|         0|            0|            0|  0.00%|) -> tuple[Any, list[Any]] | None:
   156|         2|  7.15256e-06|  3.57628e-06|  0.01%|    if source is not decimal.Decimal:
   157|         2|   3.8147e-06|  1.90735e-06|  0.00%|        return None
   158|         0|            0|            0|  0.00%|
   159|         0|            0|            0|  0.00%|    metadata, remaining_annotations = _known_annotated_metadata.collect_known_metadata(annotations)
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|    config_allow_inf_nan = config.get('allow_inf_nan')
   162|         0|            0|            0|  0.00%|    if config_allow_inf_nan is not None:
   163|         0|            0|            0|  0.00%|        metadata.setdefault('allow_inf_nan', config_allow_inf_nan)
   164|         0|            0|            0|  0.00%|
   165|         0|            0|            0|  0.00%|    _known_annotated_metadata.check_metadata(
   166|         0|            0|            0|  0.00%|        metadata, {*_known_annotated_metadata.FLOAT_CONSTRAINTS, 'max_digits', 'decimal_places'}, decimal.Decimal
   167|         0|            0|            0|  0.00%|    )
   168|         0|            0|            0|  0.00%|    return source, [InnerSchemaValidator(core_schema.decimal_schema(**metadata)), *remaining_annotations]
   169|         0|            0|            0|  0.00%|
   170|         0|            0|            0|  0.00%|
   171|         2|  5.96046e-06|  2.98023e-06|  0.01%|def datetime_prepare_pydantic_annotations(
   172|         0|            0|            0|  0.00%|    source_type: Any, annotations: Iterable[Any], _config: ConfigDict
   173|         0|            0|            0|  0.00%|) -> tuple[Any, list[Any]] | None:
   174|         2|  6.19888e-06|  3.09944e-06|  0.01%|    import datetime
   175|         0|            0|            0|  0.00%|
   176|         2|  6.41346e-05|  3.20673e-05|  0.07%|    metadata, remaining_annotations = _known_annotated_metadata.collect_known_metadata(annotations)
(call)|         2|  0.000780106|  0.000390053|  0.80%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_known_annotated_metadata.py:298 collect_known_metadata
   177|         2|  6.19888e-06|  3.09944e-06|  0.01%|    if source_type is datetime.date:
   178|         0|            0|            0|  0.00%|        sv = InnerSchemaValidator(core_schema.date_schema(**metadata))
   179|         2|  5.48363e-06|  2.74181e-06|  0.01%|    elif source_type is datetime.datetime:
   180|         0|            0|            0|  0.00%|        sv = InnerSchemaValidator(core_schema.datetime_schema(**metadata))
   181|         2|  4.52995e-06|  2.26498e-06|  0.00%|    elif source_type is datetime.time:
   182|         0|            0|            0|  0.00%|        sv = InnerSchemaValidator(core_schema.time_schema(**metadata))
   183|         2|  4.29153e-06|  2.14577e-06|  0.00%|    elif source_type is datetime.timedelta:
   184|         0|            0|            0|  0.00%|        sv = InnerSchemaValidator(core_schema.timedelta_schema(**metadata))
   185|         0|            0|            0|  0.00%|    else:
   186|         2|  4.76837e-06|  2.38419e-06|  0.00%|        return None
   187|         0|            0|            0|  0.00%|    # check now that we know the source type is correct
   188|         0|            0|            0|  0.00%|    _known_annotated_metadata.check_metadata(metadata, _known_annotated_metadata.DATE_TIME_CONSTRAINTS, source_type)
   189|         0|            0|            0|  0.00%|    return (source_type, [sv, *remaining_annotations])
   190|         0|            0|            0|  0.00%|
   191|         0|            0|            0|  0.00%|
   192|         2|  4.52995e-06|  2.26498e-06|  0.00%|def uuid_prepare_pydantic_annotations(
   193|         0|            0|            0|  0.00%|    source_type: Any, annotations: Iterable[Any], _config: ConfigDict
   194|         0|            0|            0|  0.00%|) -> tuple[Any, list[Any]] | None:
   195|         0|            0|            0|  0.00%|    # UUIDs have no constraints - they are fixed length, constructing a UUID instance checks the length
   196|         0|            0|            0|  0.00%|
   197|         2|  8.34465e-06|  4.17233e-06|  0.01%|    from uuid import UUID
   198|         0|            0|            0|  0.00%|
   199|         2|  3.33786e-06|  1.66893e-06|  0.00%|    if source_type is not UUID:
   200|         2|  3.09944e-06|  1.54972e-06|  0.00%|        return None
   201|         0|            0|            0|  0.00%|
   202|         0|            0|            0|  0.00%|    return (source_type, [InnerSchemaValidator(core_schema.uuid_schema()), *annotations])
   203|         0|            0|            0|  0.00%|
   204|         0|            0|            0|  0.00%|
   205|         2|  1.38283e-05|  6.91414e-06|  0.01%|def path_schema_prepare_pydantic_annotations(
   206|         0|            0|            0|  0.00%|    source_type: Any, annotations: Iterable[Any], _config: ConfigDict
   207|         0|            0|            0|  0.00%|) -> tuple[Any, list[Any]] | None:
   208|         2|  8.58307e-06|  4.29153e-06|  0.01%|    import pathlib
   209|         0|            0|            0|  0.00%|
   210|         4|  1.62125e-05|  4.05312e-06|  0.02%|    if source_type not in {
   211|         2|  7.86781e-06|  3.93391e-06|  0.01%|        os.PathLike,
   212|         2|  6.67572e-06|  3.33786e-06|  0.01%|        pathlib.Path,
   213|         2|  6.19888e-06|  3.09944e-06|  0.01%|        pathlib.PurePath,
   214|         2|  5.72205e-06|  2.86102e-06|  0.01%|        pathlib.PosixPath,
   215|         2|  5.72205e-06|  2.86102e-06|  0.01%|        pathlib.PurePosixPath,
   216|         2|  5.72205e-06|  2.86102e-06|  0.01%|        pathlib.PureWindowsPath,
   217|         0|            0|            0|  0.00%|    }:
   218|         2|   3.8147e-06|  1.90735e-06|  0.00%|        return None
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|    metadata, remaining_annotations = _known_annotated_metadata.collect_known_metadata(annotations)
   221|         0|            0|            0|  0.00%|    _known_annotated_metadata.check_metadata(metadata, _known_annotated_metadata.STR_CONSTRAINTS, source_type)
   222|         0|            0|            0|  0.00%|
   223|         0|            0|            0|  0.00%|    construct_path = pathlib.PurePath if source_type is os.PathLike else source_type
   224|         0|            0|            0|  0.00%|
   225|         0|            0|            0|  0.00%|    def path_validator(input_value: str) -> os.PathLike[Any]:
   226|         0|            0|            0|  0.00%|        try:
   227|         0|            0|            0|  0.00%|            return construct_path(input_value)
   228|         0|            0|            0|  0.00%|        except TypeError as e:
   229|         0|            0|            0|  0.00%|            raise PydanticCustomError('path_type', 'Input is not a valid path') from e
   230|         0|            0|            0|  0.00%|
   231|         0|            0|            0|  0.00%|    constrained_str_schema = core_schema.str_schema(**metadata)
   232|         0|            0|            0|  0.00%|
   233|         0|            0|            0|  0.00%|    instance_schema = core_schema.json_or_python_schema(
   234|         0|            0|            0|  0.00%|        json_schema=core_schema.no_info_after_validator_function(path_validator, constrained_str_schema),
   235|         0|            0|            0|  0.00%|        python_schema=core_schema.is_instance_schema(source_type),
   236|         0|            0|            0|  0.00%|    )
   237|         0|            0|            0|  0.00%|
   238|         0|            0|            0|  0.00%|    strict: bool | None = None
   239|         0|            0|            0|  0.00%|    for annotation in annotations:
   240|         0|            0|            0|  0.00%|        if isinstance(annotation, Strict):
   241|         0|            0|            0|  0.00%|            strict = annotation.strict
   242|         0|            0|            0|  0.00%|
   243|         0|            0|            0|  0.00%|    schema = core_schema.lax_or_strict_schema(
   244|         0|            0|            0|  0.00%|        lax_schema=core_schema.union_schema(
   245|         0|            0|            0|  0.00%|            [
   246|         0|            0|            0|  0.00%|                instance_schema,
   247|         0|            0|            0|  0.00%|                core_schema.no_info_after_validator_function(path_validator, constrained_str_schema),
   248|         0|            0|            0|  0.00%|            ],
   249|         0|            0|            0|  0.00%|            custom_error_type='path_type',
   250|         0|            0|            0|  0.00%|            custom_error_message='Input is not a valid path',
   251|         0|            0|            0|  0.00%|            strict=True,
   252|         0|            0|            0|  0.00%|        ),
   253|         0|            0|            0|  0.00%|        strict_schema=instance_schema,
   254|         0|            0|            0|  0.00%|        serialization=core_schema.to_string_ser_schema(),
   255|         0|            0|            0|  0.00%|        strict=strict,
   256|         0|            0|            0|  0.00%|    )
   257|         0|            0|            0|  0.00%|
   258|         0|            0|            0|  0.00%|    return (
   259|         0|            0|            0|  0.00%|        source_type,
   260|         0|            0|            0|  0.00%|        [
   261|         0|            0|            0|  0.00%|            InnerSchemaValidator(schema, js_core_schema=constrained_str_schema, js_schema_update={'format': 'path'}),
   262|         0|            0|            0|  0.00%|            *remaining_annotations,
   263|         0|            0|            0|  0.00%|        ],
   264|         0|            0|            0|  0.00%|    )
   265|         0|            0|            0|  0.00%|
   266|         0|            0|            0|  0.00%|
   267|         0|            0|            0|  0.00%|def dequeue_validator(
   268|         0|            0|            0|  0.00%|    input_value: Any, handler: core_schema.ValidatorFunctionWrapHandler, maxlen: None | int
   269|         0|            0|            0|  0.00%|) -> collections.deque[Any]:
   270|         0|            0|            0|  0.00%|    if isinstance(input_value, collections.deque):
   271|         0|            0|            0|  0.00%|        maxlens = [v for v in (input_value.maxlen, maxlen) if v is not None]
   272|         0|            0|            0|  0.00%|        if maxlens:
   273|         0|            0|            0|  0.00%|            maxlen = min(maxlens)
   274|         0|            0|            0|  0.00%|        return collections.deque(handler(input_value), maxlen=maxlen)
   275|         0|            0|            0|  0.00%|    else:
   276|         0|            0|            0|  0.00%|        return collections.deque(handler(input_value), maxlen=maxlen)
   277|         0|            0|            0|  0.00%|
   278|         0|            0|            0|  0.00%|
   279|         0|            0|            0|  0.00%|def serialize_sequence_via_list(
   280|         0|            0|            0|  0.00%|    v: Any, handler: core_schema.SerializerFunctionWrapHandler, info: core_schema.SerializationInfo
   281|         0|            0|            0|  0.00%|) -> Any:
   282|         0|            0|            0|  0.00%|    items: list[Any] = []
   283|         0|            0|            0|  0.00%|
   284|         0|            0|            0|  0.00%|    mapped_origin = SEQUENCE_ORIGIN_MAP.get(type(v), None)
   285|         0|            0|            0|  0.00%|    if mapped_origin is None:
   286|         0|            0|            0|  0.00%|        # we shouldn't hit this branch, should probably add a serialization error or something
   287|         0|            0|            0|  0.00%|        return v
   288|         0|            0|            0|  0.00%|
   289|         0|            0|            0|  0.00%|    for index, item in enumerate(v):
   290|         0|            0|            0|  0.00%|        try:
   291|         0|            0|            0|  0.00%|            v = handler(item, index)
   292|         0|            0|            0|  0.00%|        except PydanticOmit:
   293|         0|            0|            0|  0.00%|            pass
   294|         0|            0|            0|  0.00%|        else:
   295|         0|            0|            0|  0.00%|            items.append(v)
   296|         0|            0|            0|  0.00%|
   297|         0|            0|            0|  0.00%|    if info.mode_is_json():
   298|         0|            0|            0|  0.00%|        return items
   299|         0|            0|            0|  0.00%|    else:
   300|         0|            0|            0|  0.00%|        return mapped_origin(items)
   301|         0|            0|            0|  0.00%|
   302|         0|            0|            0|  0.00%|
   303|         0|            0|            0|  0.00%|@dataclasses.dataclass(**slots_true)
   304|         0|            0|            0|  0.00%|class SequenceValidator:
   305|         0|            0|            0|  0.00%|    mapped_origin: type[Any]
   306|         0|            0|            0|  0.00%|    item_source_type: type[Any]
   307|         0|            0|            0|  0.00%|    min_length: int | None = None
   308|         0|            0|            0|  0.00%|    max_length: int | None = None
   309|         0|            0|            0|  0.00%|    strict: bool | None = None
   310|         0|            0|            0|  0.00%|    fail_fast: bool | None = None
   311|         0|            0|            0|  0.00%|
   312|         0|            0|            0|  0.00%|    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> CoreSchema:
   313|         0|            0|            0|  0.00%|        if self.item_source_type is Any:
   314|         0|            0|            0|  0.00%|            items_schema = None
   315|         0|            0|            0|  0.00%|        else:
   316|         0|            0|            0|  0.00%|            items_schema = handler.generate_schema(self.item_source_type)
   317|         0|            0|            0|  0.00%|
   318|         0|            0|            0|  0.00%|        metadata = {
   319|         0|            0|            0|  0.00%|            'min_length': self.min_length,
   320|         0|            0|            0|  0.00%|            'max_length': self.max_length,
   321|         0|            0|            0|  0.00%|            'strict': self.strict,
   322|         0|            0|            0|  0.00%|            'fail_fast': self.fail_fast,
   323|         0|            0|            0|  0.00%|        }
   324|         0|            0|            0|  0.00%|
   325|         0|            0|            0|  0.00%|        if self.mapped_origin in (list, set, frozenset):
   326|         0|            0|            0|  0.00%|            if self.mapped_origin is list:
   327|         0|            0|            0|  0.00%|                constrained_schema = core_schema.list_schema(items_schema, **metadata)
   328|         0|            0|            0|  0.00%|            elif self.mapped_origin is set:
   329|         0|            0|            0|  0.00%|                constrained_schema = core_schema.set_schema(items_schema, **metadata)
   330|         0|            0|            0|  0.00%|            else:
   331|         0|            0|            0|  0.00%|                assert self.mapped_origin is frozenset  # safety check in case we forget to add a case
   332|         0|            0|            0|  0.00%|                constrained_schema = core_schema.frozenset_schema(items_schema, **metadata)
   333|         0|            0|            0|  0.00%|
   334|         0|            0|            0|  0.00%|            schema = constrained_schema
   335|         0|            0|            0|  0.00%|        else:
   336|         0|            0|            0|  0.00%|            # safety check in case we forget to add a case
   337|         0|            0|            0|  0.00%|            assert self.mapped_origin in (collections.deque, collections.Counter)
   338|         0|            0|            0|  0.00%|
   339|         0|            0|            0|  0.00%|            if self.mapped_origin is collections.deque:
   340|         0|            0|            0|  0.00%|                # if we have a MaxLen annotation might as well set that as the default maxlen on the deque
   341|         0|            0|            0|  0.00%|                # this lets us re-use existing metadata annotations to let users set the maxlen on a dequeue
   342|         0|            0|            0|  0.00%|                # that e.g. comes from JSON
   343|         0|            0|            0|  0.00%|                coerce_instance_wrap = partial(
   344|         0|            0|            0|  0.00%|                    core_schema.no_info_wrap_validator_function,
   345|         0|            0|            0|  0.00%|                    partial(dequeue_validator, maxlen=metadata.get('max_length', None)),
   346|         0|            0|            0|  0.00%|                )
   347|         0|            0|            0|  0.00%|            else:
   348|         0|            0|            0|  0.00%|                coerce_instance_wrap = partial(core_schema.no_info_after_validator_function, self.mapped_origin)
   349|         0|            0|            0|  0.00%|
   350|         0|            0|            0|  0.00%|            # we have to use a lax list schema here, because we need to validate the deque's
   351|         0|            0|            0|  0.00%|            # items via a list schema, but it's ok if the deque itself is not a list (same for Counter)
   352|         0|            0|            0|  0.00%|            metadata_with_strict_override = {**metadata, 'strict': False}
   353|         0|            0|            0|  0.00%|            constrained_schema = core_schema.list_schema(items_schema, **metadata_with_strict_override)
   354|         0|            0|            0|  0.00%|
   355|         0|            0|            0|  0.00%|            check_instance = core_schema.json_or_python_schema(
   356|         0|            0|            0|  0.00%|                json_schema=core_schema.list_schema(),
   357|         0|            0|            0|  0.00%|                python_schema=core_schema.is_instance_schema(self.mapped_origin),
   358|         0|            0|            0|  0.00%|            )
   359|         0|            0|            0|  0.00%|
   360|         0|            0|            0|  0.00%|            serialization = core_schema.wrap_serializer_function_ser_schema(
   361|         0|            0|            0|  0.00%|                serialize_sequence_via_list, schema=items_schema or core_schema.any_schema(), info_arg=True
   362|         0|            0|            0|  0.00%|            )
   363|         0|            0|            0|  0.00%|
   364|         0|            0|            0|  0.00%|            strict = core_schema.chain_schema([check_instance, coerce_instance_wrap(constrained_schema)])
   365|         0|            0|            0|  0.00%|
   366|         0|            0|            0|  0.00%|            if metadata.get('strict', False):
   367|         0|            0|            0|  0.00%|                schema = strict
   368|         0|            0|            0|  0.00%|            else:
   369|         0|            0|            0|  0.00%|                lax = coerce_instance_wrap(constrained_schema)
   370|         0|            0|            0|  0.00%|                schema = core_schema.lax_or_strict_schema(lax_schema=lax, strict_schema=strict)
   371|         0|            0|            0|  0.00%|            schema['serialization'] = serialization
   372|         0|            0|            0|  0.00%|
   373|         0|            0|            0|  0.00%|        return schema
   374|         0|            0|            0|  0.00%|
   375|         0|            0|            0|  0.00%|
   376|         0|            0|            0|  0.00%|SEQUENCE_ORIGIN_MAP: dict[Any, Any] = {
   377|         0|            0|            0|  0.00%|    typing.Deque: collections.deque,
   378|         0|            0|            0|  0.00%|    collections.deque: collections.deque,
   379|         0|            0|            0|  0.00%|    list: list,
   380|         0|            0|            0|  0.00%|    typing.List: list,
   381|         0|            0|            0|  0.00%|    set: set,
   382|         0|            0|            0|  0.00%|    typing.AbstractSet: set,
   383|         0|            0|            0|  0.00%|    typing.Set: set,
   384|         0|            0|            0|  0.00%|    frozenset: frozenset,
   385|         0|            0|            0|  0.00%|    typing.FrozenSet: frozenset,
   386|         0|            0|            0|  0.00%|    typing.Sequence: list,
   387|         0|            0|            0|  0.00%|    typing.MutableSequence: list,
   388|         0|            0|            0|  0.00%|    typing.MutableSet: set,
   389|         0|            0|            0|  0.00%|    # this doesn't handle subclasses of these
   390|         0|            0|            0|  0.00%|    # parametrized typing.Set creates one of these
   391|         0|            0|            0|  0.00%|    collections.abc.MutableSet: set,
   392|         0|            0|            0|  0.00%|    collections.abc.Set: frozenset,
   393|         0|            0|            0|  0.00%|}
   394|         0|            0|            0|  0.00%|
   395|         0|            0|            0|  0.00%|
   396|         0|            0|            0|  0.00%|def identity(s: CoreSchema) -> CoreSchema:
   397|         0|            0|            0|  0.00%|    return s
   398|         0|            0|            0|  0.00%|
   399|         0|            0|            0|  0.00%|
   400|         2|  5.96046e-06|  2.98023e-06|  0.01%|def sequence_like_prepare_pydantic_annotations(
   401|         0|            0|            0|  0.00%|    source_type: Any, annotations: Iterable[Any], _config: ConfigDict
   402|         0|            0|            0|  0.00%|) -> tuple[Any, list[Any]] | None:
   403|         2|  1.45435e-05|  7.27177e-06|  0.01%|    origin: Any = get_origin(source_type)
(call)|         2|  2.31266e-05|  1.15633e-05|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:2310 get_origin
   404|         0|            0|            0|  0.00%|
   405|         2|  5.24521e-06|   2.6226e-06|  0.01%|    mapped_origin = SEQUENCE_ORIGIN_MAP.get(origin, None) if origin else SEQUENCE_ORIGIN_MAP.get(source_type, None)
   406|         2|  4.05312e-06|  2.02656e-06|  0.00%|    if mapped_origin is None:
   407|         2|  6.67572e-06|  3.33786e-06|  0.01%|        return None
   408|         0|            0|            0|  0.00%|
   409|         0|            0|            0|  0.00%|    args = get_args(source_type)
   410|         0|            0|            0|  0.00%|
   411|         0|            0|            0|  0.00%|    if not args:
   412|         0|            0|            0|  0.00%|        args = typing.cast(Tuple[Any], (Any,))
   413|         0|            0|            0|  0.00%|    elif len(args) != 1:
   414|         0|            0|            0|  0.00%|        raise ValueError('Expected sequence to have exactly 1 generic parameter')
   415|         0|            0|            0|  0.00%|
   416|         0|            0|            0|  0.00%|    item_source_type = args[0]
   417|         0|            0|            0|  0.00%|
   418|         0|            0|            0|  0.00%|    metadata, remaining_annotations = _known_annotated_metadata.collect_known_metadata(annotations)
   419|         0|            0|            0|  0.00%|    _known_annotated_metadata.check_metadata(metadata, _known_annotated_metadata.SEQUENCE_CONSTRAINTS, source_type)
   420|         0|            0|            0|  0.00%|
   421|         0|            0|            0|  0.00%|    return (source_type, [SequenceValidator(mapped_origin, item_source_type, **metadata), *remaining_annotations])
   422|         0|            0|            0|  0.00%|
   423|         0|            0|            0|  0.00%|
   424|         0|            0|            0|  0.00%|MAPPING_ORIGIN_MAP: dict[Any, Any] = {
   425|         0|            0|            0|  0.00%|    typing.DefaultDict: collections.defaultdict,
   426|         0|            0|            0|  0.00%|    collections.defaultdict: collections.defaultdict,
   427|         0|            0|            0|  0.00%|    collections.OrderedDict: collections.OrderedDict,
   428|         0|            0|            0|  0.00%|    typing_extensions.OrderedDict: collections.OrderedDict,
   429|         0|            0|            0|  0.00%|    dict: dict,
   430|         0|            0|            0|  0.00%|    typing.Dict: dict,
   431|         0|            0|            0|  0.00%|    collections.Counter: collections.Counter,
   432|         0|            0|            0|  0.00%|    typing.Counter: collections.Counter,
   433|         0|            0|            0|  0.00%|    # this doesn't handle subclasses of these
   434|         0|            0|            0|  0.00%|    typing.Mapping: dict,
   435|         0|            0|            0|  0.00%|    typing.MutableMapping: dict,
   436|         0|            0|            0|  0.00%|    # parametrized typing.{Mutable}Mapping creates one of these
   437|         0|            0|            0|  0.00%|    collections.abc.MutableMapping: dict,
   438|         0|            0|            0|  0.00%|    collections.abc.Mapping: dict,
   439|         0|            0|            0|  0.00%|}
   440|         0|            0|            0|  0.00%|
   441|         0|            0|            0|  0.00%|
   442|         0|            0|            0|  0.00%|def defaultdict_validator(
   443|         0|            0|            0|  0.00%|    input_value: Any, handler: core_schema.ValidatorFunctionWrapHandler, default_default_factory: Callable[[], Any]
   444|         0|            0|            0|  0.00%|) -> collections.defaultdict[Any, Any]:
   445|         0|            0|            0|  0.00%|    if isinstance(input_value, collections.defaultdict):
   446|         0|            0|            0|  0.00%|        default_factory = input_value.default_factory
   447|         0|            0|            0|  0.00%|        return collections.defaultdict(default_factory, handler(input_value))
   448|         0|            0|            0|  0.00%|    else:
   449|         0|            0|            0|  0.00%|        return collections.defaultdict(default_default_factory, handler(input_value))
   450|         0|            0|            0|  0.00%|
   451|         0|            0|            0|  0.00%|
   452|         0|            0|            0|  0.00%|def get_defaultdict_default_default_factory(values_source_type: Any) -> Callable[[], Any]:
   453|         0|            0|            0|  0.00%|    def infer_default() -> Callable[[], Any]:
   454|         0|            0|            0|  0.00%|        allowed_default_types: dict[Any, Any] = {
   455|         0|            0|            0|  0.00%|            typing.Tuple: tuple,
   456|         0|            0|            0|  0.00%|            tuple: tuple,
   457|         0|            0|            0|  0.00%|            collections.abc.Sequence: tuple,
   458|         0|            0|            0|  0.00%|            collections.abc.MutableSequence: list,
   459|         0|            0|            0|  0.00%|            typing.List: list,
   460|         0|            0|            0|  0.00%|            list: list,
   461|         0|            0|            0|  0.00%|            typing.Sequence: list,
   462|         0|            0|            0|  0.00%|            typing.Set: set,
   463|         0|            0|            0|  0.00%|            set: set,
   464|         0|            0|            0|  0.00%|            typing.MutableSet: set,
   465|         0|            0|            0|  0.00%|            collections.abc.MutableSet: set,
   466|         0|            0|            0|  0.00%|            collections.abc.Set: frozenset,
   467|         0|            0|            0|  0.00%|            typing.MutableMapping: dict,
   468|         0|            0|            0|  0.00%|            typing.Mapping: dict,
   469|         0|            0|            0|  0.00%|            collections.abc.Mapping: dict,
   470|         0|            0|            0|  0.00%|            collections.abc.MutableMapping: dict,
   471|         0|            0|            0|  0.00%|            float: float,
   472|         0|            0|            0|  0.00%|            int: int,
   473|         0|            0|            0|  0.00%|            str: str,
   474|         0|            0|            0|  0.00%|            bool: bool,
   475|         0|            0|            0|  0.00%|        }
   476|         0|            0|            0|  0.00%|        values_type_origin = get_origin(values_source_type) or values_source_type
   477|         0|            0|            0|  0.00%|        instructions = 'set using `DefaultDict[..., Annotated[..., Field(default_factory=...)]]`'
   478|         0|            0|            0|  0.00%|        if isinstance(values_type_origin, TypeVar):
   479|         0|            0|            0|  0.00%|
   480|         0|            0|            0|  0.00%|            def type_var_default_factory() -> None:
   481|         0|            0|            0|  0.00%|                raise RuntimeError(
   482|         0|            0|            0|  0.00%|                    'Generic defaultdict cannot be used without a concrete value type or an'
   483|         0|            0|            0|  0.00%|                    ' explicit default factory, ' + instructions
   484|         0|            0|            0|  0.00%|                )
   485|         0|            0|            0|  0.00%|
   486|         0|            0|            0|  0.00%|            return type_var_default_factory
   487|         0|            0|            0|  0.00%|        elif values_type_origin not in allowed_default_types:
   488|         0|            0|            0|  0.00%|            # a somewhat subjective set of types that have reasonable default values
   489|         0|            0|            0|  0.00%|            allowed_msg = ', '.join([t.__name__ for t in set(allowed_default_types.values())])
   490|         0|            0|            0|  0.00%|            raise PydanticSchemaGenerationError(
   491|         0|            0|            0|  0.00%|                f'Unable to infer a default factory for keys of type {values_source_type}.'
   492|         0|            0|            0|  0.00%|                f' Only {allowed_msg} are supported, other types require an explicit default factory'
   493|         0|            0|            0|  0.00%|                ' ' + instructions
   494|         0|            0|            0|  0.00%|            )
   495|         0|            0|            0|  0.00%|        return allowed_default_types[values_type_origin]
   496|         0|            0|            0|  0.00%|
   497|         0|            0|            0|  0.00%|    # Assume Annotated[..., Field(...)]
   498|         0|            0|            0|  0.00%|    if _typing_extra.is_annotated(values_source_type):
   499|         0|            0|            0|  0.00%|        field_info = next((v for v in get_args(values_source_type) if isinstance(v, FieldInfo)), None)
   500|         0|            0|            0|  0.00%|    else:
   501|         0|            0|            0|  0.00%|        field_info = None
   502|         0|            0|            0|  0.00%|    if field_info and field_info.default_factory:
   503|         0|            0|            0|  0.00%|        default_default_factory = field_info.default_factory
   504|         0|            0|            0|  0.00%|    else:
   505|         0|            0|            0|  0.00%|        default_default_factory = infer_default()
   506|         0|            0|            0|  0.00%|    return default_default_factory
   507|         0|            0|            0|  0.00%|
   508|         0|            0|            0|  0.00%|
   509|         0|            0|            0|  0.00%|@dataclasses.dataclass(**slots_true)
   510|         0|            0|            0|  0.00%|class MappingValidator:
   511|         0|            0|            0|  0.00%|    mapped_origin: type[Any]
   512|         0|            0|            0|  0.00%|    keys_source_type: type[Any]
   513|         0|            0|            0|  0.00%|    values_source_type: type[Any]
   514|         0|            0|            0|  0.00%|    min_length: int | None = None
   515|         0|            0|            0|  0.00%|    max_length: int | None = None
   516|         0|            0|            0|  0.00%|    strict: bool = False
   517|         0|            0|            0|  0.00%|
   518|         0|            0|            0|  0.00%|    def serialize_mapping_via_dict(self, v: Any, handler: core_schema.SerializerFunctionWrapHandler) -> Any:
   519|         0|            0|            0|  0.00%|        return handler(v)
   520|         0|            0|            0|  0.00%|
   521|         0|            0|            0|  0.00%|    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> CoreSchema:
   522|         0|            0|            0|  0.00%|        if self.keys_source_type is Any:
   523|         0|            0|            0|  0.00%|            keys_schema = None
   524|         0|            0|            0|  0.00%|        else:
   525|         0|            0|            0|  0.00%|            keys_schema = handler.generate_schema(self.keys_source_type)
   526|         0|            0|            0|  0.00%|        if self.values_source_type is Any:
   527|         0|            0|            0|  0.00%|            values_schema = None
   528|         0|            0|            0|  0.00%|        else:
   529|         0|            0|            0|  0.00%|            values_schema = handler.generate_schema(self.values_source_type)
   530|         0|            0|            0|  0.00%|
   531|         0|            0|            0|  0.00%|        metadata = {'min_length': self.min_length, 'max_length': self.max_length, 'strict': self.strict}
   532|         0|            0|            0|  0.00%|
   533|         0|            0|            0|  0.00%|        if self.mapped_origin is dict:
   534|         0|            0|            0|  0.00%|            schema = core_schema.dict_schema(keys_schema, values_schema, **metadata)
   535|         0|            0|            0|  0.00%|        else:
   536|         0|            0|            0|  0.00%|            constrained_schema = core_schema.dict_schema(keys_schema, values_schema, **metadata)
   537|         0|            0|            0|  0.00%|            check_instance = core_schema.json_or_python_schema(
   538|         0|            0|            0|  0.00%|                json_schema=core_schema.dict_schema(),
   539|         0|            0|            0|  0.00%|                python_schema=core_schema.is_instance_schema(self.mapped_origin),
   540|         0|            0|            0|  0.00%|            )
   541|         0|            0|            0|  0.00%|
   542|         0|            0|            0|  0.00%|            if self.mapped_origin is collections.defaultdict:
   543|         0|            0|            0|  0.00%|                default_default_factory = get_defaultdict_default_default_factory(self.values_source_type)
   544|         0|            0|            0|  0.00%|                coerce_instance_wrap = partial(
   545|         0|            0|            0|  0.00%|                    core_schema.no_info_wrap_validator_function,
   546|         0|            0|            0|  0.00%|                    partial(defaultdict_validator, default_default_factory=default_default_factory),
   547|         0|            0|            0|  0.00%|                )
   548|         0|            0|            0|  0.00%|            else:
   549|         0|            0|            0|  0.00%|                coerce_instance_wrap = partial(core_schema.no_info_after_validator_function, self.mapped_origin)
   550|         0|            0|            0|  0.00%|
   551|         0|            0|            0|  0.00%|            serialization = core_schema.wrap_serializer_function_ser_schema(
   552|         0|            0|            0|  0.00%|                self.serialize_mapping_via_dict,
   553|         0|            0|            0|  0.00%|                schema=core_schema.dict_schema(
   554|         0|            0|            0|  0.00%|                    keys_schema or core_schema.any_schema(), values_schema or core_schema.any_schema()
   555|         0|            0|            0|  0.00%|                ),
   556|         0|            0|            0|  0.00%|                info_arg=False,
   557|         0|            0|            0|  0.00%|            )
   558|         0|            0|            0|  0.00%|
   559|         0|            0|            0|  0.00%|            strict = core_schema.chain_schema([check_instance, coerce_instance_wrap(constrained_schema)])
   560|         0|            0|            0|  0.00%|
   561|         0|            0|            0|  0.00%|            if metadata.get('strict', False):
   562|         0|            0|            0|  0.00%|                schema = strict
   563|         0|            0|            0|  0.00%|            else:
   564|         0|            0|            0|  0.00%|                lax = coerce_instance_wrap(constrained_schema)
   565|         0|            0|            0|  0.00%|                schema = core_schema.lax_or_strict_schema(lax_schema=lax, strict_schema=strict)
   566|         0|            0|            0|  0.00%|                schema['serialization'] = serialization
   567|         0|            0|            0|  0.00%|
   568|         0|            0|            0|  0.00%|        return schema
   569|         0|            0|            0|  0.00%|
   570|         0|            0|            0|  0.00%|
   571|         2|  8.58307e-06|  4.29153e-06|  0.01%|def mapping_like_prepare_pydantic_annotations(
   572|         0|            0|            0|  0.00%|    source_type: Any, annotations: Iterable[Any], _config: ConfigDict
   573|         0|            0|            0|  0.00%|) -> tuple[Any, list[Any]] | None:
   574|         2|  1.64509e-05|  8.22544e-06|  0.02%|    origin: Any = get_origin(source_type)
(call)|         2|   2.7895e-05|  1.39475e-05|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:2310 get_origin
   575|         0|            0|            0|  0.00%|
   576|         2|  5.72205e-06|  2.86102e-06|  0.01%|    mapped_origin = MAPPING_ORIGIN_MAP.get(origin, None) if origin else MAPPING_ORIGIN_MAP.get(source_type, None)
   577|         2|  5.00679e-06|   2.5034e-06|  0.01%|    if mapped_origin is None:
   578|         2|   6.4373e-06|  3.21865e-06|  0.01%|        return None
   579|         0|            0|            0|  0.00%|
   580|         0|            0|            0|  0.00%|    args = get_args(source_type)
   581|         0|            0|            0|  0.00%|
   582|         0|            0|            0|  0.00%|    if not args:
   583|         0|            0|            0|  0.00%|        args = typing.cast(Tuple[Any, Any], (Any, Any))
   584|         0|            0|            0|  0.00%|    elif mapped_origin is collections.Counter:
   585|         0|            0|            0|  0.00%|        # a single generic
   586|         0|            0|            0|  0.00%|        if len(args) != 1:
   587|         0|            0|            0|  0.00%|            raise ValueError('Expected Counter to have exactly 1 generic parameter')
   588|         0|            0|            0|  0.00%|        args = (args[0], int)  # keys are always an int
   589|         0|            0|            0|  0.00%|    elif len(args) != 2:
   590|         0|            0|            0|  0.00%|        raise ValueError('Expected mapping to have exactly 2 generic parameters')
   591|         0|            0|            0|  0.00%|
   592|         0|            0|            0|  0.00%|    keys_source_type, values_source_type = args
   593|         0|            0|            0|  0.00%|
   594|         0|            0|            0|  0.00%|    metadata, remaining_annotations = _known_annotated_metadata.collect_known_metadata(annotations)
   595|         0|            0|            0|  0.00%|    _known_annotated_metadata.check_metadata(metadata, _known_annotated_metadata.SEQUENCE_CONSTRAINTS, source_type)
   596|         0|            0|            0|  0.00%|
   597|         0|            0|            0|  0.00%|    return (
   598|         0|            0|            0|  0.00%|        source_type,
   599|         0|            0|            0|  0.00%|        [
   600|         0|            0|            0|  0.00%|            MappingValidator(mapped_origin, keys_source_type, values_source_type, **metadata),
   601|         0|            0|            0|  0.00%|            *remaining_annotations,
   602|         0|            0|            0|  0.00%|        ],
   603|         0|            0|            0|  0.00%|    )
   604|         0|            0|            0|  0.00%|
   605|         0|            0|            0|  0.00%|
   606|         2|  2.43187e-05|  1.21593e-05|  0.02%|def ip_prepare_pydantic_annotations(
   607|         0|            0|            0|  0.00%|    source_type: Any, annotations: Iterable[Any], _config: ConfigDict
   608|         0|            0|            0|  0.00%|) -> tuple[Any, list[Any]] | None:
   609|         2|  1.00136e-05|  5.00679e-06|  0.01%|    def make_strict_ip_schema(tp: type[Any]) -> CoreSchema:
   610|         0|            0|            0|  0.00%|        return core_schema.json_or_python_schema(
   611|         0|            0|            0|  0.00%|            json_schema=core_schema.no_info_after_validator_function(tp, core_schema.str_schema()),
   612|         0|            0|            0|  0.00%|            python_schema=core_schema.is_instance_schema(tp),
   613|         0|            0|            0|  0.00%|        )
   614|         0|            0|            0|  0.00%|
   615|         2|  9.29832e-06|  4.64916e-06|  0.01%|    if source_type is IPv4Address:
   616|         0|            0|            0|  0.00%|        return source_type, [
   617|         0|            0|            0|  0.00%|            SchemaTransformer(
   618|         0|            0|            0|  0.00%|                lambda _1, _2: core_schema.lax_or_strict_schema(
   619|         0|            0|            0|  0.00%|                    lax_schema=core_schema.no_info_plain_validator_function(_validators.ip_v4_address_validator),
   620|         0|            0|            0|  0.00%|                    strict_schema=make_strict_ip_schema(IPv4Address),
   621|         0|            0|            0|  0.00%|                    serialization=core_schema.to_string_ser_schema(),
   622|         0|            0|            0|  0.00%|                ),
   623|         0|            0|            0|  0.00%|                lambda _1, _2: {'type': 'string', 'format': 'ipv4'},
   624|         0|            0|            0|  0.00%|            ),
   625|         0|            0|            0|  0.00%|            *annotations,
   626|         0|            0|            0|  0.00%|        ]
   627|         2|  9.05991e-06|  4.52995e-06|  0.01%|    if source_type is IPv4Network:
   628|         0|            0|            0|  0.00%|        return source_type, [
   629|         0|            0|            0|  0.00%|            SchemaTransformer(
   630|         0|            0|            0|  0.00%|                lambda _1, _2: core_schema.lax_or_strict_schema(
   631|         0|            0|            0|  0.00%|                    lax_schema=core_schema.no_info_plain_validator_function(_validators.ip_v4_network_validator),
   632|         0|            0|            0|  0.00%|                    strict_schema=make_strict_ip_schema(IPv4Network),
   633|         0|            0|            0|  0.00%|                    serialization=core_schema.to_string_ser_schema(),
   634|         0|            0|            0|  0.00%|                ),
   635|         0|            0|            0|  0.00%|                lambda _1, _2: {'type': 'string', 'format': 'ipv4network'},
   636|         0|            0|            0|  0.00%|            ),
   637|         0|            0|            0|  0.00%|            *annotations,
   638|         0|            0|            0|  0.00%|        ]
   639|         2|  9.29832e-06|  4.64916e-06|  0.01%|    if source_type is IPv4Interface:
   640|         0|            0|            0|  0.00%|        return source_type, [
   641|         0|            0|            0|  0.00%|            SchemaTransformer(
   642|         0|            0|            0|  0.00%|                lambda _1, _2: core_schema.lax_or_strict_schema(
   643|         0|            0|            0|  0.00%|                    lax_schema=core_schema.no_info_plain_validator_function(_validators.ip_v4_interface_validator),
   644|         0|            0|            0|  0.00%|                    strict_schema=make_strict_ip_schema(IPv4Interface),
   645|         0|            0|            0|  0.00%|                    serialization=core_schema.to_string_ser_schema(),
   646|         0|            0|            0|  0.00%|                ),
   647|         0|            0|            0|  0.00%|                lambda _1, _2: {'type': 'string', 'format': 'ipv4interface'},
   648|         0|            0|            0|  0.00%|            ),
   649|         0|            0|            0|  0.00%|            *annotations,
   650|         0|            0|            0|  0.00%|        ]
   651|         0|            0|            0|  0.00%|
   652|         2|  8.58307e-06|  4.29153e-06|  0.01%|    if source_type is IPv6Address:
   653|         0|            0|            0|  0.00%|        return source_type, [
   654|         0|            0|            0|  0.00%|            SchemaTransformer(
   655|         0|            0|            0|  0.00%|                lambda _1, _2: core_schema.lax_or_strict_schema(
   656|         0|            0|            0|  0.00%|                    lax_schema=core_schema.no_info_plain_validator_function(_validators.ip_v6_address_validator),
   657|         0|            0|            0|  0.00%|                    strict_schema=make_strict_ip_schema(IPv6Address),
   658|         0|            0|            0|  0.00%|                    serialization=core_schema.to_string_ser_schema(),
   659|         0|            0|            0|  0.00%|                ),
   660|         0|            0|            0|  0.00%|                lambda _1, _2: {'type': 'string', 'format': 'ipv6'},
   661|         0|            0|            0|  0.00%|            ),
   662|         0|            0|            0|  0.00%|            *annotations,
   663|         0|            0|            0|  0.00%|        ]
   664|         2|  8.82149e-06|  4.41074e-06|  0.01%|    if source_type is IPv6Network:
   665|         0|            0|            0|  0.00%|        return source_type, [
   666|         0|            0|            0|  0.00%|            SchemaTransformer(
   667|         0|            0|            0|  0.00%|                lambda _1, _2: core_schema.lax_or_strict_schema(
   668|         0|            0|            0|  0.00%|                    lax_schema=core_schema.no_info_plain_validator_function(_validators.ip_v6_network_validator),
   669|         0|            0|            0|  0.00%|                    strict_schema=make_strict_ip_schema(IPv6Network),
   670|         0|            0|            0|  0.00%|                    serialization=core_schema.to_string_ser_schema(),
   671|         0|            0|            0|  0.00%|                ),
   672|         0|            0|            0|  0.00%|                lambda _1, _2: {'type': 'string', 'format': 'ipv6network'},
   673|         0|            0|            0|  0.00%|            ),
   674|         0|            0|            0|  0.00%|            *annotations,
   675|         0|            0|            0|  0.00%|        ]
   676|         2|  8.58307e-06|  4.29153e-06|  0.01%|    if source_type is IPv6Interface:
   677|         0|            0|            0|  0.00%|        return source_type, [
   678|         0|            0|            0|  0.00%|            SchemaTransformer(
   679|         0|            0|            0|  0.00%|                lambda _1, _2: core_schema.lax_or_strict_schema(
   680|         0|            0|            0|  0.00%|                    lax_schema=core_schema.no_info_plain_validator_function(_validators.ip_v6_interface_validator),
   681|         0|            0|            0|  0.00%|                    strict_schema=make_strict_ip_schema(IPv6Interface),
   682|         0|            0|            0|  0.00%|                    serialization=core_schema.to_string_ser_schema(),
   683|         0|            0|            0|  0.00%|                ),
   684|         0|            0|            0|  0.00%|                lambda _1, _2: {'type': 'string', 'format': 'ipv6interface'},
   685|         0|            0|            0|  0.00%|            ),
   686|         0|            0|            0|  0.00%|            *annotations,
   687|         0|            0|            0|  0.00%|        ]
   688|         0|            0|            0|  0.00%|
   689|         2|  9.05991e-06|  4.52995e-06|  0.01%|    return None
   690|         0|            0|            0|  0.00%|
   691|         0|            0|            0|  0.00%|
   692|         2|  1.23978e-05|  6.19888e-06|  0.01%|def url_prepare_pydantic_annotations(
   693|         0|            0|            0|  0.00%|    source_type: Any, annotations: Iterable[Any], _config: ConfigDict
   694|         0|            0|            0|  0.00%|) -> tuple[Any, list[Any]] | None:
   695|         2|  4.29153e-06|  2.14577e-06|  0.00%|    if source_type is Url:
   696|         0|            0|            0|  0.00%|        return source_type, [
   697|         0|            0|            0|  0.00%|            SchemaTransformer(
   698|         0|            0|            0|  0.00%|                lambda _1, _2: core_schema.url_schema(),
   699|         0|            0|            0|  0.00%|                lambda cs, handler: handler(cs),
   700|         0|            0|            0|  0.00%|            ),
   701|         0|            0|            0|  0.00%|            *annotations,
   702|         0|            0|            0|  0.00%|        ]
   703|         2|  4.29153e-06|  2.14577e-06|  0.00%|    if source_type is MultiHostUrl:
   704|         0|            0|            0|  0.00%|        return source_type, [
   705|         0|            0|            0|  0.00%|            SchemaTransformer(
   706|         0|            0|            0|  0.00%|                lambda _1, _2: core_schema.multi_host_url_schema(),
   707|         0|            0|            0|  0.00%|                lambda cs, handler: handler(cs),
   708|         0|            0|            0|  0.00%|            ),
   709|         0|            0|            0|  0.00%|            *annotations,
   710|         0|            0|            0|  0.00%|        ]
   711|         0|            0|            0|  0.00%|
   712|         0|            0|            0|  0.00%|
   713|         0|            0|            0|  0.00%|PREPARE_METHODS: tuple[Callable[[Any, Iterable[Any], ConfigDict], tuple[Any, list[Any]] | None], ...] = (
   714|         0|            0|            0|  0.00%|    decimal_prepare_pydantic_annotations,
   715|         0|            0|            0|  0.00%|    sequence_like_prepare_pydantic_annotations,
   716|         0|            0|            0|  0.00%|    datetime_prepare_pydantic_annotations,
   717|         0|            0|            0|  0.00%|    uuid_prepare_pydantic_annotations,
   718|         0|            0|            0|  0.00%|    path_schema_prepare_pydantic_annotations,
   719|         0|            0|            0|  0.00%|    mapping_like_prepare_pydantic_annotations,
   720|         0|            0|            0|  0.00%|    ip_prepare_pydantic_annotations,
   721|         0|            0|            0|  0.00%|    url_prepare_pydantic_annotations,
   722|         0|            0|            0|  0.00%|)
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/enum.py
File duration: 0.000331163s (0.34%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|import sys
     2|         0|            0|            0|  0.00%|import builtins as bltns
     3|         0|            0|            0|  0.00%|from types import MappingProxyType, DynamicClassAttribute
     4|         0|            0|            0|  0.00%|from operator import or_ as _or_
     5|         0|            0|            0|  0.00%|from functools import reduce
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|__all__ = [
     9|         0|            0|            0|  0.00%|        'EnumType', 'EnumMeta',
    10|         0|            0|            0|  0.00%|        'Enum', 'IntEnum', 'StrEnum', 'Flag', 'IntFlag', 'ReprEnum',
    11|         0|            0|            0|  0.00%|        'auto', 'unique', 'property', 'verify', 'member', 'nonmember',
    12|         0|            0|            0|  0.00%|        'FlagBoundary', 'STRICT', 'CONFORM', 'EJECT', 'KEEP',
    13|         0|            0|            0|  0.00%|        'global_flag_repr', 'global_enum_repr', 'global_str', 'global_enum',
    14|         0|            0|            0|  0.00%|        'EnumCheck', 'CONTINUOUS', 'NAMED_FLAGS', 'UNIQUE',
    15|         0|            0|            0|  0.00%|        'pickle_by_global_name', 'pickle_by_enum_name',
    16|         0|            0|            0|  0.00%|        ]
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|# Dummy value for Enum and Flag as there are explicit checks for them
    20|         0|            0|            0|  0.00%|# before they have been created.
    21|         0|            0|            0|  0.00%|# This is also why there are checks in EnumType like `if Enum is not None`
    22|         0|            0|            0|  0.00%|Enum = Flag = EJECT = _stdlib_enums = ReprEnum = None
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|class nonmember(object):
    25|         0|            0|            0|  0.00%|    """
    26|         0|            0|            0|  0.00%|    Protects item from becoming an Enum member during class creation.
    27|         0|            0|            0|  0.00%|    """
    28|         0|            0|            0|  0.00%|    def __init__(self, value):
    29|         0|            0|            0|  0.00%|        self.value = value
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|class member(object):
    32|         0|            0|            0|  0.00%|    """
    33|         0|            0|            0|  0.00%|    Forces item to become an Enum member during class creation.
    34|         0|            0|            0|  0.00%|    """
    35|         0|            0|            0|  0.00%|    def __init__(self, value):
    36|         0|            0|            0|  0.00%|        self.value = value
    37|         0|            0|            0|  0.00%|
    38|         0|            0|            0|  0.00%|def _is_descriptor(obj):
    39|         0|            0|            0|  0.00%|    """
    40|         0|            0|            0|  0.00%|    Returns True if obj is a descriptor, False otherwise.
    41|         0|            0|            0|  0.00%|    """
    42|         0|            0|            0|  0.00%|    return (
    43|         0|            0|            0|  0.00%|            hasattr(obj, '__get__') or
    44|         0|            0|            0|  0.00%|            hasattr(obj, '__set__') or
    45|         0|            0|            0|  0.00%|            hasattr(obj, '__delete__')
    46|         0|            0|            0|  0.00%|            )
    47|         0|            0|            0|  0.00%|
    48|         0|            0|            0|  0.00%|def _is_dunder(name):
    49|         0|            0|            0|  0.00%|    """
    50|         0|            0|            0|  0.00%|    Returns True if a __dunder__ name, False otherwise.
    51|         0|            0|            0|  0.00%|    """
    52|         0|            0|            0|  0.00%|    return (
    53|         0|            0|            0|  0.00%|            len(name) > 4 and
    54|         0|            0|            0|  0.00%|            name[:2] == name[-2:] == '__' and
    55|         0|            0|            0|  0.00%|            name[2] != '_' and
    56|         0|            0|            0|  0.00%|            name[-3] != '_'
    57|         0|            0|            0|  0.00%|            )
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|def _is_sunder(name):
    60|         0|            0|            0|  0.00%|    """
    61|         0|            0|            0|  0.00%|    Returns True if a _sunder_ name, False otherwise.
    62|         0|            0|            0|  0.00%|    """
    63|         0|            0|            0|  0.00%|    return (
    64|         0|            0|            0|  0.00%|            len(name) > 2 and
    65|         0|            0|            0|  0.00%|            name[0] == name[-1] == '_' and
    66|         0|            0|            0|  0.00%|            name[1:2] != '_' and
    67|         0|            0|            0|  0.00%|            name[-2:-1] != '_'
    68|         0|            0|            0|  0.00%|            )
    69|         0|            0|            0|  0.00%|
    70|         0|            0|            0|  0.00%|def _is_internal_class(cls_name, obj):
    71|         0|            0|            0|  0.00%|    # do not use `re` as `re` imports `enum`
    72|         0|            0|            0|  0.00%|    if not isinstance(obj, type):
    73|         0|            0|            0|  0.00%|        return False
    74|         0|            0|            0|  0.00%|    qualname = getattr(obj, '__qualname__', '')
    75|         0|            0|            0|  0.00%|    s_pattern = cls_name + '.' + getattr(obj, '__name__', '')
    76|         0|            0|            0|  0.00%|    e_pattern = '.' + s_pattern
    77|         0|            0|            0|  0.00%|    return qualname == s_pattern or qualname.endswith(e_pattern)
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|def _is_private(cls_name, name):
    80|         0|            0|            0|  0.00%|    # do not use `re` as `re` imports `enum`
    81|         0|            0|            0|  0.00%|    pattern = '_%s__' % (cls_name, )
    82|         0|            0|            0|  0.00%|    pat_len = len(pattern)
    83|         0|            0|            0|  0.00%|    if (
    84|         0|            0|            0|  0.00%|            len(name) > pat_len
    85|         0|            0|            0|  0.00%|            and name.startswith(pattern)
    86|         0|            0|            0|  0.00%|            and name[pat_len:pat_len+1] != ['_']
    87|         0|            0|            0|  0.00%|            and (name[-1] != '_' or name[-2] != '_')
    88|         0|            0|            0|  0.00%|        ):
    89|         0|            0|            0|  0.00%|        return True
    90|         0|            0|            0|  0.00%|    else:
    91|         0|            0|            0|  0.00%|        return False
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|def _is_single_bit(num):
    94|         0|            0|            0|  0.00%|    """
    95|         0|            0|            0|  0.00%|    True if only one bit set in num (should be an int)
    96|         0|            0|            0|  0.00%|    """
    97|         0|            0|            0|  0.00%|    if num == 0:
    98|         0|            0|            0|  0.00%|        return False
    99|         0|            0|            0|  0.00%|    num &= num - 1
   100|         0|            0|            0|  0.00%|    return num == 0
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|def _make_class_unpicklable(obj):
   103|         0|            0|            0|  0.00%|    """
   104|         0|            0|            0|  0.00%|    Make the given obj un-picklable.
   105|         0|            0|            0|  0.00%|
   106|         0|            0|            0|  0.00%|    obj should be either a dictionary, or an Enum
   107|         0|            0|            0|  0.00%|    """
   108|         0|            0|            0|  0.00%|    def _break_on_call_reduce(self, proto):
   109|         0|            0|            0|  0.00%|        raise TypeError('%r cannot be pickled' % self)
   110|         0|            0|            0|  0.00%|    if isinstance(obj, dict):
   111|         0|            0|            0|  0.00%|        obj['__reduce_ex__'] = _break_on_call_reduce
   112|         0|            0|            0|  0.00%|        obj['__module__'] = '<unknown>'
   113|         0|            0|            0|  0.00%|    else:
   114|         0|            0|            0|  0.00%|        setattr(obj, '__reduce_ex__', _break_on_call_reduce)
   115|         0|            0|            0|  0.00%|        setattr(obj, '__module__', '<unknown>')
   116|         0|            0|            0|  0.00%|
   117|         0|            0|            0|  0.00%|def _iter_bits_lsb(num):
   118|         0|            0|            0|  0.00%|    # num must be a positive integer
   119|         0|            0|            0|  0.00%|    original = num
   120|         0|            0|            0|  0.00%|    if isinstance(num, Enum):
   121|         0|            0|            0|  0.00%|        num = num.value
   122|         0|            0|            0|  0.00%|    if num < 0:
   123|         0|            0|            0|  0.00%|        raise ValueError('%r is not a positive integer' % original)
   124|         0|            0|            0|  0.00%|    while num:
   125|         0|            0|            0|  0.00%|        b = num & (~num + 1)
   126|         0|            0|            0|  0.00%|        yield b
   127|         0|            0|            0|  0.00%|        num ^= b
   128|         0|            0|            0|  0.00%|
   129|         0|            0|            0|  0.00%|def show_flag_values(value):
   130|         0|            0|            0|  0.00%|    return list(_iter_bits_lsb(value))
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|def bin(num, max_bits=None):
   133|         0|            0|            0|  0.00%|    """
   134|         0|            0|            0|  0.00%|    Like built-in bin(), except negative values are represented in
   135|         0|            0|            0|  0.00%|    twos-compliment, and the leading bit always indicates sign
   136|         0|            0|            0|  0.00%|    (0=positive, 1=negative).
   137|         0|            0|            0|  0.00%|
   138|         0|            0|            0|  0.00%|    >>> bin(10)
   139|         0|            0|            0|  0.00%|    '0b0 1010'
   140|         0|            0|            0|  0.00%|    >>> bin(~10)   # ~10 is -11
   141|         0|            0|            0|  0.00%|    '0b1 0101'
   142|         0|            0|            0|  0.00%|    """
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|    ceiling = 2 ** (num).bit_length()
   145|         0|            0|            0|  0.00%|    if num >= 0:
   146|         0|            0|            0|  0.00%|        s = bltns.bin(num + ceiling).replace('1', '0', 1)
   147|         0|            0|            0|  0.00%|    else:
   148|         0|            0|            0|  0.00%|        s = bltns.bin(~num ^ (ceiling - 1) + ceiling)
   149|         0|            0|            0|  0.00%|    sign = s[:3]
   150|         0|            0|            0|  0.00%|    digits = s[3:]
   151|         0|            0|            0|  0.00%|    if max_bits is not None:
   152|         0|            0|            0|  0.00%|        if len(digits) < max_bits:
   153|         0|            0|            0|  0.00%|            digits = (sign[-1] * max_bits + digits)[-max_bits:]
   154|         0|            0|            0|  0.00%|    return "%s %s" % (sign, digits)
   155|         0|            0|            0|  0.00%|
   156|         0|            0|            0|  0.00%|def _dedent(text):
   157|         0|            0|            0|  0.00%|    """
   158|         0|            0|            0|  0.00%|    Like textwrap.dedent.  Rewritten because we cannot import textwrap.
   159|         0|            0|            0|  0.00%|    """
   160|         0|            0|            0|  0.00%|    lines = text.split('\n')
   161|         0|            0|            0|  0.00%|    blanks = 0
   162|         0|            0|            0|  0.00%|    for i, ch in enumerate(lines[0]):
   163|         0|            0|            0|  0.00%|        if ch != ' ':
   164|         0|            0|            0|  0.00%|            break
   165|         0|            0|            0|  0.00%|    for j, l in enumerate(lines):
   166|         0|            0|            0|  0.00%|        lines[j] = l[i:]
   167|         0|            0|            0|  0.00%|    return '\n'.join(lines)
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|class _not_given:
   170|         0|            0|            0|  0.00%|    def __repr__(self):
   171|         0|            0|            0|  0.00%|        return('<not given>')
   172|         0|            0|            0|  0.00%|_not_given = _not_given()
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|class _auto_null:
   175|         0|            0|            0|  0.00%|    def __repr__(self):
   176|         0|            0|            0|  0.00%|        return '_auto_null'
   177|         0|            0|            0|  0.00%|_auto_null = _auto_null()
   178|         0|            0|            0|  0.00%|
   179|         0|            0|            0|  0.00%|class auto:
   180|         0|            0|            0|  0.00%|    """
   181|         0|            0|            0|  0.00%|    Instances are replaced with an appropriate value in Enum class suites.
   182|         0|            0|            0|  0.00%|    """
   183|         0|            0|            0|  0.00%|    def __init__(self, value=_auto_null):
   184|         0|            0|            0|  0.00%|        self.value = value
   185|         0|            0|            0|  0.00%|
   186|         0|            0|            0|  0.00%|    def __repr__(self):
   187|         0|            0|            0|  0.00%|        return "auto(%r)" % self.value
   188|         0|            0|            0|  0.00%|
   189|         0|            0|            0|  0.00%|class property(DynamicClassAttribute):
   190|         0|            0|            0|  0.00%|    """
   191|         0|            0|            0|  0.00%|    This is a descriptor, used to define attributes that act differently
   192|         0|            0|            0|  0.00%|    when accessed through an enum member and through an enum class.
   193|         0|            0|            0|  0.00%|    Instance access is the same as property(), but access to an attribute
   194|         0|            0|            0|  0.00%|    through the enum class will instead look in the class' _member_map_ for
   195|         0|            0|            0|  0.00%|    a corresponding enum member.
   196|         0|            0|            0|  0.00%|    """
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|    member = None
   199|         0|            0|            0|  0.00%|    _attr_type = None
   200|         0|            0|            0|  0.00%|    _cls_type = None
   201|         0|            0|            0|  0.00%|
   202|         0|            0|            0|  0.00%|    def __get__(self, instance, ownerclass=None):
   203|         0|            0|            0|  0.00%|        if instance is None:
   204|         0|            0|            0|  0.00%|            if self.member is not None:
   205|         0|            0|            0|  0.00%|                return self.member
   206|         0|            0|            0|  0.00%|            else:
   207|         0|            0|            0|  0.00%|                raise AttributeError(
   208|         0|            0|            0|  0.00%|                        '%r has no attribute %r' % (ownerclass, self.name)
   209|         0|            0|            0|  0.00%|                        )
   210|         0|            0|            0|  0.00%|        if self.fget is not None:
   211|         0|            0|            0|  0.00%|            # use previous enum.property
   212|         0|            0|            0|  0.00%|            return self.fget(instance)
   213|         0|            0|            0|  0.00%|        elif self._attr_type == 'attr':
   214|         0|            0|            0|  0.00%|            # look up previous attibute
   215|         0|            0|            0|  0.00%|            return getattr(self._cls_type, self.name)
   216|         0|            0|            0|  0.00%|        elif self._attr_type == 'desc':
   217|         0|            0|            0|  0.00%|            # use previous descriptor
   218|         0|            0|            0|  0.00%|            return getattr(instance._value_, self.name)
   219|         0|            0|            0|  0.00%|        # look for a member by this name.
   220|         0|            0|            0|  0.00%|        try:
   221|         0|            0|            0|  0.00%|            return ownerclass._member_map_[self.name]
   222|         0|            0|            0|  0.00%|        except KeyError:
   223|         0|            0|            0|  0.00%|            raise AttributeError(
   224|         0|            0|            0|  0.00%|                    '%r has no attribute %r' % (ownerclass, self.name)
   225|         0|            0|            0|  0.00%|                    ) from None
   226|         0|            0|            0|  0.00%|
   227|         0|            0|            0|  0.00%|    def __set__(self, instance, value):
   228|         0|            0|            0|  0.00%|        if self.fset is not None:
   229|         0|            0|            0|  0.00%|            return self.fset(instance, value)
   230|         0|            0|            0|  0.00%|        raise AttributeError(
   231|         0|            0|            0|  0.00%|                "<enum %r> cannot set attribute %r" % (self.clsname, self.name)
   232|         0|            0|            0|  0.00%|                )
   233|         0|            0|            0|  0.00%|
   234|         0|            0|            0|  0.00%|    def __delete__(self, instance):
   235|         0|            0|            0|  0.00%|        if self.fdel is not None:
   236|         0|            0|            0|  0.00%|            return self.fdel(instance)
   237|         0|            0|            0|  0.00%|        raise AttributeError(
   238|         0|            0|            0|  0.00%|                "<enum %r> cannot delete attribute %r" % (self.clsname, self.name)
   239|         0|            0|            0|  0.00%|                )
   240|         0|            0|            0|  0.00%|
   241|         0|            0|            0|  0.00%|    def __set_name__(self, ownerclass, name):
   242|         0|            0|            0|  0.00%|        self.name = name
   243|         0|            0|            0|  0.00%|        self.clsname = ownerclass.__name__
   244|         0|            0|            0|  0.00%|
   245|         0|            0|            0|  0.00%|
   246|         0|            0|            0|  0.00%|class _proto_member:
   247|         0|            0|            0|  0.00%|    """
   248|         0|            0|            0|  0.00%|    intermediate step for enum members between class execution and final creation
   249|         0|            0|            0|  0.00%|    """
   250|         0|            0|            0|  0.00%|
   251|         0|            0|            0|  0.00%|    def __init__(self, value):
   252|         0|            0|            0|  0.00%|        self.value = value
   253|         0|            0|            0|  0.00%|
   254|         0|            0|            0|  0.00%|    def __set_name__(self, enum_class, member_name):
   255|         0|            0|            0|  0.00%|        """
   256|         0|            0|            0|  0.00%|        convert each quasi-member into an instance of the new enum class
   257|         0|            0|            0|  0.00%|        """
   258|         0|            0|            0|  0.00%|        # first step: remove ourself from enum_class
   259|         0|            0|            0|  0.00%|        delattr(enum_class, member_name)
   260|         0|            0|            0|  0.00%|        # second step: create member based on enum_class
   261|         0|            0|            0|  0.00%|        value = self.value
   262|         0|            0|            0|  0.00%|        if not isinstance(value, tuple):
   263|         0|            0|            0|  0.00%|            args = (value, )
   264|         0|            0|            0|  0.00%|        else:
   265|         0|            0|            0|  0.00%|            args = value
   266|         0|            0|            0|  0.00%|        if enum_class._member_type_ is tuple:   # special case for tuple enums
   267|         0|            0|            0|  0.00%|            args = (args, )     # wrap it one more time
   268|         0|            0|            0|  0.00%|        if not enum_class._use_args_:
   269|         0|            0|            0|  0.00%|            enum_member = enum_class._new_member_(enum_class)
   270|         0|            0|            0|  0.00%|        else:
   271|         0|            0|            0|  0.00%|            enum_member = enum_class._new_member_(enum_class, *args)
   272|         0|            0|            0|  0.00%|        if not hasattr(enum_member, '_value_'):
   273|         0|            0|            0|  0.00%|            if enum_class._member_type_ is object:
   274|         0|            0|            0|  0.00%|                enum_member._value_ = value
   275|         0|            0|            0|  0.00%|            else:
   276|         0|            0|            0|  0.00%|                try:
   277|         0|            0|            0|  0.00%|                    enum_member._value_ = enum_class._member_type_(*args)
   278|         0|            0|            0|  0.00%|                except Exception as exc:
   279|         0|            0|            0|  0.00%|                    new_exc = TypeError(
   280|         0|            0|            0|  0.00%|                            '_value_ not set in __new__, unable to create it'
   281|         0|            0|            0|  0.00%|                            )
   282|         0|            0|            0|  0.00%|                    new_exc.__cause__ = exc
   283|         0|            0|            0|  0.00%|                    raise new_exc
   284|         0|            0|            0|  0.00%|        value = enum_member._value_
   285|         0|            0|            0|  0.00%|        enum_member._name_ = member_name
   286|         0|            0|            0|  0.00%|        enum_member.__objclass__ = enum_class
   287|         0|            0|            0|  0.00%|        enum_member.__init__(*args)
   288|         0|            0|            0|  0.00%|        enum_member._sort_order_ = len(enum_class._member_names_)
   289|         0|            0|            0|  0.00%|
   290|         0|            0|            0|  0.00%|        if Flag is not None and issubclass(enum_class, Flag):
   291|         0|            0|            0|  0.00%|            if isinstance(value, int):
   292|         0|            0|            0|  0.00%|                enum_class._flag_mask_ |= value
   293|         0|            0|            0|  0.00%|                if _is_single_bit(value):
   294|         0|            0|            0|  0.00%|                    enum_class._singles_mask_ |= value
   295|         0|            0|            0|  0.00%|            enum_class._all_bits_ = 2 ** ((enum_class._flag_mask_).bit_length()) - 1
   296|         0|            0|            0|  0.00%|
   297|         0|            0|            0|  0.00%|        # If another member with the same value was already defined, the
   298|         0|            0|            0|  0.00%|        # new member becomes an alias to the existing one.
   299|         0|            0|            0|  0.00%|        try:
   300|         0|            0|            0|  0.00%|            try:
   301|         0|            0|            0|  0.00%|                # try to do a fast lookup to avoid the quadratic loop
   302|         0|            0|            0|  0.00%|                enum_member = enum_class._value2member_map_[value]
   303|         0|            0|            0|  0.00%|            except TypeError:
   304|         0|            0|            0|  0.00%|                for name, canonical_member in enum_class._member_map_.items():
   305|         0|            0|            0|  0.00%|                    if canonical_member._value_ == value:
   306|         0|            0|            0|  0.00%|                        enum_member = canonical_member
   307|         0|            0|            0|  0.00%|                        break
   308|         0|            0|            0|  0.00%|                else:
   309|         0|            0|            0|  0.00%|                    raise KeyError
   310|         0|            0|            0|  0.00%|        except KeyError:
   311|         0|            0|            0|  0.00%|            # this could still be an alias if the value is multi-bit and the
   312|         0|            0|            0|  0.00%|            # class is a flag class
   313|         0|            0|            0|  0.00%|            if (
   314|         0|            0|            0|  0.00%|                    Flag is None
   315|         0|            0|            0|  0.00%|                    or not issubclass(enum_class, Flag)
   316|         0|            0|            0|  0.00%|                ):
   317|         0|            0|            0|  0.00%|                # no other instances found, record this member in _member_names_
   318|         0|            0|            0|  0.00%|                enum_class._member_names_.append(member_name)
   319|         0|            0|            0|  0.00%|            elif (
   320|         0|            0|            0|  0.00%|                    Flag is not None
   321|         0|            0|            0|  0.00%|                    and issubclass(enum_class, Flag)
   322|         0|            0|            0|  0.00%|                    and isinstance(value, int)
   323|         0|            0|            0|  0.00%|                    and _is_single_bit(value)
   324|         0|            0|            0|  0.00%|                ):
   325|         0|            0|            0|  0.00%|                # no other instances found, record this member in _member_names_
   326|         0|            0|            0|  0.00%|                enum_class._member_names_.append(member_name)
   327|         0|            0|            0|  0.00%|        # if necessary, get redirect in place and then add it to _member_map_
   328|         0|            0|            0|  0.00%|        found_descriptor = None
   329|         0|            0|            0|  0.00%|        descriptor_type = None
   330|         0|            0|            0|  0.00%|        class_type = None
   331|         0|            0|            0|  0.00%|        for base in enum_class.__mro__[1:]:
   332|         0|            0|            0|  0.00%|            attr = base.__dict__.get(member_name)
   333|         0|            0|            0|  0.00%|            if attr is not None:
   334|         0|            0|            0|  0.00%|                if isinstance(attr, (property, DynamicClassAttribute)):
   335|         0|            0|            0|  0.00%|                    found_descriptor = attr
   336|         0|            0|            0|  0.00%|                    class_type = base
   337|         0|            0|            0|  0.00%|                    descriptor_type = 'enum'
   338|         0|            0|            0|  0.00%|                    break
   339|         0|            0|            0|  0.00%|                elif _is_descriptor(attr):
   340|         0|            0|            0|  0.00%|                    found_descriptor = attr
   341|         0|            0|            0|  0.00%|                    descriptor_type = descriptor_type or 'desc'
   342|         0|            0|            0|  0.00%|                    class_type = class_type or base
   343|         0|            0|            0|  0.00%|                    continue
   344|         0|            0|            0|  0.00%|                else:
   345|         0|            0|            0|  0.00%|                    descriptor_type = 'attr'
   346|         0|            0|            0|  0.00%|                    class_type = base
   347|         0|            0|            0|  0.00%|        if found_descriptor:
   348|         0|            0|            0|  0.00%|            redirect = property()
   349|         0|            0|            0|  0.00%|            redirect.member = enum_member
   350|         0|            0|            0|  0.00%|            redirect.__set_name__(enum_class, member_name)
   351|         0|            0|            0|  0.00%|            if descriptor_type in ('enum','desc'):
   352|         0|            0|            0|  0.00%|                # earlier descriptor found; copy fget, fset, fdel to this one.
   353|         0|            0|            0|  0.00%|                redirect.fget = getattr(found_descriptor, 'fget', None)
   354|         0|            0|            0|  0.00%|                redirect._get = getattr(found_descriptor, '__get__', None)
   355|         0|            0|            0|  0.00%|                redirect.fset = getattr(found_descriptor, 'fset', None)
   356|         0|            0|            0|  0.00%|                redirect._set = getattr(found_descriptor, '__set__', None)
   357|         0|            0|            0|  0.00%|                redirect.fdel = getattr(found_descriptor, 'fdel', None)
   358|         0|            0|            0|  0.00%|                redirect._del = getattr(found_descriptor, '__delete__', None)
   359|         0|            0|            0|  0.00%|            redirect._attr_type = descriptor_type
   360|         0|            0|            0|  0.00%|            redirect._cls_type = class_type
   361|         0|            0|            0|  0.00%|            setattr(enum_class, member_name, redirect)
   362|         0|            0|            0|  0.00%|        else:
   363|         0|            0|            0|  0.00%|            setattr(enum_class, member_name, enum_member)
   364|         0|            0|            0|  0.00%|        # now add to _member_map_ (even aliases)
   365|         0|            0|            0|  0.00%|        enum_class._member_map_[member_name] = enum_member
   366|         0|            0|            0|  0.00%|        try:
   367|         0|            0|            0|  0.00%|            # This may fail if value is not hashable. We can't add the value
   368|         0|            0|            0|  0.00%|            # to the map, and by-value lookups for this value will be
   369|         0|            0|            0|  0.00%|            # linear.
   370|         0|            0|            0|  0.00%|            enum_class._value2member_map_.setdefault(value, enum_member)
   371|         0|            0|            0|  0.00%|        except TypeError:
   372|         0|            0|            0|  0.00%|            # keep track of the value in a list so containment checks are quick
   373|         0|            0|            0|  0.00%|            enum_class._unhashable_values_.append(value)
   374|         0|            0|            0|  0.00%|
   375|         0|            0|            0|  0.00%|
   376|         0|            0|            0|  0.00%|class _EnumDict(dict):
   377|         0|            0|            0|  0.00%|    """
   378|         0|            0|            0|  0.00%|    Track enum member order and ensure member names are not reused.
   379|         0|            0|            0|  0.00%|
   380|         0|            0|            0|  0.00%|    EnumType will use the names found in self._member_names as the
   381|         0|            0|            0|  0.00%|    enumeration member names.
   382|         0|            0|            0|  0.00%|    """
   383|         0|            0|            0|  0.00%|    def __init__(self):
   384|         0|            0|            0|  0.00%|        super().__init__()
   385|         0|            0|            0|  0.00%|        self._member_names = {} # use a dict to keep insertion order
   386|         0|            0|            0|  0.00%|        self._last_values = []
   387|         0|            0|            0|  0.00%|        self._ignore = []
   388|         0|            0|            0|  0.00%|        self._auto_called = False
   389|         0|            0|            0|  0.00%|
   390|         0|            0|            0|  0.00%|    def __setitem__(self, key, value):
   391|         0|            0|            0|  0.00%|        """
   392|         0|            0|            0|  0.00%|        Changes anything not dundered or not a descriptor.
   393|         0|            0|            0|  0.00%|
   394|         0|            0|            0|  0.00%|        If an enum member name is used twice, an error is raised; duplicate
   395|         0|            0|            0|  0.00%|        values are not checked for.
   396|         0|            0|            0|  0.00%|
   397|         0|            0|            0|  0.00%|        Single underscore (sunder) names are reserved.
   398|         0|            0|            0|  0.00%|        """
   399|         0|            0|            0|  0.00%|        if _is_internal_class(self._cls_name, value):
   400|         0|            0|            0|  0.00%|            import warnings
   401|         0|            0|            0|  0.00%|            warnings.warn(
   402|         0|            0|            0|  0.00%|                    "In 3.13 classes created inside an enum will not become a member.  "
   403|         0|            0|            0|  0.00%|                    "Use the `member` decorator to keep the current behavior.",
   404|         0|            0|            0|  0.00%|                    DeprecationWarning,
   405|         0|            0|            0|  0.00%|                    stacklevel=2,
   406|         0|            0|            0|  0.00%|                    )
   407|         0|            0|            0|  0.00%|        if _is_private(self._cls_name, key):
   408|         0|            0|            0|  0.00%|            # also do nothing, name will be a normal attribute
   409|         0|            0|            0|  0.00%|            pass
   410|         0|            0|            0|  0.00%|        elif _is_sunder(key):
   411|         0|            0|            0|  0.00%|            if key not in (
   412|         0|            0|            0|  0.00%|                    '_order_',
   413|         0|            0|            0|  0.00%|                    '_generate_next_value_', '_numeric_repr_', '_missing_', '_ignore_',
   414|         0|            0|            0|  0.00%|                    '_iter_member_', '_iter_member_by_value_', '_iter_member_by_def_',
   415|         0|            0|            0|  0.00%|                    ):
   416|         0|            0|            0|  0.00%|                raise ValueError(
   417|         0|            0|            0|  0.00%|                        '_sunder_ names, such as %r, are reserved for future Enum use'
   418|         0|            0|            0|  0.00%|                        % (key, )
   419|         0|            0|            0|  0.00%|                        )
   420|         0|            0|            0|  0.00%|            if key == '_generate_next_value_':
   421|         0|            0|            0|  0.00%|                # check if members already defined as auto()
   422|         0|            0|            0|  0.00%|                if self._auto_called:
   423|         0|            0|            0|  0.00%|                    raise TypeError("_generate_next_value_ must be defined before members")
   424|         0|            0|            0|  0.00%|                _gnv = value.__func__ if isinstance(value, staticmethod) else value
   425|         0|            0|            0|  0.00%|                setattr(self, '_generate_next_value', _gnv)
   426|         0|            0|            0|  0.00%|            elif key == '_ignore_':
   427|         0|            0|            0|  0.00%|                if isinstance(value, str):
   428|         0|            0|            0|  0.00%|                    value = value.replace(',',' ').split()
   429|         0|            0|            0|  0.00%|                else:
   430|         0|            0|            0|  0.00%|                    value = list(value)
   431|         0|            0|            0|  0.00%|                self._ignore = value
   432|         0|            0|            0|  0.00%|                already = set(value) & set(self._member_names)
   433|         0|            0|            0|  0.00%|                if already:
   434|         0|            0|            0|  0.00%|                    raise ValueError(
   435|         0|            0|            0|  0.00%|                            '_ignore_ cannot specify already set names: %r'
   436|         0|            0|            0|  0.00%|                            % (already, )
   437|         0|            0|            0|  0.00%|                            )
   438|         0|            0|            0|  0.00%|        elif _is_dunder(key):
   439|         0|            0|            0|  0.00%|            if key == '__order__':
   440|         0|            0|            0|  0.00%|                key = '_order_'
   441|         0|            0|            0|  0.00%|        elif key in self._member_names:
   442|         0|            0|            0|  0.00%|            # descriptor overwriting an enum?
   443|         0|            0|            0|  0.00%|            raise TypeError('%r already defined as %r' % (key, self[key]))
   444|         0|            0|            0|  0.00%|        elif key in self._ignore:
   445|         0|            0|            0|  0.00%|            pass
   446|         0|            0|            0|  0.00%|        elif isinstance(value, nonmember):
   447|         0|            0|            0|  0.00%|            # unwrap value here; it won't be processed by the below `else`
   448|         0|            0|            0|  0.00%|            value = value.value
   449|         0|            0|            0|  0.00%|        elif _is_descriptor(value):
   450|         0|            0|            0|  0.00%|            pass
   451|         0|            0|            0|  0.00%|        # TODO: uncomment next three lines in 3.13
   452|         0|            0|            0|  0.00%|        # elif _is_internal_class(self._cls_name, value):
   453|         0|            0|            0|  0.00%|        #     # do nothing, name will be a normal attribute
   454|         0|            0|            0|  0.00%|        #     pass
   455|         0|            0|            0|  0.00%|        else:
   456|         0|            0|            0|  0.00%|            if key in self:
   457|         0|            0|            0|  0.00%|                # enum overwriting a descriptor?
   458|         0|            0|            0|  0.00%|                raise TypeError('%r already defined as %r' % (key, self[key]))
   459|         0|            0|            0|  0.00%|            elif isinstance(value, member):
   460|         0|            0|            0|  0.00%|                # unwrap value here -- it will become a member
   461|         0|            0|            0|  0.00%|                value = value.value
   462|         0|            0|            0|  0.00%|            non_auto_store = True
   463|         0|            0|            0|  0.00%|            single = False
   464|         0|            0|            0|  0.00%|            if isinstance(value, auto):
   465|         0|            0|            0|  0.00%|                single = True
   466|         0|            0|            0|  0.00%|                value = (value, )
   467|         0|            0|            0|  0.00%|            if isinstance(value, tuple) and any(isinstance(v, auto) for v in value):
   468|         0|            0|            0|  0.00%|                # insist on an actual tuple, no subclasses, in keeping with only supporting
   469|         0|            0|            0|  0.00%|                # top-level auto() usage (not contained in any other data structure)
   470|         0|            0|            0|  0.00%|                auto_valued = []
   471|         0|            0|            0|  0.00%|                t = type(value)
   472|         0|            0|            0|  0.00%|                for v in value:
   473|         0|            0|            0|  0.00%|                    if isinstance(v, auto):
   474|         0|            0|            0|  0.00%|                        non_auto_store = False
   475|         0|            0|            0|  0.00%|                        if v.value == _auto_null:
   476|         0|            0|            0|  0.00%|                            v.value = self._generate_next_value(
   477|         0|            0|            0|  0.00%|                                    key, 1, len(self._member_names), self._last_values[:],
   478|         0|            0|            0|  0.00%|                                    )
   479|         0|            0|            0|  0.00%|                            self._auto_called = True
   480|         0|            0|            0|  0.00%|                        v = v.value
   481|         0|            0|            0|  0.00%|                        self._last_values.append(v)
   482|         0|            0|            0|  0.00%|                    auto_valued.append(v)
   483|         0|            0|            0|  0.00%|                if single:
   484|         0|            0|            0|  0.00%|                    value = auto_valued[0]
   485|         0|            0|            0|  0.00%|                else:
   486|         0|            0|            0|  0.00%|                    try:
   487|         0|            0|            0|  0.00%|                        # accepts iterable as multiple arguments?
   488|         0|            0|            0|  0.00%|                        value = t(auto_valued)
   489|         0|            0|            0|  0.00%|                    except TypeError:
   490|         0|            0|            0|  0.00%|                        # then pass them in singlely
   491|         0|            0|            0|  0.00%|                        value = t(*auto_valued)
   492|         0|            0|            0|  0.00%|            self._member_names[key] = None
   493|         0|            0|            0|  0.00%|            if non_auto_store:
   494|         0|            0|            0|  0.00%|                self._last_values.append(value)
   495|         0|            0|            0|  0.00%|        super().__setitem__(key, value)
   496|         0|            0|            0|  0.00%|
   497|         0|            0|            0|  0.00%|    def update(self, members, **more_members):
   498|         0|            0|            0|  0.00%|        try:
   499|         0|            0|            0|  0.00%|            for name in members.keys():
   500|         0|            0|            0|  0.00%|                self[name] = members[name]
   501|         0|            0|            0|  0.00%|        except AttributeError:
   502|         0|            0|            0|  0.00%|            for name, value in members:
   503|         0|            0|            0|  0.00%|                self[name] = value
   504|         0|            0|            0|  0.00%|        for name, value in more_members.items():
   505|         0|            0|            0|  0.00%|            self[name] = value
   506|         0|            0|            0|  0.00%|
   507|         0|            0|            0|  0.00%|
   508|         0|            0|            0|  0.00%|class EnumType(type):
   509|         0|            0|            0|  0.00%|    """
   510|         0|            0|            0|  0.00%|    Metaclass for Enum
   511|         0|            0|            0|  0.00%|    """
   512|         0|            0|            0|  0.00%|
   513|         0|            0|            0|  0.00%|    @classmethod
   514|         0|            0|            0|  0.00%|    def __prepare__(metacls, cls, bases, **kwds):
   515|         0|            0|            0|  0.00%|        # check that previous enum members do not exist
   516|         0|            0|            0|  0.00%|        metacls._check_for_existing_members_(cls, bases)
   517|         0|            0|            0|  0.00%|        # create the namespace dict
   518|         0|            0|            0|  0.00%|        enum_dict = _EnumDict()
   519|         0|            0|            0|  0.00%|        enum_dict._cls_name = cls
   520|         0|            0|            0|  0.00%|        # inherit previous flags and _generate_next_value_ function
   521|         0|            0|            0|  0.00%|        member_type, first_enum = metacls._get_mixins_(cls, bases)
   522|         0|            0|            0|  0.00%|        if first_enum is not None:
   523|         0|            0|            0|  0.00%|            enum_dict['_generate_next_value_'] = getattr(
   524|         0|            0|            0|  0.00%|                    first_enum, '_generate_next_value_', None,
   525|         0|            0|            0|  0.00%|                    )
   526|         0|            0|            0|  0.00%|        return enum_dict
   527|         0|            0|            0|  0.00%|
   528|         0|            0|            0|  0.00%|    def __new__(metacls, cls, bases, classdict, *, boundary=None, _simple=False, **kwds):
   529|         0|            0|            0|  0.00%|        # an Enum class is final once enumeration items have been defined; it
   530|         0|            0|            0|  0.00%|        # cannot be mixed with other types (int, float, etc.) if it has an
   531|         0|            0|            0|  0.00%|        # inherited __new__ unless a new __new__ is defined (or the resulting
   532|         0|            0|            0|  0.00%|        # class will fail).
   533|         0|            0|            0|  0.00%|        #
   534|         0|            0|            0|  0.00%|        if _simple:
   535|         0|            0|            0|  0.00%|            return super().__new__(metacls, cls, bases, classdict, **kwds)
   536|         0|            0|            0|  0.00%|        #
   537|         0|            0|            0|  0.00%|        # remove any keys listed in _ignore_
   538|         0|            0|            0|  0.00%|        classdict.setdefault('_ignore_', []).append('_ignore_')
   539|         0|            0|            0|  0.00%|        ignore = classdict['_ignore_']
   540|         0|            0|            0|  0.00%|        for key in ignore:
   541|         0|            0|            0|  0.00%|            classdict.pop(key, None)
   542|         0|            0|            0|  0.00%|        #
   543|         0|            0|            0|  0.00%|        # grab member names
   544|         0|            0|            0|  0.00%|        member_names = classdict._member_names
   545|         0|            0|            0|  0.00%|        #
   546|         0|            0|            0|  0.00%|        # check for illegal enum names (any others?)
   547|         0|            0|            0|  0.00%|        invalid_names = set(member_names) & {'mro', ''}
   548|         0|            0|            0|  0.00%|        if invalid_names:
   549|         0|            0|            0|  0.00%|            raise ValueError('invalid enum member name(s) %s'  % (
   550|         0|            0|            0|  0.00%|                    ','.join(repr(n) for n in invalid_names)
   551|         0|            0|            0|  0.00%|                    ))
   552|         0|            0|            0|  0.00%|        #
   553|         0|            0|            0|  0.00%|        # adjust the sunders
   554|         0|            0|            0|  0.00%|        _order_ = classdict.pop('_order_', None)
   555|         0|            0|            0|  0.00%|        _gnv = classdict.get('_generate_next_value_')
   556|         0|            0|            0|  0.00%|        if _gnv is not None and type(_gnv) is not staticmethod:
   557|         0|            0|            0|  0.00%|            _gnv = staticmethod(_gnv)
   558|         0|            0|            0|  0.00%|        # convert to normal dict
   559|         0|            0|            0|  0.00%|        classdict = dict(classdict.items())
   560|         0|            0|            0|  0.00%|        if _gnv is not None:
   561|         0|            0|            0|  0.00%|            classdict['_generate_next_value_'] = _gnv
   562|         0|            0|            0|  0.00%|        #
   563|         0|            0|            0|  0.00%|        # data type of member and the controlling Enum class
   564|         0|            0|            0|  0.00%|        member_type, first_enum = metacls._get_mixins_(cls, bases)
   565|         0|            0|            0|  0.00%|        __new__, save_new, use_args = metacls._find_new_(
   566|         0|            0|            0|  0.00%|                classdict, member_type, first_enum,
   567|         0|            0|            0|  0.00%|                )
   568|         0|            0|            0|  0.00%|        classdict['_new_member_'] = __new__
   569|         0|            0|            0|  0.00%|        classdict['_use_args_'] = use_args
   570|         0|            0|            0|  0.00%|        #
   571|         0|            0|            0|  0.00%|        # convert future enum members into temporary _proto_members
   572|         0|            0|            0|  0.00%|        for name in member_names:
   573|         0|            0|            0|  0.00%|            value = classdict[name]
   574|         0|            0|            0|  0.00%|            classdict[name] = _proto_member(value)
   575|         0|            0|            0|  0.00%|        #
   576|         0|            0|            0|  0.00%|        # house-keeping structures
   577|         0|            0|            0|  0.00%|        classdict['_member_names_'] = []
   578|         0|            0|            0|  0.00%|        classdict['_member_map_'] = {}
   579|         0|            0|            0|  0.00%|        classdict['_value2member_map_'] = {}
   580|         0|            0|            0|  0.00%|        classdict['_unhashable_values_'] = []
   581|         0|            0|            0|  0.00%|        classdict['_member_type_'] = member_type
   582|         0|            0|            0|  0.00%|        # now set the __repr__ for the value
   583|         0|            0|            0|  0.00%|        classdict['_value_repr_'] = metacls._find_data_repr_(cls, bases)
   584|         0|            0|            0|  0.00%|        #
   585|         0|            0|            0|  0.00%|        # Flag structures (will be removed if final class is not a Flag
   586|         0|            0|            0|  0.00%|        classdict['_boundary_'] = (
   587|         0|            0|            0|  0.00%|                boundary
   588|         0|            0|            0|  0.00%|                or getattr(first_enum, '_boundary_', None)
   589|         0|            0|            0|  0.00%|                )
   590|         0|            0|            0|  0.00%|        classdict['_flag_mask_'] = 0
   591|         0|            0|            0|  0.00%|        classdict['_singles_mask_'] = 0
   592|         0|            0|            0|  0.00%|        classdict['_all_bits_'] = 0
   593|         0|            0|            0|  0.00%|        classdict['_inverted_'] = None
   594|         0|            0|            0|  0.00%|        try:
   595|         0|            0|            0|  0.00%|            exc = None
   596|         0|            0|            0|  0.00%|            enum_class = super().__new__(metacls, cls, bases, classdict, **kwds)
   597|         0|            0|            0|  0.00%|        except Exception as e:
   598|         0|            0|            0|  0.00%|            # since 3.12 the line "Error calling __set_name__ on '_proto_member' instance ..."
   599|         0|            0|            0|  0.00%|            # is tacked on to the error instead of raising a RuntimeError
   600|         0|            0|            0|  0.00%|            # recreate the exception to discard
   601|         0|            0|            0|  0.00%|            exc = type(e)(str(e))
   602|         0|            0|            0|  0.00%|            exc.__cause__ = e.__cause__
   603|         0|            0|            0|  0.00%|            exc.__context__ = e.__context__
   604|         0|            0|            0|  0.00%|            tb = e.__traceback__
   605|         0|            0|            0|  0.00%|        if exc is not None:
   606|         0|            0|            0|  0.00%|            raise exc.with_traceback(tb)
   607|         0|            0|            0|  0.00%|        #
   608|         0|            0|            0|  0.00%|        # update classdict with any changes made by __init_subclass__
   609|         0|            0|            0|  0.00%|        classdict.update(enum_class.__dict__)
   610|         0|            0|            0|  0.00%|        #
   611|         0|            0|            0|  0.00%|        # double check that repr and friends are not the mixin's or various
   612|         0|            0|            0|  0.00%|        # things break (such as pickle)
   613|         0|            0|            0|  0.00%|        # however, if the method is defined in the Enum itself, don't replace
   614|         0|            0|            0|  0.00%|        # it
   615|         0|            0|            0|  0.00%|        #
   616|         0|            0|            0|  0.00%|        # Also, special handling for ReprEnum
   617|         0|            0|            0|  0.00%|        if ReprEnum is not None and ReprEnum in bases:
   618|         0|            0|            0|  0.00%|            if member_type is object:
   619|         0|            0|            0|  0.00%|                raise TypeError(
   620|         0|            0|            0|  0.00%|                        'ReprEnum subclasses must be mixed with a data type (i.e.'
   621|         0|            0|            0|  0.00%|                        ' int, str, float, etc.)'
   622|         0|            0|            0|  0.00%|                        )
   623|         0|            0|            0|  0.00%|            if '__format__' not in classdict:
   624|         0|            0|            0|  0.00%|                enum_class.__format__ = member_type.__format__
   625|         0|            0|            0|  0.00%|                classdict['__format__'] = enum_class.__format__
   626|         0|            0|            0|  0.00%|            if '__str__' not in classdict:
   627|         0|            0|            0|  0.00%|                method = member_type.__str__
   628|         0|            0|            0|  0.00%|                if method is object.__str__:
   629|         0|            0|            0|  0.00%|                    # if member_type does not define __str__, object.__str__ will use
   630|         0|            0|            0|  0.00%|                    # its __repr__ instead, so we'll also use its __repr__
   631|         0|            0|            0|  0.00%|                    method = member_type.__repr__
   632|         0|            0|            0|  0.00%|                enum_class.__str__ = method
   633|         0|            0|            0|  0.00%|                classdict['__str__'] = enum_class.__str__
   634|         0|            0|            0|  0.00%|        for name in ('__repr__', '__str__', '__format__', '__reduce_ex__'):
   635|         0|            0|            0|  0.00%|            if name not in classdict:
   636|         0|            0|            0|  0.00%|                # check for mixin overrides before replacing
   637|         0|            0|            0|  0.00%|                enum_method = getattr(first_enum, name)
   638|         0|            0|            0|  0.00%|                found_method = getattr(enum_class, name)
   639|         0|            0|            0|  0.00%|                object_method = getattr(object, name)
   640|         0|            0|            0|  0.00%|                data_type_method = getattr(member_type, name)
   641|         0|            0|            0|  0.00%|                if found_method in (data_type_method, object_method):
   642|         0|            0|            0|  0.00%|                    setattr(enum_class, name, enum_method)
   643|         0|            0|            0|  0.00%|        #
   644|         0|            0|            0|  0.00%|        # for Flag, add __or__, __and__, __xor__, and __invert__
   645|         0|            0|            0|  0.00%|        if Flag is not None and issubclass(enum_class, Flag):
   646|         0|            0|            0|  0.00%|            for name in (
   647|         0|            0|            0|  0.00%|                    '__or__', '__and__', '__xor__',
   648|         0|            0|            0|  0.00%|                    '__ror__', '__rand__', '__rxor__',
   649|         0|            0|            0|  0.00%|                    '__invert__'
   650|         0|            0|            0|  0.00%|                ):
   651|         0|            0|            0|  0.00%|                if name not in classdict:
   652|         0|            0|            0|  0.00%|                    enum_method = getattr(Flag, name)
   653|         0|            0|            0|  0.00%|                    setattr(enum_class, name, enum_method)
   654|         0|            0|            0|  0.00%|                    classdict[name] = enum_method
   655|         0|            0|            0|  0.00%|        #
   656|         0|            0|            0|  0.00%|        # replace any other __new__ with our own (as long as Enum is not None,
   657|         0|            0|            0|  0.00%|        # anyway) -- again, this is to support pickle
   658|         0|            0|            0|  0.00%|        if Enum is not None:
   659|         0|            0|            0|  0.00%|            # if the user defined their own __new__, save it before it gets
   660|         0|            0|            0|  0.00%|            # clobbered in case they subclass later
   661|         0|            0|            0|  0.00%|            if save_new:
   662|         0|            0|            0|  0.00%|                enum_class.__new_member__ = __new__
   663|         0|            0|            0|  0.00%|            enum_class.__new__ = Enum.__new__
   664|         0|            0|            0|  0.00%|        #
   665|         0|            0|            0|  0.00%|        # py3 support for definition order (helps keep py2/py3 code in sync)
   666|         0|            0|            0|  0.00%|        #
   667|         0|            0|            0|  0.00%|        # _order_ checking is spread out into three/four steps
   668|         0|            0|            0|  0.00%|        # - if enum_class is a Flag:
   669|         0|            0|            0|  0.00%|        #   - remove any non-single-bit flags from _order_
   670|         0|            0|            0|  0.00%|        # - remove any aliases from _order_
   671|         0|            0|            0|  0.00%|        # - check that _order_ and _member_names_ match
   672|         0|            0|            0|  0.00%|        #
   673|         0|            0|            0|  0.00%|        # step 1: ensure we have a list
   674|         0|            0|            0|  0.00%|        if _order_ is not None:
   675|         0|            0|            0|  0.00%|            if isinstance(_order_, str):
   676|         0|            0|            0|  0.00%|                _order_ = _order_.replace(',', ' ').split()
   677|         0|            0|            0|  0.00%|        #
   678|         0|            0|            0|  0.00%|        # remove Flag structures if final class is not a Flag
   679|         0|            0|            0|  0.00%|        if (
   680|         0|            0|            0|  0.00%|                Flag is None and cls != 'Flag'
   681|         0|            0|            0|  0.00%|                or Flag is not None and not issubclass(enum_class, Flag)
   682|         0|            0|            0|  0.00%|            ):
   683|         0|            0|            0|  0.00%|            delattr(enum_class, '_boundary_')
   684|         0|            0|            0|  0.00%|            delattr(enum_class, '_flag_mask_')
   685|         0|            0|            0|  0.00%|            delattr(enum_class, '_singles_mask_')
   686|         0|            0|            0|  0.00%|            delattr(enum_class, '_all_bits_')
   687|         0|            0|            0|  0.00%|            delattr(enum_class, '_inverted_')
   688|         0|            0|            0|  0.00%|        elif Flag is not None and issubclass(enum_class, Flag):
   689|         0|            0|            0|  0.00%|            # set correct __iter__
   690|         0|            0|            0|  0.00%|            member_list = [m._value_ for m in enum_class]
   691|         0|            0|            0|  0.00%|            if member_list != sorted(member_list):
   692|         0|            0|            0|  0.00%|                enum_class._iter_member_ = enum_class._iter_member_by_def_
   693|         0|            0|            0|  0.00%|            if _order_:
   694|         0|            0|            0|  0.00%|                # _order_ step 2: remove any items from _order_ that are not single-bit
   695|         0|            0|            0|  0.00%|                _order_ = [
   696|         0|            0|            0|  0.00%|                        o
   697|         0|            0|            0|  0.00%|                        for o in _order_
   698|         0|            0|            0|  0.00%|                        if o not in enum_class._member_map_ or _is_single_bit(enum_class[o]._value_)
   699|         0|            0|            0|  0.00%|                        ]
   700|         0|            0|            0|  0.00%|        #
   701|         0|            0|            0|  0.00%|        if _order_:
   702|         0|            0|            0|  0.00%|            # _order_ step 3: remove aliases from _order_
   703|         0|            0|            0|  0.00%|            _order_ = [
   704|         0|            0|            0|  0.00%|                    o
   705|         0|            0|            0|  0.00%|                    for o in _order_
   706|         0|            0|            0|  0.00%|                    if (
   707|         0|            0|            0|  0.00%|                        o not in enum_class._member_map_
   708|         0|            0|            0|  0.00%|                        or
   709|         0|            0|            0|  0.00%|                        (o in enum_class._member_map_ and o in enum_class._member_names_)
   710|         0|            0|            0|  0.00%|                        )]
   711|         0|            0|            0|  0.00%|            # _order_ step 4: verify that _order_ and _member_names_ match
   712|         0|            0|            0|  0.00%|            if _order_ != enum_class._member_names_:
   713|         0|            0|            0|  0.00%|                raise TypeError(
   714|         0|            0|            0|  0.00%|                        'member order does not match _order_:\n  %r\n  %r'
   715|         0|            0|            0|  0.00%|                        % (enum_class._member_names_, _order_)
   716|         0|            0|            0|  0.00%|                        )
   717|         0|            0|            0|  0.00%|        #
   718|         0|            0|            0|  0.00%|        return enum_class
   719|         0|            0|            0|  0.00%|
   720|         0|            0|            0|  0.00%|    def __bool__(cls):
   721|         0|            0|            0|  0.00%|        """
   722|         0|            0|            0|  0.00%|        classes/types should always be True.
   723|         0|            0|            0|  0.00%|        """
   724|         0|            0|            0|  0.00%|        return True
   725|         0|            0|            0|  0.00%|
   726|         8|  2.19345e-05|  2.74181e-06|  0.02%|    def __call__(cls, value, names=_not_given, *values, module=None, qualname=None, type=None, start=1, boundary=None):
   727|         0|            0|            0|  0.00%|        """
   728|         0|            0|            0|  0.00%|        Either returns an existing member, or creates a new enum class.
   729|         0|            0|            0|  0.00%|
   730|         0|            0|            0|  0.00%|        This method is used both when an enum class is given a value to match
   731|         0|            0|            0|  0.00%|        to an enumeration member (i.e. Color(3)) and for the functional API
   732|         0|            0|            0|  0.00%|        (i.e. Color = Enum('Color', names='RED GREEN BLUE')).
   733|         0|            0|            0|  0.00%|
   734|         0|            0|            0|  0.00%|        The value lookup branch is chosen if the enum is final.
   735|         0|            0|            0|  0.00%|
   736|         0|            0|            0|  0.00%|        When used for the functional API:
   737|         0|            0|            0|  0.00%|
   738|         0|            0|            0|  0.00%|        `value` will be the name of the new class.
   739|         0|            0|            0|  0.00%|
   740|         0|            0|            0|  0.00%|        `names` should be either a string of white-space/comma delimited names
   741|         0|            0|            0|  0.00%|        (values will start at `start`), or an iterator/mapping of name, value pairs.
   742|         0|            0|            0|  0.00%|
   743|         0|            0|            0|  0.00%|        `module` should be set to the module this class is being created in;
   744|         0|            0|            0|  0.00%|        if it is not set, an attempt to find that module will be made, but if
   745|         0|            0|            0|  0.00%|        it fails the class will not be picklable.
   746|         0|            0|            0|  0.00%|
   747|         0|            0|            0|  0.00%|        `qualname` should be set to the actual location this class can be found
   748|         0|            0|            0|  0.00%|        at in its module; by default it is set to the global scope.  If this is
   749|         0|            0|            0|  0.00%|        not correct, unpickling will fail in some circumstances.
   750|         0|            0|            0|  0.00%|
   751|         0|            0|            0|  0.00%|        `type`, if set, will be mixed in as the first base class.
   752|         0|            0|            0|  0.00%|        """
   753|         8|  1.64509e-05|  2.05636e-06|  0.02%|        if cls._member_map_:
   754|         0|            0|            0|  0.00%|            # simple value lookup if members exist
   755|         8|  1.35899e-05|  1.69873e-06|  0.01%|            if names is not _not_given:
   756|         0|            0|            0|  0.00%|                value = (value, names) + values
   757|         8|  8.82149e-05|  1.10269e-05|  0.09%|            return cls.__new__(cls, value)
(call)|         8|  7.20024e-05|   9.0003e-06|  0.07%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/enum.py:1129 __new__
   758|         0|            0|            0|  0.00%|        # otherwise, functional API: we're creating a new Enum type
   759|         0|            0|            0|  0.00%|        if names is _not_given and type is None:
   760|         0|            0|            0|  0.00%|            # no body? no data-type? possibly wrong usage
   761|         0|            0|            0|  0.00%|            raise TypeError(
   762|         0|            0|            0|  0.00%|                    f"{cls} has no members; specify `names=()` if you meant to create a new, empty, enum"
   763|         0|            0|            0|  0.00%|                    )
   764|         0|            0|            0|  0.00%|        return cls._create_(
   765|         0|            0|            0|  0.00%|                class_name=value,
   766|         0|            0|            0|  0.00%|                names=None if names is _not_given else names,
   767|         0|            0|            0|  0.00%|                module=module,
   768|         0|            0|            0|  0.00%|                qualname=qualname,
   769|         0|            0|            0|  0.00%|                type=type,
   770|         0|            0|            0|  0.00%|                start=start,
   771|         0|            0|            0|  0.00%|                boundary=boundary,
   772|         0|            0|            0|  0.00%|                )
   773|         0|            0|            0|  0.00%|
   774|         0|            0|            0|  0.00%|    def __contains__(cls, value):
   775|         0|            0|            0|  0.00%|        """Return True if `value` is in `cls`.
   776|         0|            0|            0|  0.00%|
   777|         0|            0|            0|  0.00%|        `value` is in `cls` if:
   778|         0|            0|            0|  0.00%|        1) `value` is a member of `cls`, or
   779|         0|            0|            0|  0.00%|        2) `value` is the value of one of the `cls`'s members.
   780|         0|            0|            0|  0.00%|        """
   781|         0|            0|            0|  0.00%|        if isinstance(value, cls):
   782|         0|            0|            0|  0.00%|            return True
   783|         0|            0|            0|  0.00%|        return value in cls._value2member_map_ or value in cls._unhashable_values_
   784|         0|            0|            0|  0.00%|
   785|         0|            0|            0|  0.00%|    def __delattr__(cls, attr):
   786|         0|            0|            0|  0.00%|        # nicer error message when someone tries to delete an attribute
   787|         0|            0|            0|  0.00%|        # (see issue19025).
   788|         0|            0|            0|  0.00%|        if attr in cls._member_map_:
   789|         0|            0|            0|  0.00%|            raise AttributeError("%r cannot delete member %r." % (cls.__name__, attr))
   790|         0|            0|            0|  0.00%|        super().__delattr__(attr)
   791|         0|            0|            0|  0.00%|
   792|         0|            0|            0|  0.00%|    def __dir__(cls):
   793|         0|            0|            0|  0.00%|        interesting = set([
   794|         0|            0|            0|  0.00%|                '__class__', '__contains__', '__doc__', '__getitem__',
   795|         0|            0|            0|  0.00%|                '__iter__', '__len__', '__members__', '__module__',
   796|         0|            0|            0|  0.00%|                '__name__', '__qualname__',
   797|         0|            0|            0|  0.00%|                ]
   798|         0|            0|            0|  0.00%|                + cls._member_names_
   799|         0|            0|            0|  0.00%|                )
   800|         0|            0|            0|  0.00%|        if cls._new_member_ is not object.__new__:
   801|         0|            0|            0|  0.00%|            interesting.add('__new__')
   802|         0|            0|            0|  0.00%|        if cls.__init_subclass__ is not object.__init_subclass__:
   803|         0|            0|            0|  0.00%|            interesting.add('__init_subclass__')
   804|         0|            0|            0|  0.00%|        if cls._member_type_ is object:
   805|         0|            0|            0|  0.00%|            return sorted(interesting)
   806|         0|            0|            0|  0.00%|        else:
   807|         0|            0|            0|  0.00%|            # return whatever mixed-in data type has
   808|         0|            0|            0|  0.00%|            return sorted(set(dir(cls._member_type_)) | interesting)
   809|         0|            0|            0|  0.00%|
   810|         0|            0|            0|  0.00%|    def __getitem__(cls, name):
   811|         0|            0|            0|  0.00%|        """
   812|         0|            0|            0|  0.00%|        Return the member matching `name`.
   813|         0|            0|            0|  0.00%|        """
   814|         0|            0|            0|  0.00%|        return cls._member_map_[name]
   815|         0|            0|            0|  0.00%|
   816|         0|            0|            0|  0.00%|    def __iter__(cls):
   817|         0|            0|            0|  0.00%|        """
   818|         0|            0|            0|  0.00%|        Return members in definition order.
   819|         0|            0|            0|  0.00%|        """
   820|         0|            0|            0|  0.00%|        return (cls._member_map_[name] for name in cls._member_names_)
   821|         0|            0|            0|  0.00%|
   822|         0|            0|            0|  0.00%|    def __len__(cls):
   823|         0|            0|            0|  0.00%|        """
   824|         0|            0|            0|  0.00%|        Return the number of members (no aliases)
   825|         0|            0|            0|  0.00%|        """
   826|         0|            0|            0|  0.00%|        return len(cls._member_names_)
   827|         0|            0|            0|  0.00%|
   828|         0|            0|            0|  0.00%|    @bltns.property
   829|         0|            0|            0|  0.00%|    def __members__(cls):
   830|         0|            0|            0|  0.00%|        """
   831|         0|            0|            0|  0.00%|        Returns a mapping of member name->value.
   832|         0|            0|            0|  0.00%|
   833|         0|            0|            0|  0.00%|        This mapping lists all enum members, including aliases. Note that this
   834|         0|            0|            0|  0.00%|        is a read-only view of the internal mapping.
   835|         0|            0|            0|  0.00%|        """
   836|         0|            0|            0|  0.00%|        return MappingProxyType(cls._member_map_)
   837|         0|            0|            0|  0.00%|
   838|         0|            0|            0|  0.00%|    def __repr__(cls):
   839|         0|            0|            0|  0.00%|        if Flag is not None and issubclass(cls, Flag):
   840|         0|            0|            0|  0.00%|            return "<flag %r>" % cls.__name__
   841|         0|            0|            0|  0.00%|        else:
   842|         0|            0|            0|  0.00%|            return "<enum %r>" % cls.__name__
   843|         0|            0|            0|  0.00%|
   844|         0|            0|            0|  0.00%|    def __reversed__(cls):
   845|         0|            0|            0|  0.00%|        """
   846|         0|            0|            0|  0.00%|        Return members in reverse definition order.
   847|         0|            0|            0|  0.00%|        """
   848|         0|            0|            0|  0.00%|        return (cls._member_map_[name] for name in reversed(cls._member_names_))
   849|         0|            0|            0|  0.00%|
   850|         0|            0|            0|  0.00%|    def __setattr__(cls, name, value):
   851|         0|            0|            0|  0.00%|        """
   852|         0|            0|            0|  0.00%|        Block attempts to reassign Enum members.
   853|         0|            0|            0|  0.00%|
   854|         0|            0|            0|  0.00%|        A simple assignment to the class namespace only changes one of the
   855|         0|            0|            0|  0.00%|        several possible ways to get an Enum member from the Enum class,
   856|         0|            0|            0|  0.00%|        resulting in an inconsistent Enumeration.
   857|         0|            0|            0|  0.00%|        """
   858|         0|            0|            0|  0.00%|        member_map = cls.__dict__.get('_member_map_', {})
   859|         0|            0|            0|  0.00%|        if name in member_map:
   860|         0|            0|            0|  0.00%|            raise AttributeError('cannot reassign member %r' % (name, ))
   861|         0|            0|            0|  0.00%|        super().__setattr__(name, value)
   862|         0|            0|            0|  0.00%|
   863|         0|            0|            0|  0.00%|    def _create_(cls, class_name, names, *, module=None, qualname=None, type=None, start=1, boundary=None):
   864|         0|            0|            0|  0.00%|        """
   865|         0|            0|            0|  0.00%|        Convenience method to create a new Enum class.
   866|         0|            0|            0|  0.00%|
   867|         0|            0|            0|  0.00%|        `names` can be:
   868|         0|            0|            0|  0.00%|
   869|         0|            0|            0|  0.00%|        * A string containing member names, separated either with spaces or
   870|         0|            0|            0|  0.00%|          commas.  Values are incremented by 1 from `start`.
   871|         0|            0|            0|  0.00%|        * An iterable of member names.  Values are incremented by 1 from `start`.
   872|         0|            0|            0|  0.00%|        * An iterable of (member name, value) pairs.
   873|         0|            0|            0|  0.00%|        * A mapping of member name -> value pairs.
   874|         0|            0|            0|  0.00%|        """
   875|         0|            0|            0|  0.00%|        metacls = cls.__class__
   876|         0|            0|            0|  0.00%|        bases = (cls, ) if type is None else (type, cls)
   877|         0|            0|            0|  0.00%|        _, first_enum = cls._get_mixins_(class_name, bases)
   878|         0|            0|            0|  0.00%|        classdict = metacls.__prepare__(class_name, bases)
   879|         0|            0|            0|  0.00%|
   880|         0|            0|            0|  0.00%|        # special processing needed for names?
   881|         0|            0|            0|  0.00%|        if isinstance(names, str):
   882|         0|            0|            0|  0.00%|            names = names.replace(',', ' ').split()
   883|         0|            0|            0|  0.00%|        if isinstance(names, (tuple, list)) and names and isinstance(names[0], str):
   884|         0|            0|            0|  0.00%|            original_names, names = names, []
   885|         0|            0|            0|  0.00%|            last_values = []
   886|         0|            0|            0|  0.00%|            for count, name in enumerate(original_names):
   887|         0|            0|            0|  0.00%|                value = first_enum._generate_next_value_(name, start, count, last_values[:])
   888|         0|            0|            0|  0.00%|                last_values.append(value)
   889|         0|            0|            0|  0.00%|                names.append((name, value))
   890|         0|            0|            0|  0.00%|        if names is None:
   891|         0|            0|            0|  0.00%|            names = ()
   892|         0|            0|            0|  0.00%|
   893|         0|            0|            0|  0.00%|        # Here, names is either an iterable of (name, value) or a mapping.
   894|         0|            0|            0|  0.00%|        for item in names:
   895|         0|            0|            0|  0.00%|            if isinstance(item, str):
   896|         0|            0|            0|  0.00%|                member_name, member_value = item, names[item]
   897|         0|            0|            0|  0.00%|            else:
   898|         0|            0|            0|  0.00%|                member_name, member_value = item
   899|         0|            0|            0|  0.00%|            classdict[member_name] = member_value
   900|         0|            0|            0|  0.00%|
   901|         0|            0|            0|  0.00%|        if module is None:
   902|         0|            0|            0|  0.00%|            try:
   903|         0|            0|            0|  0.00%|                module = sys._getframemodulename(2)
   904|         0|            0|            0|  0.00%|            except AttributeError:
   905|         0|            0|            0|  0.00%|                # Fall back on _getframe if _getframemodulename is missing
   906|         0|            0|            0|  0.00%|                try:
   907|         0|            0|            0|  0.00%|                    module = sys._getframe(2).f_globals['__name__']
   908|         0|            0|            0|  0.00%|                except (AttributeError, ValueError, KeyError):
   909|         0|            0|            0|  0.00%|                    pass
   910|         0|            0|            0|  0.00%|        if module is None:
   911|         0|            0|            0|  0.00%|            _make_class_unpicklable(classdict)
   912|         0|            0|            0|  0.00%|        else:
   913|         0|            0|            0|  0.00%|            classdict['__module__'] = module
   914|         0|            0|            0|  0.00%|        if qualname is not None:
   915|         0|            0|            0|  0.00%|            classdict['__qualname__'] = qualname
   916|         0|            0|            0|  0.00%|
   917|         0|            0|            0|  0.00%|        return metacls.__new__(metacls, class_name, bases, classdict, boundary=boundary)
   918|         0|            0|            0|  0.00%|
   919|         0|            0|            0|  0.00%|    def _convert_(cls, name, module, filter, source=None, *, boundary=None, as_global=False):
   920|         0|            0|            0|  0.00%|        """
   921|         0|            0|            0|  0.00%|        Create a new Enum subclass that replaces a collection of global constants
   922|         0|            0|            0|  0.00%|        """
   923|         0|            0|            0|  0.00%|        # convert all constants from source (or module) that pass filter() to
   924|         0|            0|            0|  0.00%|        # a new Enum called name, and export the enum and its members back to
   925|         0|            0|            0|  0.00%|        # module;
   926|         0|            0|            0|  0.00%|        # also, replace the __reduce_ex__ method so unpickling works in
   927|         0|            0|            0|  0.00%|        # previous Python versions
   928|         0|            0|            0|  0.00%|        module_globals = sys.modules[module].__dict__
   929|         0|            0|            0|  0.00%|        if source:
   930|         0|            0|            0|  0.00%|            source = source.__dict__
   931|         0|            0|            0|  0.00%|        else:
   932|         0|            0|            0|  0.00%|            source = module_globals
   933|         0|            0|            0|  0.00%|        # _value2member_map_ is populated in the same order every time
   934|         0|            0|            0|  0.00%|        # for a consistent reverse mapping of number to name when there
   935|         0|            0|            0|  0.00%|        # are multiple names for the same number.
   936|         0|            0|            0|  0.00%|        members = [
   937|         0|            0|            0|  0.00%|                (name, value)
   938|         0|            0|            0|  0.00%|                for name, value in source.items()
   939|         0|            0|            0|  0.00%|                if filter(name)]
   940|         0|            0|            0|  0.00%|        try:
   941|         0|            0|            0|  0.00%|            # sort by value
   942|         0|            0|            0|  0.00%|            members.sort(key=lambda t: (t[1], t[0]))
   943|         0|            0|            0|  0.00%|        except TypeError:
   944|         0|            0|            0|  0.00%|            # unless some values aren't comparable, in which case sort by name
   945|         0|            0|            0|  0.00%|            members.sort(key=lambda t: t[0])
   946|         0|            0|            0|  0.00%|        body = {t[0]: t[1] for t in members}
   947|         0|            0|            0|  0.00%|        body['__module__'] = module
   948|         0|            0|            0|  0.00%|        tmp_cls = type(name, (object, ), body)
   949|         0|            0|            0|  0.00%|        cls = _simple_enum(etype=cls, boundary=boundary or KEEP)(tmp_cls)
   950|         0|            0|            0|  0.00%|        if as_global:
   951|         0|            0|            0|  0.00%|            global_enum(cls)
   952|         0|            0|            0|  0.00%|        else:
   953|         0|            0|            0|  0.00%|            sys.modules[cls.__module__].__dict__.update(cls.__members__)
   954|         0|            0|            0|  0.00%|        module_globals[name] = cls
   955|         0|            0|            0|  0.00%|        return cls
   956|         0|            0|            0|  0.00%|
   957|         0|            0|            0|  0.00%|    @classmethod
   958|         0|            0|            0|  0.00%|    def _check_for_existing_members_(mcls, class_name, bases):
   959|         0|            0|            0|  0.00%|        for chain in bases:
   960|         0|            0|            0|  0.00%|            for base in chain.__mro__:
   961|         0|            0|            0|  0.00%|                if isinstance(base, EnumType) and base._member_names_:
   962|         0|            0|            0|  0.00%|                    raise TypeError(
   963|         0|            0|            0|  0.00%|                            "<enum %r> cannot extend %r"
   964|         0|            0|            0|  0.00%|                            % (class_name, base)
   965|         0|            0|            0|  0.00%|                            )
   966|         0|            0|            0|  0.00%|
   967|         0|            0|            0|  0.00%|    @classmethod
   968|         0|            0|            0|  0.00%|    def _get_mixins_(mcls, class_name, bases):
   969|         0|            0|            0|  0.00%|        """
   970|         0|            0|            0|  0.00%|        Returns the type for creating enum members, and the first inherited
   971|         0|            0|            0|  0.00%|        enum class.
   972|         0|            0|            0|  0.00%|
   973|         0|            0|            0|  0.00%|        bases: the tuple of bases that was given to __new__
   974|         0|            0|            0|  0.00%|        """
   975|         0|            0|            0|  0.00%|        if not bases:
   976|         0|            0|            0|  0.00%|            return object, Enum
   977|         0|            0|            0|  0.00%|        # ensure final parent class is an Enum derivative, find any concrete
   978|         0|            0|            0|  0.00%|        # data type, and check that Enum has no members
   979|         0|            0|            0|  0.00%|        first_enum = bases[-1]
   980|         0|            0|            0|  0.00%|        if not isinstance(first_enum, EnumType):
   981|         0|            0|            0|  0.00%|            raise TypeError("new enumerations should be created as "
   982|         0|            0|            0|  0.00%|                    "`EnumName([mixin_type, ...] [data_type,] enum_type)`")
   983|         0|            0|            0|  0.00%|        member_type = mcls._find_data_type_(class_name, bases) or object
   984|         0|            0|            0|  0.00%|        return member_type, first_enum
   985|         0|            0|            0|  0.00%|
   986|         0|            0|            0|  0.00%|    @classmethod
   987|         0|            0|            0|  0.00%|    def _find_data_repr_(mcls, class_name, bases):
   988|         0|            0|            0|  0.00%|        for chain in bases:
   989|         0|            0|            0|  0.00%|            for base in chain.__mro__:
   990|         0|            0|            0|  0.00%|                if base is object:
   991|         0|            0|            0|  0.00%|                    continue
   992|         0|            0|            0|  0.00%|                elif isinstance(base, EnumType):
   993|         0|            0|            0|  0.00%|                    # if we hit an Enum, use it's _value_repr_
   994|         0|            0|            0|  0.00%|                    return base._value_repr_
   995|         0|            0|            0|  0.00%|                elif '__repr__' in base.__dict__:
   996|         0|            0|            0|  0.00%|                    # this is our data repr
   997|         0|            0|            0|  0.00%|                    # double-check if a dataclass with a default __repr__
   998|         0|            0|            0|  0.00%|                    if (
   999|         0|            0|            0|  0.00%|                            '__dataclass_fields__' in base.__dict__
  1000|         0|            0|            0|  0.00%|                            and '__dataclass_params__' in base.__dict__
  1001|         0|            0|            0|  0.00%|                            and base.__dict__['__dataclass_params__'].repr
  1002|         0|            0|            0|  0.00%|                        ):
  1003|         0|            0|            0|  0.00%|                        return _dataclass_repr
  1004|         0|            0|            0|  0.00%|                    else:
  1005|         0|            0|            0|  0.00%|                        return base.__dict__['__repr__']
  1006|         0|            0|            0|  0.00%|        return None
  1007|         0|            0|            0|  0.00%|
  1008|         0|            0|            0|  0.00%|    @classmethod
  1009|         0|            0|            0|  0.00%|    def _find_data_type_(mcls, class_name, bases):
  1010|         0|            0|            0|  0.00%|        # a datatype has a __new__ method, or a __dataclass_fields__ attribute
  1011|         0|            0|            0|  0.00%|        data_types = set()
  1012|         0|            0|            0|  0.00%|        base_chain = set()
  1013|         0|            0|            0|  0.00%|        for chain in bases:
  1014|         0|            0|            0|  0.00%|            candidate = None
  1015|         0|            0|            0|  0.00%|            for base in chain.__mro__:
  1016|         0|            0|            0|  0.00%|                base_chain.add(base)
  1017|         0|            0|            0|  0.00%|                if base is object:
  1018|         0|            0|            0|  0.00%|                    continue
  1019|         0|            0|            0|  0.00%|                elif isinstance(base, EnumType):
  1020|         0|            0|            0|  0.00%|                    if base._member_type_ is not object:
  1021|         0|            0|            0|  0.00%|                        data_types.add(base._member_type_)
  1022|         0|            0|            0|  0.00%|                        break
  1023|         0|            0|            0|  0.00%|                elif '__new__' in base.__dict__ or '__dataclass_fields__' in base.__dict__:
  1024|         0|            0|            0|  0.00%|                    data_types.add(candidate or base)
  1025|         0|            0|            0|  0.00%|                    break
  1026|         0|            0|            0|  0.00%|                else:
  1027|         0|            0|            0|  0.00%|                    candidate = candidate or base
  1028|         0|            0|            0|  0.00%|        if len(data_types) > 1:
  1029|         0|            0|            0|  0.00%|            raise TypeError('too many data types for %r: %r' % (class_name, data_types))
  1030|         0|            0|            0|  0.00%|        elif data_types:
  1031|         0|            0|            0|  0.00%|            return data_types.pop()
  1032|         0|            0|            0|  0.00%|        else:
  1033|         0|            0|            0|  0.00%|            return None
  1034|         0|            0|            0|  0.00%|
  1035|         0|            0|            0|  0.00%|    @classmethod
  1036|         0|            0|            0|  0.00%|    def _find_new_(mcls, classdict, member_type, first_enum):
  1037|         0|            0|            0|  0.00%|        """
  1038|         0|            0|            0|  0.00%|        Returns the __new__ to be used for creating the enum members.
  1039|         0|            0|            0|  0.00%|
  1040|         0|            0|            0|  0.00%|        classdict: the class dictionary given to __new__
  1041|         0|            0|            0|  0.00%|        member_type: the data type whose __new__ will be used by default
  1042|         0|            0|            0|  0.00%|        first_enum: enumeration to check for an overriding __new__
  1043|         0|            0|            0|  0.00%|        """
  1044|         0|            0|            0|  0.00%|        # now find the correct __new__, checking to see of one was defined
  1045|         0|            0|            0|  0.00%|        # by the user; also check earlier enum classes in case a __new__ was
  1046|         0|            0|            0|  0.00%|        # saved as __new_member__
  1047|         0|            0|            0|  0.00%|        __new__ = classdict.get('__new__', None)
  1048|         0|            0|            0|  0.00%|
  1049|         0|            0|            0|  0.00%|        # should __new__ be saved as __new_member__ later?
  1050|         0|            0|            0|  0.00%|        save_new = first_enum is not None and __new__ is not None
  1051|         0|            0|            0|  0.00%|
  1052|         0|            0|            0|  0.00%|        if __new__ is None:
  1053|         0|            0|            0|  0.00%|            # check all possibles for __new_member__ before falling back to
  1054|         0|            0|            0|  0.00%|            # __new__
  1055|         0|            0|            0|  0.00%|            for method in ('__new_member__', '__new__'):
  1056|         0|            0|            0|  0.00%|                for possible in (member_type, first_enum):
  1057|         0|            0|            0|  0.00%|                    target = getattr(possible, method, None)
  1058|         0|            0|            0|  0.00%|                    if target not in {
  1059|         0|            0|            0|  0.00%|                            None,
  1060|         0|            0|            0|  0.00%|                            None.__new__,
  1061|         0|            0|            0|  0.00%|                            object.__new__,
  1062|         0|            0|            0|  0.00%|                            Enum.__new__,
  1063|         0|            0|            0|  0.00%|                            }:
  1064|         0|            0|            0|  0.00%|                        __new__ = target
  1065|         0|            0|            0|  0.00%|                        break
  1066|         0|            0|            0|  0.00%|                if __new__ is not None:
  1067|         0|            0|            0|  0.00%|                    break
  1068|         0|            0|            0|  0.00%|            else:
  1069|         0|            0|            0|  0.00%|                __new__ = object.__new__
  1070|         0|            0|            0|  0.00%|
  1071|         0|            0|            0|  0.00%|        # if a non-object.__new__ is used then whatever value/tuple was
  1072|         0|            0|            0|  0.00%|        # assigned to the enum member name will be passed to __new__ and to the
  1073|         0|            0|            0|  0.00%|        # new enum member's __init__
  1074|         0|            0|            0|  0.00%|        if first_enum is None or __new__ in (Enum.__new__, object.__new__):
  1075|         0|            0|            0|  0.00%|            use_args = False
  1076|         0|            0|            0|  0.00%|        else:
  1077|         0|            0|            0|  0.00%|            use_args = True
  1078|         0|            0|            0|  0.00%|        return __new__, save_new, use_args
  1079|         0|            0|            0|  0.00%|EnumMeta = EnumType
  1080|         0|            0|            0|  0.00%|
  1081|         0|            0|            0|  0.00%|
  1082|         0|            0|            0|  0.00%|class Enum(metaclass=EnumType):
  1083|         0|            0|            0|  0.00%|    """
  1084|         0|            0|            0|  0.00%|    Create a collection of name/value pairs.
  1085|         0|            0|            0|  0.00%|
  1086|         0|            0|            0|  0.00%|    Example enumeration:
  1087|         0|            0|            0|  0.00%|
  1088|         0|            0|            0|  0.00%|    >>> class Color(Enum):
  1089|         0|            0|            0|  0.00%|    ...     RED = 1
  1090|         0|            0|            0|  0.00%|    ...     BLUE = 2
  1091|         0|            0|            0|  0.00%|    ...     GREEN = 3
  1092|         0|            0|            0|  0.00%|
  1093|         0|            0|            0|  0.00%|    Access them by:
  1094|         0|            0|            0|  0.00%|
  1095|         0|            0|            0|  0.00%|    - attribute access:
  1096|         0|            0|            0|  0.00%|
  1097|         0|            0|            0|  0.00%|      >>> Color.RED
  1098|         0|            0|            0|  0.00%|      <Color.RED: 1>
  1099|         0|            0|            0|  0.00%|
  1100|         0|            0|            0|  0.00%|    - value lookup:
  1101|         0|            0|            0|  0.00%|
  1102|         0|            0|            0|  0.00%|      >>> Color(1)
  1103|         0|            0|            0|  0.00%|      <Color.RED: 1>
  1104|         0|            0|            0|  0.00%|
  1105|         0|            0|            0|  0.00%|    - name lookup:
  1106|         0|            0|            0|  0.00%|
  1107|         0|            0|            0|  0.00%|      >>> Color['RED']
  1108|         0|            0|            0|  0.00%|      <Color.RED: 1>
  1109|         0|            0|            0|  0.00%|
  1110|         0|            0|            0|  0.00%|    Enumerations can be iterated over, and know how many members they have:
  1111|         0|            0|            0|  0.00%|
  1112|         0|            0|            0|  0.00%|    >>> len(Color)
  1113|         0|            0|            0|  0.00%|    3
  1114|         0|            0|            0|  0.00%|
  1115|         0|            0|            0|  0.00%|    >>> list(Color)
  1116|         0|            0|            0|  0.00%|    [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]
  1117|         0|            0|            0|  0.00%|
  1118|         0|            0|            0|  0.00%|    Methods can be added to enumerations, and members can have their own
  1119|         0|            0|            0|  0.00%|    attributes -- see the documentation for details.
  1120|         0|            0|            0|  0.00%|    """
  1121|         0|            0|            0|  0.00%|
  1122|         0|            0|            0|  0.00%|    @classmethod
  1123|         0|            0|            0|  0.00%|    def __signature__(cls):
  1124|         0|            0|            0|  0.00%|        if cls._member_names_:
  1125|         0|            0|            0|  0.00%|            return '(*values)'
  1126|         0|            0|            0|  0.00%|        else:
  1127|         0|            0|            0|  0.00%|            return '(new_class_name, /, names, *, module=None, qualname=None, type=None, start=1, boundary=None)'
  1128|         0|            0|            0|  0.00%|
  1129|         8|   2.7895e-05|  3.48687e-06|  0.03%|    def __new__(cls, value):
  1130|         0|            0|            0|  0.00%|        # all enum instances are actually created during class construction
  1131|         0|            0|            0|  0.00%|        # without calling this method; this method is called by the metaclass'
  1132|         0|            0|            0|  0.00%|        # __call__ (i.e. Color(3) ), and by pickle
  1133|         8|   2.0504e-05|    2.563e-06|  0.02%|        if type(value) is cls:
  1134|         0|            0|            0|  0.00%|            # For lookups like Color(Color.RED)
  1135|         6|  1.23978e-05|  2.06629e-06|  0.01%|            return value
  1136|         0|            0|            0|  0.00%|        # by-value search for a matching enum member
  1137|         0|            0|            0|  0.00%|        # see if it's in the reverse mapping (for hashable values)
  1138|         2|  5.48363e-06|  2.74181e-06|  0.01%|        try:
  1139|         2|  5.72205e-06|  2.86102e-06|  0.01%|            return cls._value2member_map_[value]
  1140|         0|            0|            0|  0.00%|        except KeyError:
  1141|         0|            0|            0|  0.00%|            # Not found, no need to do long O(n) search
  1142|         0|            0|            0|  0.00%|            pass
  1143|         0|            0|            0|  0.00%|        except TypeError:
  1144|         0|            0|            0|  0.00%|            # not there, now do long search -- O(n) behavior
  1145|         0|            0|            0|  0.00%|            for member in cls._member_map_.values():
  1146|         0|            0|            0|  0.00%|                if member._value_ == value:
  1147|         0|            0|            0|  0.00%|                    return member
  1148|         0|            0|            0|  0.00%|        # still not found -- verify that members exist, in-case somebody got here mistakenly
  1149|         0|            0|            0|  0.00%|        # (such as via super when trying to override __new__)
  1150|         0|            0|            0|  0.00%|        if not cls._member_map_:
  1151|         0|            0|            0|  0.00%|            raise TypeError("%r has no members defined" % cls)
  1152|         0|            0|            0|  0.00%|        #
  1153|         0|            0|            0|  0.00%|        # still not found -- try _missing_ hook
  1154|         0|            0|            0|  0.00%|        try:
  1155|         0|            0|            0|  0.00%|            exc = None
  1156|         0|            0|            0|  0.00%|            result = cls._missing_(value)
  1157|         0|            0|            0|  0.00%|        except Exception as e:
  1158|         0|            0|            0|  0.00%|            exc = e
  1159|         0|            0|            0|  0.00%|            result = None
  1160|         0|            0|            0|  0.00%|        try:
  1161|         0|            0|            0|  0.00%|            if isinstance(result, cls):
  1162|         0|            0|            0|  0.00%|                return result
  1163|         0|            0|            0|  0.00%|            elif (
  1164|         0|            0|            0|  0.00%|                    Flag is not None and issubclass(cls, Flag)
  1165|         0|            0|            0|  0.00%|                    and cls._boundary_ is EJECT and isinstance(result, int)
  1166|         0|            0|            0|  0.00%|                ):
  1167|         0|            0|            0|  0.00%|                return result
  1168|         0|            0|            0|  0.00%|            else:
  1169|         0|            0|            0|  0.00%|                ve_exc = ValueError("%r is not a valid %s" % (value, cls.__qualname__))
  1170|         0|            0|            0|  0.00%|                if result is None and exc is None:
  1171|         0|            0|            0|  0.00%|                    raise ve_exc
  1172|         0|            0|            0|  0.00%|                elif exc is None:
  1173|         0|            0|            0|  0.00%|                    exc = TypeError(
  1174|         0|            0|            0|  0.00%|                            'error in %s._missing_: returned %r instead of None or a valid member'
  1175|         0|            0|            0|  0.00%|                            % (cls.__name__, result)
  1176|         0|            0|            0|  0.00%|                            )
  1177|         0|            0|            0|  0.00%|                if not isinstance(exc, ValueError):
  1178|         0|            0|            0|  0.00%|                    exc.__context__ = ve_exc
  1179|         0|            0|            0|  0.00%|                raise exc
  1180|         0|            0|            0|  0.00%|        finally:
  1181|         0|            0|            0|  0.00%|            # ensure all variables that could hold an exception are destroyed
  1182|         0|            0|            0|  0.00%|            exc = None
  1183|         0|            0|            0|  0.00%|            ve_exc = None
  1184|         0|            0|            0|  0.00%|
  1185|         0|            0|            0|  0.00%|    def __init__(self, *args, **kwds):
  1186|         0|            0|            0|  0.00%|        pass
  1187|         0|            0|            0|  0.00%|
  1188|         0|            0|            0|  0.00%|    @staticmethod
  1189|         0|            0|            0|  0.00%|    def _generate_next_value_(name, start, count, last_values):
  1190|         0|            0|            0|  0.00%|        """
  1191|         0|            0|            0|  0.00%|        Generate the next value when not given.
  1192|         0|            0|            0|  0.00%|
  1193|         0|            0|            0|  0.00%|        name: the name of the member
  1194|         0|            0|            0|  0.00%|        start: the initial start value or None
  1195|         0|            0|            0|  0.00%|        count: the number of existing members
  1196|         0|            0|            0|  0.00%|        last_values: the list of values assigned
  1197|         0|            0|            0|  0.00%|        """
  1198|         0|            0|            0|  0.00%|        if not last_values:
  1199|         0|            0|            0|  0.00%|            return start
  1200|         0|            0|            0|  0.00%|        try:
  1201|         0|            0|            0|  0.00%|            last = last_values[-1]
  1202|         0|            0|            0|  0.00%|            last_values.sort()
  1203|         0|            0|            0|  0.00%|            if last == last_values[-1]:
  1204|         0|            0|            0|  0.00%|                # no difference between old and new methods
  1205|         0|            0|            0|  0.00%|                return last + 1
  1206|         0|            0|            0|  0.00%|            else:
  1207|         0|            0|            0|  0.00%|                # trigger old method (with warning)
  1208|         0|            0|            0|  0.00%|                raise TypeError
  1209|         0|            0|            0|  0.00%|        except TypeError:
  1210|         0|            0|            0|  0.00%|            import warnings
  1211|         0|            0|            0|  0.00%|            warnings.warn(
  1212|         0|            0|            0|  0.00%|                    "In 3.13 the default `auto()`/`_generate_next_value_` will require all values to be sortable and support adding +1\n"
  1213|         0|            0|            0|  0.00%|                    "and the value returned will be the largest value in the enum incremented by 1",
  1214|         0|            0|            0|  0.00%|                    DeprecationWarning,
  1215|         0|            0|            0|  0.00%|                    stacklevel=3,
  1216|         0|            0|            0|  0.00%|                    )
  1217|         0|            0|            0|  0.00%|            for v in reversed(last_values):
  1218|         0|            0|            0|  0.00%|                try:
  1219|         0|            0|            0|  0.00%|                    return v + 1
  1220|         0|            0|            0|  0.00%|                except TypeError:
  1221|         0|            0|            0|  0.00%|                    pass
  1222|         0|            0|            0|  0.00%|            return start
  1223|         0|            0|            0|  0.00%|
  1224|         0|            0|            0|  0.00%|    @classmethod
  1225|         0|            0|            0|  0.00%|    def _missing_(cls, value):
  1226|         0|            0|            0|  0.00%|        return None
  1227|         0|            0|            0|  0.00%|
  1228|         0|            0|            0|  0.00%|    def __repr__(self):
  1229|         0|            0|            0|  0.00%|        v_repr = self.__class__._value_repr_ or repr
  1230|         0|            0|            0|  0.00%|        return "<%s.%s: %s>" % (self.__class__.__name__, self._name_, v_repr(self._value_))
  1231|         0|            0|            0|  0.00%|
  1232|         0|            0|            0|  0.00%|    def __str__(self):
  1233|         0|            0|            0|  0.00%|        return "%s.%s" % (self.__class__.__name__, self._name_, )
  1234|         0|            0|            0|  0.00%|
  1235|         0|            0|            0|  0.00%|    def __dir__(self):
  1236|         0|            0|            0|  0.00%|        """
  1237|         0|            0|            0|  0.00%|        Returns public methods and other interesting attributes.
  1238|         0|            0|            0|  0.00%|        """
  1239|         0|            0|            0|  0.00%|        interesting = set()
  1240|         0|            0|            0|  0.00%|        if self.__class__._member_type_ is not object:
  1241|         0|            0|            0|  0.00%|            interesting = set(object.__dir__(self))
  1242|         0|            0|            0|  0.00%|        for name in getattr(self, '__dict__', []):
  1243|         0|            0|            0|  0.00%|            if name[0] != '_' and name not in self._member_map_:
  1244|         0|            0|            0|  0.00%|                interesting.add(name)
  1245|         0|            0|            0|  0.00%|        for cls in self.__class__.mro():
  1246|         0|            0|            0|  0.00%|            for name, obj in cls.__dict__.items():
  1247|         0|            0|            0|  0.00%|                if name[0] == '_':
  1248|         0|            0|            0|  0.00%|                    continue
  1249|         0|            0|            0|  0.00%|                if isinstance(obj, property):
  1250|         0|            0|            0|  0.00%|                    # that's an enum.property
  1251|         0|            0|            0|  0.00%|                    if obj.fget is not None or name not in self._member_map_:
  1252|         0|            0|            0|  0.00%|                        interesting.add(name)
  1253|         0|            0|            0|  0.00%|                    else:
  1254|         0|            0|            0|  0.00%|                        # in case it was added by `dir(self)`
  1255|         0|            0|            0|  0.00%|                        interesting.discard(name)
  1256|         0|            0|            0|  0.00%|                elif name not in self._member_map_:
  1257|         0|            0|            0|  0.00%|                    interesting.add(name)
  1258|         0|            0|            0|  0.00%|        names = sorted(
  1259|         0|            0|            0|  0.00%|                set(['__class__', '__doc__', '__eq__', '__hash__', '__module__'])
  1260|         0|            0|            0|  0.00%|                | interesting
  1261|         0|            0|            0|  0.00%|                )
  1262|         0|            0|            0|  0.00%|        return names
  1263|         0|            0|            0|  0.00%|
  1264|         0|            0|            0|  0.00%|    def __format__(self, format_spec):
  1265|         0|            0|            0|  0.00%|        return str.__format__(str(self), format_spec)
  1266|         0|            0|            0|  0.00%|
  1267|         0|            0|            0|  0.00%|    def __hash__(self):
  1268|         0|            0|            0|  0.00%|        return hash(self._name_)
  1269|         0|            0|            0|  0.00%|
  1270|         0|            0|            0|  0.00%|    def __reduce_ex__(self, proto):
  1271|         0|            0|            0|  0.00%|        return self.__class__, (self._value_, )
  1272|         0|            0|            0|  0.00%|
  1273|         0|            0|            0|  0.00%|    def __deepcopy__(self,memo):
  1274|         0|            0|            0|  0.00%|        return self
  1275|         0|            0|            0|  0.00%|
  1276|         0|            0|            0|  0.00%|    def __copy__(self):
  1277|         0|            0|            0|  0.00%|        return self
  1278|         0|            0|            0|  0.00%|
  1279|         0|            0|            0|  0.00%|    # enum.property is used to provide access to the `name` and
  1280|         0|            0|            0|  0.00%|    # `value` attributes of enum members while keeping some measure of
  1281|         0|            0|            0|  0.00%|    # protection from modification, while still allowing for an enumeration
  1282|         0|            0|            0|  0.00%|    # to have members named `name` and `value`.  This works because each
  1283|         0|            0|            0|  0.00%|    # instance of enum.property saves its companion member, which it returns
  1284|         0|            0|            0|  0.00%|    # on class lookup; on instance lookup it either executes a provided function
  1285|         0|            0|            0|  0.00%|    # or raises an AttributeError.
  1286|         0|            0|            0|  0.00%|
  1287|         0|            0|            0|  0.00%|    @property
  1288|         0|            0|            0|  0.00%|    def name(self):
  1289|         0|            0|            0|  0.00%|        """The name of the Enum member."""
  1290|         0|            0|            0|  0.00%|        return self._name_
  1291|         0|            0|            0|  0.00%|
  1292|         0|            0|            0|  0.00%|    @property
  1293|         0|            0|            0|  0.00%|    def value(self):
  1294|         0|            0|            0|  0.00%|        """The value of the Enum member."""
  1295|         0|            0|            0|  0.00%|        return self._value_
  1296|         0|            0|            0|  0.00%|
  1297|         0|            0|            0|  0.00%|
  1298|         0|            0|            0|  0.00%|class ReprEnum(Enum):
  1299|         0|            0|            0|  0.00%|    """
  1300|         0|            0|            0|  0.00%|    Only changes the repr(), leaving str() and format() to the mixed-in type.
  1301|         0|            0|            0|  0.00%|    """
  1302|         0|            0|            0|  0.00%|
  1303|         0|            0|            0|  0.00%|
  1304|         0|            0|            0|  0.00%|class IntEnum(int, ReprEnum):
  1305|         0|            0|            0|  0.00%|    """
  1306|         0|            0|            0|  0.00%|    Enum where members are also (and must be) ints
  1307|         0|            0|            0|  0.00%|    """
  1308|         0|            0|            0|  0.00%|
  1309|         0|            0|            0|  0.00%|
  1310|         0|            0|            0|  0.00%|class StrEnum(str, ReprEnum):
  1311|         0|            0|            0|  0.00%|    """
  1312|         0|            0|            0|  0.00%|    Enum where members are also (and must be) strings
  1313|         0|            0|            0|  0.00%|    """
  1314|         0|            0|            0|  0.00%|
  1315|         0|            0|            0|  0.00%|    def __new__(cls, *values):
  1316|         0|            0|            0|  0.00%|        "values must already be of type `str`"
  1317|         0|            0|            0|  0.00%|        if len(values) > 3:
  1318|         0|            0|            0|  0.00%|            raise TypeError('too many arguments for str(): %r' % (values, ))
  1319|         0|            0|            0|  0.00%|        if len(values) == 1:
  1320|         0|            0|            0|  0.00%|            # it must be a string
  1321|         0|            0|            0|  0.00%|            if not isinstance(values[0], str):
  1322|         0|            0|            0|  0.00%|                raise TypeError('%r is not a string' % (values[0], ))
  1323|         0|            0|            0|  0.00%|        if len(values) >= 2:
  1324|         0|            0|            0|  0.00%|            # check that encoding argument is a string
  1325|         0|            0|            0|  0.00%|            if not isinstance(values[1], str):
  1326|         0|            0|            0|  0.00%|                raise TypeError('encoding must be a string, not %r' % (values[1], ))
  1327|         0|            0|            0|  0.00%|        if len(values) == 3:
  1328|         0|            0|            0|  0.00%|            # check that errors argument is a string
  1329|         0|            0|            0|  0.00%|            if not isinstance(values[2], str):
  1330|         0|            0|            0|  0.00%|                raise TypeError('errors must be a string, not %r' % (values[2]))
  1331|         0|            0|            0|  0.00%|        value = str(*values)
  1332|         0|            0|            0|  0.00%|        member = str.__new__(cls, value)
  1333|         0|            0|            0|  0.00%|        member._value_ = value
  1334|         0|            0|            0|  0.00%|        return member
  1335|         0|            0|            0|  0.00%|
  1336|         0|            0|            0|  0.00%|    @staticmethod
  1337|         0|            0|            0|  0.00%|    def _generate_next_value_(name, start, count, last_values):
  1338|         0|            0|            0|  0.00%|        """
  1339|         0|            0|            0|  0.00%|        Return the lower-cased version of the member name.
  1340|         0|            0|            0|  0.00%|        """
  1341|         0|            0|            0|  0.00%|        return name.lower()
  1342|         0|            0|            0|  0.00%|
  1343|         0|            0|            0|  0.00%|
  1344|         0|            0|            0|  0.00%|def pickle_by_global_name(self, proto):
  1345|         0|            0|            0|  0.00%|    # should not be used with Flag-type enums
  1346|         0|            0|            0|  0.00%|    return self.name
  1347|         0|            0|            0|  0.00%|_reduce_ex_by_global_name = pickle_by_global_name
  1348|         0|            0|            0|  0.00%|
  1349|         0|            0|            0|  0.00%|def pickle_by_enum_name(self, proto):
  1350|         0|            0|            0|  0.00%|    # should not be used with Flag-type enums
  1351|         0|            0|            0|  0.00%|    return getattr, (self.__class__, self._name_)
  1352|         0|            0|            0|  0.00%|
  1353|         0|            0|            0|  0.00%|class FlagBoundary(StrEnum):
  1354|         0|            0|            0|  0.00%|    """
  1355|         0|            0|            0|  0.00%|    control how out of range values are handled
  1356|         0|            0|            0|  0.00%|    "strict" -> error is raised             [default for Flag]
  1357|         0|            0|            0|  0.00%|    "conform" -> extra bits are discarded
  1358|         0|            0|            0|  0.00%|    "eject" -> lose flag status
  1359|         0|            0|            0|  0.00%|    "keep" -> keep flag status and all bits [default for IntFlag]
  1360|         0|            0|            0|  0.00%|    """
  1361|         0|            0|            0|  0.00%|    STRICT = auto()
  1362|         0|            0|            0|  0.00%|    CONFORM = auto()
  1363|         0|            0|            0|  0.00%|    EJECT = auto()
  1364|         0|            0|            0|  0.00%|    KEEP = auto()
  1365|         0|            0|            0|  0.00%|STRICT, CONFORM, EJECT, KEEP = FlagBoundary
  1366|         0|            0|            0|  0.00%|
  1367|         0|            0|            0|  0.00%|
  1368|         0|            0|            0|  0.00%|class Flag(Enum, boundary=STRICT):
  1369|         0|            0|            0|  0.00%|    """
  1370|         0|            0|            0|  0.00%|    Support for flags
  1371|         0|            0|            0|  0.00%|    """
  1372|         0|            0|            0|  0.00%|
  1373|         0|            0|            0|  0.00%|    _numeric_repr_ = repr
  1374|         0|            0|            0|  0.00%|
  1375|         0|            0|            0|  0.00%|    @staticmethod
  1376|         0|            0|            0|  0.00%|    def _generate_next_value_(name, start, count, last_values):
  1377|         0|            0|            0|  0.00%|        """
  1378|         0|            0|            0|  0.00%|        Generate the next value when not given.
  1379|         0|            0|            0|  0.00%|
  1380|         0|            0|            0|  0.00%|        name: the name of the member
  1381|         0|            0|            0|  0.00%|        start: the initial start value or None
  1382|         0|            0|            0|  0.00%|        count: the number of existing members
  1383|         0|            0|            0|  0.00%|        last_values: the last value assigned or None
  1384|         0|            0|            0|  0.00%|        """
  1385|         0|            0|            0|  0.00%|        if not count:
  1386|         0|            0|            0|  0.00%|            return start if start is not None else 1
  1387|         0|            0|            0|  0.00%|        last_value = max(last_values)
  1388|         0|            0|            0|  0.00%|        try:
  1389|         0|            0|            0|  0.00%|            high_bit = _high_bit(last_value)
  1390|         0|            0|            0|  0.00%|        except Exception:
  1391|         0|            0|            0|  0.00%|            raise TypeError('invalid flag value %r' % last_value) from None
  1392|         0|            0|            0|  0.00%|        return 2 ** (high_bit+1)
  1393|         0|            0|            0|  0.00%|
  1394|         0|            0|            0|  0.00%|    @classmethod
  1395|         0|            0|            0|  0.00%|    def _iter_member_by_value_(cls, value):
  1396|         0|            0|            0|  0.00%|        """
  1397|         0|            0|            0|  0.00%|        Extract all members from the value in definition (i.e. increasing value) order.
  1398|         0|            0|            0|  0.00%|        """
  1399|         0|            0|            0|  0.00%|        for val in _iter_bits_lsb(value & cls._flag_mask_):
  1400|         0|            0|            0|  0.00%|            yield cls._value2member_map_.get(val)
  1401|         0|            0|            0|  0.00%|
  1402|         0|            0|            0|  0.00%|    _iter_member_ = _iter_member_by_value_
  1403|         0|            0|            0|  0.00%|
  1404|         0|            0|            0|  0.00%|    @classmethod
  1405|         0|            0|            0|  0.00%|    def _iter_member_by_def_(cls, value):
  1406|         0|            0|            0|  0.00%|        """
  1407|         0|            0|            0|  0.00%|        Extract all members from the value in definition order.
  1408|         0|            0|            0|  0.00%|        """
  1409|         0|            0|            0|  0.00%|        yield from sorted(
  1410|         0|            0|            0|  0.00%|                cls._iter_member_by_value_(value),
  1411|         0|            0|            0|  0.00%|                key=lambda m: m._sort_order_,
  1412|         0|            0|            0|  0.00%|                )
  1413|         0|            0|            0|  0.00%|
  1414|         0|            0|            0|  0.00%|    @classmethod
  1415|         0|            0|            0|  0.00%|    def _missing_(cls, value):
  1416|         0|            0|            0|  0.00%|        """
  1417|         0|            0|            0|  0.00%|        Create a composite member containing all canonical members present in `value`.
  1418|         0|            0|            0|  0.00%|
  1419|         0|            0|            0|  0.00%|        If non-member values are present, result depends on `_boundary_` setting.
  1420|         0|            0|            0|  0.00%|        """
  1421|         0|            0|            0|  0.00%|        if not isinstance(value, int):
  1422|         0|            0|            0|  0.00%|            raise ValueError(
  1423|         0|            0|            0|  0.00%|                    "%r is not a valid %s" % (value, cls.__qualname__)
  1424|         0|            0|            0|  0.00%|                    )
  1425|         0|            0|            0|  0.00%|        # check boundaries
  1426|         0|            0|            0|  0.00%|        # - value must be in range (e.g. -16 <-> +15, i.e. ~15 <-> 15)
  1427|         0|            0|            0|  0.00%|        # - value must not include any skipped flags (e.g. if bit 2 is not
  1428|         0|            0|            0|  0.00%|        #   defined, then 0d10 is invalid)
  1429|         0|            0|            0|  0.00%|        flag_mask = cls._flag_mask_
  1430|         0|            0|            0|  0.00%|        singles_mask = cls._singles_mask_
  1431|         0|            0|            0|  0.00%|        all_bits = cls._all_bits_
  1432|         0|            0|            0|  0.00%|        neg_value = None
  1433|         0|            0|            0|  0.00%|        if (
  1434|         0|            0|            0|  0.00%|                not ~all_bits <= value <= all_bits
  1435|         0|            0|            0|  0.00%|                or value & (all_bits ^ flag_mask)
  1436|         0|            0|            0|  0.00%|            ):
  1437|         0|            0|            0|  0.00%|            if cls._boundary_ is STRICT:
  1438|         0|            0|            0|  0.00%|                max_bits = max(value.bit_length(), flag_mask.bit_length())
  1439|         0|            0|            0|  0.00%|                raise ValueError(
  1440|         0|            0|            0|  0.00%|                        "%r invalid value %r\n    given %s\n  allowed %s" % (
  1441|         0|            0|            0|  0.00%|                            cls, value, bin(value, max_bits), bin(flag_mask, max_bits),
  1442|         0|            0|            0|  0.00%|                            ))
  1443|         0|            0|            0|  0.00%|            elif cls._boundary_ is CONFORM:
  1444|         0|            0|            0|  0.00%|                value = value & flag_mask
  1445|         0|            0|            0|  0.00%|            elif cls._boundary_ is EJECT:
  1446|         0|            0|            0|  0.00%|                return value
  1447|         0|            0|            0|  0.00%|            elif cls._boundary_ is KEEP:
  1448|         0|            0|            0|  0.00%|                if value < 0:
  1449|         0|            0|            0|  0.00%|                    value = (
  1450|         0|            0|            0|  0.00%|                            max(all_bits+1, 2**(value.bit_length()))
  1451|         0|            0|            0|  0.00%|                            + value
  1452|         0|            0|            0|  0.00%|                            )
  1453|         0|            0|            0|  0.00%|            else:
  1454|         0|            0|            0|  0.00%|                raise ValueError(
  1455|         0|            0|            0|  0.00%|                        '%r unknown flag boundary %r' % (cls, cls._boundary_, )
  1456|         0|            0|            0|  0.00%|                        )
  1457|         0|            0|            0|  0.00%|        if value < 0:
  1458|         0|            0|            0|  0.00%|            neg_value = value
  1459|         0|            0|            0|  0.00%|            value = all_bits + 1 + value
  1460|         0|            0|            0|  0.00%|        # get members and unknown
  1461|         0|            0|            0|  0.00%|        unknown = value & ~flag_mask
  1462|         0|            0|            0|  0.00%|        aliases = value & ~singles_mask
  1463|         0|            0|            0|  0.00%|        member_value = value & singles_mask
  1464|         0|            0|            0|  0.00%|        if unknown and cls._boundary_ is not KEEP:
  1465|         0|            0|            0|  0.00%|            raise ValueError(
  1466|         0|            0|            0|  0.00%|                    '%s(%r) -->  unknown values %r [%s]'
  1467|         0|            0|            0|  0.00%|                    % (cls.__name__, value, unknown, bin(unknown))
  1468|         0|            0|            0|  0.00%|                    )
  1469|         0|            0|            0|  0.00%|        # normal Flag?
  1470|         0|            0|            0|  0.00%|        if cls._member_type_ is object:
  1471|         0|            0|            0|  0.00%|            # construct a singleton enum pseudo-member
  1472|         0|            0|            0|  0.00%|            pseudo_member = object.__new__(cls)
  1473|         0|            0|            0|  0.00%|        else:
  1474|         0|            0|            0|  0.00%|            pseudo_member = cls._member_type_.__new__(cls, value)
  1475|         0|            0|            0|  0.00%|        if not hasattr(pseudo_member, '_value_'):
  1476|         0|            0|            0|  0.00%|            pseudo_member._value_ = value
  1477|         0|            0|            0|  0.00%|        if member_value or aliases:
  1478|         0|            0|            0|  0.00%|            members = []
  1479|         0|            0|            0|  0.00%|            combined_value = 0
  1480|         0|            0|            0|  0.00%|            for m in cls._iter_member_(member_value):
  1481|         0|            0|            0|  0.00%|                members.append(m)
  1482|         0|            0|            0|  0.00%|                combined_value |= m._value_
  1483|         0|            0|            0|  0.00%|            if aliases:
  1484|         0|            0|            0|  0.00%|                value = member_value | aliases
  1485|         0|            0|            0|  0.00%|                for n, pm in cls._member_map_.items():
  1486|         0|            0|            0|  0.00%|                    if pm not in members and pm._value_ and pm._value_ & value == pm._value_:
  1487|         0|            0|            0|  0.00%|                        members.append(pm)
  1488|         0|            0|            0|  0.00%|                        combined_value |= pm._value_
  1489|         0|            0|            0|  0.00%|            unknown = value ^ combined_value
  1490|         0|            0|            0|  0.00%|            pseudo_member._name_ = '|'.join([m._name_ for m in members])
  1491|         0|            0|            0|  0.00%|            if not combined_value:
  1492|         0|            0|            0|  0.00%|                pseudo_member._name_ = None
  1493|         0|            0|            0|  0.00%|            elif unknown and cls._boundary_ is STRICT:
  1494|         0|            0|            0|  0.00%|                raise ValueError('%r: no members with value %r' % (cls, unknown))
  1495|         0|            0|            0|  0.00%|            elif unknown:
  1496|         0|            0|            0|  0.00%|                pseudo_member._name_ += '|%s' % cls._numeric_repr_(unknown)
  1497|         0|            0|            0|  0.00%|        else:
  1498|         0|            0|            0|  0.00%|            pseudo_member._name_ = None
  1499|         0|            0|            0|  0.00%|        # use setdefault in case another thread already created a composite
  1500|         0|            0|            0|  0.00%|        # with this value
  1501|         0|            0|            0|  0.00%|        # note: zero is a special case -- always add it
  1502|         0|            0|            0|  0.00%|        pseudo_member = cls._value2member_map_.setdefault(value, pseudo_member)
  1503|         0|            0|            0|  0.00%|        if neg_value is not None:
  1504|         0|            0|            0|  0.00%|            cls._value2member_map_[neg_value] = pseudo_member
  1505|         0|            0|            0|  0.00%|        return pseudo_member
  1506|         0|            0|            0|  0.00%|
  1507|         0|            0|            0|  0.00%|    def __contains__(self, other):
  1508|         0|            0|            0|  0.00%|        """
  1509|         0|            0|            0|  0.00%|        Returns True if self has at least the same flags set as other.
  1510|         0|            0|            0|  0.00%|        """
  1511|         0|            0|            0|  0.00%|        if not isinstance(other, self.__class__):
  1512|         0|            0|            0|  0.00%|            raise TypeError(
  1513|         0|            0|            0|  0.00%|                "unsupported operand type(s) for 'in': %r and %r" % (
  1514|         0|            0|            0|  0.00%|                    type(other).__qualname__, self.__class__.__qualname__))
  1515|         0|            0|            0|  0.00%|        return other._value_ & self._value_ == other._value_
  1516|         0|            0|            0|  0.00%|
  1517|         0|            0|            0|  0.00%|    def __iter__(self):
  1518|         0|            0|            0|  0.00%|        """
  1519|         0|            0|            0|  0.00%|        Returns flags in definition order.
  1520|         0|            0|            0|  0.00%|        """
  1521|         0|            0|            0|  0.00%|        yield from self._iter_member_(self._value_)
  1522|         0|            0|            0|  0.00%|
  1523|         0|            0|            0|  0.00%|    def __len__(self):
  1524|         0|            0|            0|  0.00%|        return self._value_.bit_count()
  1525|         0|            0|            0|  0.00%|
  1526|         0|            0|            0|  0.00%|    def __repr__(self):
  1527|         0|            0|            0|  0.00%|        cls_name = self.__class__.__name__
  1528|         0|            0|            0|  0.00%|        v_repr = self.__class__._value_repr_ or repr
  1529|         0|            0|            0|  0.00%|        if self._name_ is None:
  1530|         0|            0|            0|  0.00%|            return "<%s: %s>" % (cls_name, v_repr(self._value_))
  1531|         0|            0|            0|  0.00%|        else:
  1532|         0|            0|            0|  0.00%|            return "<%s.%s: %s>" % (cls_name, self._name_, v_repr(self._value_))
  1533|         0|            0|            0|  0.00%|
  1534|         0|            0|            0|  0.00%|    def __str__(self):
  1535|         0|            0|            0|  0.00%|        cls_name = self.__class__.__name__
  1536|         0|            0|            0|  0.00%|        if self._name_ is None:
  1537|         0|            0|            0|  0.00%|            return '%s(%r)' % (cls_name, self._value_)
  1538|         0|            0|            0|  0.00%|        else:
  1539|         0|            0|            0|  0.00%|            return "%s.%s" % (cls_name, self._name_)
  1540|         0|            0|            0|  0.00%|
  1541|         0|            0|            0|  0.00%|    def __bool__(self):
  1542|         0|            0|            0|  0.00%|        return bool(self._value_)
  1543|         0|            0|            0|  0.00%|
  1544|         6|  9.05991e-06|  1.50998e-06|  0.01%|    def _get_value(self, flag):
  1545|         6|  1.00136e-05|  1.66893e-06|  0.01%|        if isinstance(flag, self.__class__):
  1546|         2|   2.6226e-06|   1.3113e-06|  0.00%|            return flag._value_
  1547|         4|  6.19888e-06|  1.54972e-06|  0.01%|        elif self._member_type_ is not object and isinstance(flag, self._member_type_):
  1548|         4|  5.48363e-06|  1.37091e-06|  0.01%|            return flag
  1549|         0|            0|            0|  0.00%|        return NotImplemented
  1550|         0|            0|            0|  0.00%|
  1551|         0|            0|            0|  0.00%|    def __or__(self, other):
  1552|         0|            0|            0|  0.00%|        other_value = self._get_value(other)
  1553|         0|            0|            0|  0.00%|        if other_value is NotImplemented:
  1554|         0|            0|            0|  0.00%|            return NotImplemented
  1555|         0|            0|            0|  0.00%|
  1556|         0|            0|            0|  0.00%|        for flag in self, other:
  1557|         0|            0|            0|  0.00%|            if self._get_value(flag) is None:
  1558|         0|            0|            0|  0.00%|                raise TypeError(f"'{flag}' cannot be combined with other flags with |")
  1559|         0|            0|            0|  0.00%|        value = self._value_
  1560|         0|            0|            0|  0.00%|        return self.__class__(value | other_value)
  1561|         0|            0|            0|  0.00%|
  1562|         2|  7.39098e-06|  3.69549e-06|  0.01%|    def __and__(self, other):
  1563|         2|   1.7643e-05|  8.82149e-06|  0.02%|        other_value = self._get_value(other)
(call)|         2|  1.62125e-05|  8.10623e-06|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/enum.py:1544 _get_value
  1564|         2|  5.96046e-06|  2.98023e-06|  0.01%|        if other_value is NotImplemented:
  1565|         0|            0|            0|  0.00%|            return NotImplemented
  1566|         0|            0|            0|  0.00%|
  1567|         6|  9.53674e-06|  1.58946e-06|  0.01%|        for flag in self, other:
  1568|         4|   2.3365e-05|  5.84126e-06|  0.02%|            if self._get_value(flag) is None:
(call)|         4|  1.71661e-05|  4.29153e-06|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/enum.py:1544 _get_value
  1569|         0|            0|            0|  0.00%|                raise TypeError(f"'{flag}' cannot be combined with other flags with &")
  1570|         2|  2.14577e-06|  1.07288e-06|  0.00%|        value = self._value_
  1571|         2|  1.95503e-05|  9.77516e-06|  0.02%|        return self.__class__(value & other_value)
(call)|         2|  7.43866e-05|  3.71933e-05|  0.08%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/enum.py:726 __call__
  1572|         0|            0|            0|  0.00%|
  1573|         0|            0|            0|  0.00%|    def __xor__(self, other):
  1574|         0|            0|            0|  0.00%|        other_value = self._get_value(other)
  1575|         0|            0|            0|  0.00%|        if other_value is NotImplemented:
  1576|         0|            0|            0|  0.00%|            return NotImplemented
  1577|         0|            0|            0|  0.00%|
  1578|         0|            0|            0|  0.00%|        for flag in self, other:
  1579|         0|            0|            0|  0.00%|            if self._get_value(flag) is None:
  1580|         0|            0|            0|  0.00%|                raise TypeError(f"'{flag}' cannot be combined with other flags with ^")
  1581|         0|            0|            0|  0.00%|        value = self._value_
  1582|         0|            0|            0|  0.00%|        return self.__class__(value ^ other_value)
  1583|         0|            0|            0|  0.00%|
  1584|         0|            0|            0|  0.00%|    def __invert__(self):
  1585|         0|            0|            0|  0.00%|        if self._get_value(self) is None:
  1586|         0|            0|            0|  0.00%|            raise TypeError(f"'{self}' cannot be inverted")
  1587|         0|            0|            0|  0.00%|
  1588|         0|            0|            0|  0.00%|        if self._inverted_ is None:
  1589|         0|            0|            0|  0.00%|            if self._boundary_ in (EJECT, KEEP):
  1590|         0|            0|            0|  0.00%|                self._inverted_ = self.__class__(~self._value_)
  1591|         0|            0|            0|  0.00%|            else:
  1592|         0|            0|            0|  0.00%|                self._inverted_ = self.__class__(self._singles_mask_ & ~self._value_)
  1593|         0|            0|            0|  0.00%|        return self._inverted_
  1594|         0|            0|            0|  0.00%|
  1595|         0|            0|            0|  0.00%|    __rand__ = __and__
  1596|         0|            0|            0|  0.00%|    __ror__ = __or__
  1597|         0|            0|            0|  0.00%|    __rxor__ = __xor__
  1598|         0|            0|            0|  0.00%|
  1599|         0|            0|            0|  0.00%|
  1600|         0|            0|            0|  0.00%|class IntFlag(int, ReprEnum, Flag, boundary=KEEP):
  1601|         0|            0|            0|  0.00%|    """
  1602|         0|            0|            0|  0.00%|    Support for integer-based Flags
  1603|         0|            0|            0|  0.00%|    """
  1604|         0|            0|            0|  0.00%|
  1605|         0|            0|            0|  0.00%|
  1606|         0|            0|            0|  0.00%|def _high_bit(value):
  1607|         0|            0|            0|  0.00%|    """
  1608|         0|            0|            0|  0.00%|    returns index of highest bit, or -1 if value is zero or negative
  1609|         0|            0|            0|  0.00%|    """
  1610|         0|            0|            0|  0.00%|    return value.bit_length() - 1
  1611|         0|            0|            0|  0.00%|
  1612|         0|            0|            0|  0.00%|def unique(enumeration):
  1613|         0|            0|            0|  0.00%|    """
  1614|         0|            0|            0|  0.00%|    Class decorator for enumerations ensuring unique member values.
  1615|         0|            0|            0|  0.00%|    """
  1616|         0|            0|            0|  0.00%|    duplicates = []
  1617|         0|            0|            0|  0.00%|    for name, member in enumeration.__members__.items():
  1618|         0|            0|            0|  0.00%|        if name != member.name:
  1619|         0|            0|            0|  0.00%|            duplicates.append((name, member.name))
  1620|         0|            0|            0|  0.00%|    if duplicates:
  1621|         0|            0|            0|  0.00%|        alias_details = ', '.join(
  1622|         0|            0|            0|  0.00%|                ["%s -> %s" % (alias, name) for (alias, name) in duplicates])
  1623|         0|            0|            0|  0.00%|        raise ValueError('duplicate values found in %r: %s' %
  1624|         0|            0|            0|  0.00%|                (enumeration, alias_details))
  1625|         0|            0|            0|  0.00%|    return enumeration
  1626|         0|            0|            0|  0.00%|
  1627|         0|            0|            0|  0.00%|def _dataclass_repr(self):
  1628|         0|            0|            0|  0.00%|    dcf = self.__dataclass_fields__
  1629|         0|            0|            0|  0.00%|    return ', '.join(
  1630|         0|            0|            0|  0.00%|            '%s=%r' % (k, getattr(self, k))
  1631|         0|            0|            0|  0.00%|            for k in dcf.keys()
  1632|         0|            0|            0|  0.00%|            if dcf[k].repr
  1633|         0|            0|            0|  0.00%|            )
  1634|         0|            0|            0|  0.00%|
  1635|         0|            0|            0|  0.00%|def global_enum_repr(self):
  1636|         0|            0|            0|  0.00%|    """
  1637|         0|            0|            0|  0.00%|    use module.enum_name instead of class.enum_name
  1638|         0|            0|            0|  0.00%|
  1639|         0|            0|            0|  0.00%|    the module is the last module in case of a multi-module name
  1640|         0|            0|            0|  0.00%|    """
  1641|         0|            0|            0|  0.00%|    module = self.__class__.__module__.split('.')[-1]
  1642|         0|            0|            0|  0.00%|    return '%s.%s' % (module, self._name_)
  1643|         0|            0|            0|  0.00%|
  1644|         0|            0|            0|  0.00%|def global_flag_repr(self):
  1645|         0|            0|            0|  0.00%|    """
  1646|         0|            0|            0|  0.00%|    use module.flag_name instead of class.flag_name
  1647|         0|            0|            0|  0.00%|
  1648|         0|            0|            0|  0.00%|    the module is the last module in case of a multi-module name
  1649|         0|            0|            0|  0.00%|    """
  1650|         0|            0|            0|  0.00%|    module = self.__class__.__module__.split('.')[-1]
  1651|         0|            0|            0|  0.00%|    cls_name = self.__class__.__name__
  1652|         0|            0|            0|  0.00%|    if self._name_ is None:
  1653|         0|            0|            0|  0.00%|        return "%s.%s(%r)" % (module, cls_name, self._value_)
  1654|         0|            0|            0|  0.00%|    if _is_single_bit(self._value_):
  1655|         0|            0|            0|  0.00%|        return '%s.%s' % (module, self._name_)
  1656|         0|            0|            0|  0.00%|    if self._boundary_ is not FlagBoundary.KEEP:
  1657|         0|            0|            0|  0.00%|        return '|'.join(['%s.%s' % (module, name) for name in self.name.split('|')])
  1658|         0|            0|            0|  0.00%|    else:
  1659|         0|            0|            0|  0.00%|        name = []
  1660|         0|            0|            0|  0.00%|        for n in self._name_.split('|'):
  1661|         0|            0|            0|  0.00%|            if n[0].isdigit():
  1662|         0|            0|            0|  0.00%|                name.append(n)
  1663|         0|            0|            0|  0.00%|            else:
  1664|         0|            0|            0|  0.00%|                name.append('%s.%s' % (module, n))
  1665|         0|            0|            0|  0.00%|        return '|'.join(name)
  1666|         0|            0|            0|  0.00%|
  1667|         0|            0|            0|  0.00%|def global_str(self):
  1668|         0|            0|            0|  0.00%|    """
  1669|         0|            0|            0|  0.00%|    use enum_name instead of class.enum_name
  1670|         0|            0|            0|  0.00%|    """
  1671|         0|            0|            0|  0.00%|    if self._name_ is None:
  1672|         0|            0|            0|  0.00%|        cls_name = self.__class__.__name__
  1673|         0|            0|            0|  0.00%|        return "%s(%r)" % (cls_name, self._value_)
  1674|         0|            0|            0|  0.00%|    else:
  1675|         0|            0|            0|  0.00%|        return self._name_
  1676|         0|            0|            0|  0.00%|
  1677|         0|            0|            0|  0.00%|def global_enum(cls, update_str=False):
  1678|         0|            0|            0|  0.00%|    """
  1679|         0|            0|            0|  0.00%|    decorator that makes the repr() of an enum member reference its module
  1680|         0|            0|            0|  0.00%|    instead of its class; also exports all members to the enum's module's
  1681|         0|            0|            0|  0.00%|    global namespace
  1682|         0|            0|            0|  0.00%|    """
  1683|         0|            0|            0|  0.00%|    if issubclass(cls, Flag):
  1684|         0|            0|            0|  0.00%|        cls.__repr__ = global_flag_repr
  1685|         0|            0|            0|  0.00%|    else:
  1686|         0|            0|            0|  0.00%|        cls.__repr__ = global_enum_repr
  1687|         0|            0|            0|  0.00%|    if not issubclass(cls, ReprEnum) or update_str:
  1688|         0|            0|            0|  0.00%|        cls.__str__ = global_str
  1689|         0|            0|            0|  0.00%|    sys.modules[cls.__module__].__dict__.update(cls.__members__)
  1690|         0|            0|            0|  0.00%|    return cls
  1691|         0|            0|            0|  0.00%|
  1692|         0|            0|            0|  0.00%|def _simple_enum(etype=Enum, *, boundary=None, use_args=None):
  1693|         0|            0|            0|  0.00%|    """
  1694|         0|            0|            0|  0.00%|    Class decorator that converts a normal class into an :class:`Enum`.  No
  1695|         0|            0|            0|  0.00%|    safety checks are done, and some advanced behavior (such as
  1696|         0|            0|            0|  0.00%|    :func:`__init_subclass__`) is not available.  Enum creation can be faster
  1697|         0|            0|            0|  0.00%|    using :func:`simple_enum`.
  1698|         0|            0|            0|  0.00%|
  1699|         0|            0|            0|  0.00%|        >>> from enum import Enum, _simple_enum
  1700|         0|            0|            0|  0.00%|        >>> @_simple_enum(Enum)
  1701|         0|            0|            0|  0.00%|        ... class Color:
  1702|         0|            0|            0|  0.00%|        ...     RED = auto()
  1703|         0|            0|            0|  0.00%|        ...     GREEN = auto()
  1704|         0|            0|            0|  0.00%|        ...     BLUE = auto()
  1705|         0|            0|            0|  0.00%|        >>> Color
  1706|         0|            0|            0|  0.00%|        <enum 'Color'>
  1707|         0|            0|            0|  0.00%|    """
  1708|         0|            0|            0|  0.00%|    def convert_class(cls):
  1709|         0|            0|            0|  0.00%|        nonlocal use_args
  1710|         0|            0|            0|  0.00%|        cls_name = cls.__name__
  1711|         0|            0|            0|  0.00%|        if use_args is None:
  1712|         0|            0|            0|  0.00%|            use_args = etype._use_args_
  1713|         0|            0|            0|  0.00%|        __new__ = cls.__dict__.get('__new__')
  1714|         0|            0|            0|  0.00%|        if __new__ is not None:
  1715|         0|            0|            0|  0.00%|            new_member = __new__.__func__
  1716|         0|            0|            0|  0.00%|        else:
  1717|         0|            0|            0|  0.00%|            new_member = etype._member_type_.__new__
  1718|         0|            0|            0|  0.00%|        attrs = {}
  1719|         0|            0|            0|  0.00%|        body = {}
  1720|         0|            0|            0|  0.00%|        if __new__ is not None:
  1721|         0|            0|            0|  0.00%|            body['__new_member__'] = new_member
  1722|         0|            0|            0|  0.00%|        body['_new_member_'] = new_member
  1723|         0|            0|            0|  0.00%|        body['_use_args_'] = use_args
  1724|         0|            0|            0|  0.00%|        body['_generate_next_value_'] = gnv = etype._generate_next_value_
  1725|         0|            0|            0|  0.00%|        body['_member_names_'] = member_names = []
  1726|         0|            0|            0|  0.00%|        body['_member_map_'] = member_map = {}
  1727|         0|            0|            0|  0.00%|        body['_value2member_map_'] = value2member_map = {}
  1728|         0|            0|            0|  0.00%|        body['_unhashable_values_'] = []
  1729|         0|            0|            0|  0.00%|        body['_member_type_'] = member_type = etype._member_type_
  1730|         0|            0|            0|  0.00%|        body['_value_repr_'] = etype._value_repr_
  1731|         0|            0|            0|  0.00%|        if issubclass(etype, Flag):
  1732|         0|            0|            0|  0.00%|            body['_boundary_'] = boundary or etype._boundary_
  1733|         0|            0|            0|  0.00%|            body['_flag_mask_'] = None
  1734|         0|            0|            0|  0.00%|            body['_all_bits_'] = None
  1735|         0|            0|            0|  0.00%|            body['_singles_mask_'] = None
  1736|         0|            0|            0|  0.00%|            body['_inverted_'] = None
  1737|         0|            0|            0|  0.00%|            body['__or__'] = Flag.__or__
  1738|         0|            0|            0|  0.00%|            body['__xor__'] = Flag.__xor__
  1739|         0|            0|            0|  0.00%|            body['__and__'] = Flag.__and__
  1740|         0|            0|            0|  0.00%|            body['__ror__'] = Flag.__ror__
  1741|         0|            0|            0|  0.00%|            body['__rxor__'] = Flag.__rxor__
  1742|         0|            0|            0|  0.00%|            body['__rand__'] = Flag.__rand__
  1743|         0|            0|            0|  0.00%|            body['__invert__'] = Flag.__invert__
  1744|         0|            0|            0|  0.00%|        for name, obj in cls.__dict__.items():
  1745|         0|            0|            0|  0.00%|            if name in ('__dict__', '__weakref__'):
  1746|         0|            0|            0|  0.00%|                continue
  1747|         0|            0|            0|  0.00%|            if _is_dunder(name) or _is_private(cls_name, name) or _is_sunder(name) or _is_descriptor(obj):
  1748|         0|            0|            0|  0.00%|                body[name] = obj
  1749|         0|            0|            0|  0.00%|            else:
  1750|         0|            0|            0|  0.00%|                attrs[name] = obj
  1751|         0|            0|            0|  0.00%|        if cls.__dict__.get('__doc__') is None:
  1752|         0|            0|            0|  0.00%|            body['__doc__'] = 'An enumeration.'
  1753|         0|            0|            0|  0.00%|        #
  1754|         0|            0|            0|  0.00%|        # double check that repr and friends are not the mixin's or various
  1755|         0|            0|            0|  0.00%|        # things break (such as pickle)
  1756|         0|            0|            0|  0.00%|        # however, if the method is defined in the Enum itself, don't replace
  1757|         0|            0|            0|  0.00%|        # it
  1758|         0|            0|            0|  0.00%|        enum_class = type(cls_name, (etype, ), body, boundary=boundary, _simple=True)
  1759|         0|            0|            0|  0.00%|        for name in ('__repr__', '__str__', '__format__', '__reduce_ex__'):
  1760|         0|            0|            0|  0.00%|            if name not in body:
  1761|         0|            0|            0|  0.00%|                # check for mixin overrides before replacing
  1762|         0|            0|            0|  0.00%|                enum_method = getattr(etype, name)
  1763|         0|            0|            0|  0.00%|                found_method = getattr(enum_class, name)
  1764|         0|            0|            0|  0.00%|                object_method = getattr(object, name)
  1765|         0|            0|            0|  0.00%|                data_type_method = getattr(member_type, name)
  1766|         0|            0|            0|  0.00%|                if found_method in (data_type_method, object_method):
  1767|         0|            0|            0|  0.00%|                    setattr(enum_class, name, enum_method)
  1768|         0|            0|            0|  0.00%|        gnv_last_values = []
  1769|         0|            0|            0|  0.00%|        if issubclass(enum_class, Flag):
  1770|         0|            0|            0|  0.00%|            # Flag / IntFlag
  1771|         0|            0|            0|  0.00%|            single_bits = multi_bits = 0
  1772|         0|            0|            0|  0.00%|            for name, value in attrs.items():
  1773|         0|            0|            0|  0.00%|                if isinstance(value, auto) and auto.value is _auto_null:
  1774|         0|            0|            0|  0.00%|                    value = gnv(name, 1, len(member_names), gnv_last_values)
  1775|         0|            0|            0|  0.00%|                if value in value2member_map:
  1776|         0|            0|            0|  0.00%|                    # an alias to an existing member
  1777|         0|            0|            0|  0.00%|                    member = value2member_map[value]
  1778|         0|            0|            0|  0.00%|                    redirect = property()
  1779|         0|            0|            0|  0.00%|                    redirect.member = member
  1780|         0|            0|            0|  0.00%|                    redirect.__set_name__(enum_class, name)
  1781|         0|            0|            0|  0.00%|                    setattr(enum_class, name, redirect)
  1782|         0|            0|            0|  0.00%|                    member_map[name] = member
  1783|         0|            0|            0|  0.00%|                else:
  1784|         0|            0|            0|  0.00%|                    # create the member
  1785|         0|            0|            0|  0.00%|                    if use_args:
  1786|         0|            0|            0|  0.00%|                        if not isinstance(value, tuple):
  1787|         0|            0|            0|  0.00%|                            value = (value, )
  1788|         0|            0|            0|  0.00%|                        member = new_member(enum_class, *value)
  1789|         0|            0|            0|  0.00%|                        value = value[0]
  1790|         0|            0|            0|  0.00%|                    else:
  1791|         0|            0|            0|  0.00%|                        member = new_member(enum_class)
  1792|         0|            0|            0|  0.00%|                    if __new__ is None:
  1793|         0|            0|            0|  0.00%|                        member._value_ = value
  1794|         0|            0|            0|  0.00%|                    member._name_ = name
  1795|         0|            0|            0|  0.00%|                    member.__objclass__ = enum_class
  1796|         0|            0|            0|  0.00%|                    member.__init__(value)
  1797|         0|            0|            0|  0.00%|                    redirect = property()
  1798|         0|            0|            0|  0.00%|                    redirect.member = member
  1799|         0|            0|            0|  0.00%|                    redirect.__set_name__(enum_class, name)
  1800|         0|            0|            0|  0.00%|                    setattr(enum_class, name, redirect)
  1801|         0|            0|            0|  0.00%|                    member_map[name] = member
  1802|         0|            0|            0|  0.00%|                    member._sort_order_ = len(member_names)
  1803|         0|            0|            0|  0.00%|                    value2member_map[value] = member
  1804|         0|            0|            0|  0.00%|                    if _is_single_bit(value):
  1805|         0|            0|            0|  0.00%|                        # not a multi-bit alias, record in _member_names_ and _flag_mask_
  1806|         0|            0|            0|  0.00%|                        member_names.append(name)
  1807|         0|            0|            0|  0.00%|                        single_bits |= value
  1808|         0|            0|            0|  0.00%|                    else:
  1809|         0|            0|            0|  0.00%|                        multi_bits |= value
  1810|         0|            0|            0|  0.00%|                    gnv_last_values.append(value)
  1811|         0|            0|            0|  0.00%|            enum_class._flag_mask_ = single_bits | multi_bits
  1812|         0|            0|            0|  0.00%|            enum_class._singles_mask_ = single_bits
  1813|         0|            0|            0|  0.00%|            enum_class._all_bits_ = 2 ** ((single_bits|multi_bits).bit_length()) - 1
  1814|         0|            0|            0|  0.00%|            # set correct __iter__
  1815|         0|            0|            0|  0.00%|            member_list = [m._value_ for m in enum_class]
  1816|         0|            0|            0|  0.00%|            if member_list != sorted(member_list):
  1817|         0|            0|            0|  0.00%|                enum_class._iter_member_ = enum_class._iter_member_by_def_
  1818|         0|            0|            0|  0.00%|        else:
  1819|         0|            0|            0|  0.00%|            # Enum / IntEnum / StrEnum
  1820|         0|            0|            0|  0.00%|            for name, value in attrs.items():
  1821|         0|            0|            0|  0.00%|                if isinstance(value, auto):
  1822|         0|            0|            0|  0.00%|                    if value.value is _auto_null:
  1823|         0|            0|            0|  0.00%|                        value.value = gnv(name, 1, len(member_names), gnv_last_values)
  1824|         0|            0|            0|  0.00%|                    value = value.value
  1825|         0|            0|            0|  0.00%|                if value in value2member_map:
  1826|         0|            0|            0|  0.00%|                    # an alias to an existing member
  1827|         0|            0|            0|  0.00%|                    member = value2member_map[value]
  1828|         0|            0|            0|  0.00%|                    redirect = property()
  1829|         0|            0|            0|  0.00%|                    redirect.member = member
  1830|         0|            0|            0|  0.00%|                    redirect.__set_name__(enum_class, name)
  1831|         0|            0|            0|  0.00%|                    setattr(enum_class, name, redirect)
  1832|         0|            0|            0|  0.00%|                    member_map[name] = member
  1833|         0|            0|            0|  0.00%|                else:
  1834|         0|            0|            0|  0.00%|                    # create the member
  1835|         0|            0|            0|  0.00%|                    if use_args:
  1836|         0|            0|            0|  0.00%|                        if not isinstance(value, tuple):
  1837|         0|            0|            0|  0.00%|                            value = (value, )
  1838|         0|            0|            0|  0.00%|                        member = new_member(enum_class, *value)
  1839|         0|            0|            0|  0.00%|                        value = value[0]
  1840|         0|            0|            0|  0.00%|                    else:
  1841|         0|            0|            0|  0.00%|                        member = new_member(enum_class)
  1842|         0|            0|            0|  0.00%|                    if __new__ is None:
  1843|         0|            0|            0|  0.00%|                        member._value_ = value
  1844|         0|            0|            0|  0.00%|                    member._name_ = name
  1845|         0|            0|            0|  0.00%|                    member.__objclass__ = enum_class
  1846|         0|            0|            0|  0.00%|                    member.__init__(value)
  1847|         0|            0|            0|  0.00%|                    member._sort_order_ = len(member_names)
  1848|         0|            0|            0|  0.00%|                    redirect = property()
  1849|         0|            0|            0|  0.00%|                    redirect.member = member
  1850|         0|            0|            0|  0.00%|                    redirect.__set_name__(enum_class, name)
  1851|         0|            0|            0|  0.00%|                    setattr(enum_class, name, redirect)
  1852|         0|            0|            0|  0.00%|                    member_map[name] = member
  1853|         0|            0|            0|  0.00%|                    value2member_map[value] = member
  1854|         0|            0|            0|  0.00%|                    member_names.append(name)
  1855|         0|            0|            0|  0.00%|                    gnv_last_values.append(value)
  1856|         0|            0|            0|  0.00%|        if '__new__' in body:
  1857|         0|            0|            0|  0.00%|            enum_class.__new_member__ = enum_class.__new__
  1858|         0|            0|            0|  0.00%|        enum_class.__new__ = Enum.__new__
  1859|         0|            0|            0|  0.00%|        return enum_class
  1860|         0|            0|            0|  0.00%|    return convert_class
  1861|         0|            0|            0|  0.00%|
  1862|         0|            0|            0|  0.00%|@_simple_enum(StrEnum)
  1863|         0|            0|            0|  0.00%|class EnumCheck:
  1864|         0|            0|            0|  0.00%|    """
  1865|         0|            0|            0|  0.00%|    various conditions to check an enumeration for
  1866|         0|            0|            0|  0.00%|    """
  1867|         0|            0|            0|  0.00%|    CONTINUOUS = "no skipped integer values"
  1868|         0|            0|            0|  0.00%|    NAMED_FLAGS = "multi-flag aliases may not contain unnamed flags"
  1869|         0|            0|            0|  0.00%|    UNIQUE = "one name per value"
  1870|         0|            0|            0|  0.00%|CONTINUOUS, NAMED_FLAGS, UNIQUE = EnumCheck
  1871|         0|            0|            0|  0.00%|
  1872|         0|            0|            0|  0.00%|
  1873|         0|            0|            0|  0.00%|class verify:
  1874|         0|            0|            0|  0.00%|    """
  1875|         0|            0|            0|  0.00%|    Check an enumeration for various constraints. (see EnumCheck)
  1876|         0|            0|            0|  0.00%|    """
  1877|         0|            0|            0|  0.00%|    def __init__(self, *checks):
  1878|         0|            0|            0|  0.00%|        self.checks = checks
  1879|         0|            0|            0|  0.00%|    def __call__(self, enumeration):
  1880|         0|            0|            0|  0.00%|        checks = self.checks
  1881|         0|            0|            0|  0.00%|        cls_name = enumeration.__name__
  1882|         0|            0|            0|  0.00%|        if Flag is not None and issubclass(enumeration, Flag):
  1883|         0|            0|            0|  0.00%|            enum_type = 'flag'
  1884|         0|            0|            0|  0.00%|        elif issubclass(enumeration, Enum):
  1885|         0|            0|            0|  0.00%|            enum_type = 'enum'
  1886|         0|            0|            0|  0.00%|        else:
  1887|         0|            0|            0|  0.00%|            raise TypeError("the 'verify' decorator only works with Enum and Flag")
  1888|         0|            0|            0|  0.00%|        for check in checks:
  1889|         0|            0|            0|  0.00%|            if check is UNIQUE:
  1890|         0|            0|            0|  0.00%|                # check for duplicate names
  1891|         0|            0|            0|  0.00%|                duplicates = []
  1892|         0|            0|            0|  0.00%|                for name, member in enumeration.__members__.items():
  1893|         0|            0|            0|  0.00%|                    if name != member.name:
  1894|         0|            0|            0|  0.00%|                        duplicates.append((name, member.name))
  1895|         0|            0|            0|  0.00%|                if duplicates:
  1896|         0|            0|            0|  0.00%|                    alias_details = ', '.join(
  1897|         0|            0|            0|  0.00%|                            ["%s -> %s" % (alias, name) for (alias, name) in duplicates])
  1898|         0|            0|            0|  0.00%|                    raise ValueError('aliases found in %r: %s' %
  1899|         0|            0|            0|  0.00%|                            (enumeration, alias_details))
  1900|         0|            0|            0|  0.00%|            elif check is CONTINUOUS:
  1901|         0|            0|            0|  0.00%|                values = set(e.value for e in enumeration)
  1902|         0|            0|            0|  0.00%|                if len(values) < 2:
  1903|         0|            0|            0|  0.00%|                    continue
  1904|         0|            0|            0|  0.00%|                low, high = min(values), max(values)
  1905|         0|            0|            0|  0.00%|                missing = []
  1906|         0|            0|            0|  0.00%|                if enum_type == 'flag':
  1907|         0|            0|            0|  0.00%|                    # check for powers of two
  1908|         0|            0|            0|  0.00%|                    for i in range(_high_bit(low)+1, _high_bit(high)):
  1909|         0|            0|            0|  0.00%|                        if 2**i not in values:
  1910|         0|            0|            0|  0.00%|                            missing.append(2**i)
  1911|         0|            0|            0|  0.00%|                elif enum_type == 'enum':
  1912|         0|            0|            0|  0.00%|                    # check for powers of one
  1913|         0|            0|            0|  0.00%|                    for i in range(low+1, high):
  1914|         0|            0|            0|  0.00%|                        if i not in values:
  1915|         0|            0|            0|  0.00%|                            missing.append(i)
  1916|         0|            0|            0|  0.00%|                else:
  1917|         0|            0|            0|  0.00%|                    raise Exception('verify: unknown type %r' % enum_type)
  1918|         0|            0|            0|  0.00%|                if missing:
  1919|         0|            0|            0|  0.00%|                    raise ValueError(('invalid %s %r: missing values %s' % (
  1920|         0|            0|            0|  0.00%|                            enum_type, cls_name, ', '.join((str(m) for m in missing)))
  1921|         0|            0|            0|  0.00%|                            )[:256])
  1922|         0|            0|            0|  0.00%|                            # limit max length to protect against DOS attacks
  1923|         0|            0|            0|  0.00%|            elif check is NAMED_FLAGS:
  1924|         0|            0|            0|  0.00%|                # examine each alias and check for unnamed flags
  1925|         0|            0|            0|  0.00%|                member_names = enumeration._member_names_
  1926|         0|            0|            0|  0.00%|                member_values = [m.value for m in enumeration]
  1927|         0|            0|            0|  0.00%|                missing_names = []
  1928|         0|            0|            0|  0.00%|                missing_value = 0
  1929|         0|            0|            0|  0.00%|                for name, alias in enumeration._member_map_.items():
  1930|         0|            0|            0|  0.00%|                    if name in member_names:
  1931|         0|            0|            0|  0.00%|                        # not an alias
  1932|         0|            0|            0|  0.00%|                        continue
  1933|         0|            0|            0|  0.00%|                    if alias.value < 0:
  1934|         0|            0|            0|  0.00%|                        # negative numbers are not checked
  1935|         0|            0|            0|  0.00%|                        continue
  1936|         0|            0|            0|  0.00%|                    values = list(_iter_bits_lsb(alias.value))
  1937|         0|            0|            0|  0.00%|                    missed = [v for v in values if v not in member_values]
  1938|         0|            0|            0|  0.00%|                    if missed:
  1939|         0|            0|            0|  0.00%|                        missing_names.append(name)
  1940|         0|            0|            0|  0.00%|                        missing_value |= reduce(_or_, missed)
  1941|         0|            0|            0|  0.00%|                if missing_names:
  1942|         0|            0|            0|  0.00%|                    if len(missing_names) == 1:
  1943|         0|            0|            0|  0.00%|                        alias = 'alias %s is missing' % missing_names[0]
  1944|         0|            0|            0|  0.00%|                    else:
  1945|         0|            0|            0|  0.00%|                        alias = 'aliases %s and %s are missing' % (
  1946|         0|            0|            0|  0.00%|                                ', '.join(missing_names[:-1]), missing_names[-1]
  1947|         0|            0|            0|  0.00%|                                )
  1948|         0|            0|            0|  0.00%|                    if _is_single_bit(missing_value):
  1949|         0|            0|            0|  0.00%|                        value = 'value 0x%x' % missing_value
  1950|         0|            0|            0|  0.00%|                    else:
  1951|         0|            0|            0|  0.00%|                        value = 'combined values of 0x%x' % missing_value
  1952|         0|            0|            0|  0.00%|                    raise ValueError(
  1953|         0|            0|            0|  0.00%|                            'invalid Flag %r: %s %s [use enum.show_flag_values(value) for details]'
  1954|         0|            0|            0|  0.00%|                            % (cls_name, alias, value)
  1955|         0|            0|            0|  0.00%|                            )
  1956|         0|            0|            0|  0.00%|        return enumeration
  1957|         0|            0|            0|  0.00%|
  1958|         0|            0|            0|  0.00%|def _test_simple_enum(checked_enum, simple_enum):
  1959|         0|            0|            0|  0.00%|    """
  1960|         0|            0|            0|  0.00%|    A function that can be used to test an enum created with :func:`_simple_enum`
  1961|         0|            0|            0|  0.00%|    against the version created by subclassing :class:`Enum`::
  1962|         0|            0|            0|  0.00%|
  1963|         0|            0|            0|  0.00%|        >>> from enum import Enum, _simple_enum, _test_simple_enum
  1964|         0|            0|            0|  0.00%|        >>> @_simple_enum(Enum)
  1965|         0|            0|            0|  0.00%|        ... class Color:
  1966|         0|            0|            0|  0.00%|        ...     RED = auto()
  1967|         0|            0|            0|  0.00%|        ...     GREEN = auto()
  1968|         0|            0|            0|  0.00%|        ...     BLUE = auto()
  1969|         0|            0|            0|  0.00%|        >>> class CheckedColor(Enum):
  1970|         0|            0|            0|  0.00%|        ...     RED = auto()
  1971|         0|            0|            0|  0.00%|        ...     GREEN = auto()
  1972|         0|            0|            0|  0.00%|        ...     BLUE = auto()
  1973|         0|            0|            0|  0.00%|        >>> _test_simple_enum(CheckedColor, Color)
  1974|         0|            0|            0|  0.00%|
  1975|         0|            0|            0|  0.00%|    If differences are found, a :exc:`TypeError` is raised.
  1976|         0|            0|            0|  0.00%|    """
  1977|         0|            0|            0|  0.00%|    failed = []
  1978|         0|            0|            0|  0.00%|    if checked_enum.__dict__ != simple_enum.__dict__:
  1979|         0|            0|            0|  0.00%|        checked_dict = checked_enum.__dict__
  1980|         0|            0|            0|  0.00%|        checked_keys = list(checked_dict.keys())
  1981|         0|            0|            0|  0.00%|        simple_dict = simple_enum.__dict__
  1982|         0|            0|            0|  0.00%|        simple_keys = list(simple_dict.keys())
  1983|         0|            0|            0|  0.00%|        member_names = set(
  1984|         0|            0|            0|  0.00%|                list(checked_enum._member_map_.keys())
  1985|         0|            0|            0|  0.00%|                + list(simple_enum._member_map_.keys())
  1986|         0|            0|            0|  0.00%|                )
  1987|         0|            0|            0|  0.00%|        for key in set(checked_keys + simple_keys):
  1988|         0|            0|            0|  0.00%|            if key in ('__module__', '_member_map_', '_value2member_map_', '__doc__'):
  1989|         0|            0|            0|  0.00%|                # keys known to be different, or very long
  1990|         0|            0|            0|  0.00%|                continue
  1991|         0|            0|            0|  0.00%|            elif key in member_names:
  1992|         0|            0|            0|  0.00%|                # members are checked below
  1993|         0|            0|            0|  0.00%|                continue
  1994|         0|            0|            0|  0.00%|            elif key not in simple_keys:
  1995|         0|            0|            0|  0.00%|                failed.append("missing key: %r" % (key, ))
  1996|         0|            0|            0|  0.00%|            elif key not in checked_keys:
  1997|         0|            0|            0|  0.00%|                failed.append("extra key:   %r" % (key, ))
  1998|         0|            0|            0|  0.00%|            else:
  1999|         0|            0|            0|  0.00%|                checked_value = checked_dict[key]
  2000|         0|            0|            0|  0.00%|                simple_value = simple_dict[key]
  2001|         0|            0|            0|  0.00%|                if callable(checked_value) or isinstance(checked_value, bltns.property):
  2002|         0|            0|            0|  0.00%|                    continue
  2003|         0|            0|            0|  0.00%|                if key == '__doc__':
  2004|         0|            0|            0|  0.00%|                    # remove all spaces/tabs
  2005|         0|            0|            0|  0.00%|                    compressed_checked_value = checked_value.replace(' ','').replace('\t','')
  2006|         0|            0|            0|  0.00%|                    compressed_simple_value = simple_value.replace(' ','').replace('\t','')
  2007|         0|            0|            0|  0.00%|                    if compressed_checked_value != compressed_simple_value:
  2008|         0|            0|            0|  0.00%|                        failed.append("%r:\n         %s\n         %s" % (
  2009|         0|            0|            0|  0.00%|                                key,
  2010|         0|            0|            0|  0.00%|                                "checked -> %r" % (checked_value, ),
  2011|         0|            0|            0|  0.00%|                                "simple  -> %r" % (simple_value, ),
  2012|         0|            0|            0|  0.00%|                                ))
  2013|         0|            0|            0|  0.00%|                elif checked_value != simple_value:
  2014|         0|            0|            0|  0.00%|                    failed.append("%r:\n         %s\n         %s" % (
  2015|         0|            0|            0|  0.00%|                            key,
  2016|         0|            0|            0|  0.00%|                            "checked -> %r" % (checked_value, ),
  2017|         0|            0|            0|  0.00%|                            "simple  -> %r" % (simple_value, ),
  2018|         0|            0|            0|  0.00%|                            ))
  2019|         0|            0|            0|  0.00%|        failed.sort()
  2020|         0|            0|            0|  0.00%|        for name in member_names:
  2021|         0|            0|            0|  0.00%|            failed_member = []
  2022|         0|            0|            0|  0.00%|            if name not in simple_keys:
  2023|         0|            0|            0|  0.00%|                failed.append('missing member from simple enum: %r' % name)
  2024|         0|            0|            0|  0.00%|            elif name not in checked_keys:
  2025|         0|            0|            0|  0.00%|                failed.append('extra member in simple enum: %r' % name)
  2026|         0|            0|            0|  0.00%|            else:
  2027|         0|            0|            0|  0.00%|                checked_member_dict = checked_enum[name].__dict__
  2028|         0|            0|            0|  0.00%|                checked_member_keys = list(checked_member_dict.keys())
  2029|         0|            0|            0|  0.00%|                simple_member_dict = simple_enum[name].__dict__
  2030|         0|            0|            0|  0.00%|                simple_member_keys = list(simple_member_dict.keys())
  2031|         0|            0|            0|  0.00%|                for key in set(checked_member_keys + simple_member_keys):
  2032|         0|            0|            0|  0.00%|                    if key in ('__module__', '__objclass__', '_inverted_'):
  2033|         0|            0|            0|  0.00%|                        # keys known to be different or absent
  2034|         0|            0|            0|  0.00%|                        continue
  2035|         0|            0|            0|  0.00%|                    elif key not in simple_member_keys:
  2036|         0|            0|            0|  0.00%|                        failed_member.append("missing key %r not in the simple enum member %r" % (key, name))
  2037|         0|            0|            0|  0.00%|                    elif key not in checked_member_keys:
  2038|         0|            0|            0|  0.00%|                        failed_member.append("extra key %r in simple enum member %r" % (key, name))
  2039|         0|            0|            0|  0.00%|                    else:
  2040|         0|            0|            0|  0.00%|                        checked_value = checked_member_dict[key]
  2041|         0|            0|            0|  0.00%|                        simple_value = simple_member_dict[key]
  2042|         0|            0|            0|  0.00%|                        if checked_value != simple_value:
  2043|         0|            0|            0|  0.00%|                            failed_member.append("%r:\n         %s\n         %s" % (
  2044|         0|            0|            0|  0.00%|                                    key,
  2045|         0|            0|            0|  0.00%|                                    "checked member -> %r" % (checked_value, ),
  2046|         0|            0|            0|  0.00%|                                    "simple member  -> %r" % (simple_value, ),
  2047|         0|            0|            0|  0.00%|                                    ))
  2048|         0|            0|            0|  0.00%|            if failed_member:
  2049|         0|            0|            0|  0.00%|                failed.append('%r member mismatch:\n      %s' % (
  2050|         0|            0|            0|  0.00%|                        name, '\n      '.join(failed_member),
  2051|         0|            0|            0|  0.00%|                        ))
  2052|         0|            0|            0|  0.00%|        for method in (
  2053|         0|            0|            0|  0.00%|                '__str__', '__repr__', '__reduce_ex__', '__format__',
  2054|         0|            0|            0|  0.00%|                '__getnewargs_ex__', '__getnewargs__', '__reduce_ex__', '__reduce__'
  2055|         0|            0|            0|  0.00%|            ):
  2056|         0|            0|            0|  0.00%|            if method in simple_keys and method in checked_keys:
  2057|         0|            0|            0|  0.00%|                # cannot compare functions, and it exists in both, so we're good
  2058|         0|            0|            0|  0.00%|                continue
  2059|         0|            0|            0|  0.00%|            elif method not in simple_keys and method not in checked_keys:
  2060|         0|            0|            0|  0.00%|                # method is inherited -- check it out
  2061|         0|            0|            0|  0.00%|                checked_method = getattr(checked_enum, method, None)
  2062|         0|            0|            0|  0.00%|                simple_method = getattr(simple_enum, method, None)
  2063|         0|            0|            0|  0.00%|                if hasattr(checked_method, '__func__'):
  2064|         0|            0|            0|  0.00%|                    checked_method = checked_method.__func__
  2065|         0|            0|            0|  0.00%|                    simple_method = simple_method.__func__
  2066|         0|            0|            0|  0.00%|                if checked_method != simple_method:
  2067|         0|            0|            0|  0.00%|                    failed.append("%r:  %-30s %s" % (
  2068|         0|            0|            0|  0.00%|                            method,
  2069|         0|            0|            0|  0.00%|                            "checked -> %r" % (checked_method, ),
  2070|         0|            0|            0|  0.00%|                            "simple -> %r" % (simple_method, ),
  2071|         0|            0|            0|  0.00%|                            ))
  2072|         0|            0|            0|  0.00%|            else:
  2073|         0|            0|            0|  0.00%|                # if the method existed in only one of the enums, it will have been caught
  2074|         0|            0|            0|  0.00%|                # in the first checks above
  2075|         0|            0|            0|  0.00%|                pass
  2076|         0|            0|            0|  0.00%|    if failed:
  2077|         0|            0|            0|  0.00%|        raise TypeError('enum mismatch:\n   %s' % '\n   '.join(failed))
  2078|         0|            0|            0|  0.00%|
  2079|         0|            0|            0|  0.00%|def _old_convert_(etype, name, module, filter, source=None, *, boundary=None):
  2080|         0|            0|            0|  0.00%|    """
  2081|         0|            0|            0|  0.00%|    Create a new Enum subclass that replaces a collection of global constants
  2082|         0|            0|            0|  0.00%|    """
  2083|         0|            0|            0|  0.00%|    # convert all constants from source (or module) that pass filter() to
  2084|         0|            0|            0|  0.00%|    # a new Enum called name, and export the enum and its members back to
  2085|         0|            0|            0|  0.00%|    # module;
  2086|         0|            0|            0|  0.00%|    # also, replace the __reduce_ex__ method so unpickling works in
  2087|         0|            0|            0|  0.00%|    # previous Python versions
  2088|         0|            0|            0|  0.00%|    module_globals = sys.modules[module].__dict__
  2089|         0|            0|            0|  0.00%|    if source:
  2090|         0|            0|            0|  0.00%|        source = source.__dict__
  2091|         0|            0|            0|  0.00%|    else:
  2092|         0|            0|            0|  0.00%|        source = module_globals
  2093|         0|            0|            0|  0.00%|    # _value2member_map_ is populated in the same order every time
  2094|         0|            0|            0|  0.00%|    # for a consistent reverse mapping of number to name when there
  2095|         0|            0|            0|  0.00%|    # are multiple names for the same number.
  2096|         0|            0|            0|  0.00%|    members = [
  2097|         0|            0|            0|  0.00%|            (name, value)
  2098|         0|            0|            0|  0.00%|            for name, value in source.items()
  2099|         0|            0|            0|  0.00%|            if filter(name)]
  2100|         0|            0|            0|  0.00%|    try:
  2101|         0|            0|            0|  0.00%|        # sort by value
  2102|         0|            0|            0|  0.00%|        members.sort(key=lambda t: (t[1], t[0]))
  2103|         0|            0|            0|  0.00%|    except TypeError:
  2104|         0|            0|            0|  0.00%|        # unless some values aren't comparable, in which case sort by name
  2105|         0|            0|            0|  0.00%|        members.sort(key=lambda t: t[0])
  2106|         0|            0|            0|  0.00%|    cls = etype(name, members, module=module, boundary=boundary or KEEP)
  2107|         0|            0|            0|  0.00%|    return cls
  2108|         0|            0|            0|  0.00%|
  2109|         0|            0|            0|  0.00%|_stdlib_enums = IntEnum, StrEnum, IntFlag
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_utils.py
File duration: 0.000317812s (0.33%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Bucket of reusable internal utilities.
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|This should be reduced as much as possible with functions only used in one place, moved to that place.
     4|         0|            0|            0|  0.00%|"""
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|from __future__ import annotations as _annotations
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|import dataclasses
     9|         0|            0|            0|  0.00%|import keyword
    10|         0|            0|            0|  0.00%|import typing
    11|         0|            0|            0|  0.00%|import weakref
    12|         0|            0|            0|  0.00%|from collections import OrderedDict, defaultdict, deque
    13|         0|            0|            0|  0.00%|from copy import deepcopy
    14|         0|            0|            0|  0.00%|from itertools import zip_longest
    15|         0|            0|            0|  0.00%|from types import BuiltinFunctionType, CodeType, FunctionType, GeneratorType, LambdaType, ModuleType
    16|         0|            0|            0|  0.00%|from typing import Any, Mapping, TypeVar
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|from typing_extensions import TypeAlias, TypeGuard
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|from . import _repr, _typing_extra
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|if typing.TYPE_CHECKING:
    23|         0|            0|            0|  0.00%|    MappingIntStrAny: TypeAlias = 'typing.Mapping[int, Any] | typing.Mapping[str, Any]'
    24|         0|            0|            0|  0.00%|    AbstractSetIntStr: TypeAlias = 'typing.AbstractSet[int] | typing.AbstractSet[str]'
    25|         0|            0|            0|  0.00%|    from ..main import BaseModel
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|# these are types that are returned unchanged by deepcopy
    29|         0|            0|            0|  0.00%|IMMUTABLE_NON_COLLECTIONS_TYPES: set[type[Any]] = {
    30|         0|            0|            0|  0.00%|    int,
    31|         0|            0|            0|  0.00%|    float,
    32|         0|            0|            0|  0.00%|    complex,
    33|         0|            0|            0|  0.00%|    str,
    34|         0|            0|            0|  0.00%|    bool,
    35|         0|            0|            0|  0.00%|    bytes,
    36|         0|            0|            0|  0.00%|    type,
    37|         0|            0|            0|  0.00%|    _typing_extra.NoneType,
    38|         0|            0|            0|  0.00%|    FunctionType,
    39|         0|            0|            0|  0.00%|    BuiltinFunctionType,
    40|         0|            0|            0|  0.00%|    LambdaType,
    41|         0|            0|            0|  0.00%|    weakref.ref,
    42|         0|            0|            0|  0.00%|    CodeType,
    43|         0|            0|            0|  0.00%|    # note: including ModuleType will differ from behaviour of deepcopy by not producing error.
    44|         0|            0|            0|  0.00%|    # It might be not a good idea in general, but considering that this function used only internally
    45|         0|            0|            0|  0.00%|    # against default values of fields, this will allow to actually have a field with module as default value
    46|         0|            0|            0|  0.00%|    ModuleType,
    47|         0|            0|            0|  0.00%|    NotImplemented.__class__,
    48|         0|            0|            0|  0.00%|    Ellipsis.__class__,
    49|         0|            0|            0|  0.00%|}
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|# these are types that if empty, might be copied with simple copy() instead of deepcopy()
    52|         0|            0|            0|  0.00%|BUILTIN_COLLECTIONS: set[type[Any]] = {
    53|         0|            0|            0|  0.00%|    list,
    54|         0|            0|            0|  0.00%|    set,
    55|         0|            0|            0|  0.00%|    tuple,
    56|         0|            0|            0|  0.00%|    frozenset,
    57|         0|            0|            0|  0.00%|    dict,
    58|         0|            0|            0|  0.00%|    OrderedDict,
    59|         0|            0|            0|  0.00%|    defaultdict,
    60|         0|            0|            0|  0.00%|    deque,
    61|         0|            0|            0|  0.00%|}
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|def sequence_like(v: Any) -> bool:
    65|         0|            0|            0|  0.00%|    return isinstance(v, (list, tuple, set, frozenset, GeneratorType, deque))
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|def lenient_isinstance(o: Any, class_or_tuple: type[Any] | tuple[type[Any], ...] | None) -> bool:  # pragma: no cover
    69|         0|            0|            0|  0.00%|    try:
    70|         0|            0|            0|  0.00%|        return isinstance(o, class_or_tuple)  # type: ignore[arg-type]
    71|         0|            0|            0|  0.00%|    except TypeError:
    72|         0|            0|            0|  0.00%|        return False
    73|         0|            0|            0|  0.00%|
    74|         0|            0|            0|  0.00%|
    75|        40|  8.63075e-05|  2.15769e-06|  0.09%|def lenient_issubclass(cls: Any, class_or_tuple: Any) -> bool:  # pragma: no cover
    76|        40|  6.07967e-05|  1.51992e-06|  0.06%|    try:
    77|        40|  0.000170708|  4.26769e-06|  0.18%|        return isinstance(cls, type) and issubclass(cls, class_or_tuple)
(call)|        23|  0.000195742|  8.51051e-06|  0.20%|# <frozen abc>:121 __subclasscheck__
(call)|         3|  0.000810623|  0.000270208|  0.83%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:1465 __subclasscheck__
    78|         0|            0|            0|  0.00%|    except TypeError:
    79|         0|            0|            0|  0.00%|        if isinstance(cls, _typing_extra.WithArgsTypes):
    80|         0|            0|            0|  0.00%|            return False
    81|         0|            0|            0|  0.00%|        raise  # pragma: no cover
    82|         0|            0|            0|  0.00%|
    83|         0|            0|            0|  0.00%|
    84|         0|            0|            0|  0.00%|def is_model_class(cls: Any) -> TypeGuard[type[BaseModel]]:
    85|         0|            0|            0|  0.00%|    """Returns true if cls is a _proper_ subclass of BaseModel, and provides proper type-checking,
    86|         0|            0|            0|  0.00%|    unlike raw calls to lenient_issubclass.
    87|         0|            0|            0|  0.00%|    """
    88|         0|            0|            0|  0.00%|    from ..main import BaseModel
    89|         0|            0|            0|  0.00%|
    90|         0|            0|            0|  0.00%|    return lenient_issubclass(cls, BaseModel) and cls is not BaseModel
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|def is_valid_identifier(identifier: str) -> bool:
    94|         0|            0|            0|  0.00%|    """Checks that a string is a valid identifier and not a Python keyword.
    95|         0|            0|            0|  0.00%|    :param identifier: The identifier to test.
    96|         0|            0|            0|  0.00%|    :return: True if the identifier is valid.
    97|         0|            0|            0|  0.00%|    """
    98|         0|            0|            0|  0.00%|    return identifier.isidentifier() and not keyword.iskeyword(identifier)
    99|         0|            0|            0|  0.00%|
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|KeyType = TypeVar('KeyType')
   102|         0|            0|            0|  0.00%|
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|def deep_update(mapping: dict[KeyType, Any], *updating_mappings: dict[KeyType, Any]) -> dict[KeyType, Any]:
   105|         0|            0|            0|  0.00%|    updated_mapping = mapping.copy()
   106|         0|            0|            0|  0.00%|    for updating_mapping in updating_mappings:
   107|         0|            0|            0|  0.00%|        for k, v in updating_mapping.items():
   108|         0|            0|            0|  0.00%|            if k in updated_mapping and isinstance(updated_mapping[k], dict) and isinstance(v, dict):
   109|         0|            0|            0|  0.00%|                updated_mapping[k] = deep_update(updated_mapping[k], v)
   110|         0|            0|            0|  0.00%|            else:
   111|         0|            0|            0|  0.00%|                updated_mapping[k] = v
   112|         0|            0|            0|  0.00%|    return updated_mapping
   113|         0|            0|            0|  0.00%|
   114|         0|            0|            0|  0.00%|
   115|         0|            0|            0|  0.00%|def update_not_none(mapping: dict[Any, Any], **update: Any) -> None:
   116|         0|            0|            0|  0.00%|    mapping.update({k: v for k, v in update.items() if v is not None})
   117|         0|            0|            0|  0.00%|
   118|         0|            0|            0|  0.00%|
   119|         0|            0|            0|  0.00%|T = TypeVar('T')
   120|         0|            0|            0|  0.00%|
   121|         0|            0|            0|  0.00%|
   122|         0|            0|            0|  0.00%|def unique_list(
   123|         0|            0|            0|  0.00%|    input_list: list[T] | tuple[T, ...],
   124|         0|            0|            0|  0.00%|    *,
   125|         0|            0|            0|  0.00%|    name_factory: typing.Callable[[T], str] = str,
   126|         0|            0|            0|  0.00%|) -> list[T]:
   127|         0|            0|            0|  0.00%|    """Make a list unique while maintaining order.
   128|         0|            0|            0|  0.00%|    We update the list if another one with the same name is set
   129|         0|            0|            0|  0.00%|    (e.g. model validator overridden in subclass).
   130|         0|            0|            0|  0.00%|    """
   131|         0|            0|            0|  0.00%|    result: list[T] = []
   132|         0|            0|            0|  0.00%|    result_names: list[str] = []
   133|         0|            0|            0|  0.00%|    for v in input_list:
   134|         0|            0|            0|  0.00%|        v_name = name_factory(v)
   135|         0|            0|            0|  0.00%|        if v_name not in result_names:
   136|         0|            0|            0|  0.00%|            result_names.append(v_name)
   137|         0|            0|            0|  0.00%|            result.append(v)
   138|         0|            0|            0|  0.00%|        else:
   139|         0|            0|            0|  0.00%|            result[result_names.index(v_name)] = v
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|    return result
   142|         0|            0|            0|  0.00%|
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|class ValueItems(_repr.Representation):
   145|         0|            0|            0|  0.00%|    """Class for more convenient calculation of excluded or included fields on values."""
   146|         0|            0|            0|  0.00%|
   147|         0|            0|            0|  0.00%|    __slots__ = ('_items', '_type')
   148|         0|            0|            0|  0.00%|
   149|         0|            0|            0|  0.00%|    def __init__(self, value: Any, items: AbstractSetIntStr | MappingIntStrAny) -> None:
   150|         0|            0|            0|  0.00%|        items = self._coerce_items(items)
   151|         0|            0|            0|  0.00%|
   152|         0|            0|            0|  0.00%|        if isinstance(value, (list, tuple)):
   153|         0|            0|            0|  0.00%|            items = self._normalize_indexes(items, len(value))  # type: ignore
   154|         0|            0|            0|  0.00%|
   155|         0|            0|            0|  0.00%|        self._items: MappingIntStrAny = items  # type: ignore
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|    def is_excluded(self, item: Any) -> bool:
   158|         0|            0|            0|  0.00%|        """Check if item is fully excluded.
   159|         0|            0|            0|  0.00%|
   160|         0|            0|            0|  0.00%|        :param item: key or index of a value
   161|         0|            0|            0|  0.00%|        """
   162|         0|            0|            0|  0.00%|        return self.is_true(self._items.get(item))
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|    def is_included(self, item: Any) -> bool:
   165|         0|            0|            0|  0.00%|        """Check if value is contained in self._items.
   166|         0|            0|            0|  0.00%|
   167|         0|            0|            0|  0.00%|        :param item: key or index of value
   168|         0|            0|            0|  0.00%|        """
   169|         0|            0|            0|  0.00%|        return item in self._items
   170|         0|            0|            0|  0.00%|
   171|         0|            0|            0|  0.00%|    def for_element(self, e: int | str) -> AbstractSetIntStr | MappingIntStrAny | None:
   172|         0|            0|            0|  0.00%|        """:param e: key or index of element on value
   173|         0|            0|            0|  0.00%|        :return: raw values for element if self._items is dict and contain needed element
   174|         0|            0|            0|  0.00%|        """
   175|         0|            0|            0|  0.00%|        item = self._items.get(e)  # type: ignore
   176|         0|            0|            0|  0.00%|        return item if not self.is_true(item) else None
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|    def _normalize_indexes(self, items: MappingIntStrAny, v_length: int) -> dict[int | str, Any]:
   179|         0|            0|            0|  0.00%|        """:param items: dict or set of indexes which will be normalized
   180|         0|            0|            0|  0.00%|        :param v_length: length of sequence indexes of which will be
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|        >>> self._normalize_indexes({0: True, -2: True, -1: True}, 4)
   183|         0|            0|            0|  0.00%|        {0: True, 2: True, 3: True}
   184|         0|            0|            0|  0.00%|        >>> self._normalize_indexes({'__all__': True}, 4)
   185|         0|            0|            0|  0.00%|        {0: True, 1: True, 2: True, 3: True}
   186|         0|            0|            0|  0.00%|        """
   187|         0|            0|            0|  0.00%|        normalized_items: dict[int | str, Any] = {}
   188|         0|            0|            0|  0.00%|        all_items = None
   189|         0|            0|            0|  0.00%|        for i, v in items.items():
   190|         0|            0|            0|  0.00%|            if not (isinstance(v, typing.Mapping) or isinstance(v, typing.AbstractSet) or self.is_true(v)):
   191|         0|            0|            0|  0.00%|                raise TypeError(f'Unexpected type of exclude value for index "{i}" {v.__class__}')
   192|         0|            0|            0|  0.00%|            if i == '__all__':
   193|         0|            0|            0|  0.00%|                all_items = self._coerce_value(v)
   194|         0|            0|            0|  0.00%|                continue
   195|         0|            0|            0|  0.00%|            if not isinstance(i, int):
   196|         0|            0|            0|  0.00%|                raise TypeError(
   197|         0|            0|            0|  0.00%|                    'Excluding fields from a sequence of sub-models or dicts must be performed index-wise: '
   198|         0|            0|            0|  0.00%|                    'expected integer keys or keyword "__all__"'
   199|         0|            0|            0|  0.00%|                )
   200|         0|            0|            0|  0.00%|            normalized_i = v_length + i if i < 0 else i
   201|         0|            0|            0|  0.00%|            normalized_items[normalized_i] = self.merge(v, normalized_items.get(normalized_i))
   202|         0|            0|            0|  0.00%|
   203|         0|            0|            0|  0.00%|        if not all_items:
   204|         0|            0|            0|  0.00%|            return normalized_items
   205|         0|            0|            0|  0.00%|        if self.is_true(all_items):
   206|         0|            0|            0|  0.00%|            for i in range(v_length):
   207|         0|            0|            0|  0.00%|                normalized_items.setdefault(i, ...)
   208|         0|            0|            0|  0.00%|            return normalized_items
   209|         0|            0|            0|  0.00%|        for i in range(v_length):
   210|         0|            0|            0|  0.00%|            normalized_item = normalized_items.setdefault(i, {})
   211|         0|            0|            0|  0.00%|            if not self.is_true(normalized_item):
   212|         0|            0|            0|  0.00%|                normalized_items[i] = self.merge(all_items, normalized_item)
   213|         0|            0|            0|  0.00%|        return normalized_items
   214|         0|            0|            0|  0.00%|
   215|         0|            0|            0|  0.00%|    @classmethod
   216|         0|            0|            0|  0.00%|    def merge(cls, base: Any, override: Any, intersect: bool = False) -> Any:
   217|         0|            0|            0|  0.00%|        """Merge a `base` item with an `override` item.
   218|         0|            0|            0|  0.00%|
   219|         0|            0|            0|  0.00%|        Both `base` and `override` are converted to dictionaries if possible.
   220|         0|            0|            0|  0.00%|        Sets are converted to dictionaries with the sets entries as keys and
   221|         0|            0|            0|  0.00%|        Ellipsis as values.
   222|         0|            0|            0|  0.00%|
   223|         0|            0|            0|  0.00%|        Each key-value pair existing in `base` is merged with `override`,
   224|         0|            0|            0|  0.00%|        while the rest of the key-value pairs are updated recursively with this function.
   225|         0|            0|            0|  0.00%|
   226|         0|            0|            0|  0.00%|        Merging takes place based on the "union" of keys if `intersect` is
   227|         0|            0|            0|  0.00%|        set to `False` (default) and on the intersection of keys if
   228|         0|            0|            0|  0.00%|        `intersect` is set to `True`.
   229|         0|            0|            0|  0.00%|        """
   230|         0|            0|            0|  0.00%|        override = cls._coerce_value(override)
   231|         0|            0|            0|  0.00%|        base = cls._coerce_value(base)
   232|         0|            0|            0|  0.00%|        if override is None:
   233|         0|            0|            0|  0.00%|            return base
   234|         0|            0|            0|  0.00%|        if cls.is_true(base) or base is None:
   235|         0|            0|            0|  0.00%|            return override
   236|         0|            0|            0|  0.00%|        if cls.is_true(override):
   237|         0|            0|            0|  0.00%|            return base if intersect else override
   238|         0|            0|            0|  0.00%|
   239|         0|            0|            0|  0.00%|        # intersection or union of keys while preserving ordering:
   240|         0|            0|            0|  0.00%|        if intersect:
   241|         0|            0|            0|  0.00%|            merge_keys = [k for k in base if k in override] + [k for k in override if k in base]
   242|         0|            0|            0|  0.00%|        else:
   243|         0|            0|            0|  0.00%|            merge_keys = list(base) + [k for k in override if k not in base]
   244|         0|            0|            0|  0.00%|
   245|         0|            0|            0|  0.00%|        merged: dict[int | str, Any] = {}
   246|         0|            0|            0|  0.00%|        for k in merge_keys:
   247|         0|            0|            0|  0.00%|            merged_item = cls.merge(base.get(k), override.get(k), intersect=intersect)
   248|         0|            0|            0|  0.00%|            if merged_item is not None:
   249|         0|            0|            0|  0.00%|                merged[k] = merged_item
   250|         0|            0|            0|  0.00%|
   251|         0|            0|            0|  0.00%|        return merged
   252|         0|            0|            0|  0.00%|
   253|         0|            0|            0|  0.00%|    @staticmethod
   254|         0|            0|            0|  0.00%|    def _coerce_items(items: AbstractSetIntStr | MappingIntStrAny) -> MappingIntStrAny:
   255|         0|            0|            0|  0.00%|        if isinstance(items, typing.Mapping):
   256|         0|            0|            0|  0.00%|            pass
   257|         0|            0|            0|  0.00%|        elif isinstance(items, typing.AbstractSet):
   258|         0|            0|            0|  0.00%|            items = dict.fromkeys(items, ...)  # type: ignore
   259|         0|            0|            0|  0.00%|        else:
   260|         0|            0|            0|  0.00%|            class_name = getattr(items, '__class__', '???')
   261|         0|            0|            0|  0.00%|            raise TypeError(f'Unexpected type of exclude value {class_name}')
   262|         0|            0|            0|  0.00%|        return items  # type: ignore
   263|         0|            0|            0|  0.00%|
   264|         0|            0|            0|  0.00%|    @classmethod
   265|         0|            0|            0|  0.00%|    def _coerce_value(cls, value: Any) -> Any:
   266|         0|            0|            0|  0.00%|        if value is None or cls.is_true(value):
   267|         0|            0|            0|  0.00%|            return value
   268|         0|            0|            0|  0.00%|        return cls._coerce_items(value)
   269|         0|            0|            0|  0.00%|
   270|         0|            0|            0|  0.00%|    @staticmethod
   271|         0|            0|            0|  0.00%|    def is_true(v: Any) -> bool:
   272|         0|            0|            0|  0.00%|        return v is True or v is ...
   273|         0|            0|            0|  0.00%|
   274|         0|            0|            0|  0.00%|    def __repr_args__(self) -> _repr.ReprArgs:
   275|         0|            0|            0|  0.00%|        return [(None, self._items)]
   276|         0|            0|            0|  0.00%|
   277|         0|            0|            0|  0.00%|
   278|         0|            0|            0|  0.00%|if typing.TYPE_CHECKING:
   279|         0|            0|            0|  0.00%|
   280|         0|            0|            0|  0.00%|    def ClassAttribute(name: str, value: T) -> T: ...
   281|         0|            0|            0|  0.00%|
   282|         0|            0|            0|  0.00%|else:
   283|         0|            0|            0|  0.00%|
   284|         0|            0|            0|  0.00%|    class ClassAttribute:
   285|         0|            0|            0|  0.00%|        """Hide class attribute from its instances."""
   286|         0|            0|            0|  0.00%|
   287|         0|            0|            0|  0.00%|        __slots__ = 'name', 'value'
   288|         0|            0|            0|  0.00%|
   289|         0|            0|            0|  0.00%|        def __init__(self, name: str, value: Any) -> None:
   290|         0|            0|            0|  0.00%|            self.name = name
   291|         0|            0|            0|  0.00%|            self.value = value
   292|         0|            0|            0|  0.00%|
   293|         0|            0|            0|  0.00%|        def __get__(self, instance: Any, owner: type[Any]) -> None:
   294|         0|            0|            0|  0.00%|            if instance is None:
   295|         0|            0|            0|  0.00%|                return self.value
   296|         0|            0|            0|  0.00%|            raise AttributeError(f'{self.name!r} attribute of {owner.__name__!r} is class-only')
   297|         0|            0|            0|  0.00%|
   298|         0|            0|            0|  0.00%|
   299|         0|            0|            0|  0.00%|Obj = TypeVar('Obj')
   300|         0|            0|            0|  0.00%|
   301|         0|            0|            0|  0.00%|
   302|         0|            0|            0|  0.00%|def smart_deepcopy(obj: Obj) -> Obj:
   303|         0|            0|            0|  0.00%|    """Return type as is for immutable built-in types
   304|         0|            0|            0|  0.00%|    Use obj.copy() for built-in empty collections
   305|         0|            0|            0|  0.00%|    Use copy.deepcopy() for non-empty collections and unknown objects.
   306|         0|            0|            0|  0.00%|    """
   307|         0|            0|            0|  0.00%|    obj_type = obj.__class__
   308|         0|            0|            0|  0.00%|    if obj_type in IMMUTABLE_NON_COLLECTIONS_TYPES:
   309|         0|            0|            0|  0.00%|        return obj  # fastest case: obj is immutable and not collection therefore will not be copied anyway
   310|         0|            0|            0|  0.00%|    try:
   311|         0|            0|            0|  0.00%|        if not obj and obj_type in BUILTIN_COLLECTIONS:
   312|         0|            0|            0|  0.00%|            # faster way for empty collections, no need to copy its members
   313|         0|            0|            0|  0.00%|            return obj if obj_type is tuple else obj.copy()  # tuple doesn't have copy method  # type: ignore
   314|         0|            0|            0|  0.00%|    except (TypeError, ValueError, RuntimeError):
   315|         0|            0|            0|  0.00%|        # do we really dare to catch ALL errors? Seems a bit risky
   316|         0|            0|            0|  0.00%|        pass
   317|         0|            0|            0|  0.00%|
   318|         0|            0|            0|  0.00%|    return deepcopy(obj)  # slowest way when we actually might need a deepcopy
   319|         0|            0|            0|  0.00%|
   320|         0|            0|            0|  0.00%|
   321|         0|            0|            0|  0.00%|_SENTINEL = object()
   322|         0|            0|            0|  0.00%|
   323|         0|            0|            0|  0.00%|
   324|         0|            0|            0|  0.00%|def all_identical(left: typing.Iterable[Any], right: typing.Iterable[Any]) -> bool:
   325|         0|            0|            0|  0.00%|    """Check that the items of `left` are the same objects as those in `right`.
   326|         0|            0|            0|  0.00%|
   327|         0|            0|            0|  0.00%|    >>> a, b = object(), object()
   328|         0|            0|            0|  0.00%|    >>> all_identical([a, b, a], [a, b, a])
   329|         0|            0|            0|  0.00%|    True
   330|         0|            0|            0|  0.00%|    >>> all_identical([a, b, [a]], [a, b, [a]])  # new list object, while "equal" is not "identical"
   331|         0|            0|            0|  0.00%|    False
   332|         0|            0|            0|  0.00%|    """
   333|         0|            0|            0|  0.00%|    for left_item, right_item in zip_longest(left, right, fillvalue=_SENTINEL):
   334|         0|            0|            0|  0.00%|        if left_item is not right_item:
   335|         0|            0|            0|  0.00%|            return False
   336|         0|            0|            0|  0.00%|    return True
   337|         0|            0|            0|  0.00%|
   338|         0|            0|            0|  0.00%|
   339|         0|            0|            0|  0.00%|@dataclasses.dataclass(frozen=True)
   340|         0|            0|            0|  0.00%|class SafeGetItemProxy:
   341|         0|            0|            0|  0.00%|    """Wrapper redirecting `__getitem__` to `get` with a sentinel value as default
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|    This makes is safe to use in `operator.itemgetter` when some keys may be missing
   344|         0|            0|            0|  0.00%|    """
   345|         0|            0|            0|  0.00%|
   346|         0|            0|            0|  0.00%|    # Define __slots__manually for performances
   347|         0|            0|            0|  0.00%|    # @dataclasses.dataclass() only support slots=True in python>=3.10
   348|         0|            0|            0|  0.00%|    __slots__ = ('wrapped',)
   349|         0|            0|            0|  0.00%|
   350|         0|            0|            0|  0.00%|    wrapped: Mapping[str, Any]
   351|         0|            0|            0|  0.00%|
   352|         0|            0|            0|  0.00%|    def __getitem__(self, key: str, /) -> Any:
   353|         0|            0|            0|  0.00%|        return self.wrapped.get(key, _SENTINEL)
   354|         0|            0|            0|  0.00%|
   355|         0|            0|            0|  0.00%|    # required to pass the object to operator.itemgetter() instances due to a quirk of typeshed
   356|         0|            0|            0|  0.00%|    # https://github.com/python/mypy/issues/13713
   357|         0|            0|            0|  0.00%|    # https://github.com/python/typeshed/pull/8785
   358|         0|            0|            0|  0.00%|    # Since this is typing-only, hide it in a typing.TYPE_CHECKING block
   359|         0|            0|            0|  0.00%|    if typing.TYPE_CHECKING:
   360|         0|            0|            0|  0.00%|
   361|         0|            0|            0|  0.00%|        def __contains__(self, key: str, /) -> bool:
   362|         0|            0|            0|  0.00%|            return self.wrapped.__contains__(key)
File: <frozen _collections_abc>
File duration: 0.000303984s (0.31%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|
    44|         0|            0|            0|  0.00%|
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|
    48|         0|            0|            0|  0.00%|
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|
    54|         0|            0|            0|  0.00%|
    55|         0|            0|            0|  0.00%|
    56|         0|            0|            0|  0.00%|
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|
    69|         0|            0|            0|  0.00%|
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|
    72|         0|            0|            0|  0.00%|
    73|         0|            0|            0|  0.00%|
    74|         0|            0|            0|  0.00%|
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|
    83|         0|            0|            0|  0.00%|
    84|         0|            0|            0|  0.00%|
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|
    87|         0|            0|            0|  0.00%|
    88|         0|            0|            0|  0.00%|
    89|         0|            0|            0|  0.00%|
    90|         0|            0|            0|  0.00%|
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|
   106|         0|            0|            0|  0.00%|
   107|         0|            0|            0|  0.00%|
   108|         0|            0|            0|  0.00%|
   109|         0|            0|            0|  0.00%|
   110|         0|            0|            0|  0.00%|
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|
   113|         0|            0|            0|  0.00%|
   114|         0|            0|            0|  0.00%|
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|
   117|         0|            0|            0|  0.00%|
   118|         0|            0|            0|  0.00%|
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|
   121|         0|            0|            0|  0.00%|
   122|         0|            0|            0|  0.00%|
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|
   125|         0|            0|            0|  0.00%|
   126|         0|            0|            0|  0.00%|
   127|         0|            0|            0|  0.00%|
   128|         0|            0|            0|  0.00%|
   129|         0|            0|            0|  0.00%|
   130|         0|            0|            0|  0.00%|
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|
   133|         0|            0|            0|  0.00%|
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|
   136|         0|            0|            0|  0.00%|
   137|         0|            0|            0|  0.00%|
   138|         0|            0|            0|  0.00%|
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|
   142|         0|            0|            0|  0.00%|
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|
   145|         0|            0|            0|  0.00%|
   146|         0|            0|            0|  0.00%|
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|
   149|         0|            0|            0|  0.00%|
   150|         0|            0|            0|  0.00%|
   151|         0|            0|            0|  0.00%|
   152|         0|            0|            0|  0.00%|
   153|         0|            0|            0|  0.00%|
   154|         0|            0|            0|  0.00%|
   155|         0|            0|            0|  0.00%|
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|
   158|         0|            0|            0|  0.00%|
   159|         0|            0|            0|  0.00%|
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|
   167|         0|            0|            0|  0.00%|
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|
   170|         0|            0|            0|  0.00%|
   171|         0|            0|            0|  0.00%|
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|
   175|         0|            0|            0|  0.00%|
   176|         0|            0|            0|  0.00%|
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|
   179|         0|            0|            0|  0.00%|
   180|         0|            0|            0|  0.00%|
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|
   184|         0|            0|            0|  0.00%|
   185|         0|            0|            0|  0.00%|
   186|         0|            0|            0|  0.00%|
   187|         0|            0|            0|  0.00%|
   188|         0|            0|            0|  0.00%|
   189|         0|            0|            0|  0.00%|
   190|         0|            0|            0|  0.00%|
   191|         0|            0|            0|  0.00%|
   192|         0|            0|            0|  0.00%|
   193|         0|            0|            0|  0.00%|
   194|         0|            0|            0|  0.00%|
   195|         0|            0|            0|  0.00%|
   196|         0|            0|            0|  0.00%|
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|
   199|         0|            0|            0|  0.00%|
   200|         0|            0|            0|  0.00%|
   201|         0|            0|            0|  0.00%|
   202|         0|            0|            0|  0.00%|
   203|         0|            0|            0|  0.00%|
   204|         0|            0|            0|  0.00%|
   205|         0|            0|            0|  0.00%|
   206|         0|            0|            0|  0.00%|
   207|         0|            0|            0|  0.00%|
   208|         0|            0|            0|  0.00%|
   209|         0|            0|            0|  0.00%|
   210|         0|            0|            0|  0.00%|
   211|         0|            0|            0|  0.00%|
   212|         0|            0|            0|  0.00%|
   213|         0|            0|            0|  0.00%|
   214|         0|            0|            0|  0.00%|
   215|         0|            0|            0|  0.00%|
   216|         0|            0|            0|  0.00%|
   217|         0|            0|            0|  0.00%|
   218|         0|            0|            0|  0.00%|
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|
   221|         0|            0|            0|  0.00%|
   222|         0|            0|            0|  0.00%|
   223|         0|            0|            0|  0.00%|
   224|         0|            0|            0|  0.00%|
   225|         0|            0|            0|  0.00%|
   226|         0|            0|            0|  0.00%|
   227|         0|            0|            0|  0.00%|
   228|         0|            0|            0|  0.00%|
   229|         0|            0|            0|  0.00%|
   230|         0|            0|            0|  0.00%|
   231|         0|            0|            0|  0.00%|
   232|         0|            0|            0|  0.00%|
   233|         0|            0|            0|  0.00%|
   234|         0|            0|            0|  0.00%|
   235|         0|            0|            0|  0.00%|
   236|         0|            0|            0|  0.00%|
   237|         0|            0|            0|  0.00%|
   238|         0|            0|            0|  0.00%|
   239|         0|            0|            0|  0.00%|
   240|         0|            0|            0|  0.00%|
   241|         0|            0|            0|  0.00%|
   242|         0|            0|            0|  0.00%|
   243|         0|            0|            0|  0.00%|
   244|         0|            0|            0|  0.00%|
   245|         0|            0|            0|  0.00%|
   246|         0|            0|            0|  0.00%|
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|
   249|         0|            0|            0|  0.00%|
   250|         0|            0|            0|  0.00%|
   251|         0|            0|            0|  0.00%|
   252|         0|            0|            0|  0.00%|
   253|         0|            0|            0|  0.00%|
   254|         0|            0|            0|  0.00%|
   255|         0|            0|            0|  0.00%|
   256|         0|            0|            0|  0.00%|
   257|         0|            0|            0|  0.00%|
   258|         0|            0|            0|  0.00%|
   259|         0|            0|            0|  0.00%|
   260|         0|            0|            0|  0.00%|
   261|         0|            0|            0|  0.00%|
   262|         0|            0|            0|  0.00%|
   263|         0|            0|            0|  0.00%|
   264|         0|            0|            0|  0.00%|
   265|         0|            0|            0|  0.00%|
   266|         0|            0|            0|  0.00%|
   267|         0|            0|            0|  0.00%|
   268|         0|            0|            0|  0.00%|
   269|         0|            0|            0|  0.00%|
   270|         0|            0|            0|  0.00%|
   271|         0|            0|            0|  0.00%|
   272|         0|            0|            0|  0.00%|
   273|         0|            0|            0|  0.00%|
   274|         0|            0|            0|  0.00%|
   275|         0|            0|            0|  0.00%|
   276|         0|            0|            0|  0.00%|
   277|         0|            0|            0|  0.00%|
   278|         0|            0|            0|  0.00%|
   279|         0|            0|            0|  0.00%|
   280|         0|            0|            0|  0.00%|
   281|         0|            0|            0|  0.00%|
   282|         0|            0|            0|  0.00%|
   283|         0|            0|            0|  0.00%|
   284|         0|            0|            0|  0.00%|
   285|         0|            0|            0|  0.00%|
   286|         0|            0|            0|  0.00%|
   287|         0|            0|            0|  0.00%|
   288|         0|            0|            0|  0.00%|
   289|         0|            0|            0|  0.00%|
   290|         0|            0|            0|  0.00%|
   291|         0|            0|            0|  0.00%|
   292|         0|            0|            0|  0.00%|
   293|         0|            0|            0|  0.00%|
   294|         0|            0|            0|  0.00%|
   295|         0|            0|            0|  0.00%|
   296|         0|            0|            0|  0.00%|
   297|         0|            0|            0|  0.00%|
   298|         0|            0|            0|  0.00%|
   299|         0|            0|            0|  0.00%|
   300|         0|            0|            0|  0.00%|
   301|         0|            0|            0|  0.00%|
   302|         0|            0|            0|  0.00%|
   303|         0|            0|            0|  0.00%|
   304|         0|            0|            0|  0.00%|
   305|         0|            0|            0|  0.00%|
   306|         0|            0|            0|  0.00%|
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|
   309|         0|            0|            0|  0.00%|
   310|         0|            0|            0|  0.00%|
   311|         0|            0|            0|  0.00%|
   312|         0|            0|            0|  0.00%|
   313|         0|            0|            0|  0.00%|
   314|         0|            0|            0|  0.00%|
   315|         0|            0|            0|  0.00%|
   316|         0|            0|            0|  0.00%|
   317|         0|            0|            0|  0.00%|
   318|         0|            0|            0|  0.00%|
   319|         0|            0|            0|  0.00%|
   320|         0|            0|            0|  0.00%|
   321|         0|            0|            0|  0.00%|
   322|         0|            0|            0|  0.00%|
   323|         0|            0|            0|  0.00%|
   324|         0|            0|            0|  0.00%|
   325|         0|            0|            0|  0.00%|
   326|         0|            0|            0|  0.00%|
   327|         0|            0|            0|  0.00%|
   328|         0|            0|            0|  0.00%|
   329|         0|            0|            0|  0.00%|
   330|         0|            0|            0|  0.00%|
   331|         0|            0|            0|  0.00%|
   332|         0|            0|            0|  0.00%|
   333|         0|            0|            0|  0.00%|
   334|         0|            0|            0|  0.00%|
   335|         0|            0|            0|  0.00%|
   336|         0|            0|            0|  0.00%|
   337|         0|            0|            0|  0.00%|
   338|         0|            0|            0|  0.00%|
   339|         0|            0|            0|  0.00%|
   340|         0|            0|            0|  0.00%|
   341|         0|            0|            0|  0.00%|
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|
   344|         0|            0|            0|  0.00%|
   345|         0|            0|            0|  0.00%|
   346|         0|            0|            0|  0.00%|
   347|         0|            0|            0|  0.00%|
   348|         0|            0|            0|  0.00%|
   349|         0|            0|            0|  0.00%|
   350|         0|            0|            0|  0.00%|
   351|         0|            0|            0|  0.00%|
   352|         0|            0|            0|  0.00%|
   353|         0|            0|            0|  0.00%|
   354|         0|            0|            0|  0.00%|
   355|         0|            0|            0|  0.00%|
   356|         0|            0|            0|  0.00%|
   357|         0|            0|            0|  0.00%|
   358|         0|            0|            0|  0.00%|
   359|         0|            0|            0|  0.00%|
   360|         0|            0|            0|  0.00%|
   361|         0|            0|            0|  0.00%|
   362|         0|            0|            0|  0.00%|
   363|         0|            0|            0|  0.00%|
   364|         0|            0|            0|  0.00%|
   365|         0|            0|            0|  0.00%|
   366|         0|            0|            0|  0.00%|
   367|         0|            0|            0|  0.00%|
   368|         0|            0|            0|  0.00%|
   369|         0|            0|            0|  0.00%|
   370|         0|            0|            0|  0.00%|
   371|         0|            0|            0|  0.00%|
   372|         0|            0|            0|  0.00%|
   373|         0|            0|            0|  0.00%|
   374|         0|            0|            0|  0.00%|
   375|         0|            0|            0|  0.00%|
   376|         0|            0|            0|  0.00%|
   377|         0|            0|            0|  0.00%|
   378|         0|            0|            0|  0.00%|
   379|         0|            0|            0|  0.00%|
   380|         0|            0|            0|  0.00%|
   381|         0|            0|            0|  0.00%|
   382|         0|            0|            0|  0.00%|
   383|         0|            0|            0|  0.00%|
   384|         0|            0|            0|  0.00%|
   385|         0|            0|            0|  0.00%|
   386|         0|            0|            0|  0.00%|
   387|         0|            0|            0|  0.00%|
   388|         0|            0|            0|  0.00%|
   389|         0|            0|            0|  0.00%|
   390|         0|            0|            0|  0.00%|
   391|         0|            0|            0|  0.00%|
   392|         0|            0|            0|  0.00%|
   393|         0|            0|            0|  0.00%|
   394|         0|            0|            0|  0.00%|
   395|         0|            0|            0|  0.00%|
   396|         0|            0|            0|  0.00%|
   397|         0|            0|            0|  0.00%|
   398|         0|            0|            0|  0.00%|
   399|         0|            0|            0|  0.00%|
   400|         0|            0|            0|  0.00%|
   401|         0|            0|            0|  0.00%|
   402|         0|            0|            0|  0.00%|
   403|         0|            0|            0|  0.00%|
   404|         0|            0|            0|  0.00%|
   405|         0|            0|            0|  0.00%|
   406|         0|            0|            0|  0.00%|
   407|         0|            0|            0|  0.00%|
   408|         0|            0|            0|  0.00%|
   409|         0|            0|            0|  0.00%|
   410|         0|            0|            0|  0.00%|
   411|         0|            0|            0|  0.00%|
   412|         0|            0|            0|  0.00%|
   413|         0|            0|            0|  0.00%|
   414|         0|            0|            0|  0.00%|
   415|         0|            0|            0|  0.00%|
   416|         0|            0|            0|  0.00%|
   417|         0|            0|            0|  0.00%|
   418|         0|            0|            0|  0.00%|
   419|         0|            0|            0|  0.00%|
   420|         0|            0|            0|  0.00%|
   421|         0|            0|            0|  0.00%|
   422|         0|            0|            0|  0.00%|
   423|         0|            0|            0|  0.00%|
   424|         0|            0|            0|  0.00%|
   425|         0|            0|            0|  0.00%|
   426|         0|            0|            0|  0.00%|
   427|         0|            0|            0|  0.00%|
   428|         0|            0|            0|  0.00%|
   429|         0|            0|            0|  0.00%|
   430|         0|            0|            0|  0.00%|
   431|         0|            0|            0|  0.00%|
   432|         0|            0|            0|  0.00%|
   433|         0|            0|            0|  0.00%|
   434|         0|            0|            0|  0.00%|
   435|        43|  6.98566e-05|  1.62457e-06|  0.07%|
   436|         0|            0|            0|  0.00%|
   437|        43|   8.4877e-05|  1.97388e-06|  0.09%|
   438|         0|            0|            0|  0.00%|
   439|        43|  7.84397e-05|  1.82418e-06|  0.08%|
   440|         0|            0|            0|  0.00%|
   441|         0|            0|            0|  0.00%|
   442|         0|            0|            0|  0.00%|
   443|         0|            0|            0|  0.00%|
   444|         0|            0|            0|  0.00%|
   445|         0|            0|            0|  0.00%|
   446|         0|            0|            0|  0.00%|
   447|         0|            0|            0|  0.00%|
   448|         0|            0|            0|  0.00%|
   449|         0|            0|            0|  0.00%|
   450|         0|            0|            0|  0.00%|
   451|         0|            0|            0|  0.00%|
   452|         0|            0|            0|  0.00%|
   453|         0|            0|            0|  0.00%|
   454|         0|            0|            0|  0.00%|
   455|         0|            0|            0|  0.00%|
   456|         0|            0|            0|  0.00%|
   457|         0|            0|            0|  0.00%|
   458|         0|            0|            0|  0.00%|
   459|         0|            0|            0|  0.00%|
   460|         0|            0|            0|  0.00%|
   461|         0|            0|            0|  0.00%|
   462|         0|            0|            0|  0.00%|
   463|         0|            0|            0|  0.00%|
   464|         0|            0|            0|  0.00%|
   465|         0|            0|            0|  0.00%|
   466|         0|            0|            0|  0.00%|
   467|         0|            0|            0|  0.00%|
   468|         0|            0|            0|  0.00%|
   469|         0|            0|            0|  0.00%|
   470|         0|            0|            0|  0.00%|
   471|         0|            0|            0|  0.00%|
   472|         0|            0|            0|  0.00%|
   473|         0|            0|            0|  0.00%|
   474|         0|            0|            0|  0.00%|
   475|         0|            0|            0|  0.00%|
   476|         0|            0|            0|  0.00%|
   477|         0|            0|            0|  0.00%|
   478|         0|            0|            0|  0.00%|
   479|         0|            0|            0|  0.00%|
   480|         0|            0|            0|  0.00%|
   481|         0|            0|            0|  0.00%|
   482|         0|            0|            0|  0.00%|
   483|         0|            0|            0|  0.00%|
   484|         0|            0|            0|  0.00%|
   485|         0|            0|            0|  0.00%|
   486|         0|            0|            0|  0.00%|
   487|         0|            0|            0|  0.00%|
   488|         0|            0|            0|  0.00%|
   489|         0|            0|            0|  0.00%|
   490|         0|            0|            0|  0.00%|
   491|         0|            0|            0|  0.00%|
   492|         0|            0|            0|  0.00%|
   493|         0|            0|            0|  0.00%|
   494|         0|            0|            0|  0.00%|
   495|         0|            0|            0|  0.00%|
   496|         0|            0|            0|  0.00%|
   497|         0|            0|            0|  0.00%|
   498|         0|            0|            0|  0.00%|
   499|         0|            0|            0|  0.00%|
   500|         0|            0|            0|  0.00%|
   501|         0|            0|            0|  0.00%|
   502|         0|            0|            0|  0.00%|
   503|         0|            0|            0|  0.00%|
   504|         0|            0|            0|  0.00%|
   505|         0|            0|            0|  0.00%|
   506|         0|            0|            0|  0.00%|
   507|         0|            0|            0|  0.00%|
   508|         0|            0|            0|  0.00%|
   509|         0|            0|            0|  0.00%|
   510|         0|            0|            0|  0.00%|
   511|         0|            0|            0|  0.00%|
   512|         0|            0|            0|  0.00%|
   513|         0|            0|            0|  0.00%|
   514|         0|            0|            0|  0.00%|
   515|         0|            0|            0|  0.00%|
   516|         0|            0|            0|  0.00%|
   517|         0|            0|            0|  0.00%|
   518|         0|            0|            0|  0.00%|
   519|         0|            0|            0|  0.00%|
   520|         0|            0|            0|  0.00%|
   521|         0|            0|            0|  0.00%|
   522|         0|            0|            0|  0.00%|
   523|         0|            0|            0|  0.00%|
   524|         0|            0|            0|  0.00%|
   525|         0|            0|            0|  0.00%|
   526|         0|            0|            0|  0.00%|
   527|         0|            0|            0|  0.00%|
   528|         0|            0|            0|  0.00%|
   529|         0|            0|            0|  0.00%|
   530|         0|            0|            0|  0.00%|
   531|         0|            0|            0|  0.00%|
   532|         0|            0|            0|  0.00%|
   533|         0|            0|            0|  0.00%|
   534|         0|            0|            0|  0.00%|
   535|         0|            0|            0|  0.00%|
   536|         0|            0|            0|  0.00%|
   537|         0|            0|            0|  0.00%|
   538|         0|            0|            0|  0.00%|
   539|         0|            0|            0|  0.00%|
   540|         0|            0|            0|  0.00%|
   541|         0|            0|            0|  0.00%|
   542|         0|            0|            0|  0.00%|
   543|         0|            0|            0|  0.00%|
   544|         0|            0|            0|  0.00%|
   545|         0|            0|            0|  0.00%|
   546|         0|            0|            0|  0.00%|
   547|         0|            0|            0|  0.00%|
   548|         0|            0|            0|  0.00%|
   549|         0|            0|            0|  0.00%|
   550|         0|            0|            0|  0.00%|
   551|         0|            0|            0|  0.00%|
   552|         0|            0|            0|  0.00%|
   553|         0|            0|            0|  0.00%|
   554|         0|            0|            0|  0.00%|
   555|         0|            0|            0|  0.00%|
   556|         0|            0|            0|  0.00%|
   557|         0|            0|            0|  0.00%|
   558|         0|            0|            0|  0.00%|
   559|         0|            0|            0|  0.00%|
   560|         0|            0|            0|  0.00%|
   561|         0|            0|            0|  0.00%|
   562|         0|            0|            0|  0.00%|
   563|         0|            0|            0|  0.00%|
   564|         0|            0|            0|  0.00%|
   565|         0|            0|            0|  0.00%|
   566|         0|            0|            0|  0.00%|
   567|         0|            0|            0|  0.00%|
   568|         0|            0|            0|  0.00%|
   569|         0|            0|            0|  0.00%|
   570|         0|            0|            0|  0.00%|
   571|         0|            0|            0|  0.00%|
   572|         0|            0|            0|  0.00%|
   573|         0|            0|            0|  0.00%|
   574|         0|            0|            0|  0.00%|
   575|         0|            0|            0|  0.00%|
   576|         0|            0|            0|  0.00%|
   577|         0|            0|            0|  0.00%|
   578|         0|            0|            0|  0.00%|
   579|         0|            0|            0|  0.00%|
   580|         0|            0|            0|  0.00%|
   581|         0|            0|            0|  0.00%|
   582|         0|            0|            0|  0.00%|
   583|         0|            0|            0|  0.00%|
   584|         0|            0|            0|  0.00%|
   585|         0|            0|            0|  0.00%|
   586|         0|            0|            0|  0.00%|
   587|         0|            0|            0|  0.00%|
   588|         0|            0|            0|  0.00%|
   589|         0|            0|            0|  0.00%|
   590|         0|            0|            0|  0.00%|
   591|         0|            0|            0|  0.00%|
   592|         0|            0|            0|  0.00%|
   593|         0|            0|            0|  0.00%|
   594|         0|            0|            0|  0.00%|
   595|         0|            0|            0|  0.00%|
   596|         0|            0|            0|  0.00%|
   597|         0|            0|            0|  0.00%|
   598|         0|            0|            0|  0.00%|
   599|         0|            0|            0|  0.00%|
   600|         0|            0|            0|  0.00%|
   601|         0|            0|            0|  0.00%|
   602|         0|            0|            0|  0.00%|
   603|         0|            0|            0|  0.00%|
   604|         0|            0|            0|  0.00%|
   605|         0|            0|            0|  0.00%|
   606|         0|            0|            0|  0.00%|
   607|         0|            0|            0|  0.00%|
   608|         0|            0|            0|  0.00%|
   609|         0|            0|            0|  0.00%|
   610|         0|            0|            0|  0.00%|
   611|         0|            0|            0|  0.00%|
   612|         0|            0|            0|  0.00%|
   613|         0|            0|            0|  0.00%|
   614|         0|            0|            0|  0.00%|
   615|         0|            0|            0|  0.00%|
   616|         0|            0|            0|  0.00%|
   617|         0|            0|            0|  0.00%|
   618|         0|            0|            0|  0.00%|
   619|         0|            0|            0|  0.00%|
   620|         0|            0|            0|  0.00%|
   621|         0|            0|            0|  0.00%|
   622|         0|            0|            0|  0.00%|
   623|         0|            0|            0|  0.00%|
   624|         0|            0|            0|  0.00%|
   625|         0|            0|            0|  0.00%|
   626|         0|            0|            0|  0.00%|
   627|         0|            0|            0|  0.00%|
   628|         0|            0|            0|  0.00%|
   629|         0|            0|            0|  0.00%|
   630|         0|            0|            0|  0.00%|
   631|         0|            0|            0|  0.00%|
   632|         0|            0|            0|  0.00%|
   633|         0|            0|            0|  0.00%|
   634|         0|            0|            0|  0.00%|
   635|         0|            0|            0|  0.00%|
   636|         0|            0|            0|  0.00%|
   637|         0|            0|            0|  0.00%|
   638|         0|            0|            0|  0.00%|
   639|         0|            0|            0|  0.00%|
   640|         0|            0|            0|  0.00%|
   641|         0|            0|            0|  0.00%|
   642|         0|            0|            0|  0.00%|
   643|         0|            0|            0|  0.00%|
   644|         0|            0|            0|  0.00%|
   645|         0|            0|            0|  0.00%|
   646|         0|            0|            0|  0.00%|
   647|         0|            0|            0|  0.00%|
   648|         0|            0|            0|  0.00%|
   649|         0|            0|            0|  0.00%|
   650|         0|            0|            0|  0.00%|
   651|         0|            0|            0|  0.00%|
   652|         0|            0|            0|  0.00%|
   653|         0|            0|            0|  0.00%|
   654|         0|            0|            0|  0.00%|
   655|         0|            0|            0|  0.00%|
   656|         0|            0|            0|  0.00%|
   657|         0|            0|            0|  0.00%|
   658|         0|            0|            0|  0.00%|
   659|         0|            0|            0|  0.00%|
   660|         0|            0|            0|  0.00%|
   661|         0|            0|            0|  0.00%|
   662|         0|            0|            0|  0.00%|
   663|         0|            0|            0|  0.00%|
   664|         0|            0|            0|  0.00%|
   665|         0|            0|            0|  0.00%|
   666|         0|            0|            0|  0.00%|
   667|         0|            0|            0|  0.00%|
   668|         0|            0|            0|  0.00%|
   669|         0|            0|            0|  0.00%|
   670|         0|            0|            0|  0.00%|
   671|         0|            0|            0|  0.00%|
   672|         0|            0|            0|  0.00%|
   673|         0|            0|            0|  0.00%|
   674|         0|            0|            0|  0.00%|
   675|         0|            0|            0|  0.00%|
   676|         0|            0|            0|  0.00%|
   677|         0|            0|            0|  0.00%|
   678|         0|            0|            0|  0.00%|
   679|         0|            0|            0|  0.00%|
   680|         0|            0|            0|  0.00%|
   681|         0|            0|            0|  0.00%|
   682|         0|            0|            0|  0.00%|
   683|         0|            0|            0|  0.00%|
   684|         0|            0|            0|  0.00%|
   685|         0|            0|            0|  0.00%|
   686|         0|            0|            0|  0.00%|
   687|         0|            0|            0|  0.00%|
   688|         0|            0|            0|  0.00%|
   689|         0|            0|            0|  0.00%|
   690|         0|            0|            0|  0.00%|
   691|         0|            0|            0|  0.00%|
   692|         0|            0|            0|  0.00%|
   693|         0|            0|            0|  0.00%|
   694|         0|            0|            0|  0.00%|
   695|         0|            0|            0|  0.00%|
   696|         0|            0|            0|  0.00%|
   697|         0|            0|            0|  0.00%|
   698|         0|            0|            0|  0.00%|
   699|         0|            0|            0|  0.00%|
   700|         0|            0|            0|  0.00%|
   701|         0|            0|            0|  0.00%|
   702|         0|            0|            0|  0.00%|
   703|         0|            0|            0|  0.00%|
   704|         0|            0|            0|  0.00%|
   705|         0|            0|            0|  0.00%|
   706|         0|            0|            0|  0.00%|
   707|         0|            0|            0|  0.00%|
   708|         0|            0|            0|  0.00%|
   709|         0|            0|            0|  0.00%|
   710|         0|            0|            0|  0.00%|
   711|         0|            0|            0|  0.00%|
   712|         0|            0|            0|  0.00%|
   713|         0|            0|            0|  0.00%|
   714|         0|            0|            0|  0.00%|
   715|         0|            0|            0|  0.00%|
   716|         0|            0|            0|  0.00%|
   717|         0|            0|            0|  0.00%|
   718|         0|            0|            0|  0.00%|
   719|         0|            0|            0|  0.00%|
   720|         0|            0|            0|  0.00%|
   721|         0|            0|            0|  0.00%|
   722|         0|            0|            0|  0.00%|
   723|         0|            0|            0|  0.00%|
   724|         0|            0|            0|  0.00%|
   725|         0|            0|            0|  0.00%|
   726|         0|            0|            0|  0.00%|
   727|         0|            0|            0|  0.00%|
   728|         0|            0|            0|  0.00%|
   729|         0|            0|            0|  0.00%|
   730|         0|            0|            0|  0.00%|
   731|         0|            0|            0|  0.00%|
   732|         0|            0|            0|  0.00%|
   733|         0|            0|            0|  0.00%|
   734|         0|            0|            0|  0.00%|
   735|         0|            0|            0|  0.00%|
   736|         0|            0|            0|  0.00%|
   737|         0|            0|            0|  0.00%|
   738|         0|            0|            0|  0.00%|
   739|         0|            0|            0|  0.00%|
   740|         0|            0|            0|  0.00%|
   741|         0|            0|            0|  0.00%|
   742|         0|            0|            0|  0.00%|
   743|         0|            0|            0|  0.00%|
   744|         0|            0|            0|  0.00%|
   745|         0|            0|            0|  0.00%|
   746|         0|            0|            0|  0.00%|
   747|         0|            0|            0|  0.00%|
   748|         0|            0|            0|  0.00%|
   749|         0|            0|            0|  0.00%|
   750|         0|            0|            0|  0.00%|
   751|         0|            0|            0|  0.00%|
   752|         0|            0|            0|  0.00%|
   753|         0|            0|            0|  0.00%|
   754|         0|            0|            0|  0.00%|
   755|         0|            0|            0|  0.00%|
   756|         0|            0|            0|  0.00%|
   757|         0|            0|            0|  0.00%|
   758|         0|            0|            0|  0.00%|
   759|         0|            0|            0|  0.00%|
   760|         0|            0|            0|  0.00%|
   761|         0|            0|            0|  0.00%|
   762|         0|            0|            0|  0.00%|
   763|         0|            0|            0|  0.00%|
   764|         0|            0|            0|  0.00%|
   765|         0|            0|            0|  0.00%|
   766|         0|            0|            0|  0.00%|
   767|         0|            0|            0|  0.00%|
   768|         0|            0|            0|  0.00%|
   769|         0|            0|            0|  0.00%|
   770|         0|            0|            0|  0.00%|
   771|         0|            0|            0|  0.00%|
   772|         0|            0|            0|  0.00%|
   773|         0|            0|            0|  0.00%|
   774|         0|            0|            0|  0.00%|
   775|         0|            0|            0|  0.00%|
   776|         0|            0|            0|  0.00%|
   777|         0|            0|            0|  0.00%|
   778|         0|            0|            0|  0.00%|
   779|         0|            0|            0|  0.00%|
   780|         0|            0|            0|  0.00%|
   781|         0|            0|            0|  0.00%|
   782|         0|            0|            0|  0.00%|
   783|         0|            0|            0|  0.00%|
   784|         0|            0|            0|  0.00%|
   785|         0|            0|            0|  0.00%|
   786|         0|            0|            0|  0.00%|
   787|         0|            0|            0|  0.00%|
   788|         0|            0|            0|  0.00%|
   789|         0|            0|            0|  0.00%|
   790|         0|            0|            0|  0.00%|
   791|         0|            0|            0|  0.00%|
   792|         0|            0|            0|  0.00%|
   793|         0|            0|            0|  0.00%|
   794|         0|            0|            0|  0.00%|
   795|         0|            0|            0|  0.00%|
   796|         0|            0|            0|  0.00%|
   797|         0|            0|            0|  0.00%|
   798|         0|            0|            0|  0.00%|
   799|         0|            0|            0|  0.00%|
   800|         0|            0|            0|  0.00%|
   801|         0|            0|            0|  0.00%|
   802|         0|            0|            0|  0.00%|
   803|         0|            0|            0|  0.00%|
   804|         2|  3.57628e-06|  1.78814e-06|  0.00%|
   805|         0|            0|            0|  0.00%|
   806|         2|  5.96046e-06|  2.98023e-06|  0.01%|
   807|         2|  1.23978e-05|  6.19888e-06|  0.01%|
(call)|         2|  3.50475e-05|  1.75238e-05|  0.04%|# <frozen os>:680 __getitem__
   808|         2|  4.52995e-06|  2.26498e-06|  0.00%|
   809|         2|  3.57628e-06|  1.78814e-06|  0.00%|
   810|         0|            0|            0|  0.00%|
   811|         2|  4.29153e-06|  2.14577e-06|  0.00%|
   812|         2|  4.52995e-06|  2.26498e-06|  0.00%|
   813|         2|  2.14577e-05|  1.07288e-05|  0.02%|
(call)|         2|   7.7486e-05|   3.8743e-05|  0.08%|# <frozen os>:680 __getitem__
   814|         2|  5.48363e-06|  2.74181e-06|  0.01%|
   815|         2|  5.00679e-06|   2.5034e-06|  0.01%|
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_known_annotated_metadata.py
File duration: 0.000283718s (0.29%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|from __future__ import annotations
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|from collections import defaultdict
     4|         0|            0|            0|  0.00%|from copy import copy
     5|         0|            0|            0|  0.00%|from functools import lru_cache, partial
     6|         0|            0|            0|  0.00%|from typing import TYPE_CHECKING, Any, Callable, Iterable
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|from pydantic_core import CoreSchema, PydanticCustomError, to_jsonable_python
     9|         0|            0|            0|  0.00%|from pydantic_core import core_schema as cs
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|from ._fields import PydanticMetadata
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|if TYPE_CHECKING:
    14|         0|            0|            0|  0.00%|    from ..annotated_handlers import GetJsonSchemaHandler
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|STRICT = {'strict'}
    17|         0|            0|            0|  0.00%|FAIL_FAST = {'fail_fast'}
    18|         0|            0|            0|  0.00%|LENGTH_CONSTRAINTS = {'min_length', 'max_length'}
    19|         0|            0|            0|  0.00%|INEQUALITY = {'le', 'ge', 'lt', 'gt'}
    20|         0|            0|            0|  0.00%|NUMERIC_CONSTRAINTS = {'multiple_of', *INEQUALITY}
    21|         0|            0|            0|  0.00%|ALLOW_INF_NAN = {'allow_inf_nan'}
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|STR_CONSTRAINTS = {
    24|         0|            0|            0|  0.00%|    *LENGTH_CONSTRAINTS,
    25|         0|            0|            0|  0.00%|    *STRICT,
    26|         0|            0|            0|  0.00%|    'strip_whitespace',
    27|         0|            0|            0|  0.00%|    'to_lower',
    28|         0|            0|            0|  0.00%|    'to_upper',
    29|         0|            0|            0|  0.00%|    'pattern',
    30|         0|            0|            0|  0.00%|    'coerce_numbers_to_str',
    31|         0|            0|            0|  0.00%|}
    32|         0|            0|            0|  0.00%|BYTES_CONSTRAINTS = {*LENGTH_CONSTRAINTS, *STRICT}
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|LIST_CONSTRAINTS = {*LENGTH_CONSTRAINTS, *STRICT, *FAIL_FAST}
    35|         0|            0|            0|  0.00%|TUPLE_CONSTRAINTS = {*LENGTH_CONSTRAINTS, *STRICT, *FAIL_FAST}
    36|         0|            0|            0|  0.00%|SET_CONSTRAINTS = {*LENGTH_CONSTRAINTS, *STRICT, *FAIL_FAST}
    37|         0|            0|            0|  0.00%|DICT_CONSTRAINTS = {*LENGTH_CONSTRAINTS, *STRICT}
    38|         0|            0|            0|  0.00%|GENERATOR_CONSTRAINTS = {*LENGTH_CONSTRAINTS, *STRICT}
    39|         0|            0|            0|  0.00%|SEQUENCE_CONSTRAINTS = {*LENGTH_CONSTRAINTS, *FAIL_FAST}
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|FLOAT_CONSTRAINTS = {*NUMERIC_CONSTRAINTS, *ALLOW_INF_NAN, *STRICT}
    42|         0|            0|            0|  0.00%|DECIMAL_CONSTRAINTS = {'max_digits', 'decimal_places', *FLOAT_CONSTRAINTS}
    43|         0|            0|            0|  0.00%|INT_CONSTRAINTS = {*NUMERIC_CONSTRAINTS, *ALLOW_INF_NAN, *STRICT}
    44|         0|            0|            0|  0.00%|BOOL_CONSTRAINTS = STRICT
    45|         0|            0|            0|  0.00%|UUID_CONSTRAINTS = STRICT
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|DATE_TIME_CONSTRAINTS = {*NUMERIC_CONSTRAINTS, *STRICT}
    48|         0|            0|            0|  0.00%|TIMEDELTA_CONSTRAINTS = {*NUMERIC_CONSTRAINTS, *STRICT}
    49|         0|            0|            0|  0.00%|TIME_CONSTRAINTS = {*NUMERIC_CONSTRAINTS, *STRICT}
    50|         0|            0|            0|  0.00%|LAX_OR_STRICT_CONSTRAINTS = STRICT
    51|         0|            0|            0|  0.00%|ENUM_CONSTRAINTS = STRICT
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|UNION_CONSTRAINTS = {'union_mode'}
    54|         0|            0|            0|  0.00%|URL_CONSTRAINTS = {
    55|         0|            0|            0|  0.00%|    'max_length',
    56|         0|            0|            0|  0.00%|    'allowed_schemes',
    57|         0|            0|            0|  0.00%|    'host_required',
    58|         0|            0|            0|  0.00%|    'default_host',
    59|         0|            0|            0|  0.00%|    'default_port',
    60|         0|            0|            0|  0.00%|    'default_path',
    61|         0|            0|            0|  0.00%|}
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|TEXT_SCHEMA_TYPES = ('str', 'bytes', 'url', 'multi-host-url')
    64|         0|            0|            0|  0.00%|SEQUENCE_SCHEMA_TYPES = ('list', 'tuple', 'set', 'frozenset', 'generator', *TEXT_SCHEMA_TYPES)
    65|         0|            0|            0|  0.00%|NUMERIC_SCHEMA_TYPES = ('float', 'int', 'date', 'time', 'timedelta', 'datetime')
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|CONSTRAINTS_TO_ALLOWED_SCHEMAS: dict[str, set[str]] = defaultdict(set)
    68|         0|            0|            0|  0.00%|
    69|         0|            0|            0|  0.00%|constraint_schema_pairings: list[tuple[set[str], tuple[str, ...]]] = [
    70|         0|            0|            0|  0.00%|    (STR_CONSTRAINTS, TEXT_SCHEMA_TYPES),
    71|         0|            0|            0|  0.00%|    (BYTES_CONSTRAINTS, ('bytes',)),
    72|         0|            0|            0|  0.00%|    (LIST_CONSTRAINTS, ('list',)),
    73|         0|            0|            0|  0.00%|    (TUPLE_CONSTRAINTS, ('tuple',)),
    74|         0|            0|            0|  0.00%|    (SET_CONSTRAINTS, ('set', 'frozenset')),
    75|         0|            0|            0|  0.00%|    (DICT_CONSTRAINTS, ('dict',)),
    76|         0|            0|            0|  0.00%|    (GENERATOR_CONSTRAINTS, ('generator',)),
    77|         0|            0|            0|  0.00%|    (FLOAT_CONSTRAINTS, ('float',)),
    78|         0|            0|            0|  0.00%|    (INT_CONSTRAINTS, ('int',)),
    79|         0|            0|            0|  0.00%|    (DATE_TIME_CONSTRAINTS, ('date', 'time', 'datetime')),
    80|         0|            0|            0|  0.00%|    (TIMEDELTA_CONSTRAINTS, ('timedelta',)),
    81|         0|            0|            0|  0.00%|    (TIME_CONSTRAINTS, ('time',)),
    82|         0|            0|            0|  0.00%|    # TODO: this is a bit redundant, we could probably avoid some of these
    83|         0|            0|            0|  0.00%|    (STRICT, (*TEXT_SCHEMA_TYPES, *SEQUENCE_SCHEMA_TYPES, *NUMERIC_SCHEMA_TYPES, 'typed-dict', 'model')),
    84|         0|            0|            0|  0.00%|    (UNION_CONSTRAINTS, ('union',)),
    85|         0|            0|            0|  0.00%|    (URL_CONSTRAINTS, ('url', 'multi-host-url')),
    86|         0|            0|            0|  0.00%|    (BOOL_CONSTRAINTS, ('bool',)),
    87|         0|            0|            0|  0.00%|    (UUID_CONSTRAINTS, ('uuid',)),
    88|         0|            0|            0|  0.00%|    (LAX_OR_STRICT_CONSTRAINTS, ('lax-or-strict',)),
    89|         0|            0|            0|  0.00%|    (ENUM_CONSTRAINTS, ('enum',)),
    90|         0|            0|            0|  0.00%|    (DECIMAL_CONSTRAINTS, ('decimal',)),
    91|         0|            0|            0|  0.00%|]
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|for constraints, schemas in constraint_schema_pairings:
    94|         0|            0|            0|  0.00%|    for c in constraints:
    95|         0|            0|            0|  0.00%|        CONSTRAINTS_TO_ALLOWED_SCHEMAS[c].update(schemas)
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|
    98|         0|            0|            0|  0.00%|def add_js_update_schema(s: cs.CoreSchema, f: Callable[[], dict[str, Any]]) -> None:
    99|         0|            0|            0|  0.00%|    def update_js_schema(s: cs.CoreSchema, handler: GetJsonSchemaHandler) -> dict[str, Any]:
   100|         0|            0|            0|  0.00%|        js_schema = handler(s)
   101|         0|            0|            0|  0.00%|        js_schema.update(f())
   102|         0|            0|            0|  0.00%|        return js_schema
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|    if 'metadata' in s:
   105|         0|            0|            0|  0.00%|        metadata = s['metadata']
   106|         0|            0|            0|  0.00%|        if 'pydantic_js_functions' in s:
   107|         0|            0|            0|  0.00%|            metadata['pydantic_js_functions'].append(update_js_schema)
   108|         0|            0|            0|  0.00%|        else:
   109|         0|            0|            0|  0.00%|            metadata['pydantic_js_functions'] = [update_js_schema]
   110|         0|            0|            0|  0.00%|    else:
   111|         0|            0|            0|  0.00%|        s['metadata'] = {'pydantic_js_functions': [update_js_schema]}
   112|         0|            0|            0|  0.00%|
   113|         0|            0|            0|  0.00%|
   114|         0|            0|            0|  0.00%|def as_jsonable_value(v: Any) -> Any:
   115|         0|            0|            0|  0.00%|    if type(v) not in (int, str, float, bytes, bool, type(None)):
   116|         0|            0|            0|  0.00%|        return to_jsonable_python(v)
   117|         0|            0|            0|  0.00%|    return v
   118|         0|            0|            0|  0.00%|
   119|         0|            0|            0|  0.00%|
   120|         4|  1.62125e-05|  4.05312e-06|  0.02%|def expand_grouped_metadata(annotations: Iterable[Any]) -> Iterable[Any]:
   121|         0|            0|            0|  0.00%|    """Expand the annotations.
   122|         0|            0|            0|  0.00%|
   123|         0|            0|            0|  0.00%|    Args:
   124|         0|            0|            0|  0.00%|        annotations: An iterable of annotations.
   125|         0|            0|            0|  0.00%|
   126|         0|            0|            0|  0.00%|    Returns:
   127|         0|            0|            0|  0.00%|        An iterable of expanded annotations.
   128|         0|            0|            0|  0.00%|
   129|         0|            0|            0|  0.00%|    Example:
   130|         0|            0|            0|  0.00%|        ```py
   131|         0|            0|            0|  0.00%|        from annotated_types import Ge, Len
   132|         0|            0|            0|  0.00%|
   133|         0|            0|            0|  0.00%|        from pydantic._internal._known_annotated_metadata import expand_grouped_metadata
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|        print(list(expand_grouped_metadata([Ge(4), Len(5)])))
   136|         0|            0|            0|  0.00%|        #> [Ge(ge=4), MinLen(min_length=5)]
   137|         0|            0|            0|  0.00%|        ```
   138|         0|            0|            0|  0.00%|    """
   139|         4|  1.78814e-05|  4.47035e-06|  0.02%|    import annotated_types as at
   140|         0|            0|            0|  0.00%|
   141|         4|  9.77516e-06|  2.44379e-06|  0.01%|    from pydantic.fields import FieldInfo  # circular import
   142|         0|            0|            0|  0.00%|
   143|         8|  1.62125e-05|  2.02656e-06|  0.02%|    for annotation in annotations:
   144|         4|  4.19617e-05|  1.04904e-05|  0.04%|        if isinstance(annotation, at.GroupedMetadata):
(call)|         4|   0.00123358|  0.000308394|  1.27%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:1871 __instancecheck__
   145|         0|            0|            0|  0.00%|            yield from annotation
   146|         4|  8.34465e-06|  2.08616e-06|  0.01%|        elif isinstance(annotation, FieldInfo):
   147|         4|   1.0252e-05|    2.563e-06|  0.01%|            yield from annotation.metadata
   148|         0|            0|            0|  0.00%|            # this is a bit problematic in that it results in duplicate metadata
   149|         0|            0|            0|  0.00%|            # all of our "consumers" can handle it, but it is not ideal
   150|         0|            0|            0|  0.00%|            # we probably should split up FieldInfo into:
   151|         0|            0|            0|  0.00%|            # - annotated types metadata
   152|         0|            0|            0|  0.00%|            # - individual metadata known only to Pydantic
   153|         4|  3.91006e-05|  9.77516e-06|  0.04%|            annotation = copy(annotation)
(call)|         4|   0.00111461|  0.000278652|  1.15%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/copy.py:61 copy
   154|         4|  8.10623e-06|  2.02656e-06|  0.01%|            annotation.metadata = []
   155|         8|   1.7643e-05|  2.20537e-06|  0.02%|            yield annotation
   156|         0|            0|            0|  0.00%|        else:
   157|         0|            0|            0|  0.00%|            yield annotation
   158|         0|            0|            0|  0.00%|
   159|         0|            0|            0|  0.00%|
   160|         0|            0|            0|  0.00%|@lru_cache
   161|         0|            0|            0|  0.00%|def _get_at_to_constraint_map() -> dict[type, str]:
   162|         0|            0|            0|  0.00%|    """Return a mapping of annotated types to constraints.
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|    Normally, we would define a mapping like this in the module scope, but we can't do that
   165|         0|            0|            0|  0.00%|    because we don't permit module level imports of `annotated_types`, in an attempt to speed up
   166|         0|            0|            0|  0.00%|    the import time of `pydantic`. We still only want to have this dictionary defined in one place,
   167|         0|            0|            0|  0.00%|    so we use this function to cache the result.
   168|         0|            0|            0|  0.00%|    """
   169|         0|            0|            0|  0.00%|    import annotated_types as at
   170|         0|            0|            0|  0.00%|
   171|         0|            0|            0|  0.00%|    return {
   172|         0|            0|            0|  0.00%|        at.Gt: 'gt',
   173|         0|            0|            0|  0.00%|        at.Ge: 'ge',
   174|         0|            0|            0|  0.00%|        at.Lt: 'lt',
   175|         0|            0|            0|  0.00%|        at.Le: 'le',
   176|         0|            0|            0|  0.00%|        at.MultipleOf: 'multiple_of',
   177|         0|            0|            0|  0.00%|        at.MinLen: 'min_length',
   178|         0|            0|            0|  0.00%|        at.MaxLen: 'max_length',
   179|         0|            0|            0|  0.00%|    }
   180|         0|            0|            0|  0.00%|
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|def apply_known_metadata(annotation: Any, schema: CoreSchema) -> CoreSchema | None:  # noqa: C901
   183|         0|            0|            0|  0.00%|    """Apply `annotation` to `schema` if it is an annotation we know about (Gt, Le, etc.).
   184|         0|            0|            0|  0.00%|    Otherwise return `None`.
   185|         0|            0|            0|  0.00%|
   186|         0|            0|            0|  0.00%|    This does not handle all known annotations. If / when it does, it can always
   187|         0|            0|            0|  0.00%|    return a CoreSchema and return the unmodified schema if the annotation should be ignored.
   188|         0|            0|            0|  0.00%|
   189|         0|            0|            0|  0.00%|    Assumes that GroupedMetadata has already been expanded via `expand_grouped_metadata`.
   190|         0|            0|            0|  0.00%|
   191|         0|            0|            0|  0.00%|    Args:
   192|         0|            0|            0|  0.00%|        annotation: The annotation.
   193|         0|            0|            0|  0.00%|        schema: The schema.
   194|         0|            0|            0|  0.00%|
   195|         0|            0|            0|  0.00%|    Returns:
   196|         0|            0|            0|  0.00%|        An updated schema with annotation if it is an annotation we know about, `None` otherwise.
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|    Raises:
   199|         0|            0|            0|  0.00%|        PydanticCustomError: If `Predicate` fails.
   200|         0|            0|            0|  0.00%|    """
   201|         0|            0|            0|  0.00%|    import annotated_types as at
   202|         0|            0|            0|  0.00%|
   203|         0|            0|            0|  0.00%|    from ._validators import forbid_inf_nan_check, get_constraint_validator
   204|         0|            0|            0|  0.00%|
   205|         0|            0|            0|  0.00%|    schema = schema.copy()
   206|         0|            0|            0|  0.00%|    schema_update, other_metadata = collect_known_metadata([annotation])
   207|         0|            0|            0|  0.00%|    schema_type = schema['type']
   208|         0|            0|            0|  0.00%|
   209|         0|            0|            0|  0.00%|    chain_schema_constraints: set[str] = {
   210|         0|            0|            0|  0.00%|        'pattern',
   211|         0|            0|            0|  0.00%|        'strip_whitespace',
   212|         0|            0|            0|  0.00%|        'to_lower',
   213|         0|            0|            0|  0.00%|        'to_upper',
   214|         0|            0|            0|  0.00%|        'coerce_numbers_to_str',
   215|         0|            0|            0|  0.00%|    }
   216|         0|            0|            0|  0.00%|    chain_schema_steps: list[CoreSchema] = []
   217|         0|            0|            0|  0.00%|
   218|         0|            0|            0|  0.00%|    for constraint, value in schema_update.items():
   219|         0|            0|            0|  0.00%|        if constraint not in CONSTRAINTS_TO_ALLOWED_SCHEMAS:
   220|         0|            0|            0|  0.00%|            raise ValueError(f'Unknown constraint {constraint}')
   221|         0|            0|            0|  0.00%|        allowed_schemas = CONSTRAINTS_TO_ALLOWED_SCHEMAS[constraint]
   222|         0|            0|            0|  0.00%|
   223|         0|            0|            0|  0.00%|        # if it becomes necessary to handle more than one constraint
   224|         0|            0|            0|  0.00%|        # in this recursive case with function-after or function-wrap, we should refactor
   225|         0|            0|            0|  0.00%|        # this is a bit challenging because we sometimes want to apply constraints to the inner schema,
   226|         0|            0|            0|  0.00%|        # whereas other times we want to wrap the existing schema with a new one that enforces a new constraint.
   227|         0|            0|            0|  0.00%|        if schema_type in {'function-before', 'function-wrap', 'function-after'} and constraint == 'strict':
   228|         0|            0|            0|  0.00%|            schema['schema'] = apply_known_metadata(annotation, schema['schema'])  # type: ignore  # schema is function-after schema
   229|         0|            0|            0|  0.00%|            return schema
   230|         0|            0|            0|  0.00%|
   231|         0|            0|            0|  0.00%|        if schema_type in allowed_schemas:
   232|         0|            0|            0|  0.00%|            if constraint == 'union_mode' and schema_type == 'union':
   233|         0|            0|            0|  0.00%|                schema['mode'] = value  # type: ignore  # schema is UnionSchema
   234|         0|            0|            0|  0.00%|            else:
   235|         0|            0|            0|  0.00%|                schema[constraint] = value
   236|         0|            0|            0|  0.00%|            continue
   237|         0|            0|            0|  0.00%|
   238|         0|            0|            0|  0.00%|        if constraint in chain_schema_constraints:
   239|         0|            0|            0|  0.00%|            chain_schema_steps.append(cs.str_schema(**{constraint: value}))
   240|         0|            0|            0|  0.00%|        elif constraint in {*NUMERIC_CONSTRAINTS, *LENGTH_CONSTRAINTS}:
   241|         0|            0|            0|  0.00%|            if constraint in NUMERIC_CONSTRAINTS:
   242|         0|            0|            0|  0.00%|                json_schema_constraint = constraint
   243|         0|            0|            0|  0.00%|            elif constraint in LENGTH_CONSTRAINTS:
   244|         0|            0|            0|  0.00%|                inner_schema = schema
   245|         0|            0|            0|  0.00%|                while inner_schema['type'] in {'function-before', 'function-wrap', 'function-after'}:
   246|         0|            0|            0|  0.00%|                    inner_schema = inner_schema['schema']  # type: ignore
   247|         0|            0|            0|  0.00%|                inner_schema_type = inner_schema['type']
   248|         0|            0|            0|  0.00%|                if inner_schema_type == 'list' or (
   249|         0|            0|            0|  0.00%|                    inner_schema_type == 'json-or-python' and inner_schema['json_schema']['type'] == 'list'  # type: ignore
   250|         0|            0|            0|  0.00%|                ):
   251|         0|            0|            0|  0.00%|                    json_schema_constraint = 'minItems' if constraint == 'min_length' else 'maxItems'
   252|         0|            0|            0|  0.00%|                else:
   253|         0|            0|            0|  0.00%|                    json_schema_constraint = 'minLength' if constraint == 'min_length' else 'maxLength'
   254|         0|            0|            0|  0.00%|
   255|         0|            0|            0|  0.00%|            schema = cs.no_info_after_validator_function(
   256|         0|            0|            0|  0.00%|                partial(get_constraint_validator(constraint), **{constraint: value}), schema
   257|         0|            0|            0|  0.00%|            )
   258|         0|            0|            0|  0.00%|            add_js_update_schema(schema, lambda: {json_schema_constraint: as_jsonable_value(value)})
   259|         0|            0|            0|  0.00%|        elif constraint == 'allow_inf_nan' and value is False:
   260|         0|            0|            0|  0.00%|            schema = cs.no_info_after_validator_function(
   261|         0|            0|            0|  0.00%|                forbid_inf_nan_check,
   262|         0|            0|            0|  0.00%|                schema,
   263|         0|            0|            0|  0.00%|            )
   264|         0|            0|            0|  0.00%|        else:
   265|         0|            0|            0|  0.00%|            raise RuntimeError(f'Unable to apply constraint {constraint} to schema {schema_type}')
   266|         0|            0|            0|  0.00%|
   267|         0|            0|            0|  0.00%|    for annotation in other_metadata:
   268|         0|            0|            0|  0.00%|        if (annotation_type := type(annotation)) in (at_to_constraint_map := _get_at_to_constraint_map()):
   269|         0|            0|            0|  0.00%|            constraint = at_to_constraint_map[annotation_type]
   270|         0|            0|            0|  0.00%|            schema = cs.no_info_after_validator_function(
   271|         0|            0|            0|  0.00%|                partial(get_constraint_validator(constraint), {constraint: getattr(annotation, constraint)}), schema
   272|         0|            0|            0|  0.00%|            )
   273|         0|            0|            0|  0.00%|            continue
   274|         0|            0|            0|  0.00%|        elif isinstance(annotation, at.Predicate):
   275|         0|            0|            0|  0.00%|            predicate_name = f'{annotation.func.__qualname__} ' if hasattr(annotation.func, '__qualname__') else ''
   276|         0|            0|            0|  0.00%|
   277|         0|            0|            0|  0.00%|            def val_func(v: Any) -> Any:
   278|         0|            0|            0|  0.00%|                # annotation.func may also raise an exception, let it pass through
   279|         0|            0|            0|  0.00%|                if not annotation.func(v):
   280|         0|            0|            0|  0.00%|                    raise PydanticCustomError(
   281|         0|            0|            0|  0.00%|                        'predicate_failed',
   282|         0|            0|            0|  0.00%|                        f'Predicate {predicate_name}failed',  # type: ignore
   283|         0|            0|            0|  0.00%|                    )
   284|         0|            0|            0|  0.00%|                return v
   285|         0|            0|            0|  0.00%|
   286|         0|            0|            0|  0.00%|            schema = cs.no_info_after_validator_function(val_func, schema)
   287|         0|            0|            0|  0.00%|        else:
   288|         0|            0|            0|  0.00%|            # ignore any other unknown metadata
   289|         0|            0|            0|  0.00%|            return None
   290|         0|            0|            0|  0.00%|
   291|         0|            0|            0|  0.00%|    if chain_schema_steps:
   292|         0|            0|            0|  0.00%|        chain_schema_steps = [schema] + chain_schema_steps
   293|         0|            0|            0|  0.00%|        return cs.chain_schema(chain_schema_steps)
   294|         0|            0|            0|  0.00%|
   295|         0|            0|            0|  0.00%|    return schema
   296|         0|            0|            0|  0.00%|
   297|         0|            0|            0|  0.00%|
   298|         2|  9.05991e-06|  4.52995e-06|  0.01%|def collect_known_metadata(annotations: Iterable[Any]) -> tuple[dict[str, Any], list[Any]]:
   299|         0|            0|            0|  0.00%|    """Split `annotations` into known metadata and unknown annotations.
   300|         0|            0|            0|  0.00%|
   301|         0|            0|            0|  0.00%|    Args:
   302|         0|            0|            0|  0.00%|        annotations: An iterable of annotations.
   303|         0|            0|            0|  0.00%|
   304|         0|            0|            0|  0.00%|    Returns:
   305|         0|            0|            0|  0.00%|        A tuple contains a dict of known metadata and a list of unknown annotations.
   306|         0|            0|            0|  0.00%|
   307|         0|            0|            0|  0.00%|    Example:
   308|         0|            0|            0|  0.00%|        ```py
   309|         0|            0|            0|  0.00%|        from annotated_types import Gt, Len
   310|         0|            0|            0|  0.00%|
   311|         0|            0|            0|  0.00%|        from pydantic._internal._known_annotated_metadata import collect_known_metadata
   312|         0|            0|            0|  0.00%|
   313|         0|            0|            0|  0.00%|        print(collect_known_metadata([Gt(1), Len(42), ...]))
   314|         0|            0|            0|  0.00%|        #> ({'gt': 1, 'min_length': 42}, [Ellipsis])
   315|         0|            0|            0|  0.00%|        ```
   316|         0|            0|            0|  0.00%|    """
   317|         2|   6.4373e-06|  3.21865e-06|  0.01%|    annotations = expand_grouped_metadata(annotations)
   318|         0|            0|            0|  0.00%|
   319|         2|  4.52995e-06|  2.26498e-06|  0.00%|    res: dict[str, Any] = {}
   320|         2|  5.00679e-06|   2.5034e-06|  0.01%|    remaining: list[Any] = []
   321|         0|            0|            0|  0.00%|
   322|         4|  3.60012e-05|   9.0003e-06|  0.04%|    for annotation in annotations:
(call)|         4|  0.000681877|  0.000170469|  0.70%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_known_annotated_metadata.py:120 expand_grouped_metadata
   323|         0|            0|            0|  0.00%|        # isinstance(annotation, PydanticMetadata) also covers ._fields:_PydanticGeneralMetadata
   324|         2|  7.39098e-06|  3.69549e-06|  0.01%|        if isinstance(annotation, PydanticMetadata):
   325|         0|            0|            0|  0.00%|            res.update(annotation.__dict__)
   326|         0|            0|            0|  0.00%|        # we don't use dataclasses.asdict because that recursively calls asdict on the field values
   327|         2|  8.58307e-06|  4.29153e-06|  0.01%|        elif (annotation_type := type(annotation)) in (at_to_constraint_map := _get_at_to_constraint_map()):
   328|         0|            0|            0|  0.00%|            constraint = at_to_constraint_map[annotation_type]
   329|         0|            0|            0|  0.00%|            res[constraint] = getattr(annotation, constraint)
   330|         2|  5.48363e-06|  2.74181e-06|  0.01%|        elif isinstance(annotation, type) and issubclass(annotation, PydanticMetadata):
   331|         0|            0|            0|  0.00%|            # also support PydanticMetadata classes being used without initialisation,
   332|         0|            0|            0|  0.00%|            # e.g. `Annotated[int, Strict]` as well as `Annotated[int, Strict()]`
   333|         0|            0|            0|  0.00%|            res.update({k: v for k, v in vars(annotation).items() if not k.startswith('_')})
   334|         0|            0|            0|  0.00%|        else:
   335|         2|  5.96046e-06|  2.98023e-06|  0.01%|            remaining.append(annotation)
   336|         0|            0|            0|  0.00%|    # Nones can sneak in but pydantic-core will reject them
   337|         0|            0|            0|  0.00%|    # it'd be nice to clean things up so we don't put in None (we probably don't _need_ to, it was just easier)
   338|         0|            0|            0|  0.00%|    # but this is simple enough to kick that can down the road
   339|         2|  4.76837e-06|  2.38419e-06|  0.00%|    res = {k: v for k, v in res.items() if v is not None}
   340|         2|  5.00679e-06|   2.5034e-06|  0.01%|    return res, remaining
   341|         0|            0|            0|  0.00%|
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|def check_metadata(metadata: dict[str, Any], allowed: Iterable[str], source_type: Any) -> None:
   344|         0|            0|            0|  0.00%|    """A small utility function to validate that the given metadata can be applied to the target.
   345|         0|            0|            0|  0.00%|    More than saving lines of code, this gives us a consistent error message for all of our internal implementations.
   346|         0|            0|            0|  0.00%|
   347|         0|            0|            0|  0.00%|    Args:
   348|         0|            0|            0|  0.00%|        metadata: A dict of metadata.
   349|         0|            0|            0|  0.00%|        allowed: An iterable of allowed metadata.
   350|         0|            0|            0|  0.00%|        source_type: The source type.
   351|         0|            0|            0|  0.00%|
   352|         0|            0|            0|  0.00%|    Raises:
   353|         0|            0|            0|  0.00%|        TypeError: If there is metadatas that can't be applied on source type.
   354|         0|            0|            0|  0.00%|    """
   355|         0|            0|            0|  0.00%|    unknown = metadata.keys() - set(allowed)
   356|         0|            0|            0|  0.00%|    if unknown:
   357|         0|            0|            0|  0.00%|        raise TypeError(
   358|         0|            0|            0|  0.00%|            f'The following constraints cannot be applied to {source_type!r}: {", ".join([f"{k!r}" for k in unknown])}'
   359|         0|            0|            0|  0.00%|        )
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/routing.py
File duration: 0.000268936s (0.28%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|import asyncio
     2|         0|            0|            0|  0.00%|import dataclasses
     3|         0|            0|            0|  0.00%|import email.message
     4|         0|            0|            0|  0.00%|import inspect
     5|         0|            0|            0|  0.00%|import json
     6|         0|            0|            0|  0.00%|from contextlib import AsyncExitStack, asynccontextmanager
     7|         0|            0|            0|  0.00%|from enum import Enum, IntEnum
     8|         0|            0|            0|  0.00%|from typing import (
     9|         0|            0|            0|  0.00%|    Any,
    10|         0|            0|            0|  0.00%|    AsyncIterator,
    11|         0|            0|            0|  0.00%|    Callable,
    12|         0|            0|            0|  0.00%|    Coroutine,
    13|         0|            0|            0|  0.00%|    Dict,
    14|         0|            0|            0|  0.00%|    List,
    15|         0|            0|            0|  0.00%|    Mapping,
    16|         0|            0|            0|  0.00%|    Optional,
    17|         0|            0|            0|  0.00%|    Sequence,
    18|         0|            0|            0|  0.00%|    Set,
    19|         0|            0|            0|  0.00%|    Tuple,
    20|         0|            0|            0|  0.00%|    Type,
    21|         0|            0|            0|  0.00%|    Union,
    22|         0|            0|            0|  0.00%|)
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|from fastapi import params
    25|         0|            0|            0|  0.00%|from fastapi._compat import (
    26|         0|            0|            0|  0.00%|    ModelField,
    27|         0|            0|            0|  0.00%|    Undefined,
    28|         0|            0|            0|  0.00%|    _get_model_config,
    29|         0|            0|            0|  0.00%|    _model_dump,
    30|         0|            0|            0|  0.00%|    _normalize_errors,
    31|         0|            0|            0|  0.00%|    lenient_issubclass,
    32|         0|            0|            0|  0.00%|)
    33|         0|            0|            0|  0.00%|from fastapi.datastructures import Default, DefaultPlaceholder
    34|         0|            0|            0|  0.00%|from fastapi.dependencies.models import Dependant
    35|         0|            0|            0|  0.00%|from fastapi.dependencies.utils import (
    36|         0|            0|            0|  0.00%|    get_body_field,
    37|         0|            0|            0|  0.00%|    get_dependant,
    38|         0|            0|            0|  0.00%|    get_parameterless_sub_dependant,
    39|         0|            0|            0|  0.00%|    get_typed_return_annotation,
    40|         0|            0|            0|  0.00%|    solve_dependencies,
    41|         0|            0|            0|  0.00%|)
    42|         0|            0|            0|  0.00%|from fastapi.encoders import jsonable_encoder
    43|         0|            0|            0|  0.00%|from fastapi.exceptions import (
    44|         0|            0|            0|  0.00%|    FastAPIError,
    45|         0|            0|            0|  0.00%|    RequestValidationError,
    46|         0|            0|            0|  0.00%|    ResponseValidationError,
    47|         0|            0|            0|  0.00%|    WebSocketRequestValidationError,
    48|         0|            0|            0|  0.00%|)
    49|         0|            0|            0|  0.00%|from fastapi.types import DecoratedCallable, IncEx
    50|         0|            0|            0|  0.00%|from fastapi.utils import (
    51|         0|            0|            0|  0.00%|    create_cloned_field,
    52|         0|            0|            0|  0.00%|    create_response_field,
    53|         0|            0|            0|  0.00%|    generate_unique_id,
    54|         0|            0|            0|  0.00%|    get_value_or_default,
    55|         0|            0|            0|  0.00%|    is_body_allowed_for_status_code,
    56|         0|            0|            0|  0.00%|)
    57|         0|            0|            0|  0.00%|from pydantic import BaseModel
    58|         0|            0|            0|  0.00%|from starlette import routing
    59|         0|            0|            0|  0.00%|from starlette.concurrency import run_in_threadpool
    60|         0|            0|            0|  0.00%|from starlette.exceptions import HTTPException
    61|         0|            0|            0|  0.00%|from starlette.requests import Request
    62|         0|            0|            0|  0.00%|from starlette.responses import JSONResponse, Response
    63|         0|            0|            0|  0.00%|from starlette.routing import (
    64|         0|            0|            0|  0.00%|    BaseRoute,
    65|         0|            0|            0|  0.00%|    Match,
    66|         0|            0|            0|  0.00%|    compile_path,
    67|         0|            0|            0|  0.00%|    get_name,
    68|         0|            0|            0|  0.00%|    request_response,
    69|         0|            0|            0|  0.00%|    websocket_session,
    70|         0|            0|            0|  0.00%|)
    71|         0|            0|            0|  0.00%|from starlette.routing import Mount as Mount  # noqa
    72|         0|            0|            0|  0.00%|from starlette.types import AppType, ASGIApp, Lifespan, Scope
    73|         0|            0|            0|  0.00%|from starlette.websockets import WebSocket
    74|         0|            0|            0|  0.00%|from typing_extensions import Annotated, Doc, deprecated
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|def _prepare_response_content(
    78|         0|            0|            0|  0.00%|    res: Any,
    79|         0|            0|            0|  0.00%|    *,
    80|         0|            0|            0|  0.00%|    exclude_unset: bool,
    81|         0|            0|            0|  0.00%|    exclude_defaults: bool = False,
    82|         0|            0|            0|  0.00%|    exclude_none: bool = False,
    83|         0|            0|            0|  0.00%|) -> Any:
    84|         0|            0|            0|  0.00%|    if isinstance(res, BaseModel):
    85|         0|            0|            0|  0.00%|        read_with_orm_mode = getattr(_get_model_config(res), "read_with_orm_mode", None)
    86|         0|            0|            0|  0.00%|        if read_with_orm_mode:
    87|         0|            0|            0|  0.00%|            # Let from_orm extract the data from this model instead of converting
    88|         0|            0|            0|  0.00%|            # it now to a dict.
    89|         0|            0|            0|  0.00%|            # Otherwise, there's no way to extract lazy data that requires attribute
    90|         0|            0|            0|  0.00%|            # access instead of dict iteration, e.g. lazy relationships.
    91|         0|            0|            0|  0.00%|            return res
    92|         0|            0|            0|  0.00%|        return _model_dump(
    93|         0|            0|            0|  0.00%|            res,
    94|         0|            0|            0|  0.00%|            by_alias=True,
    95|         0|            0|            0|  0.00%|            exclude_unset=exclude_unset,
    96|         0|            0|            0|  0.00%|            exclude_defaults=exclude_defaults,
    97|         0|            0|            0|  0.00%|            exclude_none=exclude_none,
    98|         0|            0|            0|  0.00%|        )
    99|         0|            0|            0|  0.00%|    elif isinstance(res, list):
   100|         0|            0|            0|  0.00%|        return [
   101|         0|            0|            0|  0.00%|            _prepare_response_content(
   102|         0|            0|            0|  0.00%|                item,
   103|         0|            0|            0|  0.00%|                exclude_unset=exclude_unset,
   104|         0|            0|            0|  0.00%|                exclude_defaults=exclude_defaults,
   105|         0|            0|            0|  0.00%|                exclude_none=exclude_none,
   106|         0|            0|            0|  0.00%|            )
   107|         0|            0|            0|  0.00%|            for item in res
   108|         0|            0|            0|  0.00%|        ]
   109|         0|            0|            0|  0.00%|    elif isinstance(res, dict):
   110|         0|            0|            0|  0.00%|        return {
   111|         0|            0|            0|  0.00%|            k: _prepare_response_content(
   112|         0|            0|            0|  0.00%|                v,
   113|         0|            0|            0|  0.00%|                exclude_unset=exclude_unset,
   114|         0|            0|            0|  0.00%|                exclude_defaults=exclude_defaults,
   115|         0|            0|            0|  0.00%|                exclude_none=exclude_none,
   116|         0|            0|            0|  0.00%|            )
   117|         0|            0|            0|  0.00%|            for k, v in res.items()
   118|         0|            0|            0|  0.00%|        }
   119|         0|            0|            0|  0.00%|    elif dataclasses.is_dataclass(res):
   120|         0|            0|            0|  0.00%|        return dataclasses.asdict(res)
   121|         0|            0|            0|  0.00%|    return res
   122|         0|            0|            0|  0.00%|
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|def _merge_lifespan_context(
   125|         0|            0|            0|  0.00%|    original_context: Lifespan[Any], nested_context: Lifespan[Any]
   126|         0|            0|            0|  0.00%|) -> Lifespan[Any]:
   127|         0|            0|            0|  0.00%|    @asynccontextmanager
   128|         0|            0|            0|  0.00%|    async def merged_lifespan(
   129|         0|            0|            0|  0.00%|        app: AppType,
   130|         0|            0|            0|  0.00%|    ) -> AsyncIterator[Optional[Mapping[str, Any]]]:
   131|         0|            0|            0|  0.00%|        async with original_context(app) as maybe_original_state:
   132|         0|            0|            0|  0.00%|            async with nested_context(app) as maybe_nested_state:
   133|         0|            0|            0|  0.00%|                if maybe_nested_state is None and maybe_original_state is None:
   134|         0|            0|            0|  0.00%|                    yield None  # old ASGI compatibility
   135|         0|            0|            0|  0.00%|                else:
   136|         0|            0|            0|  0.00%|                    yield {**(maybe_nested_state or {}), **(maybe_original_state or {})}
   137|         0|            0|            0|  0.00%|
   138|         0|            0|            0|  0.00%|    return merged_lifespan  # type: ignore[return-value]
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|async def serialize_response(
   142|         0|            0|            0|  0.00%|    *,
   143|         0|            0|            0|  0.00%|    field: Optional[ModelField] = None,
   144|         0|            0|            0|  0.00%|    response_content: Any,
   145|         0|            0|            0|  0.00%|    include: Optional[IncEx] = None,
   146|         0|            0|            0|  0.00%|    exclude: Optional[IncEx] = None,
   147|         0|            0|            0|  0.00%|    by_alias: bool = True,
   148|         0|            0|            0|  0.00%|    exclude_unset: bool = False,
   149|         0|            0|            0|  0.00%|    exclude_defaults: bool = False,
   150|         0|            0|            0|  0.00%|    exclude_none: bool = False,
   151|         0|            0|            0|  0.00%|    is_coroutine: bool = True,
   152|         0|            0|            0|  0.00%|) -> Any:
   153|         0|            0|            0|  0.00%|    if field:
   154|         0|            0|            0|  0.00%|        errors = []
   155|         0|            0|            0|  0.00%|        if not hasattr(field, "serialize"):
   156|         0|            0|            0|  0.00%|            # pydantic v1
   157|         0|            0|            0|  0.00%|            response_content = _prepare_response_content(
   158|         0|            0|            0|  0.00%|                response_content,
   159|         0|            0|            0|  0.00%|                exclude_unset=exclude_unset,
   160|         0|            0|            0|  0.00%|                exclude_defaults=exclude_defaults,
   161|         0|            0|            0|  0.00%|                exclude_none=exclude_none,
   162|         0|            0|            0|  0.00%|            )
   163|         0|            0|            0|  0.00%|        if is_coroutine:
   164|         0|            0|            0|  0.00%|            value, errors_ = field.validate(response_content, {}, loc=("response",))
   165|         0|            0|            0|  0.00%|        else:
   166|         0|            0|            0|  0.00%|            value, errors_ = await run_in_threadpool(
   167|         0|            0|            0|  0.00%|                field.validate, response_content, {}, loc=("response",)
   168|         0|            0|            0|  0.00%|            )
   169|         0|            0|            0|  0.00%|        if isinstance(errors_, list):
   170|         0|            0|            0|  0.00%|            errors.extend(errors_)
   171|         0|            0|            0|  0.00%|        elif errors_:
   172|         0|            0|            0|  0.00%|            errors.append(errors_)
   173|         0|            0|            0|  0.00%|        if errors:
   174|         0|            0|            0|  0.00%|            raise ResponseValidationError(
   175|         0|            0|            0|  0.00%|                errors=_normalize_errors(errors), body=response_content
   176|         0|            0|            0|  0.00%|            )
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|        if hasattr(field, "serialize"):
   179|         0|            0|            0|  0.00%|            return field.serialize(
   180|         0|            0|            0|  0.00%|                value,
   181|         0|            0|            0|  0.00%|                include=include,
   182|         0|            0|            0|  0.00%|                exclude=exclude,
   183|         0|            0|            0|  0.00%|                by_alias=by_alias,
   184|         0|            0|            0|  0.00%|                exclude_unset=exclude_unset,
   185|         0|            0|            0|  0.00%|                exclude_defaults=exclude_defaults,
   186|         0|            0|            0|  0.00%|                exclude_none=exclude_none,
   187|         0|            0|            0|  0.00%|            )
   188|         0|            0|            0|  0.00%|
   189|         0|            0|            0|  0.00%|        return jsonable_encoder(
   190|         0|            0|            0|  0.00%|            value,
   191|         0|            0|            0|  0.00%|            include=include,
   192|         0|            0|            0|  0.00%|            exclude=exclude,
   193|         0|            0|            0|  0.00%|            by_alias=by_alias,
   194|         0|            0|            0|  0.00%|            exclude_unset=exclude_unset,
   195|         0|            0|            0|  0.00%|            exclude_defaults=exclude_defaults,
   196|         0|            0|            0|  0.00%|            exclude_none=exclude_none,
   197|         0|            0|            0|  0.00%|        )
   198|         0|            0|            0|  0.00%|    else:
   199|         0|            0|            0|  0.00%|        return jsonable_encoder(response_content)
   200|         0|            0|            0|  0.00%|
   201|         0|            0|            0|  0.00%|
   202|         0|            0|            0|  0.00%|async def run_endpoint_function(
   203|         0|            0|            0|  0.00%|    *, dependant: Dependant, values: Dict[str, Any], is_coroutine: bool
   204|         0|            0|            0|  0.00%|) -> Any:
   205|         0|            0|            0|  0.00%|    # Only called by get_request_handler. Has been split into its own function to
   206|         0|            0|            0|  0.00%|    # facilitate profiling endpoints, since inner functions are harder to profile.
   207|         0|            0|            0|  0.00%|    assert dependant.call is not None, "dependant.call must be a function"
   208|         0|            0|            0|  0.00%|
   209|         0|            0|            0|  0.00%|    if is_coroutine:
   210|         0|            0|            0|  0.00%|        return await dependant.call(**values)
   211|         0|            0|            0|  0.00%|    else:
   212|         0|            0|            0|  0.00%|        return await run_in_threadpool(dependant.call, **values)
   213|         0|            0|            0|  0.00%|
   214|         0|            0|            0|  0.00%|
   215|         0|            0|            0|  0.00%|def get_request_handler(
   216|         0|            0|            0|  0.00%|    dependant: Dependant,
   217|         0|            0|            0|  0.00%|    body_field: Optional[ModelField] = None,
   218|         0|            0|            0|  0.00%|    status_code: Optional[int] = None,
   219|         0|            0|            0|  0.00%|    response_class: Union[Type[Response], DefaultPlaceholder] = Default(JSONResponse),
   220|         0|            0|            0|  0.00%|    response_field: Optional[ModelField] = None,
   221|         0|            0|            0|  0.00%|    response_model_include: Optional[IncEx] = None,
   222|         0|            0|            0|  0.00%|    response_model_exclude: Optional[IncEx] = None,
   223|         0|            0|            0|  0.00%|    response_model_by_alias: bool = True,
   224|         0|            0|            0|  0.00%|    response_model_exclude_unset: bool = False,
   225|         0|            0|            0|  0.00%|    response_model_exclude_defaults: bool = False,
   226|         0|            0|            0|  0.00%|    response_model_exclude_none: bool = False,
   227|         0|            0|            0|  0.00%|    dependency_overrides_provider: Optional[Any] = None,
   228|         0|            0|            0|  0.00%|) -> Callable[[Request], Coroutine[Any, Any, Response]]:
   229|         0|            0|            0|  0.00%|    assert dependant.call is not None, "dependant.call must be a function"
   230|         0|            0|            0|  0.00%|    is_coroutine = asyncio.iscoroutinefunction(dependant.call)
   231|         0|            0|            0|  0.00%|    is_body_form = body_field and isinstance(body_field.field_info, params.Form)
   232|         0|            0|            0|  0.00%|    if isinstance(response_class, DefaultPlaceholder):
   233|         0|            0|            0|  0.00%|        actual_response_class: Type[Response] = response_class.value
   234|         0|            0|            0|  0.00%|    else:
   235|         0|            0|            0|  0.00%|        actual_response_class = response_class
   236|         0|            0|            0|  0.00%|
   237|         0|            0|            0|  0.00%|    async def app(request: Request) -> Response:
   238|         0|            0|            0|  0.00%|        response: Union[Response, None] = None
   239|         0|            0|            0|  0.00%|        async with AsyncExitStack() as file_stack:
   240|         0|            0|            0|  0.00%|            try:
   241|         0|            0|            0|  0.00%|                body: Any = None
   242|         0|            0|            0|  0.00%|                if body_field:
   243|         0|            0|            0|  0.00%|                    if is_body_form:
   244|         0|            0|            0|  0.00%|                        body = await request.form()
   245|         0|            0|            0|  0.00%|                        file_stack.push_async_callback(body.close)
   246|         0|            0|            0|  0.00%|                    else:
   247|         0|            0|            0|  0.00%|                        body_bytes = await request.body()
   248|         0|            0|            0|  0.00%|                        if body_bytes:
   249|         0|            0|            0|  0.00%|                            json_body: Any = Undefined
   250|         0|            0|            0|  0.00%|                            content_type_value = request.headers.get("content-type")
   251|         0|            0|            0|  0.00%|                            if not content_type_value:
   252|         0|            0|            0|  0.00%|                                json_body = await request.json()
   253|         0|            0|            0|  0.00%|                            else:
   254|         0|            0|            0|  0.00%|                                message = email.message.Message()
   255|         0|            0|            0|  0.00%|                                message["content-type"] = content_type_value
   256|         0|            0|            0|  0.00%|                                if message.get_content_maintype() == "application":
   257|         0|            0|            0|  0.00%|                                    subtype = message.get_content_subtype()
   258|         0|            0|            0|  0.00%|                                    if subtype == "json" or subtype.endswith("+json"):
   259|         0|            0|            0|  0.00%|                                        json_body = await request.json()
   260|         0|            0|            0|  0.00%|                            if json_body != Undefined:
   261|         0|            0|            0|  0.00%|                                body = json_body
   262|         0|            0|            0|  0.00%|                            else:
   263|         0|            0|            0|  0.00%|                                body = body_bytes
   264|         0|            0|            0|  0.00%|            except json.JSONDecodeError as e:
   265|         0|            0|            0|  0.00%|                validation_error = RequestValidationError(
   266|         0|            0|            0|  0.00%|                    [
   267|         0|            0|            0|  0.00%|                        {
   268|         0|            0|            0|  0.00%|                            "type": "json_invalid",
   269|         0|            0|            0|  0.00%|                            "loc": ("body", e.pos),
   270|         0|            0|            0|  0.00%|                            "msg": "JSON decode error",
   271|         0|            0|            0|  0.00%|                            "input": {},
   272|         0|            0|            0|  0.00%|                            "ctx": {"error": e.msg},
   273|         0|            0|            0|  0.00%|                        }
   274|         0|            0|            0|  0.00%|                    ],
   275|         0|            0|            0|  0.00%|                    body=e.doc,
   276|         0|            0|            0|  0.00%|                )
   277|         0|            0|            0|  0.00%|                raise validation_error from e
   278|         0|            0|            0|  0.00%|            except HTTPException:
   279|         0|            0|            0|  0.00%|                # If a middleware raises an HTTPException, it should be raised again
   280|         0|            0|            0|  0.00%|                raise
   281|         0|            0|            0|  0.00%|            except Exception as e:
   282|         0|            0|            0|  0.00%|                http_error = HTTPException(
   283|         0|            0|            0|  0.00%|                    status_code=400, detail="There was an error parsing the body"
   284|         0|            0|            0|  0.00%|                )
   285|         0|            0|            0|  0.00%|                raise http_error from e
   286|         0|            0|            0|  0.00%|            errors: List[Any] = []
   287|         0|            0|            0|  0.00%|            async with AsyncExitStack() as async_exit_stack:
   288|         0|            0|            0|  0.00%|                solved_result = await solve_dependencies(
   289|         0|            0|            0|  0.00%|                    request=request,
   290|         0|            0|            0|  0.00%|                    dependant=dependant,
   291|         0|            0|            0|  0.00%|                    body=body,
   292|         0|            0|            0|  0.00%|                    dependency_overrides_provider=dependency_overrides_provider,
   293|         0|            0|            0|  0.00%|                    async_exit_stack=async_exit_stack,
   294|         0|            0|            0|  0.00%|                )
   295|         0|            0|            0|  0.00%|                values, errors, background_tasks, sub_response, _ = solved_result
   296|         0|            0|            0|  0.00%|                if not errors:
   297|         0|            0|            0|  0.00%|                    raw_response = await run_endpoint_function(
   298|         0|            0|            0|  0.00%|                        dependant=dependant, values=values, is_coroutine=is_coroutine
   299|         0|            0|            0|  0.00%|                    )
   300|         0|            0|            0|  0.00%|                    if isinstance(raw_response, Response):
   301|         0|            0|            0|  0.00%|                        if raw_response.background is None:
   302|         0|            0|            0|  0.00%|                            raw_response.background = background_tasks
   303|         0|            0|            0|  0.00%|                        response = raw_response
   304|         0|            0|            0|  0.00%|                    else:
   305|         0|            0|            0|  0.00%|                        response_args: Dict[str, Any] = {"background": background_tasks}
   306|         0|            0|            0|  0.00%|                        # If status_code was set, use it, otherwise use the default from the
   307|         0|            0|            0|  0.00%|                        # response class, in the case of redirect it's 307
   308|         0|            0|            0|  0.00%|                        current_status_code = (
   309|         0|            0|            0|  0.00%|                            status_code if status_code else sub_response.status_code
   310|         0|            0|            0|  0.00%|                        )
   311|         0|            0|            0|  0.00%|                        if current_status_code is not None:
   312|         0|            0|            0|  0.00%|                            response_args["status_code"] = current_status_code
   313|         0|            0|            0|  0.00%|                        if sub_response.status_code:
   314|         0|            0|            0|  0.00%|                            response_args["status_code"] = sub_response.status_code
   315|         0|            0|            0|  0.00%|                        content = await serialize_response(
   316|         0|            0|            0|  0.00%|                            field=response_field,
   317|         0|            0|            0|  0.00%|                            response_content=raw_response,
   318|         0|            0|            0|  0.00%|                            include=response_model_include,
   319|         0|            0|            0|  0.00%|                            exclude=response_model_exclude,
   320|         0|            0|            0|  0.00%|                            by_alias=response_model_by_alias,
   321|         0|            0|            0|  0.00%|                            exclude_unset=response_model_exclude_unset,
   322|         0|            0|            0|  0.00%|                            exclude_defaults=response_model_exclude_defaults,
   323|         0|            0|            0|  0.00%|                            exclude_none=response_model_exclude_none,
   324|         0|            0|            0|  0.00%|                            is_coroutine=is_coroutine,
   325|         0|            0|            0|  0.00%|                        )
   326|         0|            0|            0|  0.00%|                        response = actual_response_class(content, **response_args)
   327|         0|            0|            0|  0.00%|                        if not is_body_allowed_for_status_code(response.status_code):
   328|         0|            0|            0|  0.00%|                            response.body = b""
   329|         0|            0|            0|  0.00%|                        response.headers.raw.extend(sub_response.headers.raw)
   330|         0|            0|            0|  0.00%|            if errors:
   331|         0|            0|            0|  0.00%|                validation_error = RequestValidationError(
   332|         0|            0|            0|  0.00%|                    _normalize_errors(errors), body=body
   333|         0|            0|            0|  0.00%|                )
   334|         0|            0|            0|  0.00%|                raise validation_error
   335|         0|            0|            0|  0.00%|        if response is None:
   336|         0|            0|            0|  0.00%|            raise FastAPIError(
   337|         0|            0|            0|  0.00%|                "No response object was returned. There's a high chance that the "
   338|         0|            0|            0|  0.00%|                "application code is raising an exception and a dependency with yield "
   339|         0|            0|            0|  0.00%|                "has a block with a bare except, or a block with except Exception, "
   340|         0|            0|            0|  0.00%|                "and is not raising the exception again. Read more about it in the "
   341|         0|            0|            0|  0.00%|                "docs: https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-with-yield/#dependencies-with-yield-and-except"
   342|         0|            0|            0|  0.00%|            )
   343|         0|            0|            0|  0.00%|        return response
   344|         0|            0|            0|  0.00%|
   345|         0|            0|            0|  0.00%|    return app
   346|         0|            0|            0|  0.00%|
   347|         0|            0|            0|  0.00%|
   348|         1|  5.24521e-06|  5.24521e-06|  0.01%|def get_websocket_app(
   349|         0|            0|            0|  0.00%|    dependant: Dependant, dependency_overrides_provider: Optional[Any] = None
   350|         0|            0|            0|  0.00%|) -> Callable[[WebSocket], Coroutine[Any, Any, Any]]:
   351|         1|   3.8147e-06|   3.8147e-06|  0.00%|    async def app(websocket: WebSocket) -> None:
   352|         0|            0|            0|  0.00%|        async with AsyncExitStack() as async_exit_stack:
   353|         0|            0|            0|  0.00%|            # TODO: remove this scope later, after a few releases
   354|         0|            0|            0|  0.00%|            # This scope fastapi_astack is no longer used by FastAPI, kept for
   355|         0|            0|            0|  0.00%|            # compatibility, just in case
   356|         0|            0|            0|  0.00%|            websocket.scope["fastapi_astack"] = async_exit_stack
   357|         0|            0|            0|  0.00%|            solved_result = await solve_dependencies(
   358|         0|            0|            0|  0.00%|                request=websocket,
   359|         0|            0|            0|  0.00%|                dependant=dependant,
   360|         0|            0|            0|  0.00%|                dependency_overrides_provider=dependency_overrides_provider,
   361|         0|            0|            0|  0.00%|                async_exit_stack=async_exit_stack,
   362|         0|            0|            0|  0.00%|            )
   363|         0|            0|            0|  0.00%|            values, errors, _, _2, _3 = solved_result
   364|         0|            0|            0|  0.00%|            if errors:
   365|         0|            0|            0|  0.00%|                raise WebSocketRequestValidationError(_normalize_errors(errors))
   366|         0|            0|            0|  0.00%|            assert dependant.call is not None, "dependant.call must be a function"
   367|         0|            0|            0|  0.00%|            await dependant.call(**values)
   368|         0|            0|            0|  0.00%|
   369|         1|  3.09944e-06|  3.09944e-06|  0.00%|    return app
   370|         0|            0|            0|  0.00%|
   371|         0|            0|            0|  0.00%|
   372|         0|            0|            0|  0.00%|class APIWebSocketRoute(routing.WebSocketRoute):
   373|         1|  4.05312e-06|  4.05312e-06|  0.00%|    def __init__(
   374|         0|            0|            0|  0.00%|        self,
   375|         0|            0|            0|  0.00%|        path: str,
   376|         0|            0|            0|  0.00%|        endpoint: Callable[..., Any],
   377|         0|            0|            0|  0.00%|        *,
   378|         0|            0|            0|  0.00%|        name: Optional[str] = None,
   379|         0|            0|            0|  0.00%|        dependencies: Optional[Sequence[params.Depends]] = None,
   380|         0|            0|            0|  0.00%|        dependency_overrides_provider: Optional[Any] = None,
   381|         0|            0|            0|  0.00%|    ) -> None:
   382|         1|  3.09944e-06|  3.09944e-06|  0.00%|        self.path = path
   383|         1|   2.6226e-06|   2.6226e-06|  0.00%|        self.endpoint = endpoint
   384|         1|  1.19209e-05|  1.19209e-05|  0.01%|        self.name = get_name(endpoint) if name is None else name
(call)|         1|  8.34465e-06|  8.34465e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/starlette/routing.py:101 get_name
   385|         1|  3.57628e-06|  3.57628e-06|  0.00%|        self.dependencies = list(dependencies or [])
   386|         1|  3.09944e-05|  3.09944e-05|  0.03%|        self.path_regex, self.path_format, self.param_convertors = compile_path(path)
(call)|         1|    0.0753617|    0.0753617| 77.47%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/starlette/routing.py:123 compile_path
   387|         1|  2.76566e-05|  2.76566e-05|  0.03%|        self.dependant = get_dependant(path=self.path_format, call=self.endpoint)
(call)|         1|    0.0213299|    0.0213299| 21.93%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/dependencies/utils.py:241 get_dependant
   388|         1|  4.52995e-06|  4.52995e-06|  0.00%|        for depends in self.dependencies[::-1]:
   389|         0|            0|            0|  0.00%|            self.dependant.dependencies.insert(
   390|         0|            0|            0|  0.00%|                0,
   391|         0|            0|            0|  0.00%|                get_parameterless_sub_dependant(depends=depends, path=self.path_format),
   392|         0|            0|            0|  0.00%|            )
   393|         0|            0|            0|  0.00%|
   394|         2|  1.45435e-05|  7.27177e-06|  0.01%|        self.app = websocket_session(
(call)|         1|  1.09673e-05|  1.09673e-05|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/starlette/routing.py:82 websocket_session
   395|         2|  1.95503e-05|  9.77516e-06|  0.02%|            get_websocket_app(
(call)|         1|  1.21593e-05|  1.21593e-05|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/routing.py:348 get_websocket_app
   396|         1|  2.38419e-06|  2.38419e-06|  0.00%|                dependant=self.dependant,
   397|         1|  2.38419e-06|  2.38419e-06|  0.00%|                dependency_overrides_provider=dependency_overrides_provider,
   398|         0|            0|            0|  0.00%|            )
   399|         0|            0|            0|  0.00%|        )
   400|         0|            0|            0|  0.00%|
   401|         0|            0|            0|  0.00%|    def matches(self, scope: Scope) -> Tuple[Match, Scope]:
   402|         0|            0|            0|  0.00%|        match, child_scope = super().matches(scope)
   403|         0|            0|            0|  0.00%|        if match != Match.NONE:
   404|         0|            0|            0|  0.00%|            child_scope["route"] = self
   405|         0|            0|            0|  0.00%|        return match, child_scope
   406|         0|            0|            0|  0.00%|
   407|         0|            0|            0|  0.00%|
   408|         0|            0|            0|  0.00%|class APIRoute(routing.Route):
   409|         0|            0|            0|  0.00%|    def __init__(
   410|         0|            0|            0|  0.00%|        self,
   411|         0|            0|            0|  0.00%|        path: str,
   412|         0|            0|            0|  0.00%|        endpoint: Callable[..., Any],
   413|         0|            0|            0|  0.00%|        *,
   414|         0|            0|            0|  0.00%|        response_model: Any = Default(None),
   415|         0|            0|            0|  0.00%|        status_code: Optional[int] = None,
   416|         0|            0|            0|  0.00%|        tags: Optional[List[Union[str, Enum]]] = None,
   417|         0|            0|            0|  0.00%|        dependencies: Optional[Sequence[params.Depends]] = None,
   418|         0|            0|            0|  0.00%|        summary: Optional[str] = None,
   419|         0|            0|            0|  0.00%|        description: Optional[str] = None,
   420|         0|            0|            0|  0.00%|        response_description: str = "Successful Response",
   421|         0|            0|            0|  0.00%|        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,
   422|         0|            0|            0|  0.00%|        deprecated: Optional[bool] = None,
   423|         0|            0|            0|  0.00%|        name: Optional[str] = None,
   424|         0|            0|            0|  0.00%|        methods: Optional[Union[Set[str], List[str]]] = None,
   425|         0|            0|            0|  0.00%|        operation_id: Optional[str] = None,
   426|         0|            0|            0|  0.00%|        response_model_include: Optional[IncEx] = None,
   427|         0|            0|            0|  0.00%|        response_model_exclude: Optional[IncEx] = None,
   428|         0|            0|            0|  0.00%|        response_model_by_alias: bool = True,
   429|         0|            0|            0|  0.00%|        response_model_exclude_unset: bool = False,
   430|         0|            0|            0|  0.00%|        response_model_exclude_defaults: bool = False,
   431|         0|            0|            0|  0.00%|        response_model_exclude_none: bool = False,
   432|         0|            0|            0|  0.00%|        include_in_schema: bool = True,
   433|         0|            0|            0|  0.00%|        response_class: Union[Type[Response], DefaultPlaceholder] = Default(
   434|         0|            0|            0|  0.00%|            JSONResponse
   435|         0|            0|            0|  0.00%|        ),
   436|         0|            0|            0|  0.00%|        dependency_overrides_provider: Optional[Any] = None,
   437|         0|            0|            0|  0.00%|        callbacks: Optional[List[BaseRoute]] = None,
   438|         0|            0|            0|  0.00%|        openapi_extra: Optional[Dict[str, Any]] = None,
   439|         0|            0|            0|  0.00%|        generate_unique_id_function: Union[
   440|         0|            0|            0|  0.00%|            Callable[["APIRoute"], str], DefaultPlaceholder
   441|         0|            0|            0|  0.00%|        ] = Default(generate_unique_id),
   442|         0|            0|            0|  0.00%|    ) -> None:
   443|         0|            0|            0|  0.00%|        self.path = path
   444|         0|            0|            0|  0.00%|        self.endpoint = endpoint
   445|         0|            0|            0|  0.00%|        if isinstance(response_model, DefaultPlaceholder):
   446|         0|            0|            0|  0.00%|            return_annotation = get_typed_return_annotation(endpoint)
   447|         0|            0|            0|  0.00%|            if lenient_issubclass(return_annotation, Response):
   448|         0|            0|            0|  0.00%|                response_model = None
   449|         0|            0|            0|  0.00%|            else:
   450|         0|            0|            0|  0.00%|                response_model = return_annotation
   451|         0|            0|            0|  0.00%|        self.response_model = response_model
   452|         0|            0|            0|  0.00%|        self.summary = summary
   453|         0|            0|            0|  0.00%|        self.response_description = response_description
   454|         0|            0|            0|  0.00%|        self.deprecated = deprecated
   455|         0|            0|            0|  0.00%|        self.operation_id = operation_id
   456|         0|            0|            0|  0.00%|        self.response_model_include = response_model_include
   457|         0|            0|            0|  0.00%|        self.response_model_exclude = response_model_exclude
   458|         0|            0|            0|  0.00%|        self.response_model_by_alias = response_model_by_alias
   459|         0|            0|            0|  0.00%|        self.response_model_exclude_unset = response_model_exclude_unset
   460|         0|            0|            0|  0.00%|        self.response_model_exclude_defaults = response_model_exclude_defaults
   461|         0|            0|            0|  0.00%|        self.response_model_exclude_none = response_model_exclude_none
   462|         0|            0|            0|  0.00%|        self.include_in_schema = include_in_schema
   463|         0|            0|            0|  0.00%|        self.response_class = response_class
   464|         0|            0|            0|  0.00%|        self.dependency_overrides_provider = dependency_overrides_provider
   465|         0|            0|            0|  0.00%|        self.callbacks = callbacks
   466|         0|            0|            0|  0.00%|        self.openapi_extra = openapi_extra
   467|         0|            0|            0|  0.00%|        self.generate_unique_id_function = generate_unique_id_function
   468|         0|            0|            0|  0.00%|        self.tags = tags or []
   469|         0|            0|            0|  0.00%|        self.responses = responses or {}
   470|         0|            0|            0|  0.00%|        self.name = get_name(endpoint) if name is None else name
   471|         0|            0|            0|  0.00%|        self.path_regex, self.path_format, self.param_convertors = compile_path(path)
   472|         0|            0|            0|  0.00%|        if methods is None:
   473|         0|            0|            0|  0.00%|            methods = ["GET"]
   474|         0|            0|            0|  0.00%|        self.methods: Set[str] = {method.upper() for method in methods}
   475|         0|            0|            0|  0.00%|        if isinstance(generate_unique_id_function, DefaultPlaceholder):
   476|         0|            0|            0|  0.00%|            current_generate_unique_id: Callable[[APIRoute], str] = (
   477|         0|            0|            0|  0.00%|                generate_unique_id_function.value
   478|         0|            0|            0|  0.00%|            )
   479|         0|            0|            0|  0.00%|        else:
   480|         0|            0|            0|  0.00%|            current_generate_unique_id = generate_unique_id_function
   481|         0|            0|            0|  0.00%|        self.unique_id = self.operation_id or current_generate_unique_id(self)
   482|         0|            0|            0|  0.00%|        # normalize enums e.g. http.HTTPStatus
   483|         0|            0|            0|  0.00%|        if isinstance(status_code, IntEnum):
   484|         0|            0|            0|  0.00%|            status_code = int(status_code)
   485|         0|            0|            0|  0.00%|        self.status_code = status_code
   486|         0|            0|            0|  0.00%|        if self.response_model:
   487|         0|            0|            0|  0.00%|            assert is_body_allowed_for_status_code(
   488|         0|            0|            0|  0.00%|                status_code
   489|         0|            0|            0|  0.00%|            ), f"Status code {status_code} must not have a response body"
   490|         0|            0|            0|  0.00%|            response_name = "Response_" + self.unique_id
   491|         0|            0|            0|  0.00%|            self.response_field = create_response_field(
   492|         0|            0|            0|  0.00%|                name=response_name,
   493|         0|            0|            0|  0.00%|                type_=self.response_model,
   494|         0|            0|            0|  0.00%|                mode="serialization",
   495|         0|            0|            0|  0.00%|            )
   496|         0|            0|            0|  0.00%|            # Create a clone of the field, so that a Pydantic submodel is not returned
   497|         0|            0|            0|  0.00%|            # as is just because it's an instance of a subclass of a more limited class
   498|         0|            0|            0|  0.00%|            # e.g. UserInDB (containing hashed_password) could be a subclass of User
   499|         0|            0|            0|  0.00%|            # that doesn't have the hashed_password. But because it's a subclass, it
   500|         0|            0|            0|  0.00%|            # would pass the validation and be returned as is.
   501|         0|            0|            0|  0.00%|            # By being a new field, no inheritance will be passed as is. A new model
   502|         0|            0|            0|  0.00%|            # will always be created.
   503|         0|            0|            0|  0.00%|            # TODO: remove when deprecating Pydantic v1
   504|         0|            0|            0|  0.00%|            self.secure_cloned_response_field: Optional[ModelField] = (
   505|         0|            0|            0|  0.00%|                create_cloned_field(self.response_field)
   506|         0|            0|            0|  0.00%|            )
   507|         0|            0|            0|  0.00%|        else:
   508|         0|            0|            0|  0.00%|            self.response_field = None  # type: ignore
   509|         0|            0|            0|  0.00%|            self.secure_cloned_response_field = None
   510|         0|            0|            0|  0.00%|        self.dependencies = list(dependencies or [])
   511|         0|            0|            0|  0.00%|        self.description = description or inspect.cleandoc(self.endpoint.__doc__ or "")
   512|         0|            0|            0|  0.00%|        # if a "form feed" character (page break) is found in the description text,
   513|         0|            0|            0|  0.00%|        # truncate description text to the content preceding the first "form feed"
   514|         0|            0|            0|  0.00%|        self.description = self.description.split("\f")[0].strip()
   515|         0|            0|            0|  0.00%|        response_fields = {}
   516|         0|            0|            0|  0.00%|        for additional_status_code, response in self.responses.items():
   517|         0|            0|            0|  0.00%|            assert isinstance(response, dict), "An additional response must be a dict"
   518|         0|            0|            0|  0.00%|            model = response.get("model")
   519|         0|            0|            0|  0.00%|            if model:
   520|         0|            0|            0|  0.00%|                assert is_body_allowed_for_status_code(
   521|         0|            0|            0|  0.00%|                    additional_status_code
   522|         0|            0|            0|  0.00%|                ), f"Status code {additional_status_code} must not have a response body"
   523|         0|            0|            0|  0.00%|                response_name = f"Response_{additional_status_code}_{self.unique_id}"
   524|         0|            0|            0|  0.00%|                response_field = create_response_field(name=response_name, type_=model)
   525|         0|            0|            0|  0.00%|                response_fields[additional_status_code] = response_field
   526|         0|            0|            0|  0.00%|        if response_fields:
   527|         0|            0|            0|  0.00%|            self.response_fields: Dict[Union[int, str], ModelField] = response_fields
   528|         0|            0|            0|  0.00%|        else:
   529|         0|            0|            0|  0.00%|            self.response_fields = {}
   530|         0|            0|            0|  0.00%|
   531|         0|            0|            0|  0.00%|        assert callable(endpoint), "An endpoint must be a callable"
   532|         0|            0|            0|  0.00%|        self.dependant = get_dependant(path=self.path_format, call=self.endpoint)
   533|         0|            0|            0|  0.00%|        for depends in self.dependencies[::-1]:
   534|         0|            0|            0|  0.00%|            self.dependant.dependencies.insert(
   535|         0|            0|            0|  0.00%|                0,
   536|         0|            0|            0|  0.00%|                get_parameterless_sub_dependant(depends=depends, path=self.path_format),
   537|         0|            0|            0|  0.00%|            )
   538|         0|            0|            0|  0.00%|        self.body_field = get_body_field(dependant=self.dependant, name=self.unique_id)
   539|         0|            0|            0|  0.00%|        self.app = request_response(self.get_route_handler())
   540|         0|            0|            0|  0.00%|
   541|         0|            0|            0|  0.00%|    def get_route_handler(self) -> Callable[[Request], Coroutine[Any, Any, Response]]:
   542|         0|            0|            0|  0.00%|        return get_request_handler(
   543|         0|            0|            0|  0.00%|            dependant=self.dependant,
   544|         0|            0|            0|  0.00%|            body_field=self.body_field,
   545|         0|            0|            0|  0.00%|            status_code=self.status_code,
   546|         0|            0|            0|  0.00%|            response_class=self.response_class,
   547|         0|            0|            0|  0.00%|            response_field=self.secure_cloned_response_field,
   548|         0|            0|            0|  0.00%|            response_model_include=self.response_model_include,
   549|         0|            0|            0|  0.00%|            response_model_exclude=self.response_model_exclude,
   550|         0|            0|            0|  0.00%|            response_model_by_alias=self.response_model_by_alias,
   551|         0|            0|            0|  0.00%|            response_model_exclude_unset=self.response_model_exclude_unset,
   552|         0|            0|            0|  0.00%|            response_model_exclude_defaults=self.response_model_exclude_defaults,
   553|         0|            0|            0|  0.00%|            response_model_exclude_none=self.response_model_exclude_none,
   554|         0|            0|            0|  0.00%|            dependency_overrides_provider=self.dependency_overrides_provider,
   555|         0|            0|            0|  0.00%|        )
   556|         0|            0|            0|  0.00%|
   557|         0|            0|            0|  0.00%|    def matches(self, scope: Scope) -> Tuple[Match, Scope]:
   558|         0|            0|            0|  0.00%|        match, child_scope = super().matches(scope)
   559|         0|            0|            0|  0.00%|        if match != Match.NONE:
   560|         0|            0|            0|  0.00%|            child_scope["route"] = self
   561|         0|            0|            0|  0.00%|        return match, child_scope
   562|         0|            0|            0|  0.00%|
   563|         0|            0|            0|  0.00%|
   564|         0|            0|            0|  0.00%|class APIRouter(routing.Router):
   565|         0|            0|            0|  0.00%|    """
   566|         0|            0|            0|  0.00%|    `APIRouter` class, used to group *path operations*, for example to structure
   567|         0|            0|            0|  0.00%|    an app in multiple files. It would then be included in the `FastAPI` app, or
   568|         0|            0|            0|  0.00%|    in another `APIRouter` (ultimately included in the app).
   569|         0|            0|            0|  0.00%|
   570|         0|            0|            0|  0.00%|    Read more about it in the
   571|         0|            0|            0|  0.00%|    [FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/).
   572|         0|            0|            0|  0.00%|
   573|         0|            0|            0|  0.00%|    ## Example
   574|         0|            0|            0|  0.00%|
   575|         0|            0|            0|  0.00%|    ```python
   576|         0|            0|            0|  0.00%|    from fastapi import APIRouter, FastAPI
   577|         0|            0|            0|  0.00%|
   578|         0|            0|            0|  0.00%|    app = FastAPI()
   579|         0|            0|            0|  0.00%|    router = APIRouter()
   580|         0|            0|            0|  0.00%|
   581|         0|            0|            0|  0.00%|
   582|         0|            0|            0|  0.00%|    @router.get("/users/", tags=["users"])
   583|         0|            0|            0|  0.00%|    async def read_users():
   584|         0|            0|            0|  0.00%|        return [{"username": "Rick"}, {"username": "Morty"}]
   585|         0|            0|            0|  0.00%|
   586|         0|            0|            0|  0.00%|
   587|         0|            0|            0|  0.00%|    app.include_router(router)
   588|         0|            0|            0|  0.00%|    ```
   589|         0|            0|            0|  0.00%|    """
   590|         0|            0|            0|  0.00%|
   591|         0|            0|            0|  0.00%|    def __init__(
   592|         0|            0|            0|  0.00%|        self,
   593|         0|            0|            0|  0.00%|        *,
   594|         0|            0|            0|  0.00%|        prefix: Annotated[str, Doc("An optional path prefix for the router.")] = "",
   595|         0|            0|            0|  0.00%|        tags: Annotated[
   596|         0|            0|            0|  0.00%|            Optional[List[Union[str, Enum]]],
   597|         0|            0|            0|  0.00%|            Doc(
   598|         0|            0|            0|  0.00%|                """
   599|         0|            0|            0|  0.00%|                A list of tags to be applied to all the *path operations* in this
   600|         0|            0|            0|  0.00%|                router.
   601|         0|            0|            0|  0.00%|
   602|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
   603|         0|            0|            0|  0.00%|
   604|         0|            0|            0|  0.00%|                Read more about it in the
   605|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
   606|         0|            0|            0|  0.00%|                """
   607|         0|            0|            0|  0.00%|            ),
   608|         0|            0|            0|  0.00%|        ] = None,
   609|         0|            0|            0|  0.00%|        dependencies: Annotated[
   610|         0|            0|            0|  0.00%|            Optional[Sequence[params.Depends]],
   611|         0|            0|            0|  0.00%|            Doc(
   612|         0|            0|            0|  0.00%|                """
   613|         0|            0|            0|  0.00%|                A list of dependencies (using `Depends()`) to be applied to all the
   614|         0|            0|            0|  0.00%|                *path operations* in this router.
   615|         0|            0|            0|  0.00%|
   616|         0|            0|            0|  0.00%|                Read more about it in the
   617|         0|            0|            0|  0.00%|                [FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).
   618|         0|            0|            0|  0.00%|                """
   619|         0|            0|            0|  0.00%|            ),
   620|         0|            0|            0|  0.00%|        ] = None,
   621|         0|            0|            0|  0.00%|        default_response_class: Annotated[
   622|         0|            0|            0|  0.00%|            Type[Response],
   623|         0|            0|            0|  0.00%|            Doc(
   624|         0|            0|            0|  0.00%|                """
   625|         0|            0|            0|  0.00%|                The default response class to be used.
   626|         0|            0|            0|  0.00%|
   627|         0|            0|            0|  0.00%|                Read more in the
   628|         0|            0|            0|  0.00%|                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).
   629|         0|            0|            0|  0.00%|                """
   630|         0|            0|            0|  0.00%|            ),
   631|         0|            0|            0|  0.00%|        ] = Default(JSONResponse),
   632|         0|            0|            0|  0.00%|        responses: Annotated[
   633|         0|            0|            0|  0.00%|            Optional[Dict[Union[int, str], Dict[str, Any]]],
   634|         0|            0|            0|  0.00%|            Doc(
   635|         0|            0|            0|  0.00%|                """
   636|         0|            0|            0|  0.00%|                Additional responses to be shown in OpenAPI.
   637|         0|            0|            0|  0.00%|
   638|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
   639|         0|            0|            0|  0.00%|
   640|         0|            0|            0|  0.00%|                Read more about it in the
   641|         0|            0|            0|  0.00%|                [FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).
   642|         0|            0|            0|  0.00%|
   643|         0|            0|            0|  0.00%|                And in the
   644|         0|            0|            0|  0.00%|                [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).
   645|         0|            0|            0|  0.00%|                """
   646|         0|            0|            0|  0.00%|            ),
   647|         0|            0|            0|  0.00%|        ] = None,
   648|         0|            0|            0|  0.00%|        callbacks: Annotated[
   649|         0|            0|            0|  0.00%|            Optional[List[BaseRoute]],
   650|         0|            0|            0|  0.00%|            Doc(
   651|         0|            0|            0|  0.00%|                """
   652|         0|            0|            0|  0.00%|                OpenAPI callbacks that should apply to all *path operations* in this
   653|         0|            0|            0|  0.00%|                router.
   654|         0|            0|            0|  0.00%|
   655|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
   656|         0|            0|            0|  0.00%|
   657|         0|            0|            0|  0.00%|                Read more about it in the
   658|         0|            0|            0|  0.00%|                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
   659|         0|            0|            0|  0.00%|                """
   660|         0|            0|            0|  0.00%|            ),
   661|         0|            0|            0|  0.00%|        ] = None,
   662|         0|            0|            0|  0.00%|        routes: Annotated[
   663|         0|            0|            0|  0.00%|            Optional[List[BaseRoute]],
   664|         0|            0|            0|  0.00%|            Doc(
   665|         0|            0|            0|  0.00%|                """
   666|         0|            0|            0|  0.00%|                **Note**: you probably shouldn't use this parameter, it is inherited
   667|         0|            0|            0|  0.00%|                from Starlette and supported for compatibility.
   668|         0|            0|            0|  0.00%|
   669|         0|            0|            0|  0.00%|                ---
   670|         0|            0|            0|  0.00%|
   671|         0|            0|            0|  0.00%|                A list of routes to serve incoming HTTP and WebSocket requests.
   672|         0|            0|            0|  0.00%|                """
   673|         0|            0|            0|  0.00%|            ),
   674|         0|            0|            0|  0.00%|            deprecated(
   675|         0|            0|            0|  0.00%|                """
   676|         0|            0|            0|  0.00%|                You normally wouldn't use this parameter with FastAPI, it is inherited
   677|         0|            0|            0|  0.00%|                from Starlette and supported for compatibility.
   678|         0|            0|            0|  0.00%|
   679|         0|            0|            0|  0.00%|                In FastAPI, you normally would use the *path operation methods*,
   680|         0|            0|            0|  0.00%|                like `router.get()`, `router.post()`, etc.
   681|         0|            0|            0|  0.00%|                """
   682|         0|            0|            0|  0.00%|            ),
   683|         0|            0|            0|  0.00%|        ] = None,
   684|         0|            0|            0|  0.00%|        redirect_slashes: Annotated[
   685|         0|            0|            0|  0.00%|            bool,
   686|         0|            0|            0|  0.00%|            Doc(
   687|         0|            0|            0|  0.00%|                """
   688|         0|            0|            0|  0.00%|                Whether to detect and redirect slashes in URLs when the client doesn't
   689|         0|            0|            0|  0.00%|                use the same format.
   690|         0|            0|            0|  0.00%|                """
   691|         0|            0|            0|  0.00%|            ),
   692|         0|            0|            0|  0.00%|        ] = True,
   693|         0|            0|            0|  0.00%|        default: Annotated[
   694|         0|            0|            0|  0.00%|            Optional[ASGIApp],
   695|         0|            0|            0|  0.00%|            Doc(
   696|         0|            0|            0|  0.00%|                """
   697|         0|            0|            0|  0.00%|                Default function handler for this router. Used to handle
   698|         0|            0|            0|  0.00%|                404 Not Found errors.
   699|         0|            0|            0|  0.00%|                """
   700|         0|            0|            0|  0.00%|            ),
   701|         0|            0|            0|  0.00%|        ] = None,
   702|         0|            0|            0|  0.00%|        dependency_overrides_provider: Annotated[
   703|         0|            0|            0|  0.00%|            Optional[Any],
   704|         0|            0|            0|  0.00%|            Doc(
   705|         0|            0|            0|  0.00%|                """
   706|         0|            0|            0|  0.00%|                Only used internally by FastAPI to handle dependency overrides.
   707|         0|            0|            0|  0.00%|
   708|         0|            0|            0|  0.00%|                You shouldn't need to use it. It normally points to the `FastAPI` app
   709|         0|            0|            0|  0.00%|                object.
   710|         0|            0|            0|  0.00%|                """
   711|         0|            0|            0|  0.00%|            ),
   712|         0|            0|            0|  0.00%|        ] = None,
   713|         0|            0|            0|  0.00%|        route_class: Annotated[
   714|         0|            0|            0|  0.00%|            Type[APIRoute],
   715|         0|            0|            0|  0.00%|            Doc(
   716|         0|            0|            0|  0.00%|                """
   717|         0|            0|            0|  0.00%|                Custom route (*path operation*) class to be used by this router.
   718|         0|            0|            0|  0.00%|
   719|         0|            0|            0|  0.00%|                Read more about it in the
   720|         0|            0|            0|  0.00%|                [FastAPI docs for Custom Request and APIRoute class](https://fastapi.tiangolo.com/how-to/custom-request-and-route/#custom-apiroute-class-in-a-router).
   721|         0|            0|            0|  0.00%|                """
   722|         0|            0|            0|  0.00%|            ),
   723|         0|            0|            0|  0.00%|        ] = APIRoute,
   724|         0|            0|            0|  0.00%|        on_startup: Annotated[
   725|         0|            0|            0|  0.00%|            Optional[Sequence[Callable[[], Any]]],
   726|         0|            0|            0|  0.00%|            Doc(
   727|         0|            0|            0|  0.00%|                """
   728|         0|            0|            0|  0.00%|                A list of startup event handler functions.
   729|         0|            0|            0|  0.00%|
   730|         0|            0|            0|  0.00%|                You should instead use the `lifespan` handlers.
   731|         0|            0|            0|  0.00%|
   732|         0|            0|            0|  0.00%|                Read more in the [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).
   733|         0|            0|            0|  0.00%|                """
   734|         0|            0|            0|  0.00%|            ),
   735|         0|            0|            0|  0.00%|        ] = None,
   736|         0|            0|            0|  0.00%|        on_shutdown: Annotated[
   737|         0|            0|            0|  0.00%|            Optional[Sequence[Callable[[], Any]]],
   738|         0|            0|            0|  0.00%|            Doc(
   739|         0|            0|            0|  0.00%|                """
   740|         0|            0|            0|  0.00%|                A list of shutdown event handler functions.
   741|         0|            0|            0|  0.00%|
   742|         0|            0|            0|  0.00%|                You should instead use the `lifespan` handlers.
   743|         0|            0|            0|  0.00%|
   744|         0|            0|            0|  0.00%|                Read more in the
   745|         0|            0|            0|  0.00%|                [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).
   746|         0|            0|            0|  0.00%|                """
   747|         0|            0|            0|  0.00%|            ),
   748|         0|            0|            0|  0.00%|        ] = None,
   749|         0|            0|            0|  0.00%|        # the generic to Lifespan[AppType] is the type of the top level application
   750|         0|            0|            0|  0.00%|        # which the router cannot know statically, so we use typing.Any
   751|         0|            0|            0|  0.00%|        lifespan: Annotated[
   752|         0|            0|            0|  0.00%|            Optional[Lifespan[Any]],
   753|         0|            0|            0|  0.00%|            Doc(
   754|         0|            0|            0|  0.00%|                """
   755|         0|            0|            0|  0.00%|                A `Lifespan` context manager handler. This replaces `startup` and
   756|         0|            0|            0|  0.00%|                `shutdown` functions with a single context manager.
   757|         0|            0|            0|  0.00%|
   758|         0|            0|            0|  0.00%|                Read more in the
   759|         0|            0|            0|  0.00%|                [FastAPI docs for `lifespan`](https://fastapi.tiangolo.com/advanced/events/).
   760|         0|            0|            0|  0.00%|                """
   761|         0|            0|            0|  0.00%|            ),
   762|         0|            0|            0|  0.00%|        ] = None,
   763|         0|            0|            0|  0.00%|        deprecated: Annotated[
   764|         0|            0|            0|  0.00%|            Optional[bool],
   765|         0|            0|            0|  0.00%|            Doc(
   766|         0|            0|            0|  0.00%|                """
   767|         0|            0|            0|  0.00%|                Mark all *path operations* in this router as deprecated.
   768|         0|            0|            0|  0.00%|
   769|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
   770|         0|            0|            0|  0.00%|
   771|         0|            0|            0|  0.00%|                Read more about it in the
   772|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
   773|         0|            0|            0|  0.00%|                """
   774|         0|            0|            0|  0.00%|            ),
   775|         0|            0|            0|  0.00%|        ] = None,
   776|         0|            0|            0|  0.00%|        include_in_schema: Annotated[
   777|         0|            0|            0|  0.00%|            bool,
   778|         0|            0|            0|  0.00%|            Doc(
   779|         0|            0|            0|  0.00%|                """
   780|         0|            0|            0|  0.00%|                To include (or not) all the *path operations* in this router in the
   781|         0|            0|            0|  0.00%|                generated OpenAPI.
   782|         0|            0|            0|  0.00%|
   783|         0|            0|            0|  0.00%|                This affects the generated OpenAPI (e.g. visible at `/docs`).
   784|         0|            0|            0|  0.00%|
   785|         0|            0|            0|  0.00%|                Read more about it in the
   786|         0|            0|            0|  0.00%|                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).
   787|         0|            0|            0|  0.00%|                """
   788|         0|            0|            0|  0.00%|            ),
   789|         0|            0|            0|  0.00%|        ] = True,
   790|         0|            0|            0|  0.00%|        generate_unique_id_function: Annotated[
   791|         0|            0|            0|  0.00%|            Callable[[APIRoute], str],
   792|         0|            0|            0|  0.00%|            Doc(
   793|         0|            0|            0|  0.00%|                """
   794|         0|            0|            0|  0.00%|                Customize the function used to generate unique IDs for the *path
   795|         0|            0|            0|  0.00%|                operations* shown in the generated OpenAPI.
   796|         0|            0|            0|  0.00%|
   797|         0|            0|            0|  0.00%|                This is particularly useful when automatically generating clients or
   798|         0|            0|            0|  0.00%|                SDKs for your API.
   799|         0|            0|            0|  0.00%|
   800|         0|            0|            0|  0.00%|                Read more about it in the
   801|         0|            0|            0|  0.00%|                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
   802|         0|            0|            0|  0.00%|                """
   803|         0|            0|            0|  0.00%|            ),
   804|         0|            0|            0|  0.00%|        ] = Default(generate_unique_id),
   805|         0|            0|            0|  0.00%|    ) -> None:
   806|         0|            0|            0|  0.00%|        super().__init__(
   807|         0|            0|            0|  0.00%|            routes=routes,
   808|         0|            0|            0|  0.00%|            redirect_slashes=redirect_slashes,
   809|         0|            0|            0|  0.00%|            default=default,
   810|         0|            0|            0|  0.00%|            on_startup=on_startup,
   811|         0|            0|            0|  0.00%|            on_shutdown=on_shutdown,
   812|         0|            0|            0|  0.00%|            lifespan=lifespan,
   813|         0|            0|            0|  0.00%|        )
   814|         0|            0|            0|  0.00%|        if prefix:
   815|         0|            0|            0|  0.00%|            assert prefix.startswith("/"), "A path prefix must start with '/'"
   816|         0|            0|            0|  0.00%|            assert not prefix.endswith(
   817|         0|            0|            0|  0.00%|                "/"
   818|         0|            0|            0|  0.00%|            ), "A path prefix must not end with '/', as the routes will start with '/'"
   819|         0|            0|            0|  0.00%|        self.prefix = prefix
   820|         0|            0|            0|  0.00%|        self.tags: List[Union[str, Enum]] = tags or []
   821|         0|            0|            0|  0.00%|        self.dependencies = list(dependencies or [])
   822|         0|            0|            0|  0.00%|        self.deprecated = deprecated
   823|         0|            0|            0|  0.00%|        self.include_in_schema = include_in_schema
   824|         0|            0|            0|  0.00%|        self.responses = responses or {}
   825|         0|            0|            0|  0.00%|        self.callbacks = callbacks or []
   826|         0|            0|            0|  0.00%|        self.dependency_overrides_provider = dependency_overrides_provider
   827|         0|            0|            0|  0.00%|        self.route_class = route_class
   828|         0|            0|            0|  0.00%|        self.default_response_class = default_response_class
   829|         0|            0|            0|  0.00%|        self.generate_unique_id_function = generate_unique_id_function
   830|         0|            0|            0|  0.00%|
   831|         0|            0|            0|  0.00%|    def route(
   832|         0|            0|            0|  0.00%|        self,
   833|         0|            0|            0|  0.00%|        path: str,
   834|         0|            0|            0|  0.00%|        methods: Optional[List[str]] = None,
   835|         0|            0|            0|  0.00%|        name: Optional[str] = None,
   836|         0|            0|            0|  0.00%|        include_in_schema: bool = True,
   837|         0|            0|            0|  0.00%|    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
   838|         0|            0|            0|  0.00%|        def decorator(func: DecoratedCallable) -> DecoratedCallable:
   839|         0|            0|            0|  0.00%|            self.add_route(
   840|         0|            0|            0|  0.00%|                path,
   841|         0|            0|            0|  0.00%|                func,
   842|         0|            0|            0|  0.00%|                methods=methods,
   843|         0|            0|            0|  0.00%|                name=name,
   844|         0|            0|            0|  0.00%|                include_in_schema=include_in_schema,
   845|         0|            0|            0|  0.00%|            )
   846|         0|            0|            0|  0.00%|            return func
   847|         0|            0|            0|  0.00%|
   848|         0|            0|            0|  0.00%|        return decorator
   849|         0|            0|            0|  0.00%|
   850|         0|            0|            0|  0.00%|    def add_api_route(
   851|         0|            0|            0|  0.00%|        self,
   852|         0|            0|            0|  0.00%|        path: str,
   853|         0|            0|            0|  0.00%|        endpoint: Callable[..., Any],
   854|         0|            0|            0|  0.00%|        *,
   855|         0|            0|            0|  0.00%|        response_model: Any = Default(None),
   856|         0|            0|            0|  0.00%|        status_code: Optional[int] = None,
   857|         0|            0|            0|  0.00%|        tags: Optional[List[Union[str, Enum]]] = None,
   858|         0|            0|            0|  0.00%|        dependencies: Optional[Sequence[params.Depends]] = None,
   859|         0|            0|            0|  0.00%|        summary: Optional[str] = None,
   860|         0|            0|            0|  0.00%|        description: Optional[str] = None,
   861|         0|            0|            0|  0.00%|        response_description: str = "Successful Response",
   862|         0|            0|            0|  0.00%|        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,
   863|         0|            0|            0|  0.00%|        deprecated: Optional[bool] = None,
   864|         0|            0|            0|  0.00%|        methods: Optional[Union[Set[str], List[str]]] = None,
   865|         0|            0|            0|  0.00%|        operation_id: Optional[str] = None,
   866|         0|            0|            0|  0.00%|        response_model_include: Optional[IncEx] = None,
   867|         0|            0|            0|  0.00%|        response_model_exclude: Optional[IncEx] = None,
   868|         0|            0|            0|  0.00%|        response_model_by_alias: bool = True,
   869|         0|            0|            0|  0.00%|        response_model_exclude_unset: bool = False,
   870|         0|            0|            0|  0.00%|        response_model_exclude_defaults: bool = False,
   871|         0|            0|            0|  0.00%|        response_model_exclude_none: bool = False,
   872|         0|            0|            0|  0.00%|        include_in_schema: bool = True,
   873|         0|            0|            0|  0.00%|        response_class: Union[Type[Response], DefaultPlaceholder] = Default(
   874|         0|            0|            0|  0.00%|            JSONResponse
   875|         0|            0|            0|  0.00%|        ),
   876|         0|            0|            0|  0.00%|        name: Optional[str] = None,
   877|         0|            0|            0|  0.00%|        route_class_override: Optional[Type[APIRoute]] = None,
   878|         0|            0|            0|  0.00%|        callbacks: Optional[List[BaseRoute]] = None,
   879|         0|            0|            0|  0.00%|        openapi_extra: Optional[Dict[str, Any]] = None,
   880|         0|            0|            0|  0.00%|        generate_unique_id_function: Union[
   881|         0|            0|            0|  0.00%|            Callable[[APIRoute], str], DefaultPlaceholder
   882|         0|            0|            0|  0.00%|        ] = Default(generate_unique_id),
   883|         0|            0|            0|  0.00%|    ) -> None:
   884|         0|            0|            0|  0.00%|        route_class = route_class_override or self.route_class
   885|         0|            0|            0|  0.00%|        responses = responses or {}
   886|         0|            0|            0|  0.00%|        combined_responses = {**self.responses, **responses}
   887|         0|            0|            0|  0.00%|        current_response_class = get_value_or_default(
   888|         0|            0|            0|  0.00%|            response_class, self.default_response_class
   889|         0|            0|            0|  0.00%|        )
   890|         0|            0|            0|  0.00%|        current_tags = self.tags.copy()
   891|         0|            0|            0|  0.00%|        if tags:
   892|         0|            0|            0|  0.00%|            current_tags.extend(tags)
   893|         0|            0|            0|  0.00%|        current_dependencies = self.dependencies.copy()
   894|         0|            0|            0|  0.00%|        if dependencies:
   895|         0|            0|            0|  0.00%|            current_dependencies.extend(dependencies)
   896|         0|            0|            0|  0.00%|        current_callbacks = self.callbacks.copy()
   897|         0|            0|            0|  0.00%|        if callbacks:
   898|         0|            0|            0|  0.00%|            current_callbacks.extend(callbacks)
   899|         0|            0|            0|  0.00%|        current_generate_unique_id = get_value_or_default(
   900|         0|            0|            0|  0.00%|            generate_unique_id_function, self.generate_unique_id_function
   901|         0|            0|            0|  0.00%|        )
   902|         0|            0|            0|  0.00%|        route = route_class(
   903|         0|            0|            0|  0.00%|            self.prefix + path,
   904|         0|            0|            0|  0.00%|            endpoint=endpoint,
   905|         0|            0|            0|  0.00%|            response_model=response_model,
   906|         0|            0|            0|  0.00%|            status_code=status_code,
   907|         0|            0|            0|  0.00%|            tags=current_tags,
   908|         0|            0|            0|  0.00%|            dependencies=current_dependencies,
   909|         0|            0|            0|  0.00%|            summary=summary,
   910|         0|            0|            0|  0.00%|            description=description,
   911|         0|            0|            0|  0.00%|            response_description=response_description,
   912|         0|            0|            0|  0.00%|            responses=combined_responses,
   913|         0|            0|            0|  0.00%|            deprecated=deprecated or self.deprecated,
   914|         0|            0|            0|  0.00%|            methods=methods,
   915|         0|            0|            0|  0.00%|            operation_id=operation_id,
   916|         0|            0|            0|  0.00%|            response_model_include=response_model_include,
   917|         0|            0|            0|  0.00%|            response_model_exclude=response_model_exclude,
   918|         0|            0|            0|  0.00%|            response_model_by_alias=response_model_by_alias,
   919|         0|            0|            0|  0.00%|            response_model_exclude_unset=response_model_exclude_unset,
   920|         0|            0|            0|  0.00%|            response_model_exclude_defaults=response_model_exclude_defaults,
   921|         0|            0|            0|  0.00%|            response_model_exclude_none=response_model_exclude_none,
   922|         0|            0|            0|  0.00%|            include_in_schema=include_in_schema and self.include_in_schema,
   923|         0|            0|            0|  0.00%|            response_class=current_response_class,
   924|         0|            0|            0|  0.00%|            name=name,
   925|         0|            0|            0|  0.00%|            dependency_overrides_provider=self.dependency_overrides_provider,
   926|         0|            0|            0|  0.00%|            callbacks=current_callbacks,
   927|         0|            0|            0|  0.00%|            openapi_extra=openapi_extra,
   928|         0|            0|            0|  0.00%|            generate_unique_id_function=current_generate_unique_id,
   929|         0|            0|            0|  0.00%|        )
   930|         0|            0|            0|  0.00%|        self.routes.append(route)
   931|         0|            0|            0|  0.00%|
   932|         0|            0|            0|  0.00%|    def api_route(
   933|         0|            0|            0|  0.00%|        self,
   934|         0|            0|            0|  0.00%|        path: str,
   935|         0|            0|            0|  0.00%|        *,
   936|         0|            0|            0|  0.00%|        response_model: Any = Default(None),
   937|         0|            0|            0|  0.00%|        status_code: Optional[int] = None,
   938|         0|            0|            0|  0.00%|        tags: Optional[List[Union[str, Enum]]] = None,
   939|         0|            0|            0|  0.00%|        dependencies: Optional[Sequence[params.Depends]] = None,
   940|         0|            0|            0|  0.00%|        summary: Optional[str] = None,
   941|         0|            0|            0|  0.00%|        description: Optional[str] = None,
   942|         0|            0|            0|  0.00%|        response_description: str = "Successful Response",
   943|         0|            0|            0|  0.00%|        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,
   944|         0|            0|            0|  0.00%|        deprecated: Optional[bool] = None,
   945|         0|            0|            0|  0.00%|        methods: Optional[List[str]] = None,
   946|         0|            0|            0|  0.00%|        operation_id: Optional[str] = None,
   947|         0|            0|            0|  0.00%|        response_model_include: Optional[IncEx] = None,
   948|         0|            0|            0|  0.00%|        response_model_exclude: Optional[IncEx] = None,
   949|         0|            0|            0|  0.00%|        response_model_by_alias: bool = True,
   950|         0|            0|            0|  0.00%|        response_model_exclude_unset: bool = False,
   951|         0|            0|            0|  0.00%|        response_model_exclude_defaults: bool = False,
   952|         0|            0|            0|  0.00%|        response_model_exclude_none: bool = False,
   953|         0|            0|            0|  0.00%|        include_in_schema: bool = True,
   954|         0|            0|            0|  0.00%|        response_class: Type[Response] = Default(JSONResponse),
   955|         0|            0|            0|  0.00%|        name: Optional[str] = None,
   956|         0|            0|            0|  0.00%|        callbacks: Optional[List[BaseRoute]] = None,
   957|         0|            0|            0|  0.00%|        openapi_extra: Optional[Dict[str, Any]] = None,
   958|         0|            0|            0|  0.00%|        generate_unique_id_function: Callable[[APIRoute], str] = Default(
   959|         0|            0|            0|  0.00%|            generate_unique_id
   960|         0|            0|            0|  0.00%|        ),
   961|         0|            0|            0|  0.00%|    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
   962|         0|            0|            0|  0.00%|        def decorator(func: DecoratedCallable) -> DecoratedCallable:
   963|         0|            0|            0|  0.00%|            self.add_api_route(
   964|         0|            0|            0|  0.00%|                path,
   965|         0|            0|            0|  0.00%|                func,
   966|         0|            0|            0|  0.00%|                response_model=response_model,
   967|         0|            0|            0|  0.00%|                status_code=status_code,
   968|         0|            0|            0|  0.00%|                tags=tags,
   969|         0|            0|            0|  0.00%|                dependencies=dependencies,
   970|         0|            0|            0|  0.00%|                summary=summary,
   971|         0|            0|            0|  0.00%|                description=description,
   972|         0|            0|            0|  0.00%|                response_description=response_description,
   973|         0|            0|            0|  0.00%|                responses=responses,
   974|         0|            0|            0|  0.00%|                deprecated=deprecated,
   975|         0|            0|            0|  0.00%|                methods=methods,
   976|         0|            0|            0|  0.00%|                operation_id=operation_id,
   977|         0|            0|            0|  0.00%|                response_model_include=response_model_include,
   978|         0|            0|            0|  0.00%|                response_model_exclude=response_model_exclude,
   979|         0|            0|            0|  0.00%|                response_model_by_alias=response_model_by_alias,
   980|         0|            0|            0|  0.00%|                response_model_exclude_unset=response_model_exclude_unset,
   981|         0|            0|            0|  0.00%|                response_model_exclude_defaults=response_model_exclude_defaults,
   982|         0|            0|            0|  0.00%|                response_model_exclude_none=response_model_exclude_none,
   983|         0|            0|            0|  0.00%|                include_in_schema=include_in_schema,
   984|         0|            0|            0|  0.00%|                response_class=response_class,
   985|         0|            0|            0|  0.00%|                name=name,
   986|         0|            0|            0|  0.00%|                callbacks=callbacks,
   987|         0|            0|            0|  0.00%|                openapi_extra=openapi_extra,
   988|         0|            0|            0|  0.00%|                generate_unique_id_function=generate_unique_id_function,
   989|         0|            0|            0|  0.00%|            )
   990|         0|            0|            0|  0.00%|            return func
   991|         0|            0|            0|  0.00%|
   992|         0|            0|            0|  0.00%|        return decorator
   993|         0|            0|            0|  0.00%|
   994|         1|  3.09944e-06|  3.09944e-06|  0.00%|    def add_api_websocket_route(
   995|         0|            0|            0|  0.00%|        self,
   996|         0|            0|            0|  0.00%|        path: str,
   997|         0|            0|            0|  0.00%|        endpoint: Callable[..., Any],
   998|         0|            0|            0|  0.00%|        name: Optional[str] = None,
   999|         0|            0|            0|  0.00%|        *,
  1000|         0|            0|            0|  0.00%|        dependencies: Optional[Sequence[params.Depends]] = None,
  1001|         0|            0|            0|  0.00%|    ) -> None:
  1002|         1|  3.09944e-06|  3.09944e-06|  0.00%|        current_dependencies = self.dependencies.copy()
  1003|         1|  2.14577e-06|  2.14577e-06|  0.00%|        if dependencies:
  1004|         0|            0|            0|  0.00%|            current_dependencies.extend(dependencies)
  1005|         0|            0|            0|  0.00%|
  1006|         2|   1.7643e-05|  8.82149e-06|  0.02%|        route = APIWebSocketRoute(
(call)|         1|    0.0968504|    0.0968504| 99.56%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/routing.py:373 __init__
  1007|         1|  1.90735e-06|  1.90735e-06|  0.00%|            self.prefix + path,
  1008|         1|   3.8147e-06|   3.8147e-06|  0.00%|            endpoint=endpoint,
  1009|         1|   2.6226e-06|   2.6226e-06|  0.00%|            name=name,
  1010|         1|  1.66893e-06|  1.66893e-06|  0.00%|            dependencies=current_dependencies,
  1011|         1|  1.90735e-06|  1.90735e-06|  0.00%|            dependency_overrides_provider=self.dependency_overrides_provider,
  1012|         0|            0|            0|  0.00%|        )
  1013|         1|   2.6226e-06|   2.6226e-06|  0.00%|        self.routes.append(route)
  1014|         0|            0|            0|  0.00%|
  1015|         1|  3.17097e-05|  3.17097e-05|  0.03%|    def websocket(
  1016|         0|            0|            0|  0.00%|        self,
  1017|         0|            0|            0|  0.00%|        path: Annotated[
  1018|         0|            0|            0|  0.00%|            str,
  1019|         0|            0|            0|  0.00%|            Doc(
  1020|         0|            0|            0|  0.00%|                """
  1021|         0|            0|            0|  0.00%|                WebSocket path.
  1022|         0|            0|            0|  0.00%|                """
  1023|         0|            0|            0|  0.00%|            ),
  1024|         0|            0|            0|  0.00%|        ],
  1025|         0|            0|            0|  0.00%|        name: Annotated[
  1026|         0|            0|            0|  0.00%|            Optional[str],
  1027|         0|            0|            0|  0.00%|            Doc(
  1028|         0|            0|            0|  0.00%|                """
  1029|         0|            0|            0|  0.00%|                A name for the WebSocket. Only used internally.
  1030|         0|            0|            0|  0.00%|                """
  1031|         0|            0|            0|  0.00%|            ),
  1032|         0|            0|            0|  0.00%|        ] = None,
  1033|         0|            0|            0|  0.00%|        *,
  1034|         0|            0|            0|  0.00%|        dependencies: Annotated[
  1035|         0|            0|            0|  0.00%|            Optional[Sequence[params.Depends]],
  1036|         0|            0|            0|  0.00%|            Doc(
  1037|         0|            0|            0|  0.00%|                """
  1038|         0|            0|            0|  0.00%|                A list of dependencies (using `Depends()`) to be used for this
  1039|         0|            0|            0|  0.00%|                WebSocket.
  1040|         0|            0|            0|  0.00%|
  1041|         0|            0|            0|  0.00%|                Read more about it in the
  1042|         0|            0|            0|  0.00%|                [FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).
  1043|         0|            0|            0|  0.00%|                """
  1044|         0|            0|            0|  0.00%|            ),
  1045|         0|            0|            0|  0.00%|        ] = None,
  1046|         0|            0|            0|  0.00%|    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
  1047|         0|            0|            0|  0.00%|        """
  1048|         0|            0|            0|  0.00%|        Decorate a WebSocket function.
  1049|         0|            0|            0|  0.00%|
  1050|         0|            0|            0|  0.00%|        Read more about it in the
  1051|         0|            0|            0|  0.00%|        [FastAPI docs for WebSockets](https://fastapi.tiangolo.com/advanced/websockets/).
  1052|         0|            0|            0|  0.00%|
  1053|         0|            0|            0|  0.00%|        **Example**
  1054|         0|            0|            0|  0.00%|
  1055|         0|            0|            0|  0.00%|        ## Example
  1056|         0|            0|            0|  0.00%|
  1057|         0|            0|            0|  0.00%|        ```python
  1058|         0|            0|            0|  0.00%|        from fastapi import APIRouter, FastAPI, WebSocket
  1059|         0|            0|            0|  0.00%|
  1060|         0|            0|            0|  0.00%|        app = FastAPI()
  1061|         0|            0|            0|  0.00%|        router = APIRouter()
  1062|         0|            0|            0|  0.00%|
  1063|         0|            0|            0|  0.00%|        @router.websocket("/ws")
  1064|         0|            0|            0|  0.00%|        async def websocket_endpoint(websocket: WebSocket):
  1065|         0|            0|            0|  0.00%|            await websocket.accept()
  1066|         0|            0|            0|  0.00%|            while True:
  1067|         0|            0|            0|  0.00%|                data = await websocket.receive_text()
  1068|         0|            0|            0|  0.00%|                await websocket.send_text(f"Message text was: {data}")
  1069|         0|            0|            0|  0.00%|
  1070|         0|            0|            0|  0.00%|        app.include_router(router)
  1071|         0|            0|            0|  0.00%|        ```
  1072|         0|            0|            0|  0.00%|        """
  1073|         0|            0|            0|  0.00%|
  1074|         2|  3.21865e-05|  1.60933e-05|  0.03%|        def decorator(func: DecoratedCallable) -> DecoratedCallable:
  1075|         2|  1.35899e-05|  6.79493e-06|  0.01%|            self.add_api_websocket_route(
(call)|         1|    0.0968909|    0.0968909| 99.60%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/routing.py:994 add_api_websocket_route
  1076|         1|  2.14577e-06|  2.14577e-06|  0.00%|                path, func, name=name, dependencies=dependencies
  1077|         0|            0|            0|  0.00%|            )
  1078|         1|  1.19209e-06|  1.19209e-06|  0.00%|            return func
  1079|         0|            0|            0|  0.00%|
  1080|         1|  8.10623e-06|  8.10623e-06|  0.01%|        return decorator
  1081|         0|            0|            0|  0.00%|
  1082|         0|            0|            0|  0.00%|    def websocket_route(
  1083|         0|            0|            0|  0.00%|        self, path: str, name: Union[str, None] = None
  1084|         0|            0|            0|  0.00%|    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
  1085|         0|            0|            0|  0.00%|        def decorator(func: DecoratedCallable) -> DecoratedCallable:
  1086|         0|            0|            0|  0.00%|            self.add_websocket_route(path, func, name=name)
  1087|         0|            0|            0|  0.00%|            return func
  1088|         0|            0|            0|  0.00%|
  1089|         0|            0|            0|  0.00%|        return decorator
  1090|         0|            0|            0|  0.00%|
  1091|         0|            0|            0|  0.00%|    def include_router(
  1092|         0|            0|            0|  0.00%|        self,
  1093|         0|            0|            0|  0.00%|        router: Annotated["APIRouter", Doc("The `APIRouter` to include.")],
  1094|         0|            0|            0|  0.00%|        *,
  1095|         0|            0|            0|  0.00%|        prefix: Annotated[str, Doc("An optional path prefix for the router.")] = "",
  1096|         0|            0|            0|  0.00%|        tags: Annotated[
  1097|         0|            0|            0|  0.00%|            Optional[List[Union[str, Enum]]],
  1098|         0|            0|            0|  0.00%|            Doc(
  1099|         0|            0|            0|  0.00%|                """
  1100|         0|            0|            0|  0.00%|                A list of tags to be applied to all the *path operations* in this
  1101|         0|            0|            0|  0.00%|                router.
  1102|         0|            0|            0|  0.00%|
  1103|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  1104|         0|            0|            0|  0.00%|
  1105|         0|            0|            0|  0.00%|                Read more about it in the
  1106|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
  1107|         0|            0|            0|  0.00%|                """
  1108|         0|            0|            0|  0.00%|            ),
  1109|         0|            0|            0|  0.00%|        ] = None,
  1110|         0|            0|            0|  0.00%|        dependencies: Annotated[
  1111|         0|            0|            0|  0.00%|            Optional[Sequence[params.Depends]],
  1112|         0|            0|            0|  0.00%|            Doc(
  1113|         0|            0|            0|  0.00%|                """
  1114|         0|            0|            0|  0.00%|                A list of dependencies (using `Depends()`) to be applied to all the
  1115|         0|            0|            0|  0.00%|                *path operations* in this router.
  1116|         0|            0|            0|  0.00%|
  1117|         0|            0|            0|  0.00%|                Read more about it in the
  1118|         0|            0|            0|  0.00%|                [FastAPI docs for Bigger Applications - Multiple Files](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).
  1119|         0|            0|            0|  0.00%|                """
  1120|         0|            0|            0|  0.00%|            ),
  1121|         0|            0|            0|  0.00%|        ] = None,
  1122|         0|            0|            0|  0.00%|        default_response_class: Annotated[
  1123|         0|            0|            0|  0.00%|            Type[Response],
  1124|         0|            0|            0|  0.00%|            Doc(
  1125|         0|            0|            0|  0.00%|                """
  1126|         0|            0|            0|  0.00%|                The default response class to be used.
  1127|         0|            0|            0|  0.00%|
  1128|         0|            0|            0|  0.00%|                Read more in the
  1129|         0|            0|            0|  0.00%|                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class).
  1130|         0|            0|            0|  0.00%|                """
  1131|         0|            0|            0|  0.00%|            ),
  1132|         0|            0|            0|  0.00%|        ] = Default(JSONResponse),
  1133|         0|            0|            0|  0.00%|        responses: Annotated[
  1134|         0|            0|            0|  0.00%|            Optional[Dict[Union[int, str], Dict[str, Any]]],
  1135|         0|            0|            0|  0.00%|            Doc(
  1136|         0|            0|            0|  0.00%|                """
  1137|         0|            0|            0|  0.00%|                Additional responses to be shown in OpenAPI.
  1138|         0|            0|            0|  0.00%|
  1139|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  1140|         0|            0|            0|  0.00%|
  1141|         0|            0|            0|  0.00%|                Read more about it in the
  1142|         0|            0|            0|  0.00%|                [FastAPI docs for Additional Responses in OpenAPI](https://fastapi.tiangolo.com/advanced/additional-responses/).
  1143|         0|            0|            0|  0.00%|
  1144|         0|            0|            0|  0.00%|                And in the
  1145|         0|            0|            0|  0.00%|                [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-custom-prefix-tags-responses-and-dependencies).
  1146|         0|            0|            0|  0.00%|                """
  1147|         0|            0|            0|  0.00%|            ),
  1148|         0|            0|            0|  0.00%|        ] = None,
  1149|         0|            0|            0|  0.00%|        callbacks: Annotated[
  1150|         0|            0|            0|  0.00%|            Optional[List[BaseRoute]],
  1151|         0|            0|            0|  0.00%|            Doc(
  1152|         0|            0|            0|  0.00%|                """
  1153|         0|            0|            0|  0.00%|                OpenAPI callbacks that should apply to all *path operations* in this
  1154|         0|            0|            0|  0.00%|                router.
  1155|         0|            0|            0|  0.00%|
  1156|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  1157|         0|            0|            0|  0.00%|
  1158|         0|            0|            0|  0.00%|                Read more about it in the
  1159|         0|            0|            0|  0.00%|                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
  1160|         0|            0|            0|  0.00%|                """
  1161|         0|            0|            0|  0.00%|            ),
  1162|         0|            0|            0|  0.00%|        ] = None,
  1163|         0|            0|            0|  0.00%|        deprecated: Annotated[
  1164|         0|            0|            0|  0.00%|            Optional[bool],
  1165|         0|            0|            0|  0.00%|            Doc(
  1166|         0|            0|            0|  0.00%|                """
  1167|         0|            0|            0|  0.00%|                Mark all *path operations* in this router as deprecated.
  1168|         0|            0|            0|  0.00%|
  1169|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  1170|         0|            0|            0|  0.00%|
  1171|         0|            0|            0|  0.00%|                Read more about it in the
  1172|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
  1173|         0|            0|            0|  0.00%|                """
  1174|         0|            0|            0|  0.00%|            ),
  1175|         0|            0|            0|  0.00%|        ] = None,
  1176|         0|            0|            0|  0.00%|        include_in_schema: Annotated[
  1177|         0|            0|            0|  0.00%|            bool,
  1178|         0|            0|            0|  0.00%|            Doc(
  1179|         0|            0|            0|  0.00%|                """
  1180|         0|            0|            0|  0.00%|                Include (or not) all the *path operations* in this router in the
  1181|         0|            0|            0|  0.00%|                generated OpenAPI schema.
  1182|         0|            0|            0|  0.00%|
  1183|         0|            0|            0|  0.00%|                This affects the generated OpenAPI (e.g. visible at `/docs`).
  1184|         0|            0|            0|  0.00%|                """
  1185|         0|            0|            0|  0.00%|            ),
  1186|         0|            0|            0|  0.00%|        ] = True,
  1187|         0|            0|            0|  0.00%|        generate_unique_id_function: Annotated[
  1188|         0|            0|            0|  0.00%|            Callable[[APIRoute], str],
  1189|         0|            0|            0|  0.00%|            Doc(
  1190|         0|            0|            0|  0.00%|                """
  1191|         0|            0|            0|  0.00%|                Customize the function used to generate unique IDs for the *path
  1192|         0|            0|            0|  0.00%|                operations* shown in the generated OpenAPI.
  1193|         0|            0|            0|  0.00%|
  1194|         0|            0|            0|  0.00%|                This is particularly useful when automatically generating clients or
  1195|         0|            0|            0|  0.00%|                SDKs for your API.
  1196|         0|            0|            0|  0.00%|
  1197|         0|            0|            0|  0.00%|                Read more about it in the
  1198|         0|            0|            0|  0.00%|                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
  1199|         0|            0|            0|  0.00%|                """
  1200|         0|            0|            0|  0.00%|            ),
  1201|         0|            0|            0|  0.00%|        ] = Default(generate_unique_id),
  1202|         0|            0|            0|  0.00%|    ) -> None:
  1203|         0|            0|            0|  0.00%|        """
  1204|         0|            0|            0|  0.00%|        Include another `APIRouter` in the same current `APIRouter`.
  1205|         0|            0|            0|  0.00%|
  1206|         0|            0|            0|  0.00%|        Read more about it in the
  1207|         0|            0|            0|  0.00%|        [FastAPI docs for Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/).
  1208|         0|            0|            0|  0.00%|
  1209|         0|            0|            0|  0.00%|        ## Example
  1210|         0|            0|            0|  0.00%|
  1211|         0|            0|            0|  0.00%|        ```python
  1212|         0|            0|            0|  0.00%|        from fastapi import APIRouter, FastAPI
  1213|         0|            0|            0|  0.00%|
  1214|         0|            0|            0|  0.00%|        app = FastAPI()
  1215|         0|            0|            0|  0.00%|        internal_router = APIRouter()
  1216|         0|            0|            0|  0.00%|        users_router = APIRouter()
  1217|         0|            0|            0|  0.00%|
  1218|         0|            0|            0|  0.00%|        @users_router.get("/users/")
  1219|         0|            0|            0|  0.00%|        def read_users():
  1220|         0|            0|            0|  0.00%|            return [{"name": "Rick"}, {"name": "Morty"}]
  1221|         0|            0|            0|  0.00%|
  1222|         0|            0|            0|  0.00%|        internal_router.include_router(users_router)
  1223|         0|            0|            0|  0.00%|        app.include_router(internal_router)
  1224|         0|            0|            0|  0.00%|        ```
  1225|         0|            0|            0|  0.00%|        """
  1226|         0|            0|            0|  0.00%|        if prefix:
  1227|         0|            0|            0|  0.00%|            assert prefix.startswith("/"), "A path prefix must start with '/'"
  1228|         0|            0|            0|  0.00%|            assert not prefix.endswith(
  1229|         0|            0|            0|  0.00%|                "/"
  1230|         0|            0|            0|  0.00%|            ), "A path prefix must not end with '/', as the routes will start with '/'"
  1231|         0|            0|            0|  0.00%|        else:
  1232|         0|            0|            0|  0.00%|            for r in router.routes:
  1233|         0|            0|            0|  0.00%|                path = getattr(r, "path")  # noqa: B009
  1234|         0|            0|            0|  0.00%|                name = getattr(r, "name", "unknown")
  1235|         0|            0|            0|  0.00%|                if path is not None and not path:
  1236|         0|            0|            0|  0.00%|                    raise FastAPIError(
  1237|         0|            0|            0|  0.00%|                        f"Prefix and path cannot be both empty (path operation: {name})"
  1238|         0|            0|            0|  0.00%|                    )
  1239|         0|            0|            0|  0.00%|        if responses is None:
  1240|         0|            0|            0|  0.00%|            responses = {}
  1241|         0|            0|            0|  0.00%|        for route in router.routes:
  1242|         0|            0|            0|  0.00%|            if isinstance(route, APIRoute):
  1243|         0|            0|            0|  0.00%|                combined_responses = {**responses, **route.responses}
  1244|         0|            0|            0|  0.00%|                use_response_class = get_value_or_default(
  1245|         0|            0|            0|  0.00%|                    route.response_class,
  1246|         0|            0|            0|  0.00%|                    router.default_response_class,
  1247|         0|            0|            0|  0.00%|                    default_response_class,
  1248|         0|            0|            0|  0.00%|                    self.default_response_class,
  1249|         0|            0|            0|  0.00%|                )
  1250|         0|            0|            0|  0.00%|                current_tags = []
  1251|         0|            0|            0|  0.00%|                if tags:
  1252|         0|            0|            0|  0.00%|                    current_tags.extend(tags)
  1253|         0|            0|            0|  0.00%|                if route.tags:
  1254|         0|            0|            0|  0.00%|                    current_tags.extend(route.tags)
  1255|         0|            0|            0|  0.00%|                current_dependencies: List[params.Depends] = []
  1256|         0|            0|            0|  0.00%|                if dependencies:
  1257|         0|            0|            0|  0.00%|                    current_dependencies.extend(dependencies)
  1258|         0|            0|            0|  0.00%|                if route.dependencies:
  1259|         0|            0|            0|  0.00%|                    current_dependencies.extend(route.dependencies)
  1260|         0|            0|            0|  0.00%|                current_callbacks = []
  1261|         0|            0|            0|  0.00%|                if callbacks:
  1262|         0|            0|            0|  0.00%|                    current_callbacks.extend(callbacks)
  1263|         0|            0|            0|  0.00%|                if route.callbacks:
  1264|         0|            0|            0|  0.00%|                    current_callbacks.extend(route.callbacks)
  1265|         0|            0|            0|  0.00%|                current_generate_unique_id = get_value_or_default(
  1266|         0|            0|            0|  0.00%|                    route.generate_unique_id_function,
  1267|         0|            0|            0|  0.00%|                    router.generate_unique_id_function,
  1268|         0|            0|            0|  0.00%|                    generate_unique_id_function,
  1269|         0|            0|            0|  0.00%|                    self.generate_unique_id_function,
  1270|         0|            0|            0|  0.00%|                )
  1271|         0|            0|            0|  0.00%|                self.add_api_route(
  1272|         0|            0|            0|  0.00%|                    prefix + route.path,
  1273|         0|            0|            0|  0.00%|                    route.endpoint,
  1274|         0|            0|            0|  0.00%|                    response_model=route.response_model,
  1275|         0|            0|            0|  0.00%|                    status_code=route.status_code,
  1276|         0|            0|            0|  0.00%|                    tags=current_tags,
  1277|         0|            0|            0|  0.00%|                    dependencies=current_dependencies,
  1278|         0|            0|            0|  0.00%|                    summary=route.summary,
  1279|         0|            0|            0|  0.00%|                    description=route.description,
  1280|         0|            0|            0|  0.00%|                    response_description=route.response_description,
  1281|         0|            0|            0|  0.00%|                    responses=combined_responses,
  1282|         0|            0|            0|  0.00%|                    deprecated=route.deprecated or deprecated or self.deprecated,
  1283|         0|            0|            0|  0.00%|                    methods=route.methods,
  1284|         0|            0|            0|  0.00%|                    operation_id=route.operation_id,
  1285|         0|            0|            0|  0.00%|                    response_model_include=route.response_model_include,
  1286|         0|            0|            0|  0.00%|                    response_model_exclude=route.response_model_exclude,
  1287|         0|            0|            0|  0.00%|                    response_model_by_alias=route.response_model_by_alias,
  1288|         0|            0|            0|  0.00%|                    response_model_exclude_unset=route.response_model_exclude_unset,
  1289|         0|            0|            0|  0.00%|                    response_model_exclude_defaults=route.response_model_exclude_defaults,
  1290|         0|            0|            0|  0.00%|                    response_model_exclude_none=route.response_model_exclude_none,
  1291|         0|            0|            0|  0.00%|                    include_in_schema=route.include_in_schema
  1292|         0|            0|            0|  0.00%|                    and self.include_in_schema
  1293|         0|            0|            0|  0.00%|                    and include_in_schema,
  1294|         0|            0|            0|  0.00%|                    response_class=use_response_class,
  1295|         0|            0|            0|  0.00%|                    name=route.name,
  1296|         0|            0|            0|  0.00%|                    route_class_override=type(route),
  1297|         0|            0|            0|  0.00%|                    callbacks=current_callbacks,
  1298|         0|            0|            0|  0.00%|                    openapi_extra=route.openapi_extra,
  1299|         0|            0|            0|  0.00%|                    generate_unique_id_function=current_generate_unique_id,
  1300|         0|            0|            0|  0.00%|                )
  1301|         0|            0|            0|  0.00%|            elif isinstance(route, routing.Route):
  1302|         0|            0|            0|  0.00%|                methods = list(route.methods or [])
  1303|         0|            0|            0|  0.00%|                self.add_route(
  1304|         0|            0|            0|  0.00%|                    prefix + route.path,
  1305|         0|            0|            0|  0.00%|                    route.endpoint,
  1306|         0|            0|            0|  0.00%|                    methods=methods,
  1307|         0|            0|            0|  0.00%|                    include_in_schema=route.include_in_schema,
  1308|         0|            0|            0|  0.00%|                    name=route.name,
  1309|         0|            0|            0|  0.00%|                )
  1310|         0|            0|            0|  0.00%|            elif isinstance(route, APIWebSocketRoute):
  1311|         0|            0|            0|  0.00%|                current_dependencies = []
  1312|         0|            0|            0|  0.00%|                if dependencies:
  1313|         0|            0|            0|  0.00%|                    current_dependencies.extend(dependencies)
  1314|         0|            0|            0|  0.00%|                if route.dependencies:
  1315|         0|            0|            0|  0.00%|                    current_dependencies.extend(route.dependencies)
  1316|         0|            0|            0|  0.00%|                self.add_api_websocket_route(
  1317|         0|            0|            0|  0.00%|                    prefix + route.path,
  1318|         0|            0|            0|  0.00%|                    route.endpoint,
  1319|         0|            0|            0|  0.00%|                    dependencies=current_dependencies,
  1320|         0|            0|            0|  0.00%|                    name=route.name,
  1321|         0|            0|            0|  0.00%|                )
  1322|         0|            0|            0|  0.00%|            elif isinstance(route, routing.WebSocketRoute):
  1323|         0|            0|            0|  0.00%|                self.add_websocket_route(
  1324|         0|            0|            0|  0.00%|                    prefix + route.path, route.endpoint, name=route.name
  1325|         0|            0|            0|  0.00%|                )
  1326|         0|            0|            0|  0.00%|        for handler in router.on_startup:
  1327|         0|            0|            0|  0.00%|            self.add_event_handler("startup", handler)
  1328|         0|            0|            0|  0.00%|        for handler in router.on_shutdown:
  1329|         0|            0|            0|  0.00%|            self.add_event_handler("shutdown", handler)
  1330|         0|            0|            0|  0.00%|        self.lifespan_context = _merge_lifespan_context(
  1331|         0|            0|            0|  0.00%|            self.lifespan_context,
  1332|         0|            0|            0|  0.00%|            router.lifespan_context,
  1333|         0|            0|            0|  0.00%|        )
  1334|         0|            0|            0|  0.00%|
  1335|         0|            0|            0|  0.00%|    def get(
  1336|         0|            0|            0|  0.00%|        self,
  1337|         0|            0|            0|  0.00%|        path: Annotated[
  1338|         0|            0|            0|  0.00%|            str,
  1339|         0|            0|            0|  0.00%|            Doc(
  1340|         0|            0|            0|  0.00%|                """
  1341|         0|            0|            0|  0.00%|                The URL path to be used for this *path operation*.
  1342|         0|            0|            0|  0.00%|
  1343|         0|            0|            0|  0.00%|                For example, in `http://example.com/items`, the path is `/items`.
  1344|         0|            0|            0|  0.00%|                """
  1345|         0|            0|            0|  0.00%|            ),
  1346|         0|            0|            0|  0.00%|        ],
  1347|         0|            0|            0|  0.00%|        *,
  1348|         0|            0|            0|  0.00%|        response_model: Annotated[
  1349|         0|            0|            0|  0.00%|            Any,
  1350|         0|            0|            0|  0.00%|            Doc(
  1351|         0|            0|            0|  0.00%|                """
  1352|         0|            0|            0|  0.00%|                The type to use for the response.
  1353|         0|            0|            0|  0.00%|
  1354|         0|            0|            0|  0.00%|                It could be any valid Pydantic *field* type. So, it doesn't have to
  1355|         0|            0|            0|  0.00%|                be a Pydantic model, it could be other things, like a `list`, `dict`,
  1356|         0|            0|            0|  0.00%|                etc.
  1357|         0|            0|            0|  0.00%|
  1358|         0|            0|            0|  0.00%|                It will be used for:
  1359|         0|            0|            0|  0.00%|
  1360|         0|            0|            0|  0.00%|                * Documentation: the generated OpenAPI (and the UI at `/docs`) will
  1361|         0|            0|            0|  0.00%|                    show it as the response (JSON Schema).
  1362|         0|            0|            0|  0.00%|                * Serialization: you could return an arbitrary object and the
  1363|         0|            0|            0|  0.00%|                    `response_model` would be used to serialize that object into the
  1364|         0|            0|            0|  0.00%|                    corresponding JSON.
  1365|         0|            0|            0|  0.00%|                * Filtering: the JSON sent to the client will only contain the data
  1366|         0|            0|            0|  0.00%|                    (fields) defined in the `response_model`. If you returned an object
  1367|         0|            0|            0|  0.00%|                    that contains an attribute `password` but the `response_model` does
  1368|         0|            0|            0|  0.00%|                    not include that field, the JSON sent to the client would not have
  1369|         0|            0|            0|  0.00%|                    that `password`.
  1370|         0|            0|            0|  0.00%|                * Validation: whatever you return will be serialized with the
  1371|         0|            0|            0|  0.00%|                    `response_model`, converting any data as necessary to generate the
  1372|         0|            0|            0|  0.00%|                    corresponding JSON. But if the data in the object returned is not
  1373|         0|            0|            0|  0.00%|                    valid, that would mean a violation of the contract with the client,
  1374|         0|            0|            0|  0.00%|                    so it's an error from the API developer. So, FastAPI will raise an
  1375|         0|            0|            0|  0.00%|                    error and return a 500 error code (Internal Server Error).
  1376|         0|            0|            0|  0.00%|
  1377|         0|            0|            0|  0.00%|                Read more about it in the
  1378|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
  1379|         0|            0|            0|  0.00%|                """
  1380|         0|            0|            0|  0.00%|            ),
  1381|         0|            0|            0|  0.00%|        ] = Default(None),
  1382|         0|            0|            0|  0.00%|        status_code: Annotated[
  1383|         0|            0|            0|  0.00%|            Optional[int],
  1384|         0|            0|            0|  0.00%|            Doc(
  1385|         0|            0|            0|  0.00%|                """
  1386|         0|            0|            0|  0.00%|                The default status code to be used for the response.
  1387|         0|            0|            0|  0.00%|
  1388|         0|            0|            0|  0.00%|                You could override the status code by returning a response directly.
  1389|         0|            0|            0|  0.00%|
  1390|         0|            0|            0|  0.00%|                Read more about it in the
  1391|         0|            0|            0|  0.00%|                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
  1392|         0|            0|            0|  0.00%|                """
  1393|         0|            0|            0|  0.00%|            ),
  1394|         0|            0|            0|  0.00%|        ] = None,
  1395|         0|            0|            0|  0.00%|        tags: Annotated[
  1396|         0|            0|            0|  0.00%|            Optional[List[Union[str, Enum]]],
  1397|         0|            0|            0|  0.00%|            Doc(
  1398|         0|            0|            0|  0.00%|                """
  1399|         0|            0|            0|  0.00%|                A list of tags to be applied to the *path operation*.
  1400|         0|            0|            0|  0.00%|
  1401|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  1402|         0|            0|            0|  0.00%|
  1403|         0|            0|            0|  0.00%|                Read more about it in the
  1404|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
  1405|         0|            0|            0|  0.00%|                """
  1406|         0|            0|            0|  0.00%|            ),
  1407|         0|            0|            0|  0.00%|        ] = None,
  1408|         0|            0|            0|  0.00%|        dependencies: Annotated[
  1409|         0|            0|            0|  0.00%|            Optional[Sequence[params.Depends]],
  1410|         0|            0|            0|  0.00%|            Doc(
  1411|         0|            0|            0|  0.00%|                """
  1412|         0|            0|            0|  0.00%|                A list of dependencies (using `Depends()`) to be applied to the
  1413|         0|            0|            0|  0.00%|                *path operation*.
  1414|         0|            0|            0|  0.00%|
  1415|         0|            0|            0|  0.00%|                Read more about it in the
  1416|         0|            0|            0|  0.00%|                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
  1417|         0|            0|            0|  0.00%|                """
  1418|         0|            0|            0|  0.00%|            ),
  1419|         0|            0|            0|  0.00%|        ] = None,
  1420|         0|            0|            0|  0.00%|        summary: Annotated[
  1421|         0|            0|            0|  0.00%|            Optional[str],
  1422|         0|            0|            0|  0.00%|            Doc(
  1423|         0|            0|            0|  0.00%|                """
  1424|         0|            0|            0|  0.00%|                A summary for the *path operation*.
  1425|         0|            0|            0|  0.00%|
  1426|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  1427|         0|            0|            0|  0.00%|
  1428|         0|            0|            0|  0.00%|                Read more about it in the
  1429|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
  1430|         0|            0|            0|  0.00%|                """
  1431|         0|            0|            0|  0.00%|            ),
  1432|         0|            0|            0|  0.00%|        ] = None,
  1433|         0|            0|            0|  0.00%|        description: Annotated[
  1434|         0|            0|            0|  0.00%|            Optional[str],
  1435|         0|            0|            0|  0.00%|            Doc(
  1436|         0|            0|            0|  0.00%|                """
  1437|         0|            0|            0|  0.00%|                A description for the *path operation*.
  1438|         0|            0|            0|  0.00%|
  1439|         0|            0|            0|  0.00%|                If not provided, it will be extracted automatically from the docstring
  1440|         0|            0|            0|  0.00%|                of the *path operation function*.
  1441|         0|            0|            0|  0.00%|
  1442|         0|            0|            0|  0.00%|                It can contain Markdown.
  1443|         0|            0|            0|  0.00%|
  1444|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  1445|         0|            0|            0|  0.00%|
  1446|         0|            0|            0|  0.00%|                Read more about it in the
  1447|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
  1448|         0|            0|            0|  0.00%|                """
  1449|         0|            0|            0|  0.00%|            ),
  1450|         0|            0|            0|  0.00%|        ] = None,
  1451|         0|            0|            0|  0.00%|        response_description: Annotated[
  1452|         0|            0|            0|  0.00%|            str,
  1453|         0|            0|            0|  0.00%|            Doc(
  1454|         0|            0|            0|  0.00%|                """
  1455|         0|            0|            0|  0.00%|                The description for the default response.
  1456|         0|            0|            0|  0.00%|
  1457|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  1458|         0|            0|            0|  0.00%|                """
  1459|         0|            0|            0|  0.00%|            ),
  1460|         0|            0|            0|  0.00%|        ] = "Successful Response",
  1461|         0|            0|            0|  0.00%|        responses: Annotated[
  1462|         0|            0|            0|  0.00%|            Optional[Dict[Union[int, str], Dict[str, Any]]],
  1463|         0|            0|            0|  0.00%|            Doc(
  1464|         0|            0|            0|  0.00%|                """
  1465|         0|            0|            0|  0.00%|                Additional responses that could be returned by this *path operation*.
  1466|         0|            0|            0|  0.00%|
  1467|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  1468|         0|            0|            0|  0.00%|                """
  1469|         0|            0|            0|  0.00%|            ),
  1470|         0|            0|            0|  0.00%|        ] = None,
  1471|         0|            0|            0|  0.00%|        deprecated: Annotated[
  1472|         0|            0|            0|  0.00%|            Optional[bool],
  1473|         0|            0|            0|  0.00%|            Doc(
  1474|         0|            0|            0|  0.00%|                """
  1475|         0|            0|            0|  0.00%|                Mark this *path operation* as deprecated.
  1476|         0|            0|            0|  0.00%|
  1477|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  1478|         0|            0|            0|  0.00%|                """
  1479|         0|            0|            0|  0.00%|            ),
  1480|         0|            0|            0|  0.00%|        ] = None,
  1481|         0|            0|            0|  0.00%|        operation_id: Annotated[
  1482|         0|            0|            0|  0.00%|            Optional[str],
  1483|         0|            0|            0|  0.00%|            Doc(
  1484|         0|            0|            0|  0.00%|                """
  1485|         0|            0|            0|  0.00%|                Custom operation ID to be used by this *path operation*.
  1486|         0|            0|            0|  0.00%|
  1487|         0|            0|            0|  0.00%|                By default, it is generated automatically.
  1488|         0|            0|            0|  0.00%|
  1489|         0|            0|            0|  0.00%|                If you provide a custom operation ID, you need to make sure it is
  1490|         0|            0|            0|  0.00%|                unique for the whole API.
  1491|         0|            0|            0|  0.00%|
  1492|         0|            0|            0|  0.00%|                You can customize the
  1493|         0|            0|            0|  0.00%|                operation ID generation with the parameter
  1494|         0|            0|            0|  0.00%|                `generate_unique_id_function` in the `FastAPI` class.
  1495|         0|            0|            0|  0.00%|
  1496|         0|            0|            0|  0.00%|                Read more about it in the
  1497|         0|            0|            0|  0.00%|                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
  1498|         0|            0|            0|  0.00%|                """
  1499|         0|            0|            0|  0.00%|            ),
  1500|         0|            0|            0|  0.00%|        ] = None,
  1501|         0|            0|            0|  0.00%|        response_model_include: Annotated[
  1502|         0|            0|            0|  0.00%|            Optional[IncEx],
  1503|         0|            0|            0|  0.00%|            Doc(
  1504|         0|            0|            0|  0.00%|                """
  1505|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to include only certain fields in the
  1506|         0|            0|            0|  0.00%|                response data.
  1507|         0|            0|            0|  0.00%|
  1508|         0|            0|            0|  0.00%|                Read more about it in the
  1509|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
  1510|         0|            0|            0|  0.00%|                """
  1511|         0|            0|            0|  0.00%|            ),
  1512|         0|            0|            0|  0.00%|        ] = None,
  1513|         0|            0|            0|  0.00%|        response_model_exclude: Annotated[
  1514|         0|            0|            0|  0.00%|            Optional[IncEx],
  1515|         0|            0|            0|  0.00%|            Doc(
  1516|         0|            0|            0|  0.00%|                """
  1517|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to exclude certain fields in the
  1518|         0|            0|            0|  0.00%|                response data.
  1519|         0|            0|            0|  0.00%|
  1520|         0|            0|            0|  0.00%|                Read more about it in the
  1521|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
  1522|         0|            0|            0|  0.00%|                """
  1523|         0|            0|            0|  0.00%|            ),
  1524|         0|            0|            0|  0.00%|        ] = None,
  1525|         0|            0|            0|  0.00%|        response_model_by_alias: Annotated[
  1526|         0|            0|            0|  0.00%|            bool,
  1527|         0|            0|            0|  0.00%|            Doc(
  1528|         0|            0|            0|  0.00%|                """
  1529|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response model
  1530|         0|            0|            0|  0.00%|                should be serialized by alias when an alias is used.
  1531|         0|            0|            0|  0.00%|
  1532|         0|            0|            0|  0.00%|                Read more about it in the
  1533|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
  1534|         0|            0|            0|  0.00%|                """
  1535|         0|            0|            0|  0.00%|            ),
  1536|         0|            0|            0|  0.00%|        ] = True,
  1537|         0|            0|            0|  0.00%|        response_model_exclude_unset: Annotated[
  1538|         0|            0|            0|  0.00%|            bool,
  1539|         0|            0|            0|  0.00%|            Doc(
  1540|         0|            0|            0|  0.00%|                """
  1541|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response data
  1542|         0|            0|            0|  0.00%|                should have all the fields, including the ones that were not set and
  1543|         0|            0|            0|  0.00%|                have their default values. This is different from
  1544|         0|            0|            0|  0.00%|                `response_model_exclude_defaults` in that if the fields are set,
  1545|         0|            0|            0|  0.00%|                they will be included in the response, even if the value is the same
  1546|         0|            0|            0|  0.00%|                as the default.
  1547|         0|            0|            0|  0.00%|
  1548|         0|            0|            0|  0.00%|                When `True`, default values are omitted from the response.
  1549|         0|            0|            0|  0.00%|
  1550|         0|            0|            0|  0.00%|                Read more about it in the
  1551|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
  1552|         0|            0|            0|  0.00%|                """
  1553|         0|            0|            0|  0.00%|            ),
  1554|         0|            0|            0|  0.00%|        ] = False,
  1555|         0|            0|            0|  0.00%|        response_model_exclude_defaults: Annotated[
  1556|         0|            0|            0|  0.00%|            bool,
  1557|         0|            0|            0|  0.00%|            Doc(
  1558|         0|            0|            0|  0.00%|                """
  1559|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response data
  1560|         0|            0|            0|  0.00%|                should have all the fields, including the ones that have the same value
  1561|         0|            0|            0|  0.00%|                as the default. This is different from `response_model_exclude_unset`
  1562|         0|            0|            0|  0.00%|                in that if the fields are set but contain the same default values,
  1563|         0|            0|            0|  0.00%|                they will be excluded from the response.
  1564|         0|            0|            0|  0.00%|
  1565|         0|            0|            0|  0.00%|                When `True`, default values are omitted from the response.
  1566|         0|            0|            0|  0.00%|
  1567|         0|            0|            0|  0.00%|                Read more about it in the
  1568|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
  1569|         0|            0|            0|  0.00%|                """
  1570|         0|            0|            0|  0.00%|            ),
  1571|         0|            0|            0|  0.00%|        ] = False,
  1572|         0|            0|            0|  0.00%|        response_model_exclude_none: Annotated[
  1573|         0|            0|            0|  0.00%|            bool,
  1574|         0|            0|            0|  0.00%|            Doc(
  1575|         0|            0|            0|  0.00%|                """
  1576|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response data should
  1577|         0|            0|            0|  0.00%|                exclude fields set to `None`.
  1578|         0|            0|            0|  0.00%|
  1579|         0|            0|            0|  0.00%|                This is much simpler (less smart) than `response_model_exclude_unset`
  1580|         0|            0|            0|  0.00%|                and `response_model_exclude_defaults`. You probably want to use one of
  1581|         0|            0|            0|  0.00%|                those two instead of this one, as those allow returning `None` values
  1582|         0|            0|            0|  0.00%|                when it makes sense.
  1583|         0|            0|            0|  0.00%|
  1584|         0|            0|            0|  0.00%|                Read more about it in the
  1585|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
  1586|         0|            0|            0|  0.00%|                """
  1587|         0|            0|            0|  0.00%|            ),
  1588|         0|            0|            0|  0.00%|        ] = False,
  1589|         0|            0|            0|  0.00%|        include_in_schema: Annotated[
  1590|         0|            0|            0|  0.00%|            bool,
  1591|         0|            0|            0|  0.00%|            Doc(
  1592|         0|            0|            0|  0.00%|                """
  1593|         0|            0|            0|  0.00%|                Include this *path operation* in the generated OpenAPI schema.
  1594|         0|            0|            0|  0.00%|
  1595|         0|            0|            0|  0.00%|                This affects the generated OpenAPI (e.g. visible at `/docs`).
  1596|         0|            0|            0|  0.00%|
  1597|         0|            0|            0|  0.00%|                Read more about it in the
  1598|         0|            0|            0|  0.00%|                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).
  1599|         0|            0|            0|  0.00%|                """
  1600|         0|            0|            0|  0.00%|            ),
  1601|         0|            0|            0|  0.00%|        ] = True,
  1602|         0|            0|            0|  0.00%|        response_class: Annotated[
  1603|         0|            0|            0|  0.00%|            Type[Response],
  1604|         0|            0|            0|  0.00%|            Doc(
  1605|         0|            0|            0|  0.00%|                """
  1606|         0|            0|            0|  0.00%|                Response class to be used for this *path operation*.
  1607|         0|            0|            0|  0.00%|
  1608|         0|            0|            0|  0.00%|                This will not be used if you return a response directly.
  1609|         0|            0|            0|  0.00%|
  1610|         0|            0|            0|  0.00%|                Read more about it in the
  1611|         0|            0|            0|  0.00%|                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
  1612|         0|            0|            0|  0.00%|                """
  1613|         0|            0|            0|  0.00%|            ),
  1614|         0|            0|            0|  0.00%|        ] = Default(JSONResponse),
  1615|         0|            0|            0|  0.00%|        name: Annotated[
  1616|         0|            0|            0|  0.00%|            Optional[str],
  1617|         0|            0|            0|  0.00%|            Doc(
  1618|         0|            0|            0|  0.00%|                """
  1619|         0|            0|            0|  0.00%|                Name for this *path operation*. Only used internally.
  1620|         0|            0|            0|  0.00%|                """
  1621|         0|            0|            0|  0.00%|            ),
  1622|         0|            0|            0|  0.00%|        ] = None,
  1623|         0|            0|            0|  0.00%|        callbacks: Annotated[
  1624|         0|            0|            0|  0.00%|            Optional[List[BaseRoute]],
  1625|         0|            0|            0|  0.00%|            Doc(
  1626|         0|            0|            0|  0.00%|                """
  1627|         0|            0|            0|  0.00%|                List of *path operations* that will be used as OpenAPI callbacks.
  1628|         0|            0|            0|  0.00%|
  1629|         0|            0|            0|  0.00%|                This is only for OpenAPI documentation, the callbacks won't be used
  1630|         0|            0|            0|  0.00%|                directly.
  1631|         0|            0|            0|  0.00%|
  1632|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  1633|         0|            0|            0|  0.00%|
  1634|         0|            0|            0|  0.00%|                Read more about it in the
  1635|         0|            0|            0|  0.00%|                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
  1636|         0|            0|            0|  0.00%|                """
  1637|         0|            0|            0|  0.00%|            ),
  1638|         0|            0|            0|  0.00%|        ] = None,
  1639|         0|            0|            0|  0.00%|        openapi_extra: Annotated[
  1640|         0|            0|            0|  0.00%|            Optional[Dict[str, Any]],
  1641|         0|            0|            0|  0.00%|            Doc(
  1642|         0|            0|            0|  0.00%|                """
  1643|         0|            0|            0|  0.00%|                Extra metadata to be included in the OpenAPI schema for this *path
  1644|         0|            0|            0|  0.00%|                operation*.
  1645|         0|            0|            0|  0.00%|
  1646|         0|            0|            0|  0.00%|                Read more about it in the
  1647|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
  1648|         0|            0|            0|  0.00%|                """
  1649|         0|            0|            0|  0.00%|            ),
  1650|         0|            0|            0|  0.00%|        ] = None,
  1651|         0|            0|            0|  0.00%|        generate_unique_id_function: Annotated[
  1652|         0|            0|            0|  0.00%|            Callable[[APIRoute], str],
  1653|         0|            0|            0|  0.00%|            Doc(
  1654|         0|            0|            0|  0.00%|                """
  1655|         0|            0|            0|  0.00%|                Customize the function used to generate unique IDs for the *path
  1656|         0|            0|            0|  0.00%|                operations* shown in the generated OpenAPI.
  1657|         0|            0|            0|  0.00%|
  1658|         0|            0|            0|  0.00%|                This is particularly useful when automatically generating clients or
  1659|         0|            0|            0|  0.00%|                SDKs for your API.
  1660|         0|            0|            0|  0.00%|
  1661|         0|            0|            0|  0.00%|                Read more about it in the
  1662|         0|            0|            0|  0.00%|                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
  1663|         0|            0|            0|  0.00%|                """
  1664|         0|            0|            0|  0.00%|            ),
  1665|         0|            0|            0|  0.00%|        ] = Default(generate_unique_id),
  1666|         0|            0|            0|  0.00%|    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
  1667|         0|            0|            0|  0.00%|        """
  1668|         0|            0|            0|  0.00%|        Add a *path operation* using an HTTP GET operation.
  1669|         0|            0|            0|  0.00%|
  1670|         0|            0|            0|  0.00%|        ## Example
  1671|         0|            0|            0|  0.00%|
  1672|         0|            0|            0|  0.00%|        ```python
  1673|         0|            0|            0|  0.00%|        from fastapi import APIRouter, FastAPI
  1674|         0|            0|            0|  0.00%|
  1675|         0|            0|            0|  0.00%|        app = FastAPI()
  1676|         0|            0|            0|  0.00%|        router = APIRouter()
  1677|         0|            0|            0|  0.00%|
  1678|         0|            0|            0|  0.00%|        @router.get("/items/")
  1679|         0|            0|            0|  0.00%|        def read_items():
  1680|         0|            0|            0|  0.00%|            return [{"name": "Empanada"}, {"name": "Arepa"}]
  1681|         0|            0|            0|  0.00%|
  1682|         0|            0|            0|  0.00%|        app.include_router(router)
  1683|         0|            0|            0|  0.00%|        ```
  1684|         0|            0|            0|  0.00%|        """
  1685|         0|            0|            0|  0.00%|        return self.api_route(
  1686|         0|            0|            0|  0.00%|            path=path,
  1687|         0|            0|            0|  0.00%|            response_model=response_model,
  1688|         0|            0|            0|  0.00%|            status_code=status_code,
  1689|         0|            0|            0|  0.00%|            tags=tags,
  1690|         0|            0|            0|  0.00%|            dependencies=dependencies,
  1691|         0|            0|            0|  0.00%|            summary=summary,
  1692|         0|            0|            0|  0.00%|            description=description,
  1693|         0|            0|            0|  0.00%|            response_description=response_description,
  1694|         0|            0|            0|  0.00%|            responses=responses,
  1695|         0|            0|            0|  0.00%|            deprecated=deprecated,
  1696|         0|            0|            0|  0.00%|            methods=["GET"],
  1697|         0|            0|            0|  0.00%|            operation_id=operation_id,
  1698|         0|            0|            0|  0.00%|            response_model_include=response_model_include,
  1699|         0|            0|            0|  0.00%|            response_model_exclude=response_model_exclude,
  1700|         0|            0|            0|  0.00%|            response_model_by_alias=response_model_by_alias,
  1701|         0|            0|            0|  0.00%|            response_model_exclude_unset=response_model_exclude_unset,
  1702|         0|            0|            0|  0.00%|            response_model_exclude_defaults=response_model_exclude_defaults,
  1703|         0|            0|            0|  0.00%|            response_model_exclude_none=response_model_exclude_none,
  1704|         0|            0|            0|  0.00%|            include_in_schema=include_in_schema,
  1705|         0|            0|            0|  0.00%|            response_class=response_class,
  1706|         0|            0|            0|  0.00%|            name=name,
  1707|         0|            0|            0|  0.00%|            callbacks=callbacks,
  1708|         0|            0|            0|  0.00%|            openapi_extra=openapi_extra,
  1709|         0|            0|            0|  0.00%|            generate_unique_id_function=generate_unique_id_function,
  1710|         0|            0|            0|  0.00%|        )
  1711|         0|            0|            0|  0.00%|
  1712|         0|            0|            0|  0.00%|    def put(
  1713|         0|            0|            0|  0.00%|        self,
  1714|         0|            0|            0|  0.00%|        path: Annotated[
  1715|         0|            0|            0|  0.00%|            str,
  1716|         0|            0|            0|  0.00%|            Doc(
  1717|         0|            0|            0|  0.00%|                """
  1718|         0|            0|            0|  0.00%|                The URL path to be used for this *path operation*.
  1719|         0|            0|            0|  0.00%|
  1720|         0|            0|            0|  0.00%|                For example, in `http://example.com/items`, the path is `/items`.
  1721|         0|            0|            0|  0.00%|                """
  1722|         0|            0|            0|  0.00%|            ),
  1723|         0|            0|            0|  0.00%|        ],
  1724|         0|            0|            0|  0.00%|        *,
  1725|         0|            0|            0|  0.00%|        response_model: Annotated[
  1726|         0|            0|            0|  0.00%|            Any,
  1727|         0|            0|            0|  0.00%|            Doc(
  1728|         0|            0|            0|  0.00%|                """
  1729|         0|            0|            0|  0.00%|                The type to use for the response.
  1730|         0|            0|            0|  0.00%|
  1731|         0|            0|            0|  0.00%|                It could be any valid Pydantic *field* type. So, it doesn't have to
  1732|         0|            0|            0|  0.00%|                be a Pydantic model, it could be other things, like a `list`, `dict`,
  1733|         0|            0|            0|  0.00%|                etc.
  1734|         0|            0|            0|  0.00%|
  1735|         0|            0|            0|  0.00%|                It will be used for:
  1736|         0|            0|            0|  0.00%|
  1737|         0|            0|            0|  0.00%|                * Documentation: the generated OpenAPI (and the UI at `/docs`) will
  1738|         0|            0|            0|  0.00%|                    show it as the response (JSON Schema).
  1739|         0|            0|            0|  0.00%|                * Serialization: you could return an arbitrary object and the
  1740|         0|            0|            0|  0.00%|                    `response_model` would be used to serialize that object into the
  1741|         0|            0|            0|  0.00%|                    corresponding JSON.
  1742|         0|            0|            0|  0.00%|                * Filtering: the JSON sent to the client will only contain the data
  1743|         0|            0|            0|  0.00%|                    (fields) defined in the `response_model`. If you returned an object
  1744|         0|            0|            0|  0.00%|                    that contains an attribute `password` but the `response_model` does
  1745|         0|            0|            0|  0.00%|                    not include that field, the JSON sent to the client would not have
  1746|         0|            0|            0|  0.00%|                    that `password`.
  1747|         0|            0|            0|  0.00%|                * Validation: whatever you return will be serialized with the
  1748|         0|            0|            0|  0.00%|                    `response_model`, converting any data as necessary to generate the
  1749|         0|            0|            0|  0.00%|                    corresponding JSON. But if the data in the object returned is not
  1750|         0|            0|            0|  0.00%|                    valid, that would mean a violation of the contract with the client,
  1751|         0|            0|            0|  0.00%|                    so it's an error from the API developer. So, FastAPI will raise an
  1752|         0|            0|            0|  0.00%|                    error and return a 500 error code (Internal Server Error).
  1753|         0|            0|            0|  0.00%|
  1754|         0|            0|            0|  0.00%|                Read more about it in the
  1755|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
  1756|         0|            0|            0|  0.00%|                """
  1757|         0|            0|            0|  0.00%|            ),
  1758|         0|            0|            0|  0.00%|        ] = Default(None),
  1759|         0|            0|            0|  0.00%|        status_code: Annotated[
  1760|         0|            0|            0|  0.00%|            Optional[int],
  1761|         0|            0|            0|  0.00%|            Doc(
  1762|         0|            0|            0|  0.00%|                """
  1763|         0|            0|            0|  0.00%|                The default status code to be used for the response.
  1764|         0|            0|            0|  0.00%|
  1765|         0|            0|            0|  0.00%|                You could override the status code by returning a response directly.
  1766|         0|            0|            0|  0.00%|
  1767|         0|            0|            0|  0.00%|                Read more about it in the
  1768|         0|            0|            0|  0.00%|                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
  1769|         0|            0|            0|  0.00%|                """
  1770|         0|            0|            0|  0.00%|            ),
  1771|         0|            0|            0|  0.00%|        ] = None,
  1772|         0|            0|            0|  0.00%|        tags: Annotated[
  1773|         0|            0|            0|  0.00%|            Optional[List[Union[str, Enum]]],
  1774|         0|            0|            0|  0.00%|            Doc(
  1775|         0|            0|            0|  0.00%|                """
  1776|         0|            0|            0|  0.00%|                A list of tags to be applied to the *path operation*.
  1777|         0|            0|            0|  0.00%|
  1778|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  1779|         0|            0|            0|  0.00%|
  1780|         0|            0|            0|  0.00%|                Read more about it in the
  1781|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
  1782|         0|            0|            0|  0.00%|                """
  1783|         0|            0|            0|  0.00%|            ),
  1784|         0|            0|            0|  0.00%|        ] = None,
  1785|         0|            0|            0|  0.00%|        dependencies: Annotated[
  1786|         0|            0|            0|  0.00%|            Optional[Sequence[params.Depends]],
  1787|         0|            0|            0|  0.00%|            Doc(
  1788|         0|            0|            0|  0.00%|                """
  1789|         0|            0|            0|  0.00%|                A list of dependencies (using `Depends()`) to be applied to the
  1790|         0|            0|            0|  0.00%|                *path operation*.
  1791|         0|            0|            0|  0.00%|
  1792|         0|            0|            0|  0.00%|                Read more about it in the
  1793|         0|            0|            0|  0.00%|                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
  1794|         0|            0|            0|  0.00%|                """
  1795|         0|            0|            0|  0.00%|            ),
  1796|         0|            0|            0|  0.00%|        ] = None,
  1797|         0|            0|            0|  0.00%|        summary: Annotated[
  1798|         0|            0|            0|  0.00%|            Optional[str],
  1799|         0|            0|            0|  0.00%|            Doc(
  1800|         0|            0|            0|  0.00%|                """
  1801|         0|            0|            0|  0.00%|                A summary for the *path operation*.
  1802|         0|            0|            0|  0.00%|
  1803|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  1804|         0|            0|            0|  0.00%|
  1805|         0|            0|            0|  0.00%|                Read more about it in the
  1806|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
  1807|         0|            0|            0|  0.00%|                """
  1808|         0|            0|            0|  0.00%|            ),
  1809|         0|            0|            0|  0.00%|        ] = None,
  1810|         0|            0|            0|  0.00%|        description: Annotated[
  1811|         0|            0|            0|  0.00%|            Optional[str],
  1812|         0|            0|            0|  0.00%|            Doc(
  1813|         0|            0|            0|  0.00%|                """
  1814|         0|            0|            0|  0.00%|                A description for the *path operation*.
  1815|         0|            0|            0|  0.00%|
  1816|         0|            0|            0|  0.00%|                If not provided, it will be extracted automatically from the docstring
  1817|         0|            0|            0|  0.00%|                of the *path operation function*.
  1818|         0|            0|            0|  0.00%|
  1819|         0|            0|            0|  0.00%|                It can contain Markdown.
  1820|         0|            0|            0|  0.00%|
  1821|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  1822|         0|            0|            0|  0.00%|
  1823|         0|            0|            0|  0.00%|                Read more about it in the
  1824|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
  1825|         0|            0|            0|  0.00%|                """
  1826|         0|            0|            0|  0.00%|            ),
  1827|         0|            0|            0|  0.00%|        ] = None,
  1828|         0|            0|            0|  0.00%|        response_description: Annotated[
  1829|         0|            0|            0|  0.00%|            str,
  1830|         0|            0|            0|  0.00%|            Doc(
  1831|         0|            0|            0|  0.00%|                """
  1832|         0|            0|            0|  0.00%|                The description for the default response.
  1833|         0|            0|            0|  0.00%|
  1834|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  1835|         0|            0|            0|  0.00%|                """
  1836|         0|            0|            0|  0.00%|            ),
  1837|         0|            0|            0|  0.00%|        ] = "Successful Response",
  1838|         0|            0|            0|  0.00%|        responses: Annotated[
  1839|         0|            0|            0|  0.00%|            Optional[Dict[Union[int, str], Dict[str, Any]]],
  1840|         0|            0|            0|  0.00%|            Doc(
  1841|         0|            0|            0|  0.00%|                """
  1842|         0|            0|            0|  0.00%|                Additional responses that could be returned by this *path operation*.
  1843|         0|            0|            0|  0.00%|
  1844|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  1845|         0|            0|            0|  0.00%|                """
  1846|         0|            0|            0|  0.00%|            ),
  1847|         0|            0|            0|  0.00%|        ] = None,
  1848|         0|            0|            0|  0.00%|        deprecated: Annotated[
  1849|         0|            0|            0|  0.00%|            Optional[bool],
  1850|         0|            0|            0|  0.00%|            Doc(
  1851|         0|            0|            0|  0.00%|                """
  1852|         0|            0|            0|  0.00%|                Mark this *path operation* as deprecated.
  1853|         0|            0|            0|  0.00%|
  1854|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  1855|         0|            0|            0|  0.00%|                """
  1856|         0|            0|            0|  0.00%|            ),
  1857|         0|            0|            0|  0.00%|        ] = None,
  1858|         0|            0|            0|  0.00%|        operation_id: Annotated[
  1859|         0|            0|            0|  0.00%|            Optional[str],
  1860|         0|            0|            0|  0.00%|            Doc(
  1861|         0|            0|            0|  0.00%|                """
  1862|         0|            0|            0|  0.00%|                Custom operation ID to be used by this *path operation*.
  1863|         0|            0|            0|  0.00%|
  1864|         0|            0|            0|  0.00%|                By default, it is generated automatically.
  1865|         0|            0|            0|  0.00%|
  1866|         0|            0|            0|  0.00%|                If you provide a custom operation ID, you need to make sure it is
  1867|         0|            0|            0|  0.00%|                unique for the whole API.
  1868|         0|            0|            0|  0.00%|
  1869|         0|            0|            0|  0.00%|                You can customize the
  1870|         0|            0|            0|  0.00%|                operation ID generation with the parameter
  1871|         0|            0|            0|  0.00%|                `generate_unique_id_function` in the `FastAPI` class.
  1872|         0|            0|            0|  0.00%|
  1873|         0|            0|            0|  0.00%|                Read more about it in the
  1874|         0|            0|            0|  0.00%|                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
  1875|         0|            0|            0|  0.00%|                """
  1876|         0|            0|            0|  0.00%|            ),
  1877|         0|            0|            0|  0.00%|        ] = None,
  1878|         0|            0|            0|  0.00%|        response_model_include: Annotated[
  1879|         0|            0|            0|  0.00%|            Optional[IncEx],
  1880|         0|            0|            0|  0.00%|            Doc(
  1881|         0|            0|            0|  0.00%|                """
  1882|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to include only certain fields in the
  1883|         0|            0|            0|  0.00%|                response data.
  1884|         0|            0|            0|  0.00%|
  1885|         0|            0|            0|  0.00%|                Read more about it in the
  1886|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
  1887|         0|            0|            0|  0.00%|                """
  1888|         0|            0|            0|  0.00%|            ),
  1889|         0|            0|            0|  0.00%|        ] = None,
  1890|         0|            0|            0|  0.00%|        response_model_exclude: Annotated[
  1891|         0|            0|            0|  0.00%|            Optional[IncEx],
  1892|         0|            0|            0|  0.00%|            Doc(
  1893|         0|            0|            0|  0.00%|                """
  1894|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to exclude certain fields in the
  1895|         0|            0|            0|  0.00%|                response data.
  1896|         0|            0|            0|  0.00%|
  1897|         0|            0|            0|  0.00%|                Read more about it in the
  1898|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
  1899|         0|            0|            0|  0.00%|                """
  1900|         0|            0|            0|  0.00%|            ),
  1901|         0|            0|            0|  0.00%|        ] = None,
  1902|         0|            0|            0|  0.00%|        response_model_by_alias: Annotated[
  1903|         0|            0|            0|  0.00%|            bool,
  1904|         0|            0|            0|  0.00%|            Doc(
  1905|         0|            0|            0|  0.00%|                """
  1906|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response model
  1907|         0|            0|            0|  0.00%|                should be serialized by alias when an alias is used.
  1908|         0|            0|            0|  0.00%|
  1909|         0|            0|            0|  0.00%|                Read more about it in the
  1910|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
  1911|         0|            0|            0|  0.00%|                """
  1912|         0|            0|            0|  0.00%|            ),
  1913|         0|            0|            0|  0.00%|        ] = True,
  1914|         0|            0|            0|  0.00%|        response_model_exclude_unset: Annotated[
  1915|         0|            0|            0|  0.00%|            bool,
  1916|         0|            0|            0|  0.00%|            Doc(
  1917|         0|            0|            0|  0.00%|                """
  1918|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response data
  1919|         0|            0|            0|  0.00%|                should have all the fields, including the ones that were not set and
  1920|         0|            0|            0|  0.00%|                have their default values. This is different from
  1921|         0|            0|            0|  0.00%|                `response_model_exclude_defaults` in that if the fields are set,
  1922|         0|            0|            0|  0.00%|                they will be included in the response, even if the value is the same
  1923|         0|            0|            0|  0.00%|                as the default.
  1924|         0|            0|            0|  0.00%|
  1925|         0|            0|            0|  0.00%|                When `True`, default values are omitted from the response.
  1926|         0|            0|            0|  0.00%|
  1927|         0|            0|            0|  0.00%|                Read more about it in the
  1928|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
  1929|         0|            0|            0|  0.00%|                """
  1930|         0|            0|            0|  0.00%|            ),
  1931|         0|            0|            0|  0.00%|        ] = False,
  1932|         0|            0|            0|  0.00%|        response_model_exclude_defaults: Annotated[
  1933|         0|            0|            0|  0.00%|            bool,
  1934|         0|            0|            0|  0.00%|            Doc(
  1935|         0|            0|            0|  0.00%|                """
  1936|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response data
  1937|         0|            0|            0|  0.00%|                should have all the fields, including the ones that have the same value
  1938|         0|            0|            0|  0.00%|                as the default. This is different from `response_model_exclude_unset`
  1939|         0|            0|            0|  0.00%|                in that if the fields are set but contain the same default values,
  1940|         0|            0|            0|  0.00%|                they will be excluded from the response.
  1941|         0|            0|            0|  0.00%|
  1942|         0|            0|            0|  0.00%|                When `True`, default values are omitted from the response.
  1943|         0|            0|            0|  0.00%|
  1944|         0|            0|            0|  0.00%|                Read more about it in the
  1945|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
  1946|         0|            0|            0|  0.00%|                """
  1947|         0|            0|            0|  0.00%|            ),
  1948|         0|            0|            0|  0.00%|        ] = False,
  1949|         0|            0|            0|  0.00%|        response_model_exclude_none: Annotated[
  1950|         0|            0|            0|  0.00%|            bool,
  1951|         0|            0|            0|  0.00%|            Doc(
  1952|         0|            0|            0|  0.00%|                """
  1953|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response data should
  1954|         0|            0|            0|  0.00%|                exclude fields set to `None`.
  1955|         0|            0|            0|  0.00%|
  1956|         0|            0|            0|  0.00%|                This is much simpler (less smart) than `response_model_exclude_unset`
  1957|         0|            0|            0|  0.00%|                and `response_model_exclude_defaults`. You probably want to use one of
  1958|         0|            0|            0|  0.00%|                those two instead of this one, as those allow returning `None` values
  1959|         0|            0|            0|  0.00%|                when it makes sense.
  1960|         0|            0|            0|  0.00%|
  1961|         0|            0|            0|  0.00%|                Read more about it in the
  1962|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
  1963|         0|            0|            0|  0.00%|                """
  1964|         0|            0|            0|  0.00%|            ),
  1965|         0|            0|            0|  0.00%|        ] = False,
  1966|         0|            0|            0|  0.00%|        include_in_schema: Annotated[
  1967|         0|            0|            0|  0.00%|            bool,
  1968|         0|            0|            0|  0.00%|            Doc(
  1969|         0|            0|            0|  0.00%|                """
  1970|         0|            0|            0|  0.00%|                Include this *path operation* in the generated OpenAPI schema.
  1971|         0|            0|            0|  0.00%|
  1972|         0|            0|            0|  0.00%|                This affects the generated OpenAPI (e.g. visible at `/docs`).
  1973|         0|            0|            0|  0.00%|
  1974|         0|            0|            0|  0.00%|                Read more about it in the
  1975|         0|            0|            0|  0.00%|                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).
  1976|         0|            0|            0|  0.00%|                """
  1977|         0|            0|            0|  0.00%|            ),
  1978|         0|            0|            0|  0.00%|        ] = True,
  1979|         0|            0|            0|  0.00%|        response_class: Annotated[
  1980|         0|            0|            0|  0.00%|            Type[Response],
  1981|         0|            0|            0|  0.00%|            Doc(
  1982|         0|            0|            0|  0.00%|                """
  1983|         0|            0|            0|  0.00%|                Response class to be used for this *path operation*.
  1984|         0|            0|            0|  0.00%|
  1985|         0|            0|            0|  0.00%|                This will not be used if you return a response directly.
  1986|         0|            0|            0|  0.00%|
  1987|         0|            0|            0|  0.00%|                Read more about it in the
  1988|         0|            0|            0|  0.00%|                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
  1989|         0|            0|            0|  0.00%|                """
  1990|         0|            0|            0|  0.00%|            ),
  1991|         0|            0|            0|  0.00%|        ] = Default(JSONResponse),
  1992|         0|            0|            0|  0.00%|        name: Annotated[
  1993|         0|            0|            0|  0.00%|            Optional[str],
  1994|         0|            0|            0|  0.00%|            Doc(
  1995|         0|            0|            0|  0.00%|                """
  1996|         0|            0|            0|  0.00%|                Name for this *path operation*. Only used internally.
  1997|         0|            0|            0|  0.00%|                """
  1998|         0|            0|            0|  0.00%|            ),
  1999|         0|            0|            0|  0.00%|        ] = None,
  2000|         0|            0|            0|  0.00%|        callbacks: Annotated[
  2001|         0|            0|            0|  0.00%|            Optional[List[BaseRoute]],
  2002|         0|            0|            0|  0.00%|            Doc(
  2003|         0|            0|            0|  0.00%|                """
  2004|         0|            0|            0|  0.00%|                List of *path operations* that will be used as OpenAPI callbacks.
  2005|         0|            0|            0|  0.00%|
  2006|         0|            0|            0|  0.00%|                This is only for OpenAPI documentation, the callbacks won't be used
  2007|         0|            0|            0|  0.00%|                directly.
  2008|         0|            0|            0|  0.00%|
  2009|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  2010|         0|            0|            0|  0.00%|
  2011|         0|            0|            0|  0.00%|                Read more about it in the
  2012|         0|            0|            0|  0.00%|                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
  2013|         0|            0|            0|  0.00%|                """
  2014|         0|            0|            0|  0.00%|            ),
  2015|         0|            0|            0|  0.00%|        ] = None,
  2016|         0|            0|            0|  0.00%|        openapi_extra: Annotated[
  2017|         0|            0|            0|  0.00%|            Optional[Dict[str, Any]],
  2018|         0|            0|            0|  0.00%|            Doc(
  2019|         0|            0|            0|  0.00%|                """
  2020|         0|            0|            0|  0.00%|                Extra metadata to be included in the OpenAPI schema for this *path
  2021|         0|            0|            0|  0.00%|                operation*.
  2022|         0|            0|            0|  0.00%|
  2023|         0|            0|            0|  0.00%|                Read more about it in the
  2024|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
  2025|         0|            0|            0|  0.00%|                """
  2026|         0|            0|            0|  0.00%|            ),
  2027|         0|            0|            0|  0.00%|        ] = None,
  2028|         0|            0|            0|  0.00%|        generate_unique_id_function: Annotated[
  2029|         0|            0|            0|  0.00%|            Callable[[APIRoute], str],
  2030|         0|            0|            0|  0.00%|            Doc(
  2031|         0|            0|            0|  0.00%|                """
  2032|         0|            0|            0|  0.00%|                Customize the function used to generate unique IDs for the *path
  2033|         0|            0|            0|  0.00%|                operations* shown in the generated OpenAPI.
  2034|         0|            0|            0|  0.00%|
  2035|         0|            0|            0|  0.00%|                This is particularly useful when automatically generating clients or
  2036|         0|            0|            0|  0.00%|                SDKs for your API.
  2037|         0|            0|            0|  0.00%|
  2038|         0|            0|            0|  0.00%|                Read more about it in the
  2039|         0|            0|            0|  0.00%|                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
  2040|         0|            0|            0|  0.00%|                """
  2041|         0|            0|            0|  0.00%|            ),
  2042|         0|            0|            0|  0.00%|        ] = Default(generate_unique_id),
  2043|         0|            0|            0|  0.00%|    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
  2044|         0|            0|            0|  0.00%|        """
  2045|         0|            0|            0|  0.00%|        Add a *path operation* using an HTTP PUT operation.
  2046|         0|            0|            0|  0.00%|
  2047|         0|            0|            0|  0.00%|        ## Example
  2048|         0|            0|            0|  0.00%|
  2049|         0|            0|            0|  0.00%|        ```python
  2050|         0|            0|            0|  0.00%|        from fastapi import APIRouter, FastAPI
  2051|         0|            0|            0|  0.00%|        from pydantic import BaseModel
  2052|         0|            0|            0|  0.00%|
  2053|         0|            0|            0|  0.00%|        class Item(BaseModel):
  2054|         0|            0|            0|  0.00%|            name: str
  2055|         0|            0|            0|  0.00%|            description: str | None = None
  2056|         0|            0|            0|  0.00%|
  2057|         0|            0|            0|  0.00%|        app = FastAPI()
  2058|         0|            0|            0|  0.00%|        router = APIRouter()
  2059|         0|            0|            0|  0.00%|
  2060|         0|            0|            0|  0.00%|        @router.put("/items/{item_id}")
  2061|         0|            0|            0|  0.00%|        def replace_item(item_id: str, item: Item):
  2062|         0|            0|            0|  0.00%|            return {"message": "Item replaced", "id": item_id}
  2063|         0|            0|            0|  0.00%|
  2064|         0|            0|            0|  0.00%|        app.include_router(router)
  2065|         0|            0|            0|  0.00%|        ```
  2066|         0|            0|            0|  0.00%|        """
  2067|         0|            0|            0|  0.00%|        return self.api_route(
  2068|         0|            0|            0|  0.00%|            path=path,
  2069|         0|            0|            0|  0.00%|            response_model=response_model,
  2070|         0|            0|            0|  0.00%|            status_code=status_code,
  2071|         0|            0|            0|  0.00%|            tags=tags,
  2072|         0|            0|            0|  0.00%|            dependencies=dependencies,
  2073|         0|            0|            0|  0.00%|            summary=summary,
  2074|         0|            0|            0|  0.00%|            description=description,
  2075|         0|            0|            0|  0.00%|            response_description=response_description,
  2076|         0|            0|            0|  0.00%|            responses=responses,
  2077|         0|            0|            0|  0.00%|            deprecated=deprecated,
  2078|         0|            0|            0|  0.00%|            methods=["PUT"],
  2079|         0|            0|            0|  0.00%|            operation_id=operation_id,
  2080|         0|            0|            0|  0.00%|            response_model_include=response_model_include,
  2081|         0|            0|            0|  0.00%|            response_model_exclude=response_model_exclude,
  2082|         0|            0|            0|  0.00%|            response_model_by_alias=response_model_by_alias,
  2083|         0|            0|            0|  0.00%|            response_model_exclude_unset=response_model_exclude_unset,
  2084|         0|            0|            0|  0.00%|            response_model_exclude_defaults=response_model_exclude_defaults,
  2085|         0|            0|            0|  0.00%|            response_model_exclude_none=response_model_exclude_none,
  2086|         0|            0|            0|  0.00%|            include_in_schema=include_in_schema,
  2087|         0|            0|            0|  0.00%|            response_class=response_class,
  2088|         0|            0|            0|  0.00%|            name=name,
  2089|         0|            0|            0|  0.00%|            callbacks=callbacks,
  2090|         0|            0|            0|  0.00%|            openapi_extra=openapi_extra,
  2091|         0|            0|            0|  0.00%|            generate_unique_id_function=generate_unique_id_function,
  2092|         0|            0|            0|  0.00%|        )
  2093|         0|            0|            0|  0.00%|
  2094|         0|            0|            0|  0.00%|    def post(
  2095|         0|            0|            0|  0.00%|        self,
  2096|         0|            0|            0|  0.00%|        path: Annotated[
  2097|         0|            0|            0|  0.00%|            str,
  2098|         0|            0|            0|  0.00%|            Doc(
  2099|         0|            0|            0|  0.00%|                """
  2100|         0|            0|            0|  0.00%|                The URL path to be used for this *path operation*.
  2101|         0|            0|            0|  0.00%|
  2102|         0|            0|            0|  0.00%|                For example, in `http://example.com/items`, the path is `/items`.
  2103|         0|            0|            0|  0.00%|                """
  2104|         0|            0|            0|  0.00%|            ),
  2105|         0|            0|            0|  0.00%|        ],
  2106|         0|            0|            0|  0.00%|        *,
  2107|         0|            0|            0|  0.00%|        response_model: Annotated[
  2108|         0|            0|            0|  0.00%|            Any,
  2109|         0|            0|            0|  0.00%|            Doc(
  2110|         0|            0|            0|  0.00%|                """
  2111|         0|            0|            0|  0.00%|                The type to use for the response.
  2112|         0|            0|            0|  0.00%|
  2113|         0|            0|            0|  0.00%|                It could be any valid Pydantic *field* type. So, it doesn't have to
  2114|         0|            0|            0|  0.00%|                be a Pydantic model, it could be other things, like a `list`, `dict`,
  2115|         0|            0|            0|  0.00%|                etc.
  2116|         0|            0|            0|  0.00%|
  2117|         0|            0|            0|  0.00%|                It will be used for:
  2118|         0|            0|            0|  0.00%|
  2119|         0|            0|            0|  0.00%|                * Documentation: the generated OpenAPI (and the UI at `/docs`) will
  2120|         0|            0|            0|  0.00%|                    show it as the response (JSON Schema).
  2121|         0|            0|            0|  0.00%|                * Serialization: you could return an arbitrary object and the
  2122|         0|            0|            0|  0.00%|                    `response_model` would be used to serialize that object into the
  2123|         0|            0|            0|  0.00%|                    corresponding JSON.
  2124|         0|            0|            0|  0.00%|                * Filtering: the JSON sent to the client will only contain the data
  2125|         0|            0|            0|  0.00%|                    (fields) defined in the `response_model`. If you returned an object
  2126|         0|            0|            0|  0.00%|                    that contains an attribute `password` but the `response_model` does
  2127|         0|            0|            0|  0.00%|                    not include that field, the JSON sent to the client would not have
  2128|         0|            0|            0|  0.00%|                    that `password`.
  2129|         0|            0|            0|  0.00%|                * Validation: whatever you return will be serialized with the
  2130|         0|            0|            0|  0.00%|                    `response_model`, converting any data as necessary to generate the
  2131|         0|            0|            0|  0.00%|                    corresponding JSON. But if the data in the object returned is not
  2132|         0|            0|            0|  0.00%|                    valid, that would mean a violation of the contract with the client,
  2133|         0|            0|            0|  0.00%|                    so it's an error from the API developer. So, FastAPI will raise an
  2134|         0|            0|            0|  0.00%|                    error and return a 500 error code (Internal Server Error).
  2135|         0|            0|            0|  0.00%|
  2136|         0|            0|            0|  0.00%|                Read more about it in the
  2137|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
  2138|         0|            0|            0|  0.00%|                """
  2139|         0|            0|            0|  0.00%|            ),
  2140|         0|            0|            0|  0.00%|        ] = Default(None),
  2141|         0|            0|            0|  0.00%|        status_code: Annotated[
  2142|         0|            0|            0|  0.00%|            Optional[int],
  2143|         0|            0|            0|  0.00%|            Doc(
  2144|         0|            0|            0|  0.00%|                """
  2145|         0|            0|            0|  0.00%|                The default status code to be used for the response.
  2146|         0|            0|            0|  0.00%|
  2147|         0|            0|            0|  0.00%|                You could override the status code by returning a response directly.
  2148|         0|            0|            0|  0.00%|
  2149|         0|            0|            0|  0.00%|                Read more about it in the
  2150|         0|            0|            0|  0.00%|                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
  2151|         0|            0|            0|  0.00%|                """
  2152|         0|            0|            0|  0.00%|            ),
  2153|         0|            0|            0|  0.00%|        ] = None,
  2154|         0|            0|            0|  0.00%|        tags: Annotated[
  2155|         0|            0|            0|  0.00%|            Optional[List[Union[str, Enum]]],
  2156|         0|            0|            0|  0.00%|            Doc(
  2157|         0|            0|            0|  0.00%|                """
  2158|         0|            0|            0|  0.00%|                A list of tags to be applied to the *path operation*.
  2159|         0|            0|            0|  0.00%|
  2160|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  2161|         0|            0|            0|  0.00%|
  2162|         0|            0|            0|  0.00%|                Read more about it in the
  2163|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
  2164|         0|            0|            0|  0.00%|                """
  2165|         0|            0|            0|  0.00%|            ),
  2166|         0|            0|            0|  0.00%|        ] = None,
  2167|         0|            0|            0|  0.00%|        dependencies: Annotated[
  2168|         0|            0|            0|  0.00%|            Optional[Sequence[params.Depends]],
  2169|         0|            0|            0|  0.00%|            Doc(
  2170|         0|            0|            0|  0.00%|                """
  2171|         0|            0|            0|  0.00%|                A list of dependencies (using `Depends()`) to be applied to the
  2172|         0|            0|            0|  0.00%|                *path operation*.
  2173|         0|            0|            0|  0.00%|
  2174|         0|            0|            0|  0.00%|                Read more about it in the
  2175|         0|            0|            0|  0.00%|                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
  2176|         0|            0|            0|  0.00%|                """
  2177|         0|            0|            0|  0.00%|            ),
  2178|         0|            0|            0|  0.00%|        ] = None,
  2179|         0|            0|            0|  0.00%|        summary: Annotated[
  2180|         0|            0|            0|  0.00%|            Optional[str],
  2181|         0|            0|            0|  0.00%|            Doc(
  2182|         0|            0|            0|  0.00%|                """
  2183|         0|            0|            0|  0.00%|                A summary for the *path operation*.
  2184|         0|            0|            0|  0.00%|
  2185|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  2186|         0|            0|            0|  0.00%|
  2187|         0|            0|            0|  0.00%|                Read more about it in the
  2188|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
  2189|         0|            0|            0|  0.00%|                """
  2190|         0|            0|            0|  0.00%|            ),
  2191|         0|            0|            0|  0.00%|        ] = None,
  2192|         0|            0|            0|  0.00%|        description: Annotated[
  2193|         0|            0|            0|  0.00%|            Optional[str],
  2194|         0|            0|            0|  0.00%|            Doc(
  2195|         0|            0|            0|  0.00%|                """
  2196|         0|            0|            0|  0.00%|                A description for the *path operation*.
  2197|         0|            0|            0|  0.00%|
  2198|         0|            0|            0|  0.00%|                If not provided, it will be extracted automatically from the docstring
  2199|         0|            0|            0|  0.00%|                of the *path operation function*.
  2200|         0|            0|            0|  0.00%|
  2201|         0|            0|            0|  0.00%|                It can contain Markdown.
  2202|         0|            0|            0|  0.00%|
  2203|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  2204|         0|            0|            0|  0.00%|
  2205|         0|            0|            0|  0.00%|                Read more about it in the
  2206|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
  2207|         0|            0|            0|  0.00%|                """
  2208|         0|            0|            0|  0.00%|            ),
  2209|         0|            0|            0|  0.00%|        ] = None,
  2210|         0|            0|            0|  0.00%|        response_description: Annotated[
  2211|         0|            0|            0|  0.00%|            str,
  2212|         0|            0|            0|  0.00%|            Doc(
  2213|         0|            0|            0|  0.00%|                """
  2214|         0|            0|            0|  0.00%|                The description for the default response.
  2215|         0|            0|            0|  0.00%|
  2216|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  2217|         0|            0|            0|  0.00%|                """
  2218|         0|            0|            0|  0.00%|            ),
  2219|         0|            0|            0|  0.00%|        ] = "Successful Response",
  2220|         0|            0|            0|  0.00%|        responses: Annotated[
  2221|         0|            0|            0|  0.00%|            Optional[Dict[Union[int, str], Dict[str, Any]]],
  2222|         0|            0|            0|  0.00%|            Doc(
  2223|         0|            0|            0|  0.00%|                """
  2224|         0|            0|            0|  0.00%|                Additional responses that could be returned by this *path operation*.
  2225|         0|            0|            0|  0.00%|
  2226|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  2227|         0|            0|            0|  0.00%|                """
  2228|         0|            0|            0|  0.00%|            ),
  2229|         0|            0|            0|  0.00%|        ] = None,
  2230|         0|            0|            0|  0.00%|        deprecated: Annotated[
  2231|         0|            0|            0|  0.00%|            Optional[bool],
  2232|         0|            0|            0|  0.00%|            Doc(
  2233|         0|            0|            0|  0.00%|                """
  2234|         0|            0|            0|  0.00%|                Mark this *path operation* as deprecated.
  2235|         0|            0|            0|  0.00%|
  2236|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  2237|         0|            0|            0|  0.00%|                """
  2238|         0|            0|            0|  0.00%|            ),
  2239|         0|            0|            0|  0.00%|        ] = None,
  2240|         0|            0|            0|  0.00%|        operation_id: Annotated[
  2241|         0|            0|            0|  0.00%|            Optional[str],
  2242|         0|            0|            0|  0.00%|            Doc(
  2243|         0|            0|            0|  0.00%|                """
  2244|         0|            0|            0|  0.00%|                Custom operation ID to be used by this *path operation*.
  2245|         0|            0|            0|  0.00%|
  2246|         0|            0|            0|  0.00%|                By default, it is generated automatically.
  2247|         0|            0|            0|  0.00%|
  2248|         0|            0|            0|  0.00%|                If you provide a custom operation ID, you need to make sure it is
  2249|         0|            0|            0|  0.00%|                unique for the whole API.
  2250|         0|            0|            0|  0.00%|
  2251|         0|            0|            0|  0.00%|                You can customize the
  2252|         0|            0|            0|  0.00%|                operation ID generation with the parameter
  2253|         0|            0|            0|  0.00%|                `generate_unique_id_function` in the `FastAPI` class.
  2254|         0|            0|            0|  0.00%|
  2255|         0|            0|            0|  0.00%|                Read more about it in the
  2256|         0|            0|            0|  0.00%|                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
  2257|         0|            0|            0|  0.00%|                """
  2258|         0|            0|            0|  0.00%|            ),
  2259|         0|            0|            0|  0.00%|        ] = None,
  2260|         0|            0|            0|  0.00%|        response_model_include: Annotated[
  2261|         0|            0|            0|  0.00%|            Optional[IncEx],
  2262|         0|            0|            0|  0.00%|            Doc(
  2263|         0|            0|            0|  0.00%|                """
  2264|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to include only certain fields in the
  2265|         0|            0|            0|  0.00%|                response data.
  2266|         0|            0|            0|  0.00%|
  2267|         0|            0|            0|  0.00%|                Read more about it in the
  2268|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
  2269|         0|            0|            0|  0.00%|                """
  2270|         0|            0|            0|  0.00%|            ),
  2271|         0|            0|            0|  0.00%|        ] = None,
  2272|         0|            0|            0|  0.00%|        response_model_exclude: Annotated[
  2273|         0|            0|            0|  0.00%|            Optional[IncEx],
  2274|         0|            0|            0|  0.00%|            Doc(
  2275|         0|            0|            0|  0.00%|                """
  2276|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to exclude certain fields in the
  2277|         0|            0|            0|  0.00%|                response data.
  2278|         0|            0|            0|  0.00%|
  2279|         0|            0|            0|  0.00%|                Read more about it in the
  2280|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
  2281|         0|            0|            0|  0.00%|                """
  2282|         0|            0|            0|  0.00%|            ),
  2283|         0|            0|            0|  0.00%|        ] = None,
  2284|         0|            0|            0|  0.00%|        response_model_by_alias: Annotated[
  2285|         0|            0|            0|  0.00%|            bool,
  2286|         0|            0|            0|  0.00%|            Doc(
  2287|         0|            0|            0|  0.00%|                """
  2288|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response model
  2289|         0|            0|            0|  0.00%|                should be serialized by alias when an alias is used.
  2290|         0|            0|            0|  0.00%|
  2291|         0|            0|            0|  0.00%|                Read more about it in the
  2292|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
  2293|         0|            0|            0|  0.00%|                """
  2294|         0|            0|            0|  0.00%|            ),
  2295|         0|            0|            0|  0.00%|        ] = True,
  2296|         0|            0|            0|  0.00%|        response_model_exclude_unset: Annotated[
  2297|         0|            0|            0|  0.00%|            bool,
  2298|         0|            0|            0|  0.00%|            Doc(
  2299|         0|            0|            0|  0.00%|                """
  2300|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response data
  2301|         0|            0|            0|  0.00%|                should have all the fields, including the ones that were not set and
  2302|         0|            0|            0|  0.00%|                have their default values. This is different from
  2303|         0|            0|            0|  0.00%|                `response_model_exclude_defaults` in that if the fields are set,
  2304|         0|            0|            0|  0.00%|                they will be included in the response, even if the value is the same
  2305|         0|            0|            0|  0.00%|                as the default.
  2306|         0|            0|            0|  0.00%|
  2307|         0|            0|            0|  0.00%|                When `True`, default values are omitted from the response.
  2308|         0|            0|            0|  0.00%|
  2309|         0|            0|            0|  0.00%|                Read more about it in the
  2310|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
  2311|         0|            0|            0|  0.00%|                """
  2312|         0|            0|            0|  0.00%|            ),
  2313|         0|            0|            0|  0.00%|        ] = False,
  2314|         0|            0|            0|  0.00%|        response_model_exclude_defaults: Annotated[
  2315|         0|            0|            0|  0.00%|            bool,
  2316|         0|            0|            0|  0.00%|            Doc(
  2317|         0|            0|            0|  0.00%|                """
  2318|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response data
  2319|         0|            0|            0|  0.00%|                should have all the fields, including the ones that have the same value
  2320|         0|            0|            0|  0.00%|                as the default. This is different from `response_model_exclude_unset`
  2321|         0|            0|            0|  0.00%|                in that if the fields are set but contain the same default values,
  2322|         0|            0|            0|  0.00%|                they will be excluded from the response.
  2323|         0|            0|            0|  0.00%|
  2324|         0|            0|            0|  0.00%|                When `True`, default values are omitted from the response.
  2325|         0|            0|            0|  0.00%|
  2326|         0|            0|            0|  0.00%|                Read more about it in the
  2327|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
  2328|         0|            0|            0|  0.00%|                """
  2329|         0|            0|            0|  0.00%|            ),
  2330|         0|            0|            0|  0.00%|        ] = False,
  2331|         0|            0|            0|  0.00%|        response_model_exclude_none: Annotated[
  2332|         0|            0|            0|  0.00%|            bool,
  2333|         0|            0|            0|  0.00%|            Doc(
  2334|         0|            0|            0|  0.00%|                """
  2335|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response data should
  2336|         0|            0|            0|  0.00%|                exclude fields set to `None`.
  2337|         0|            0|            0|  0.00%|
  2338|         0|            0|            0|  0.00%|                This is much simpler (less smart) than `response_model_exclude_unset`
  2339|         0|            0|            0|  0.00%|                and `response_model_exclude_defaults`. You probably want to use one of
  2340|         0|            0|            0|  0.00%|                those two instead of this one, as those allow returning `None` values
  2341|         0|            0|            0|  0.00%|                when it makes sense.
  2342|         0|            0|            0|  0.00%|
  2343|         0|            0|            0|  0.00%|                Read more about it in the
  2344|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
  2345|         0|            0|            0|  0.00%|                """
  2346|         0|            0|            0|  0.00%|            ),
  2347|         0|            0|            0|  0.00%|        ] = False,
  2348|         0|            0|            0|  0.00%|        include_in_schema: Annotated[
  2349|         0|            0|            0|  0.00%|            bool,
  2350|         0|            0|            0|  0.00%|            Doc(
  2351|         0|            0|            0|  0.00%|                """
  2352|         0|            0|            0|  0.00%|                Include this *path operation* in the generated OpenAPI schema.
  2353|         0|            0|            0|  0.00%|
  2354|         0|            0|            0|  0.00%|                This affects the generated OpenAPI (e.g. visible at `/docs`).
  2355|         0|            0|            0|  0.00%|
  2356|         0|            0|            0|  0.00%|                Read more about it in the
  2357|         0|            0|            0|  0.00%|                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).
  2358|         0|            0|            0|  0.00%|                """
  2359|         0|            0|            0|  0.00%|            ),
  2360|         0|            0|            0|  0.00%|        ] = True,
  2361|         0|            0|            0|  0.00%|        response_class: Annotated[
  2362|         0|            0|            0|  0.00%|            Type[Response],
  2363|         0|            0|            0|  0.00%|            Doc(
  2364|         0|            0|            0|  0.00%|                """
  2365|         0|            0|            0|  0.00%|                Response class to be used for this *path operation*.
  2366|         0|            0|            0|  0.00%|
  2367|         0|            0|            0|  0.00%|                This will not be used if you return a response directly.
  2368|         0|            0|            0|  0.00%|
  2369|         0|            0|            0|  0.00%|                Read more about it in the
  2370|         0|            0|            0|  0.00%|                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
  2371|         0|            0|            0|  0.00%|                """
  2372|         0|            0|            0|  0.00%|            ),
  2373|         0|            0|            0|  0.00%|        ] = Default(JSONResponse),
  2374|         0|            0|            0|  0.00%|        name: Annotated[
  2375|         0|            0|            0|  0.00%|            Optional[str],
  2376|         0|            0|            0|  0.00%|            Doc(
  2377|         0|            0|            0|  0.00%|                """
  2378|         0|            0|            0|  0.00%|                Name for this *path operation*. Only used internally.
  2379|         0|            0|            0|  0.00%|                """
  2380|         0|            0|            0|  0.00%|            ),
  2381|         0|            0|            0|  0.00%|        ] = None,
  2382|         0|            0|            0|  0.00%|        callbacks: Annotated[
  2383|         0|            0|            0|  0.00%|            Optional[List[BaseRoute]],
  2384|         0|            0|            0|  0.00%|            Doc(
  2385|         0|            0|            0|  0.00%|                """
  2386|         0|            0|            0|  0.00%|                List of *path operations* that will be used as OpenAPI callbacks.
  2387|         0|            0|            0|  0.00%|
  2388|         0|            0|            0|  0.00%|                This is only for OpenAPI documentation, the callbacks won't be used
  2389|         0|            0|            0|  0.00%|                directly.
  2390|         0|            0|            0|  0.00%|
  2391|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  2392|         0|            0|            0|  0.00%|
  2393|         0|            0|            0|  0.00%|                Read more about it in the
  2394|         0|            0|            0|  0.00%|                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
  2395|         0|            0|            0|  0.00%|                """
  2396|         0|            0|            0|  0.00%|            ),
  2397|         0|            0|            0|  0.00%|        ] = None,
  2398|         0|            0|            0|  0.00%|        openapi_extra: Annotated[
  2399|         0|            0|            0|  0.00%|            Optional[Dict[str, Any]],
  2400|         0|            0|            0|  0.00%|            Doc(
  2401|         0|            0|            0|  0.00%|                """
  2402|         0|            0|            0|  0.00%|                Extra metadata to be included in the OpenAPI schema for this *path
  2403|         0|            0|            0|  0.00%|                operation*.
  2404|         0|            0|            0|  0.00%|
  2405|         0|            0|            0|  0.00%|                Read more about it in the
  2406|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
  2407|         0|            0|            0|  0.00%|                """
  2408|         0|            0|            0|  0.00%|            ),
  2409|         0|            0|            0|  0.00%|        ] = None,
  2410|         0|            0|            0|  0.00%|        generate_unique_id_function: Annotated[
  2411|         0|            0|            0|  0.00%|            Callable[[APIRoute], str],
  2412|         0|            0|            0|  0.00%|            Doc(
  2413|         0|            0|            0|  0.00%|                """
  2414|         0|            0|            0|  0.00%|                Customize the function used to generate unique IDs for the *path
  2415|         0|            0|            0|  0.00%|                operations* shown in the generated OpenAPI.
  2416|         0|            0|            0|  0.00%|
  2417|         0|            0|            0|  0.00%|                This is particularly useful when automatically generating clients or
  2418|         0|            0|            0|  0.00%|                SDKs for your API.
  2419|         0|            0|            0|  0.00%|
  2420|         0|            0|            0|  0.00%|                Read more about it in the
  2421|         0|            0|            0|  0.00%|                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
  2422|         0|            0|            0|  0.00%|                """
  2423|         0|            0|            0|  0.00%|            ),
  2424|         0|            0|            0|  0.00%|        ] = Default(generate_unique_id),
  2425|         0|            0|            0|  0.00%|    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
  2426|         0|            0|            0|  0.00%|        """
  2427|         0|            0|            0|  0.00%|        Add a *path operation* using an HTTP POST operation.
  2428|         0|            0|            0|  0.00%|
  2429|         0|            0|            0|  0.00%|        ## Example
  2430|         0|            0|            0|  0.00%|
  2431|         0|            0|            0|  0.00%|        ```python
  2432|         0|            0|            0|  0.00%|        from fastapi import APIRouter, FastAPI
  2433|         0|            0|            0|  0.00%|        from pydantic import BaseModel
  2434|         0|            0|            0|  0.00%|
  2435|         0|            0|            0|  0.00%|        class Item(BaseModel):
  2436|         0|            0|            0|  0.00%|            name: str
  2437|         0|            0|            0|  0.00%|            description: str | None = None
  2438|         0|            0|            0|  0.00%|
  2439|         0|            0|            0|  0.00%|        app = FastAPI()
  2440|         0|            0|            0|  0.00%|        router = APIRouter()
  2441|         0|            0|            0|  0.00%|
  2442|         0|            0|            0|  0.00%|        @router.post("/items/")
  2443|         0|            0|            0|  0.00%|        def create_item(item: Item):
  2444|         0|            0|            0|  0.00%|            return {"message": "Item created"}
  2445|         0|            0|            0|  0.00%|
  2446|         0|            0|            0|  0.00%|        app.include_router(router)
  2447|         0|            0|            0|  0.00%|        ```
  2448|         0|            0|            0|  0.00%|        """
  2449|         0|            0|            0|  0.00%|        return self.api_route(
  2450|         0|            0|            0|  0.00%|            path=path,
  2451|         0|            0|            0|  0.00%|            response_model=response_model,
  2452|         0|            0|            0|  0.00%|            status_code=status_code,
  2453|         0|            0|            0|  0.00%|            tags=tags,
  2454|         0|            0|            0|  0.00%|            dependencies=dependencies,
  2455|         0|            0|            0|  0.00%|            summary=summary,
  2456|         0|            0|            0|  0.00%|            description=description,
  2457|         0|            0|            0|  0.00%|            response_description=response_description,
  2458|         0|            0|            0|  0.00%|            responses=responses,
  2459|         0|            0|            0|  0.00%|            deprecated=deprecated,
  2460|         0|            0|            0|  0.00%|            methods=["POST"],
  2461|         0|            0|            0|  0.00%|            operation_id=operation_id,
  2462|         0|            0|            0|  0.00%|            response_model_include=response_model_include,
  2463|         0|            0|            0|  0.00%|            response_model_exclude=response_model_exclude,
  2464|         0|            0|            0|  0.00%|            response_model_by_alias=response_model_by_alias,
  2465|         0|            0|            0|  0.00%|            response_model_exclude_unset=response_model_exclude_unset,
  2466|         0|            0|            0|  0.00%|            response_model_exclude_defaults=response_model_exclude_defaults,
  2467|         0|            0|            0|  0.00%|            response_model_exclude_none=response_model_exclude_none,
  2468|         0|            0|            0|  0.00%|            include_in_schema=include_in_schema,
  2469|         0|            0|            0|  0.00%|            response_class=response_class,
  2470|         0|            0|            0|  0.00%|            name=name,
  2471|         0|            0|            0|  0.00%|            callbacks=callbacks,
  2472|         0|            0|            0|  0.00%|            openapi_extra=openapi_extra,
  2473|         0|            0|            0|  0.00%|            generate_unique_id_function=generate_unique_id_function,
  2474|         0|            0|            0|  0.00%|        )
  2475|         0|            0|            0|  0.00%|
  2476|         0|            0|            0|  0.00%|    def delete(
  2477|         0|            0|            0|  0.00%|        self,
  2478|         0|            0|            0|  0.00%|        path: Annotated[
  2479|         0|            0|            0|  0.00%|            str,
  2480|         0|            0|            0|  0.00%|            Doc(
  2481|         0|            0|            0|  0.00%|                """
  2482|         0|            0|            0|  0.00%|                The URL path to be used for this *path operation*.
  2483|         0|            0|            0|  0.00%|
  2484|         0|            0|            0|  0.00%|                For example, in `http://example.com/items`, the path is `/items`.
  2485|         0|            0|            0|  0.00%|                """
  2486|         0|            0|            0|  0.00%|            ),
  2487|         0|            0|            0|  0.00%|        ],
  2488|         0|            0|            0|  0.00%|        *,
  2489|         0|            0|            0|  0.00%|        response_model: Annotated[
  2490|         0|            0|            0|  0.00%|            Any,
  2491|         0|            0|            0|  0.00%|            Doc(
  2492|         0|            0|            0|  0.00%|                """
  2493|         0|            0|            0|  0.00%|                The type to use for the response.
  2494|         0|            0|            0|  0.00%|
  2495|         0|            0|            0|  0.00%|                It could be any valid Pydantic *field* type. So, it doesn't have to
  2496|         0|            0|            0|  0.00%|                be a Pydantic model, it could be other things, like a `list`, `dict`,
  2497|         0|            0|            0|  0.00%|                etc.
  2498|         0|            0|            0|  0.00%|
  2499|         0|            0|            0|  0.00%|                It will be used for:
  2500|         0|            0|            0|  0.00%|
  2501|         0|            0|            0|  0.00%|                * Documentation: the generated OpenAPI (and the UI at `/docs`) will
  2502|         0|            0|            0|  0.00%|                    show it as the response (JSON Schema).
  2503|         0|            0|            0|  0.00%|                * Serialization: you could return an arbitrary object and the
  2504|         0|            0|            0|  0.00%|                    `response_model` would be used to serialize that object into the
  2505|         0|            0|            0|  0.00%|                    corresponding JSON.
  2506|         0|            0|            0|  0.00%|                * Filtering: the JSON sent to the client will only contain the data
  2507|         0|            0|            0|  0.00%|                    (fields) defined in the `response_model`. If you returned an object
  2508|         0|            0|            0|  0.00%|                    that contains an attribute `password` but the `response_model` does
  2509|         0|            0|            0|  0.00%|                    not include that field, the JSON sent to the client would not have
  2510|         0|            0|            0|  0.00%|                    that `password`.
  2511|         0|            0|            0|  0.00%|                * Validation: whatever you return will be serialized with the
  2512|         0|            0|            0|  0.00%|                    `response_model`, converting any data as necessary to generate the
  2513|         0|            0|            0|  0.00%|                    corresponding JSON. But if the data in the object returned is not
  2514|         0|            0|            0|  0.00%|                    valid, that would mean a violation of the contract with the client,
  2515|         0|            0|            0|  0.00%|                    so it's an error from the API developer. So, FastAPI will raise an
  2516|         0|            0|            0|  0.00%|                    error and return a 500 error code (Internal Server Error).
  2517|         0|            0|            0|  0.00%|
  2518|         0|            0|            0|  0.00%|                Read more about it in the
  2519|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
  2520|         0|            0|            0|  0.00%|                """
  2521|         0|            0|            0|  0.00%|            ),
  2522|         0|            0|            0|  0.00%|        ] = Default(None),
  2523|         0|            0|            0|  0.00%|        status_code: Annotated[
  2524|         0|            0|            0|  0.00%|            Optional[int],
  2525|         0|            0|            0|  0.00%|            Doc(
  2526|         0|            0|            0|  0.00%|                """
  2527|         0|            0|            0|  0.00%|                The default status code to be used for the response.
  2528|         0|            0|            0|  0.00%|
  2529|         0|            0|            0|  0.00%|                You could override the status code by returning a response directly.
  2530|         0|            0|            0|  0.00%|
  2531|         0|            0|            0|  0.00%|                Read more about it in the
  2532|         0|            0|            0|  0.00%|                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
  2533|         0|            0|            0|  0.00%|                """
  2534|         0|            0|            0|  0.00%|            ),
  2535|         0|            0|            0|  0.00%|        ] = None,
  2536|         0|            0|            0|  0.00%|        tags: Annotated[
  2537|         0|            0|            0|  0.00%|            Optional[List[Union[str, Enum]]],
  2538|         0|            0|            0|  0.00%|            Doc(
  2539|         0|            0|            0|  0.00%|                """
  2540|         0|            0|            0|  0.00%|                A list of tags to be applied to the *path operation*.
  2541|         0|            0|            0|  0.00%|
  2542|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  2543|         0|            0|            0|  0.00%|
  2544|         0|            0|            0|  0.00%|                Read more about it in the
  2545|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
  2546|         0|            0|            0|  0.00%|                """
  2547|         0|            0|            0|  0.00%|            ),
  2548|         0|            0|            0|  0.00%|        ] = None,
  2549|         0|            0|            0|  0.00%|        dependencies: Annotated[
  2550|         0|            0|            0|  0.00%|            Optional[Sequence[params.Depends]],
  2551|         0|            0|            0|  0.00%|            Doc(
  2552|         0|            0|            0|  0.00%|                """
  2553|         0|            0|            0|  0.00%|                A list of dependencies (using `Depends()`) to be applied to the
  2554|         0|            0|            0|  0.00%|                *path operation*.
  2555|         0|            0|            0|  0.00%|
  2556|         0|            0|            0|  0.00%|                Read more about it in the
  2557|         0|            0|            0|  0.00%|                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
  2558|         0|            0|            0|  0.00%|                """
  2559|         0|            0|            0|  0.00%|            ),
  2560|         0|            0|            0|  0.00%|        ] = None,
  2561|         0|            0|            0|  0.00%|        summary: Annotated[
  2562|         0|            0|            0|  0.00%|            Optional[str],
  2563|         0|            0|            0|  0.00%|            Doc(
  2564|         0|            0|            0|  0.00%|                """
  2565|         0|            0|            0|  0.00%|                A summary for the *path operation*.
  2566|         0|            0|            0|  0.00%|
  2567|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  2568|         0|            0|            0|  0.00%|
  2569|         0|            0|            0|  0.00%|                Read more about it in the
  2570|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
  2571|         0|            0|            0|  0.00%|                """
  2572|         0|            0|            0|  0.00%|            ),
  2573|         0|            0|            0|  0.00%|        ] = None,
  2574|         0|            0|            0|  0.00%|        description: Annotated[
  2575|         0|            0|            0|  0.00%|            Optional[str],
  2576|         0|            0|            0|  0.00%|            Doc(
  2577|         0|            0|            0|  0.00%|                """
  2578|         0|            0|            0|  0.00%|                A description for the *path operation*.
  2579|         0|            0|            0|  0.00%|
  2580|         0|            0|            0|  0.00%|                If not provided, it will be extracted automatically from the docstring
  2581|         0|            0|            0|  0.00%|                of the *path operation function*.
  2582|         0|            0|            0|  0.00%|
  2583|         0|            0|            0|  0.00%|                It can contain Markdown.
  2584|         0|            0|            0|  0.00%|
  2585|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  2586|         0|            0|            0|  0.00%|
  2587|         0|            0|            0|  0.00%|                Read more about it in the
  2588|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
  2589|         0|            0|            0|  0.00%|                """
  2590|         0|            0|            0|  0.00%|            ),
  2591|         0|            0|            0|  0.00%|        ] = None,
  2592|         0|            0|            0|  0.00%|        response_description: Annotated[
  2593|         0|            0|            0|  0.00%|            str,
  2594|         0|            0|            0|  0.00%|            Doc(
  2595|         0|            0|            0|  0.00%|                """
  2596|         0|            0|            0|  0.00%|                The description for the default response.
  2597|         0|            0|            0|  0.00%|
  2598|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  2599|         0|            0|            0|  0.00%|                """
  2600|         0|            0|            0|  0.00%|            ),
  2601|         0|            0|            0|  0.00%|        ] = "Successful Response",
  2602|         0|            0|            0|  0.00%|        responses: Annotated[
  2603|         0|            0|            0|  0.00%|            Optional[Dict[Union[int, str], Dict[str, Any]]],
  2604|         0|            0|            0|  0.00%|            Doc(
  2605|         0|            0|            0|  0.00%|                """
  2606|         0|            0|            0|  0.00%|                Additional responses that could be returned by this *path operation*.
  2607|         0|            0|            0|  0.00%|
  2608|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  2609|         0|            0|            0|  0.00%|                """
  2610|         0|            0|            0|  0.00%|            ),
  2611|         0|            0|            0|  0.00%|        ] = None,
  2612|         0|            0|            0|  0.00%|        deprecated: Annotated[
  2613|         0|            0|            0|  0.00%|            Optional[bool],
  2614|         0|            0|            0|  0.00%|            Doc(
  2615|         0|            0|            0|  0.00%|                """
  2616|         0|            0|            0|  0.00%|                Mark this *path operation* as deprecated.
  2617|         0|            0|            0|  0.00%|
  2618|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  2619|         0|            0|            0|  0.00%|                """
  2620|         0|            0|            0|  0.00%|            ),
  2621|         0|            0|            0|  0.00%|        ] = None,
  2622|         0|            0|            0|  0.00%|        operation_id: Annotated[
  2623|         0|            0|            0|  0.00%|            Optional[str],
  2624|         0|            0|            0|  0.00%|            Doc(
  2625|         0|            0|            0|  0.00%|                """
  2626|         0|            0|            0|  0.00%|                Custom operation ID to be used by this *path operation*.
  2627|         0|            0|            0|  0.00%|
  2628|         0|            0|            0|  0.00%|                By default, it is generated automatically.
  2629|         0|            0|            0|  0.00%|
  2630|         0|            0|            0|  0.00%|                If you provide a custom operation ID, you need to make sure it is
  2631|         0|            0|            0|  0.00%|                unique for the whole API.
  2632|         0|            0|            0|  0.00%|
  2633|         0|            0|            0|  0.00%|                You can customize the
  2634|         0|            0|            0|  0.00%|                operation ID generation with the parameter
  2635|         0|            0|            0|  0.00%|                `generate_unique_id_function` in the `FastAPI` class.
  2636|         0|            0|            0|  0.00%|
  2637|         0|            0|            0|  0.00%|                Read more about it in the
  2638|         0|            0|            0|  0.00%|                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
  2639|         0|            0|            0|  0.00%|                """
  2640|         0|            0|            0|  0.00%|            ),
  2641|         0|            0|            0|  0.00%|        ] = None,
  2642|         0|            0|            0|  0.00%|        response_model_include: Annotated[
  2643|         0|            0|            0|  0.00%|            Optional[IncEx],
  2644|         0|            0|            0|  0.00%|            Doc(
  2645|         0|            0|            0|  0.00%|                """
  2646|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to include only certain fields in the
  2647|         0|            0|            0|  0.00%|                response data.
  2648|         0|            0|            0|  0.00%|
  2649|         0|            0|            0|  0.00%|                Read more about it in the
  2650|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
  2651|         0|            0|            0|  0.00%|                """
  2652|         0|            0|            0|  0.00%|            ),
  2653|         0|            0|            0|  0.00%|        ] = None,
  2654|         0|            0|            0|  0.00%|        response_model_exclude: Annotated[
  2655|         0|            0|            0|  0.00%|            Optional[IncEx],
  2656|         0|            0|            0|  0.00%|            Doc(
  2657|         0|            0|            0|  0.00%|                """
  2658|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to exclude certain fields in the
  2659|         0|            0|            0|  0.00%|                response data.
  2660|         0|            0|            0|  0.00%|
  2661|         0|            0|            0|  0.00%|                Read more about it in the
  2662|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
  2663|         0|            0|            0|  0.00%|                """
  2664|         0|            0|            0|  0.00%|            ),
  2665|         0|            0|            0|  0.00%|        ] = None,
  2666|         0|            0|            0|  0.00%|        response_model_by_alias: Annotated[
  2667|         0|            0|            0|  0.00%|            bool,
  2668|         0|            0|            0|  0.00%|            Doc(
  2669|         0|            0|            0|  0.00%|                """
  2670|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response model
  2671|         0|            0|            0|  0.00%|                should be serialized by alias when an alias is used.
  2672|         0|            0|            0|  0.00%|
  2673|         0|            0|            0|  0.00%|                Read more about it in the
  2674|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
  2675|         0|            0|            0|  0.00%|                """
  2676|         0|            0|            0|  0.00%|            ),
  2677|         0|            0|            0|  0.00%|        ] = True,
  2678|         0|            0|            0|  0.00%|        response_model_exclude_unset: Annotated[
  2679|         0|            0|            0|  0.00%|            bool,
  2680|         0|            0|            0|  0.00%|            Doc(
  2681|         0|            0|            0|  0.00%|                """
  2682|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response data
  2683|         0|            0|            0|  0.00%|                should have all the fields, including the ones that were not set and
  2684|         0|            0|            0|  0.00%|                have their default values. This is different from
  2685|         0|            0|            0|  0.00%|                `response_model_exclude_defaults` in that if the fields are set,
  2686|         0|            0|            0|  0.00%|                they will be included in the response, even if the value is the same
  2687|         0|            0|            0|  0.00%|                as the default.
  2688|         0|            0|            0|  0.00%|
  2689|         0|            0|            0|  0.00%|                When `True`, default values are omitted from the response.
  2690|         0|            0|            0|  0.00%|
  2691|         0|            0|            0|  0.00%|                Read more about it in the
  2692|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
  2693|         0|            0|            0|  0.00%|                """
  2694|         0|            0|            0|  0.00%|            ),
  2695|         0|            0|            0|  0.00%|        ] = False,
  2696|         0|            0|            0|  0.00%|        response_model_exclude_defaults: Annotated[
  2697|         0|            0|            0|  0.00%|            bool,
  2698|         0|            0|            0|  0.00%|            Doc(
  2699|         0|            0|            0|  0.00%|                """
  2700|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response data
  2701|         0|            0|            0|  0.00%|                should have all the fields, including the ones that have the same value
  2702|         0|            0|            0|  0.00%|                as the default. This is different from `response_model_exclude_unset`
  2703|         0|            0|            0|  0.00%|                in that if the fields are set but contain the same default values,
  2704|         0|            0|            0|  0.00%|                they will be excluded from the response.
  2705|         0|            0|            0|  0.00%|
  2706|         0|            0|            0|  0.00%|                When `True`, default values are omitted from the response.
  2707|         0|            0|            0|  0.00%|
  2708|         0|            0|            0|  0.00%|                Read more about it in the
  2709|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
  2710|         0|            0|            0|  0.00%|                """
  2711|         0|            0|            0|  0.00%|            ),
  2712|         0|            0|            0|  0.00%|        ] = False,
  2713|         0|            0|            0|  0.00%|        response_model_exclude_none: Annotated[
  2714|         0|            0|            0|  0.00%|            bool,
  2715|         0|            0|            0|  0.00%|            Doc(
  2716|         0|            0|            0|  0.00%|                """
  2717|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response data should
  2718|         0|            0|            0|  0.00%|                exclude fields set to `None`.
  2719|         0|            0|            0|  0.00%|
  2720|         0|            0|            0|  0.00%|                This is much simpler (less smart) than `response_model_exclude_unset`
  2721|         0|            0|            0|  0.00%|                and `response_model_exclude_defaults`. You probably want to use one of
  2722|         0|            0|            0|  0.00%|                those two instead of this one, as those allow returning `None` values
  2723|         0|            0|            0|  0.00%|                when it makes sense.
  2724|         0|            0|            0|  0.00%|
  2725|         0|            0|            0|  0.00%|                Read more about it in the
  2726|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
  2727|         0|            0|            0|  0.00%|                """
  2728|         0|            0|            0|  0.00%|            ),
  2729|         0|            0|            0|  0.00%|        ] = False,
  2730|         0|            0|            0|  0.00%|        include_in_schema: Annotated[
  2731|         0|            0|            0|  0.00%|            bool,
  2732|         0|            0|            0|  0.00%|            Doc(
  2733|         0|            0|            0|  0.00%|                """
  2734|         0|            0|            0|  0.00%|                Include this *path operation* in the generated OpenAPI schema.
  2735|         0|            0|            0|  0.00%|
  2736|         0|            0|            0|  0.00%|                This affects the generated OpenAPI (e.g. visible at `/docs`).
  2737|         0|            0|            0|  0.00%|
  2738|         0|            0|            0|  0.00%|                Read more about it in the
  2739|         0|            0|            0|  0.00%|                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).
  2740|         0|            0|            0|  0.00%|                """
  2741|         0|            0|            0|  0.00%|            ),
  2742|         0|            0|            0|  0.00%|        ] = True,
  2743|         0|            0|            0|  0.00%|        response_class: Annotated[
  2744|         0|            0|            0|  0.00%|            Type[Response],
  2745|         0|            0|            0|  0.00%|            Doc(
  2746|         0|            0|            0|  0.00%|                """
  2747|         0|            0|            0|  0.00%|                Response class to be used for this *path operation*.
  2748|         0|            0|            0|  0.00%|
  2749|         0|            0|            0|  0.00%|                This will not be used if you return a response directly.
  2750|         0|            0|            0|  0.00%|
  2751|         0|            0|            0|  0.00%|                Read more about it in the
  2752|         0|            0|            0|  0.00%|                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
  2753|         0|            0|            0|  0.00%|                """
  2754|         0|            0|            0|  0.00%|            ),
  2755|         0|            0|            0|  0.00%|        ] = Default(JSONResponse),
  2756|         0|            0|            0|  0.00%|        name: Annotated[
  2757|         0|            0|            0|  0.00%|            Optional[str],
  2758|         0|            0|            0|  0.00%|            Doc(
  2759|         0|            0|            0|  0.00%|                """
  2760|         0|            0|            0|  0.00%|                Name for this *path operation*. Only used internally.
  2761|         0|            0|            0|  0.00%|                """
  2762|         0|            0|            0|  0.00%|            ),
  2763|         0|            0|            0|  0.00%|        ] = None,
  2764|         0|            0|            0|  0.00%|        callbacks: Annotated[
  2765|         0|            0|            0|  0.00%|            Optional[List[BaseRoute]],
  2766|         0|            0|            0|  0.00%|            Doc(
  2767|         0|            0|            0|  0.00%|                """
  2768|         0|            0|            0|  0.00%|                List of *path operations* that will be used as OpenAPI callbacks.
  2769|         0|            0|            0|  0.00%|
  2770|         0|            0|            0|  0.00%|                This is only for OpenAPI documentation, the callbacks won't be used
  2771|         0|            0|            0|  0.00%|                directly.
  2772|         0|            0|            0|  0.00%|
  2773|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  2774|         0|            0|            0|  0.00%|
  2775|         0|            0|            0|  0.00%|                Read more about it in the
  2776|         0|            0|            0|  0.00%|                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
  2777|         0|            0|            0|  0.00%|                """
  2778|         0|            0|            0|  0.00%|            ),
  2779|         0|            0|            0|  0.00%|        ] = None,
  2780|         0|            0|            0|  0.00%|        openapi_extra: Annotated[
  2781|         0|            0|            0|  0.00%|            Optional[Dict[str, Any]],
  2782|         0|            0|            0|  0.00%|            Doc(
  2783|         0|            0|            0|  0.00%|                """
  2784|         0|            0|            0|  0.00%|                Extra metadata to be included in the OpenAPI schema for this *path
  2785|         0|            0|            0|  0.00%|                operation*.
  2786|         0|            0|            0|  0.00%|
  2787|         0|            0|            0|  0.00%|                Read more about it in the
  2788|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
  2789|         0|            0|            0|  0.00%|                """
  2790|         0|            0|            0|  0.00%|            ),
  2791|         0|            0|            0|  0.00%|        ] = None,
  2792|         0|            0|            0|  0.00%|        generate_unique_id_function: Annotated[
  2793|         0|            0|            0|  0.00%|            Callable[[APIRoute], str],
  2794|         0|            0|            0|  0.00%|            Doc(
  2795|         0|            0|            0|  0.00%|                """
  2796|         0|            0|            0|  0.00%|                Customize the function used to generate unique IDs for the *path
  2797|         0|            0|            0|  0.00%|                operations* shown in the generated OpenAPI.
  2798|         0|            0|            0|  0.00%|
  2799|         0|            0|            0|  0.00%|                This is particularly useful when automatically generating clients or
  2800|         0|            0|            0|  0.00%|                SDKs for your API.
  2801|         0|            0|            0|  0.00%|
  2802|         0|            0|            0|  0.00%|                Read more about it in the
  2803|         0|            0|            0|  0.00%|                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
  2804|         0|            0|            0|  0.00%|                """
  2805|         0|            0|            0|  0.00%|            ),
  2806|         0|            0|            0|  0.00%|        ] = Default(generate_unique_id),
  2807|         0|            0|            0|  0.00%|    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
  2808|         0|            0|            0|  0.00%|        """
  2809|         0|            0|            0|  0.00%|        Add a *path operation* using an HTTP DELETE operation.
  2810|         0|            0|            0|  0.00%|
  2811|         0|            0|            0|  0.00%|        ## Example
  2812|         0|            0|            0|  0.00%|
  2813|         0|            0|            0|  0.00%|        ```python
  2814|         0|            0|            0|  0.00%|        from fastapi import APIRouter, FastAPI
  2815|         0|            0|            0|  0.00%|
  2816|         0|            0|            0|  0.00%|        app = FastAPI()
  2817|         0|            0|            0|  0.00%|        router = APIRouter()
  2818|         0|            0|            0|  0.00%|
  2819|         0|            0|            0|  0.00%|        @router.delete("/items/{item_id}")
  2820|         0|            0|            0|  0.00%|        def delete_item(item_id: str):
  2821|         0|            0|            0|  0.00%|            return {"message": "Item deleted"}
  2822|         0|            0|            0|  0.00%|
  2823|         0|            0|            0|  0.00%|        app.include_router(router)
  2824|         0|            0|            0|  0.00%|        ```
  2825|         0|            0|            0|  0.00%|        """
  2826|         0|            0|            0|  0.00%|        return self.api_route(
  2827|         0|            0|            0|  0.00%|            path=path,
  2828|         0|            0|            0|  0.00%|            response_model=response_model,
  2829|         0|            0|            0|  0.00%|            status_code=status_code,
  2830|         0|            0|            0|  0.00%|            tags=tags,
  2831|         0|            0|            0|  0.00%|            dependencies=dependencies,
  2832|         0|            0|            0|  0.00%|            summary=summary,
  2833|         0|            0|            0|  0.00%|            description=description,
  2834|         0|            0|            0|  0.00%|            response_description=response_description,
  2835|         0|            0|            0|  0.00%|            responses=responses,
  2836|         0|            0|            0|  0.00%|            deprecated=deprecated,
  2837|         0|            0|            0|  0.00%|            methods=["DELETE"],
  2838|         0|            0|            0|  0.00%|            operation_id=operation_id,
  2839|         0|            0|            0|  0.00%|            response_model_include=response_model_include,
  2840|         0|            0|            0|  0.00%|            response_model_exclude=response_model_exclude,
  2841|         0|            0|            0|  0.00%|            response_model_by_alias=response_model_by_alias,
  2842|         0|            0|            0|  0.00%|            response_model_exclude_unset=response_model_exclude_unset,
  2843|         0|            0|            0|  0.00%|            response_model_exclude_defaults=response_model_exclude_defaults,
  2844|         0|            0|            0|  0.00%|            response_model_exclude_none=response_model_exclude_none,
  2845|         0|            0|            0|  0.00%|            include_in_schema=include_in_schema,
  2846|         0|            0|            0|  0.00%|            response_class=response_class,
  2847|         0|            0|            0|  0.00%|            name=name,
  2848|         0|            0|            0|  0.00%|            callbacks=callbacks,
  2849|         0|            0|            0|  0.00%|            openapi_extra=openapi_extra,
  2850|         0|            0|            0|  0.00%|            generate_unique_id_function=generate_unique_id_function,
  2851|         0|            0|            0|  0.00%|        )
  2852|         0|            0|            0|  0.00%|
  2853|         0|            0|            0|  0.00%|    def options(
  2854|         0|            0|            0|  0.00%|        self,
  2855|         0|            0|            0|  0.00%|        path: Annotated[
  2856|         0|            0|            0|  0.00%|            str,
  2857|         0|            0|            0|  0.00%|            Doc(
  2858|         0|            0|            0|  0.00%|                """
  2859|         0|            0|            0|  0.00%|                The URL path to be used for this *path operation*.
  2860|         0|            0|            0|  0.00%|
  2861|         0|            0|            0|  0.00%|                For example, in `http://example.com/items`, the path is `/items`.
  2862|         0|            0|            0|  0.00%|                """
  2863|         0|            0|            0|  0.00%|            ),
  2864|         0|            0|            0|  0.00%|        ],
  2865|         0|            0|            0|  0.00%|        *,
  2866|         0|            0|            0|  0.00%|        response_model: Annotated[
  2867|         0|            0|            0|  0.00%|            Any,
  2868|         0|            0|            0|  0.00%|            Doc(
  2869|         0|            0|            0|  0.00%|                """
  2870|         0|            0|            0|  0.00%|                The type to use for the response.
  2871|         0|            0|            0|  0.00%|
  2872|         0|            0|            0|  0.00%|                It could be any valid Pydantic *field* type. So, it doesn't have to
  2873|         0|            0|            0|  0.00%|                be a Pydantic model, it could be other things, like a `list`, `dict`,
  2874|         0|            0|            0|  0.00%|                etc.
  2875|         0|            0|            0|  0.00%|
  2876|         0|            0|            0|  0.00%|                It will be used for:
  2877|         0|            0|            0|  0.00%|
  2878|         0|            0|            0|  0.00%|                * Documentation: the generated OpenAPI (and the UI at `/docs`) will
  2879|         0|            0|            0|  0.00%|                    show it as the response (JSON Schema).
  2880|         0|            0|            0|  0.00%|                * Serialization: you could return an arbitrary object and the
  2881|         0|            0|            0|  0.00%|                    `response_model` would be used to serialize that object into the
  2882|         0|            0|            0|  0.00%|                    corresponding JSON.
  2883|         0|            0|            0|  0.00%|                * Filtering: the JSON sent to the client will only contain the data
  2884|         0|            0|            0|  0.00%|                    (fields) defined in the `response_model`. If you returned an object
  2885|         0|            0|            0|  0.00%|                    that contains an attribute `password` but the `response_model` does
  2886|         0|            0|            0|  0.00%|                    not include that field, the JSON sent to the client would not have
  2887|         0|            0|            0|  0.00%|                    that `password`.
  2888|         0|            0|            0|  0.00%|                * Validation: whatever you return will be serialized with the
  2889|         0|            0|            0|  0.00%|                    `response_model`, converting any data as necessary to generate the
  2890|         0|            0|            0|  0.00%|                    corresponding JSON. But if the data in the object returned is not
  2891|         0|            0|            0|  0.00%|                    valid, that would mean a violation of the contract with the client,
  2892|         0|            0|            0|  0.00%|                    so it's an error from the API developer. So, FastAPI will raise an
  2893|         0|            0|            0|  0.00%|                    error and return a 500 error code (Internal Server Error).
  2894|         0|            0|            0|  0.00%|
  2895|         0|            0|            0|  0.00%|                Read more about it in the
  2896|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
  2897|         0|            0|            0|  0.00%|                """
  2898|         0|            0|            0|  0.00%|            ),
  2899|         0|            0|            0|  0.00%|        ] = Default(None),
  2900|         0|            0|            0|  0.00%|        status_code: Annotated[
  2901|         0|            0|            0|  0.00%|            Optional[int],
  2902|         0|            0|            0|  0.00%|            Doc(
  2903|         0|            0|            0|  0.00%|                """
  2904|         0|            0|            0|  0.00%|                The default status code to be used for the response.
  2905|         0|            0|            0|  0.00%|
  2906|         0|            0|            0|  0.00%|                You could override the status code by returning a response directly.
  2907|         0|            0|            0|  0.00%|
  2908|         0|            0|            0|  0.00%|                Read more about it in the
  2909|         0|            0|            0|  0.00%|                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
  2910|         0|            0|            0|  0.00%|                """
  2911|         0|            0|            0|  0.00%|            ),
  2912|         0|            0|            0|  0.00%|        ] = None,
  2913|         0|            0|            0|  0.00%|        tags: Annotated[
  2914|         0|            0|            0|  0.00%|            Optional[List[Union[str, Enum]]],
  2915|         0|            0|            0|  0.00%|            Doc(
  2916|         0|            0|            0|  0.00%|                """
  2917|         0|            0|            0|  0.00%|                A list of tags to be applied to the *path operation*.
  2918|         0|            0|            0|  0.00%|
  2919|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  2920|         0|            0|            0|  0.00%|
  2921|         0|            0|            0|  0.00%|                Read more about it in the
  2922|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
  2923|         0|            0|            0|  0.00%|                """
  2924|         0|            0|            0|  0.00%|            ),
  2925|         0|            0|            0|  0.00%|        ] = None,
  2926|         0|            0|            0|  0.00%|        dependencies: Annotated[
  2927|         0|            0|            0|  0.00%|            Optional[Sequence[params.Depends]],
  2928|         0|            0|            0|  0.00%|            Doc(
  2929|         0|            0|            0|  0.00%|                """
  2930|         0|            0|            0|  0.00%|                A list of dependencies (using `Depends()`) to be applied to the
  2931|         0|            0|            0|  0.00%|                *path operation*.
  2932|         0|            0|            0|  0.00%|
  2933|         0|            0|            0|  0.00%|                Read more about it in the
  2934|         0|            0|            0|  0.00%|                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
  2935|         0|            0|            0|  0.00%|                """
  2936|         0|            0|            0|  0.00%|            ),
  2937|         0|            0|            0|  0.00%|        ] = None,
  2938|         0|            0|            0|  0.00%|        summary: Annotated[
  2939|         0|            0|            0|  0.00%|            Optional[str],
  2940|         0|            0|            0|  0.00%|            Doc(
  2941|         0|            0|            0|  0.00%|                """
  2942|         0|            0|            0|  0.00%|                A summary for the *path operation*.
  2943|         0|            0|            0|  0.00%|
  2944|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  2945|         0|            0|            0|  0.00%|
  2946|         0|            0|            0|  0.00%|                Read more about it in the
  2947|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
  2948|         0|            0|            0|  0.00%|                """
  2949|         0|            0|            0|  0.00%|            ),
  2950|         0|            0|            0|  0.00%|        ] = None,
  2951|         0|            0|            0|  0.00%|        description: Annotated[
  2952|         0|            0|            0|  0.00%|            Optional[str],
  2953|         0|            0|            0|  0.00%|            Doc(
  2954|         0|            0|            0|  0.00%|                """
  2955|         0|            0|            0|  0.00%|                A description for the *path operation*.
  2956|         0|            0|            0|  0.00%|
  2957|         0|            0|            0|  0.00%|                If not provided, it will be extracted automatically from the docstring
  2958|         0|            0|            0|  0.00%|                of the *path operation function*.
  2959|         0|            0|            0|  0.00%|
  2960|         0|            0|            0|  0.00%|                It can contain Markdown.
  2961|         0|            0|            0|  0.00%|
  2962|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  2963|         0|            0|            0|  0.00%|
  2964|         0|            0|            0|  0.00%|                Read more about it in the
  2965|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
  2966|         0|            0|            0|  0.00%|                """
  2967|         0|            0|            0|  0.00%|            ),
  2968|         0|            0|            0|  0.00%|        ] = None,
  2969|         0|            0|            0|  0.00%|        response_description: Annotated[
  2970|         0|            0|            0|  0.00%|            str,
  2971|         0|            0|            0|  0.00%|            Doc(
  2972|         0|            0|            0|  0.00%|                """
  2973|         0|            0|            0|  0.00%|                The description for the default response.
  2974|         0|            0|            0|  0.00%|
  2975|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  2976|         0|            0|            0|  0.00%|                """
  2977|         0|            0|            0|  0.00%|            ),
  2978|         0|            0|            0|  0.00%|        ] = "Successful Response",
  2979|         0|            0|            0|  0.00%|        responses: Annotated[
  2980|         0|            0|            0|  0.00%|            Optional[Dict[Union[int, str], Dict[str, Any]]],
  2981|         0|            0|            0|  0.00%|            Doc(
  2982|         0|            0|            0|  0.00%|                """
  2983|         0|            0|            0|  0.00%|                Additional responses that could be returned by this *path operation*.
  2984|         0|            0|            0|  0.00%|
  2985|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  2986|         0|            0|            0|  0.00%|                """
  2987|         0|            0|            0|  0.00%|            ),
  2988|         0|            0|            0|  0.00%|        ] = None,
  2989|         0|            0|            0|  0.00%|        deprecated: Annotated[
  2990|         0|            0|            0|  0.00%|            Optional[bool],
  2991|         0|            0|            0|  0.00%|            Doc(
  2992|         0|            0|            0|  0.00%|                """
  2993|         0|            0|            0|  0.00%|                Mark this *path operation* as deprecated.
  2994|         0|            0|            0|  0.00%|
  2995|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  2996|         0|            0|            0|  0.00%|                """
  2997|         0|            0|            0|  0.00%|            ),
  2998|         0|            0|            0|  0.00%|        ] = None,
  2999|         0|            0|            0|  0.00%|        operation_id: Annotated[
  3000|         0|            0|            0|  0.00%|            Optional[str],
  3001|         0|            0|            0|  0.00%|            Doc(
  3002|         0|            0|            0|  0.00%|                """
  3003|         0|            0|            0|  0.00%|                Custom operation ID to be used by this *path operation*.
  3004|         0|            0|            0|  0.00%|
  3005|         0|            0|            0|  0.00%|                By default, it is generated automatically.
  3006|         0|            0|            0|  0.00%|
  3007|         0|            0|            0|  0.00%|                If you provide a custom operation ID, you need to make sure it is
  3008|         0|            0|            0|  0.00%|                unique for the whole API.
  3009|         0|            0|            0|  0.00%|
  3010|         0|            0|            0|  0.00%|                You can customize the
  3011|         0|            0|            0|  0.00%|                operation ID generation with the parameter
  3012|         0|            0|            0|  0.00%|                `generate_unique_id_function` in the `FastAPI` class.
  3013|         0|            0|            0|  0.00%|
  3014|         0|            0|            0|  0.00%|                Read more about it in the
  3015|         0|            0|            0|  0.00%|                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
  3016|         0|            0|            0|  0.00%|                """
  3017|         0|            0|            0|  0.00%|            ),
  3018|         0|            0|            0|  0.00%|        ] = None,
  3019|         0|            0|            0|  0.00%|        response_model_include: Annotated[
  3020|         0|            0|            0|  0.00%|            Optional[IncEx],
  3021|         0|            0|            0|  0.00%|            Doc(
  3022|         0|            0|            0|  0.00%|                """
  3023|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to include only certain fields in the
  3024|         0|            0|            0|  0.00%|                response data.
  3025|         0|            0|            0|  0.00%|
  3026|         0|            0|            0|  0.00%|                Read more about it in the
  3027|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
  3028|         0|            0|            0|  0.00%|                """
  3029|         0|            0|            0|  0.00%|            ),
  3030|         0|            0|            0|  0.00%|        ] = None,
  3031|         0|            0|            0|  0.00%|        response_model_exclude: Annotated[
  3032|         0|            0|            0|  0.00%|            Optional[IncEx],
  3033|         0|            0|            0|  0.00%|            Doc(
  3034|         0|            0|            0|  0.00%|                """
  3035|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to exclude certain fields in the
  3036|         0|            0|            0|  0.00%|                response data.
  3037|         0|            0|            0|  0.00%|
  3038|         0|            0|            0|  0.00%|                Read more about it in the
  3039|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
  3040|         0|            0|            0|  0.00%|                """
  3041|         0|            0|            0|  0.00%|            ),
  3042|         0|            0|            0|  0.00%|        ] = None,
  3043|         0|            0|            0|  0.00%|        response_model_by_alias: Annotated[
  3044|         0|            0|            0|  0.00%|            bool,
  3045|         0|            0|            0|  0.00%|            Doc(
  3046|         0|            0|            0|  0.00%|                """
  3047|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response model
  3048|         0|            0|            0|  0.00%|                should be serialized by alias when an alias is used.
  3049|         0|            0|            0|  0.00%|
  3050|         0|            0|            0|  0.00%|                Read more about it in the
  3051|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
  3052|         0|            0|            0|  0.00%|                """
  3053|         0|            0|            0|  0.00%|            ),
  3054|         0|            0|            0|  0.00%|        ] = True,
  3055|         0|            0|            0|  0.00%|        response_model_exclude_unset: Annotated[
  3056|         0|            0|            0|  0.00%|            bool,
  3057|         0|            0|            0|  0.00%|            Doc(
  3058|         0|            0|            0|  0.00%|                """
  3059|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response data
  3060|         0|            0|            0|  0.00%|                should have all the fields, including the ones that were not set and
  3061|         0|            0|            0|  0.00%|                have their default values. This is different from
  3062|         0|            0|            0|  0.00%|                `response_model_exclude_defaults` in that if the fields are set,
  3063|         0|            0|            0|  0.00%|                they will be included in the response, even if the value is the same
  3064|         0|            0|            0|  0.00%|                as the default.
  3065|         0|            0|            0|  0.00%|
  3066|         0|            0|            0|  0.00%|                When `True`, default values are omitted from the response.
  3067|         0|            0|            0|  0.00%|
  3068|         0|            0|            0|  0.00%|                Read more about it in the
  3069|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
  3070|         0|            0|            0|  0.00%|                """
  3071|         0|            0|            0|  0.00%|            ),
  3072|         0|            0|            0|  0.00%|        ] = False,
  3073|         0|            0|            0|  0.00%|        response_model_exclude_defaults: Annotated[
  3074|         0|            0|            0|  0.00%|            bool,
  3075|         0|            0|            0|  0.00%|            Doc(
  3076|         0|            0|            0|  0.00%|                """
  3077|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response data
  3078|         0|            0|            0|  0.00%|                should have all the fields, including the ones that have the same value
  3079|         0|            0|            0|  0.00%|                as the default. This is different from `response_model_exclude_unset`
  3080|         0|            0|            0|  0.00%|                in that if the fields are set but contain the same default values,
  3081|         0|            0|            0|  0.00%|                they will be excluded from the response.
  3082|         0|            0|            0|  0.00%|
  3083|         0|            0|            0|  0.00%|                When `True`, default values are omitted from the response.
  3084|         0|            0|            0|  0.00%|
  3085|         0|            0|            0|  0.00%|                Read more about it in the
  3086|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
  3087|         0|            0|            0|  0.00%|                """
  3088|         0|            0|            0|  0.00%|            ),
  3089|         0|            0|            0|  0.00%|        ] = False,
  3090|         0|            0|            0|  0.00%|        response_model_exclude_none: Annotated[
  3091|         0|            0|            0|  0.00%|            bool,
  3092|         0|            0|            0|  0.00%|            Doc(
  3093|         0|            0|            0|  0.00%|                """
  3094|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response data should
  3095|         0|            0|            0|  0.00%|                exclude fields set to `None`.
  3096|         0|            0|            0|  0.00%|
  3097|         0|            0|            0|  0.00%|                This is much simpler (less smart) than `response_model_exclude_unset`
  3098|         0|            0|            0|  0.00%|                and `response_model_exclude_defaults`. You probably want to use one of
  3099|         0|            0|            0|  0.00%|                those two instead of this one, as those allow returning `None` values
  3100|         0|            0|            0|  0.00%|                when it makes sense.
  3101|         0|            0|            0|  0.00%|
  3102|         0|            0|            0|  0.00%|                Read more about it in the
  3103|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
  3104|         0|            0|            0|  0.00%|                """
  3105|         0|            0|            0|  0.00%|            ),
  3106|         0|            0|            0|  0.00%|        ] = False,
  3107|         0|            0|            0|  0.00%|        include_in_schema: Annotated[
  3108|         0|            0|            0|  0.00%|            bool,
  3109|         0|            0|            0|  0.00%|            Doc(
  3110|         0|            0|            0|  0.00%|                """
  3111|         0|            0|            0|  0.00%|                Include this *path operation* in the generated OpenAPI schema.
  3112|         0|            0|            0|  0.00%|
  3113|         0|            0|            0|  0.00%|                This affects the generated OpenAPI (e.g. visible at `/docs`).
  3114|         0|            0|            0|  0.00%|
  3115|         0|            0|            0|  0.00%|                Read more about it in the
  3116|         0|            0|            0|  0.00%|                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).
  3117|         0|            0|            0|  0.00%|                """
  3118|         0|            0|            0|  0.00%|            ),
  3119|         0|            0|            0|  0.00%|        ] = True,
  3120|         0|            0|            0|  0.00%|        response_class: Annotated[
  3121|         0|            0|            0|  0.00%|            Type[Response],
  3122|         0|            0|            0|  0.00%|            Doc(
  3123|         0|            0|            0|  0.00%|                """
  3124|         0|            0|            0|  0.00%|                Response class to be used for this *path operation*.
  3125|         0|            0|            0|  0.00%|
  3126|         0|            0|            0|  0.00%|                This will not be used if you return a response directly.
  3127|         0|            0|            0|  0.00%|
  3128|         0|            0|            0|  0.00%|                Read more about it in the
  3129|         0|            0|            0|  0.00%|                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
  3130|         0|            0|            0|  0.00%|                """
  3131|         0|            0|            0|  0.00%|            ),
  3132|         0|            0|            0|  0.00%|        ] = Default(JSONResponse),
  3133|         0|            0|            0|  0.00%|        name: Annotated[
  3134|         0|            0|            0|  0.00%|            Optional[str],
  3135|         0|            0|            0|  0.00%|            Doc(
  3136|         0|            0|            0|  0.00%|                """
  3137|         0|            0|            0|  0.00%|                Name for this *path operation*. Only used internally.
  3138|         0|            0|            0|  0.00%|                """
  3139|         0|            0|            0|  0.00%|            ),
  3140|         0|            0|            0|  0.00%|        ] = None,
  3141|         0|            0|            0|  0.00%|        callbacks: Annotated[
  3142|         0|            0|            0|  0.00%|            Optional[List[BaseRoute]],
  3143|         0|            0|            0|  0.00%|            Doc(
  3144|         0|            0|            0|  0.00%|                """
  3145|         0|            0|            0|  0.00%|                List of *path operations* that will be used as OpenAPI callbacks.
  3146|         0|            0|            0|  0.00%|
  3147|         0|            0|            0|  0.00%|                This is only for OpenAPI documentation, the callbacks won't be used
  3148|         0|            0|            0|  0.00%|                directly.
  3149|         0|            0|            0|  0.00%|
  3150|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  3151|         0|            0|            0|  0.00%|
  3152|         0|            0|            0|  0.00%|                Read more about it in the
  3153|         0|            0|            0|  0.00%|                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
  3154|         0|            0|            0|  0.00%|                """
  3155|         0|            0|            0|  0.00%|            ),
  3156|         0|            0|            0|  0.00%|        ] = None,
  3157|         0|            0|            0|  0.00%|        openapi_extra: Annotated[
  3158|         0|            0|            0|  0.00%|            Optional[Dict[str, Any]],
  3159|         0|            0|            0|  0.00%|            Doc(
  3160|         0|            0|            0|  0.00%|                """
  3161|         0|            0|            0|  0.00%|                Extra metadata to be included in the OpenAPI schema for this *path
  3162|         0|            0|            0|  0.00%|                operation*.
  3163|         0|            0|            0|  0.00%|
  3164|         0|            0|            0|  0.00%|                Read more about it in the
  3165|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
  3166|         0|            0|            0|  0.00%|                """
  3167|         0|            0|            0|  0.00%|            ),
  3168|         0|            0|            0|  0.00%|        ] = None,
  3169|         0|            0|            0|  0.00%|        generate_unique_id_function: Annotated[
  3170|         0|            0|            0|  0.00%|            Callable[[APIRoute], str],
  3171|         0|            0|            0|  0.00%|            Doc(
  3172|         0|            0|            0|  0.00%|                """
  3173|         0|            0|            0|  0.00%|                Customize the function used to generate unique IDs for the *path
  3174|         0|            0|            0|  0.00%|                operations* shown in the generated OpenAPI.
  3175|         0|            0|            0|  0.00%|
  3176|         0|            0|            0|  0.00%|                This is particularly useful when automatically generating clients or
  3177|         0|            0|            0|  0.00%|                SDKs for your API.
  3178|         0|            0|            0|  0.00%|
  3179|         0|            0|            0|  0.00%|                Read more about it in the
  3180|         0|            0|            0|  0.00%|                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
  3181|         0|            0|            0|  0.00%|                """
  3182|         0|            0|            0|  0.00%|            ),
  3183|         0|            0|            0|  0.00%|        ] = Default(generate_unique_id),
  3184|         0|            0|            0|  0.00%|    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
  3185|         0|            0|            0|  0.00%|        """
  3186|         0|            0|            0|  0.00%|        Add a *path operation* using an HTTP OPTIONS operation.
  3187|         0|            0|            0|  0.00%|
  3188|         0|            0|            0|  0.00%|        ## Example
  3189|         0|            0|            0|  0.00%|
  3190|         0|            0|            0|  0.00%|        ```python
  3191|         0|            0|            0|  0.00%|        from fastapi import APIRouter, FastAPI
  3192|         0|            0|            0|  0.00%|
  3193|         0|            0|            0|  0.00%|        app = FastAPI()
  3194|         0|            0|            0|  0.00%|        router = APIRouter()
  3195|         0|            0|            0|  0.00%|
  3196|         0|            0|            0|  0.00%|        @router.options("/items/")
  3197|         0|            0|            0|  0.00%|        def get_item_options():
  3198|         0|            0|            0|  0.00%|            return {"additions": ["Aji", "Guacamole"]}
  3199|         0|            0|            0|  0.00%|
  3200|         0|            0|            0|  0.00%|        app.include_router(router)
  3201|         0|            0|            0|  0.00%|        ```
  3202|         0|            0|            0|  0.00%|        """
  3203|         0|            0|            0|  0.00%|        return self.api_route(
  3204|         0|            0|            0|  0.00%|            path=path,
  3205|         0|            0|            0|  0.00%|            response_model=response_model,
  3206|         0|            0|            0|  0.00%|            status_code=status_code,
  3207|         0|            0|            0|  0.00%|            tags=tags,
  3208|         0|            0|            0|  0.00%|            dependencies=dependencies,
  3209|         0|            0|            0|  0.00%|            summary=summary,
  3210|         0|            0|            0|  0.00%|            description=description,
  3211|         0|            0|            0|  0.00%|            response_description=response_description,
  3212|         0|            0|            0|  0.00%|            responses=responses,
  3213|         0|            0|            0|  0.00%|            deprecated=deprecated,
  3214|         0|            0|            0|  0.00%|            methods=["OPTIONS"],
  3215|         0|            0|            0|  0.00%|            operation_id=operation_id,
  3216|         0|            0|            0|  0.00%|            response_model_include=response_model_include,
  3217|         0|            0|            0|  0.00%|            response_model_exclude=response_model_exclude,
  3218|         0|            0|            0|  0.00%|            response_model_by_alias=response_model_by_alias,
  3219|         0|            0|            0|  0.00%|            response_model_exclude_unset=response_model_exclude_unset,
  3220|         0|            0|            0|  0.00%|            response_model_exclude_defaults=response_model_exclude_defaults,
  3221|         0|            0|            0|  0.00%|            response_model_exclude_none=response_model_exclude_none,
  3222|         0|            0|            0|  0.00%|            include_in_schema=include_in_schema,
  3223|         0|            0|            0|  0.00%|            response_class=response_class,
  3224|         0|            0|            0|  0.00%|            name=name,
  3225|         0|            0|            0|  0.00%|            callbacks=callbacks,
  3226|         0|            0|            0|  0.00%|            openapi_extra=openapi_extra,
  3227|         0|            0|            0|  0.00%|            generate_unique_id_function=generate_unique_id_function,
  3228|         0|            0|            0|  0.00%|        )
  3229|         0|            0|            0|  0.00%|
  3230|         0|            0|            0|  0.00%|    def head(
  3231|         0|            0|            0|  0.00%|        self,
  3232|         0|            0|            0|  0.00%|        path: Annotated[
  3233|         0|            0|            0|  0.00%|            str,
  3234|         0|            0|            0|  0.00%|            Doc(
  3235|         0|            0|            0|  0.00%|                """
  3236|         0|            0|            0|  0.00%|                The URL path to be used for this *path operation*.
  3237|         0|            0|            0|  0.00%|
  3238|         0|            0|            0|  0.00%|                For example, in `http://example.com/items`, the path is `/items`.
  3239|         0|            0|            0|  0.00%|                """
  3240|         0|            0|            0|  0.00%|            ),
  3241|         0|            0|            0|  0.00%|        ],
  3242|         0|            0|            0|  0.00%|        *,
  3243|         0|            0|            0|  0.00%|        response_model: Annotated[
  3244|         0|            0|            0|  0.00%|            Any,
  3245|         0|            0|            0|  0.00%|            Doc(
  3246|         0|            0|            0|  0.00%|                """
  3247|         0|            0|            0|  0.00%|                The type to use for the response.
  3248|         0|            0|            0|  0.00%|
  3249|         0|            0|            0|  0.00%|                It could be any valid Pydantic *field* type. So, it doesn't have to
  3250|         0|            0|            0|  0.00%|                be a Pydantic model, it could be other things, like a `list`, `dict`,
  3251|         0|            0|            0|  0.00%|                etc.
  3252|         0|            0|            0|  0.00%|
  3253|         0|            0|            0|  0.00%|                It will be used for:
  3254|         0|            0|            0|  0.00%|
  3255|         0|            0|            0|  0.00%|                * Documentation: the generated OpenAPI (and the UI at `/docs`) will
  3256|         0|            0|            0|  0.00%|                    show it as the response (JSON Schema).
  3257|         0|            0|            0|  0.00%|                * Serialization: you could return an arbitrary object and the
  3258|         0|            0|            0|  0.00%|                    `response_model` would be used to serialize that object into the
  3259|         0|            0|            0|  0.00%|                    corresponding JSON.
  3260|         0|            0|            0|  0.00%|                * Filtering: the JSON sent to the client will only contain the data
  3261|         0|            0|            0|  0.00%|                    (fields) defined in the `response_model`. If you returned an object
  3262|         0|            0|            0|  0.00%|                    that contains an attribute `password` but the `response_model` does
  3263|         0|            0|            0|  0.00%|                    not include that field, the JSON sent to the client would not have
  3264|         0|            0|            0|  0.00%|                    that `password`.
  3265|         0|            0|            0|  0.00%|                * Validation: whatever you return will be serialized with the
  3266|         0|            0|            0|  0.00%|                    `response_model`, converting any data as necessary to generate the
  3267|         0|            0|            0|  0.00%|                    corresponding JSON. But if the data in the object returned is not
  3268|         0|            0|            0|  0.00%|                    valid, that would mean a violation of the contract with the client,
  3269|         0|            0|            0|  0.00%|                    so it's an error from the API developer. So, FastAPI will raise an
  3270|         0|            0|            0|  0.00%|                    error and return a 500 error code (Internal Server Error).
  3271|         0|            0|            0|  0.00%|
  3272|         0|            0|            0|  0.00%|                Read more about it in the
  3273|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
  3274|         0|            0|            0|  0.00%|                """
  3275|         0|            0|            0|  0.00%|            ),
  3276|         0|            0|            0|  0.00%|        ] = Default(None),
  3277|         0|            0|            0|  0.00%|        status_code: Annotated[
  3278|         0|            0|            0|  0.00%|            Optional[int],
  3279|         0|            0|            0|  0.00%|            Doc(
  3280|         0|            0|            0|  0.00%|                """
  3281|         0|            0|            0|  0.00%|                The default status code to be used for the response.
  3282|         0|            0|            0|  0.00%|
  3283|         0|            0|            0|  0.00%|                You could override the status code by returning a response directly.
  3284|         0|            0|            0|  0.00%|
  3285|         0|            0|            0|  0.00%|                Read more about it in the
  3286|         0|            0|            0|  0.00%|                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
  3287|         0|            0|            0|  0.00%|                """
  3288|         0|            0|            0|  0.00%|            ),
  3289|         0|            0|            0|  0.00%|        ] = None,
  3290|         0|            0|            0|  0.00%|        tags: Annotated[
  3291|         0|            0|            0|  0.00%|            Optional[List[Union[str, Enum]]],
  3292|         0|            0|            0|  0.00%|            Doc(
  3293|         0|            0|            0|  0.00%|                """
  3294|         0|            0|            0|  0.00%|                A list of tags to be applied to the *path operation*.
  3295|         0|            0|            0|  0.00%|
  3296|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  3297|         0|            0|            0|  0.00%|
  3298|         0|            0|            0|  0.00%|                Read more about it in the
  3299|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
  3300|         0|            0|            0|  0.00%|                """
  3301|         0|            0|            0|  0.00%|            ),
  3302|         0|            0|            0|  0.00%|        ] = None,
  3303|         0|            0|            0|  0.00%|        dependencies: Annotated[
  3304|         0|            0|            0|  0.00%|            Optional[Sequence[params.Depends]],
  3305|         0|            0|            0|  0.00%|            Doc(
  3306|         0|            0|            0|  0.00%|                """
  3307|         0|            0|            0|  0.00%|                A list of dependencies (using `Depends()`) to be applied to the
  3308|         0|            0|            0|  0.00%|                *path operation*.
  3309|         0|            0|            0|  0.00%|
  3310|         0|            0|            0|  0.00%|                Read more about it in the
  3311|         0|            0|            0|  0.00%|                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
  3312|         0|            0|            0|  0.00%|                """
  3313|         0|            0|            0|  0.00%|            ),
  3314|         0|            0|            0|  0.00%|        ] = None,
  3315|         0|            0|            0|  0.00%|        summary: Annotated[
  3316|         0|            0|            0|  0.00%|            Optional[str],
  3317|         0|            0|            0|  0.00%|            Doc(
  3318|         0|            0|            0|  0.00%|                """
  3319|         0|            0|            0|  0.00%|                A summary for the *path operation*.
  3320|         0|            0|            0|  0.00%|
  3321|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  3322|         0|            0|            0|  0.00%|
  3323|         0|            0|            0|  0.00%|                Read more about it in the
  3324|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
  3325|         0|            0|            0|  0.00%|                """
  3326|         0|            0|            0|  0.00%|            ),
  3327|         0|            0|            0|  0.00%|        ] = None,
  3328|         0|            0|            0|  0.00%|        description: Annotated[
  3329|         0|            0|            0|  0.00%|            Optional[str],
  3330|         0|            0|            0|  0.00%|            Doc(
  3331|         0|            0|            0|  0.00%|                """
  3332|         0|            0|            0|  0.00%|                A description for the *path operation*.
  3333|         0|            0|            0|  0.00%|
  3334|         0|            0|            0|  0.00%|                If not provided, it will be extracted automatically from the docstring
  3335|         0|            0|            0|  0.00%|                of the *path operation function*.
  3336|         0|            0|            0|  0.00%|
  3337|         0|            0|            0|  0.00%|                It can contain Markdown.
  3338|         0|            0|            0|  0.00%|
  3339|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  3340|         0|            0|            0|  0.00%|
  3341|         0|            0|            0|  0.00%|                Read more about it in the
  3342|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
  3343|         0|            0|            0|  0.00%|                """
  3344|         0|            0|            0|  0.00%|            ),
  3345|         0|            0|            0|  0.00%|        ] = None,
  3346|         0|            0|            0|  0.00%|        response_description: Annotated[
  3347|         0|            0|            0|  0.00%|            str,
  3348|         0|            0|            0|  0.00%|            Doc(
  3349|         0|            0|            0|  0.00%|                """
  3350|         0|            0|            0|  0.00%|                The description for the default response.
  3351|         0|            0|            0|  0.00%|
  3352|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  3353|         0|            0|            0|  0.00%|                """
  3354|         0|            0|            0|  0.00%|            ),
  3355|         0|            0|            0|  0.00%|        ] = "Successful Response",
  3356|         0|            0|            0|  0.00%|        responses: Annotated[
  3357|         0|            0|            0|  0.00%|            Optional[Dict[Union[int, str], Dict[str, Any]]],
  3358|         0|            0|            0|  0.00%|            Doc(
  3359|         0|            0|            0|  0.00%|                """
  3360|         0|            0|            0|  0.00%|                Additional responses that could be returned by this *path operation*.
  3361|         0|            0|            0|  0.00%|
  3362|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  3363|         0|            0|            0|  0.00%|                """
  3364|         0|            0|            0|  0.00%|            ),
  3365|         0|            0|            0|  0.00%|        ] = None,
  3366|         0|            0|            0|  0.00%|        deprecated: Annotated[
  3367|         0|            0|            0|  0.00%|            Optional[bool],
  3368|         0|            0|            0|  0.00%|            Doc(
  3369|         0|            0|            0|  0.00%|                """
  3370|         0|            0|            0|  0.00%|                Mark this *path operation* as deprecated.
  3371|         0|            0|            0|  0.00%|
  3372|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  3373|         0|            0|            0|  0.00%|                """
  3374|         0|            0|            0|  0.00%|            ),
  3375|         0|            0|            0|  0.00%|        ] = None,
  3376|         0|            0|            0|  0.00%|        operation_id: Annotated[
  3377|         0|            0|            0|  0.00%|            Optional[str],
  3378|         0|            0|            0|  0.00%|            Doc(
  3379|         0|            0|            0|  0.00%|                """
  3380|         0|            0|            0|  0.00%|                Custom operation ID to be used by this *path operation*.
  3381|         0|            0|            0|  0.00%|
  3382|         0|            0|            0|  0.00%|                By default, it is generated automatically.
  3383|         0|            0|            0|  0.00%|
  3384|         0|            0|            0|  0.00%|                If you provide a custom operation ID, you need to make sure it is
  3385|         0|            0|            0|  0.00%|                unique for the whole API.
  3386|         0|            0|            0|  0.00%|
  3387|         0|            0|            0|  0.00%|                You can customize the
  3388|         0|            0|            0|  0.00%|                operation ID generation with the parameter
  3389|         0|            0|            0|  0.00%|                `generate_unique_id_function` in the `FastAPI` class.
  3390|         0|            0|            0|  0.00%|
  3391|         0|            0|            0|  0.00%|                Read more about it in the
  3392|         0|            0|            0|  0.00%|                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
  3393|         0|            0|            0|  0.00%|                """
  3394|         0|            0|            0|  0.00%|            ),
  3395|         0|            0|            0|  0.00%|        ] = None,
  3396|         0|            0|            0|  0.00%|        response_model_include: Annotated[
  3397|         0|            0|            0|  0.00%|            Optional[IncEx],
  3398|         0|            0|            0|  0.00%|            Doc(
  3399|         0|            0|            0|  0.00%|                """
  3400|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to include only certain fields in the
  3401|         0|            0|            0|  0.00%|                response data.
  3402|         0|            0|            0|  0.00%|
  3403|         0|            0|            0|  0.00%|                Read more about it in the
  3404|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
  3405|         0|            0|            0|  0.00%|                """
  3406|         0|            0|            0|  0.00%|            ),
  3407|         0|            0|            0|  0.00%|        ] = None,
  3408|         0|            0|            0|  0.00%|        response_model_exclude: Annotated[
  3409|         0|            0|            0|  0.00%|            Optional[IncEx],
  3410|         0|            0|            0|  0.00%|            Doc(
  3411|         0|            0|            0|  0.00%|                """
  3412|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to exclude certain fields in the
  3413|         0|            0|            0|  0.00%|                response data.
  3414|         0|            0|            0|  0.00%|
  3415|         0|            0|            0|  0.00%|                Read more about it in the
  3416|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
  3417|         0|            0|            0|  0.00%|                """
  3418|         0|            0|            0|  0.00%|            ),
  3419|         0|            0|            0|  0.00%|        ] = None,
  3420|         0|            0|            0|  0.00%|        response_model_by_alias: Annotated[
  3421|         0|            0|            0|  0.00%|            bool,
  3422|         0|            0|            0|  0.00%|            Doc(
  3423|         0|            0|            0|  0.00%|                """
  3424|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response model
  3425|         0|            0|            0|  0.00%|                should be serialized by alias when an alias is used.
  3426|         0|            0|            0|  0.00%|
  3427|         0|            0|            0|  0.00%|                Read more about it in the
  3428|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
  3429|         0|            0|            0|  0.00%|                """
  3430|         0|            0|            0|  0.00%|            ),
  3431|         0|            0|            0|  0.00%|        ] = True,
  3432|         0|            0|            0|  0.00%|        response_model_exclude_unset: Annotated[
  3433|         0|            0|            0|  0.00%|            bool,
  3434|         0|            0|            0|  0.00%|            Doc(
  3435|         0|            0|            0|  0.00%|                """
  3436|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response data
  3437|         0|            0|            0|  0.00%|                should have all the fields, including the ones that were not set and
  3438|         0|            0|            0|  0.00%|                have their default values. This is different from
  3439|         0|            0|            0|  0.00%|                `response_model_exclude_defaults` in that if the fields are set,
  3440|         0|            0|            0|  0.00%|                they will be included in the response, even if the value is the same
  3441|         0|            0|            0|  0.00%|                as the default.
  3442|         0|            0|            0|  0.00%|
  3443|         0|            0|            0|  0.00%|                When `True`, default values are omitted from the response.
  3444|         0|            0|            0|  0.00%|
  3445|         0|            0|            0|  0.00%|                Read more about it in the
  3446|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
  3447|         0|            0|            0|  0.00%|                """
  3448|         0|            0|            0|  0.00%|            ),
  3449|         0|            0|            0|  0.00%|        ] = False,
  3450|         0|            0|            0|  0.00%|        response_model_exclude_defaults: Annotated[
  3451|         0|            0|            0|  0.00%|            bool,
  3452|         0|            0|            0|  0.00%|            Doc(
  3453|         0|            0|            0|  0.00%|                """
  3454|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response data
  3455|         0|            0|            0|  0.00%|                should have all the fields, including the ones that have the same value
  3456|         0|            0|            0|  0.00%|                as the default. This is different from `response_model_exclude_unset`
  3457|         0|            0|            0|  0.00%|                in that if the fields are set but contain the same default values,
  3458|         0|            0|            0|  0.00%|                they will be excluded from the response.
  3459|         0|            0|            0|  0.00%|
  3460|         0|            0|            0|  0.00%|                When `True`, default values are omitted from the response.
  3461|         0|            0|            0|  0.00%|
  3462|         0|            0|            0|  0.00%|                Read more about it in the
  3463|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
  3464|         0|            0|            0|  0.00%|                """
  3465|         0|            0|            0|  0.00%|            ),
  3466|         0|            0|            0|  0.00%|        ] = False,
  3467|         0|            0|            0|  0.00%|        response_model_exclude_none: Annotated[
  3468|         0|            0|            0|  0.00%|            bool,
  3469|         0|            0|            0|  0.00%|            Doc(
  3470|         0|            0|            0|  0.00%|                """
  3471|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response data should
  3472|         0|            0|            0|  0.00%|                exclude fields set to `None`.
  3473|         0|            0|            0|  0.00%|
  3474|         0|            0|            0|  0.00%|                This is much simpler (less smart) than `response_model_exclude_unset`
  3475|         0|            0|            0|  0.00%|                and `response_model_exclude_defaults`. You probably want to use one of
  3476|         0|            0|            0|  0.00%|                those two instead of this one, as those allow returning `None` values
  3477|         0|            0|            0|  0.00%|                when it makes sense.
  3478|         0|            0|            0|  0.00%|
  3479|         0|            0|            0|  0.00%|                Read more about it in the
  3480|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
  3481|         0|            0|            0|  0.00%|                """
  3482|         0|            0|            0|  0.00%|            ),
  3483|         0|            0|            0|  0.00%|        ] = False,
  3484|         0|            0|            0|  0.00%|        include_in_schema: Annotated[
  3485|         0|            0|            0|  0.00%|            bool,
  3486|         0|            0|            0|  0.00%|            Doc(
  3487|         0|            0|            0|  0.00%|                """
  3488|         0|            0|            0|  0.00%|                Include this *path operation* in the generated OpenAPI schema.
  3489|         0|            0|            0|  0.00%|
  3490|         0|            0|            0|  0.00%|                This affects the generated OpenAPI (e.g. visible at `/docs`).
  3491|         0|            0|            0|  0.00%|
  3492|         0|            0|            0|  0.00%|                Read more about it in the
  3493|         0|            0|            0|  0.00%|                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).
  3494|         0|            0|            0|  0.00%|                """
  3495|         0|            0|            0|  0.00%|            ),
  3496|         0|            0|            0|  0.00%|        ] = True,
  3497|         0|            0|            0|  0.00%|        response_class: Annotated[
  3498|         0|            0|            0|  0.00%|            Type[Response],
  3499|         0|            0|            0|  0.00%|            Doc(
  3500|         0|            0|            0|  0.00%|                """
  3501|         0|            0|            0|  0.00%|                Response class to be used for this *path operation*.
  3502|         0|            0|            0|  0.00%|
  3503|         0|            0|            0|  0.00%|                This will not be used if you return a response directly.
  3504|         0|            0|            0|  0.00%|
  3505|         0|            0|            0|  0.00%|                Read more about it in the
  3506|         0|            0|            0|  0.00%|                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
  3507|         0|            0|            0|  0.00%|                """
  3508|         0|            0|            0|  0.00%|            ),
  3509|         0|            0|            0|  0.00%|        ] = Default(JSONResponse),
  3510|         0|            0|            0|  0.00%|        name: Annotated[
  3511|         0|            0|            0|  0.00%|            Optional[str],
  3512|         0|            0|            0|  0.00%|            Doc(
  3513|         0|            0|            0|  0.00%|                """
  3514|         0|            0|            0|  0.00%|                Name for this *path operation*. Only used internally.
  3515|         0|            0|            0|  0.00%|                """
  3516|         0|            0|            0|  0.00%|            ),
  3517|         0|            0|            0|  0.00%|        ] = None,
  3518|         0|            0|            0|  0.00%|        callbacks: Annotated[
  3519|         0|            0|            0|  0.00%|            Optional[List[BaseRoute]],
  3520|         0|            0|            0|  0.00%|            Doc(
  3521|         0|            0|            0|  0.00%|                """
  3522|         0|            0|            0|  0.00%|                List of *path operations* that will be used as OpenAPI callbacks.
  3523|         0|            0|            0|  0.00%|
  3524|         0|            0|            0|  0.00%|                This is only for OpenAPI documentation, the callbacks won't be used
  3525|         0|            0|            0|  0.00%|                directly.
  3526|         0|            0|            0|  0.00%|
  3527|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  3528|         0|            0|            0|  0.00%|
  3529|         0|            0|            0|  0.00%|                Read more about it in the
  3530|         0|            0|            0|  0.00%|                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
  3531|         0|            0|            0|  0.00%|                """
  3532|         0|            0|            0|  0.00%|            ),
  3533|         0|            0|            0|  0.00%|        ] = None,
  3534|         0|            0|            0|  0.00%|        openapi_extra: Annotated[
  3535|         0|            0|            0|  0.00%|            Optional[Dict[str, Any]],
  3536|         0|            0|            0|  0.00%|            Doc(
  3537|         0|            0|            0|  0.00%|                """
  3538|         0|            0|            0|  0.00%|                Extra metadata to be included in the OpenAPI schema for this *path
  3539|         0|            0|            0|  0.00%|                operation*.
  3540|         0|            0|            0|  0.00%|
  3541|         0|            0|            0|  0.00%|                Read more about it in the
  3542|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
  3543|         0|            0|            0|  0.00%|                """
  3544|         0|            0|            0|  0.00%|            ),
  3545|         0|            0|            0|  0.00%|        ] = None,
  3546|         0|            0|            0|  0.00%|        generate_unique_id_function: Annotated[
  3547|         0|            0|            0|  0.00%|            Callable[[APIRoute], str],
  3548|         0|            0|            0|  0.00%|            Doc(
  3549|         0|            0|            0|  0.00%|                """
  3550|         0|            0|            0|  0.00%|                Customize the function used to generate unique IDs for the *path
  3551|         0|            0|            0|  0.00%|                operations* shown in the generated OpenAPI.
  3552|         0|            0|            0|  0.00%|
  3553|         0|            0|            0|  0.00%|                This is particularly useful when automatically generating clients or
  3554|         0|            0|            0|  0.00%|                SDKs for your API.
  3555|         0|            0|            0|  0.00%|
  3556|         0|            0|            0|  0.00%|                Read more about it in the
  3557|         0|            0|            0|  0.00%|                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
  3558|         0|            0|            0|  0.00%|                """
  3559|         0|            0|            0|  0.00%|            ),
  3560|         0|            0|            0|  0.00%|        ] = Default(generate_unique_id),
  3561|         0|            0|            0|  0.00%|    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
  3562|         0|            0|            0|  0.00%|        """
  3563|         0|            0|            0|  0.00%|        Add a *path operation* using an HTTP HEAD operation.
  3564|         0|            0|            0|  0.00%|
  3565|         0|            0|            0|  0.00%|        ## Example
  3566|         0|            0|            0|  0.00%|
  3567|         0|            0|            0|  0.00%|        ```python
  3568|         0|            0|            0|  0.00%|        from fastapi import APIRouter, FastAPI
  3569|         0|            0|            0|  0.00%|        from pydantic import BaseModel
  3570|         0|            0|            0|  0.00%|
  3571|         0|            0|            0|  0.00%|        class Item(BaseModel):
  3572|         0|            0|            0|  0.00%|            name: str
  3573|         0|            0|            0|  0.00%|            description: str | None = None
  3574|         0|            0|            0|  0.00%|
  3575|         0|            0|            0|  0.00%|        app = FastAPI()
  3576|         0|            0|            0|  0.00%|        router = APIRouter()
  3577|         0|            0|            0|  0.00%|
  3578|         0|            0|            0|  0.00%|        @router.head("/items/", status_code=204)
  3579|         0|            0|            0|  0.00%|        def get_items_headers(response: Response):
  3580|         0|            0|            0|  0.00%|            response.headers["X-Cat-Dog"] = "Alone in the world"
  3581|         0|            0|            0|  0.00%|
  3582|         0|            0|            0|  0.00%|        app.include_router(router)
  3583|         0|            0|            0|  0.00%|        ```
  3584|         0|            0|            0|  0.00%|        """
  3585|         0|            0|            0|  0.00%|        return self.api_route(
  3586|         0|            0|            0|  0.00%|            path=path,
  3587|         0|            0|            0|  0.00%|            response_model=response_model,
  3588|         0|            0|            0|  0.00%|            status_code=status_code,
  3589|         0|            0|            0|  0.00%|            tags=tags,
  3590|         0|            0|            0|  0.00%|            dependencies=dependencies,
  3591|         0|            0|            0|  0.00%|            summary=summary,
  3592|         0|            0|            0|  0.00%|            description=description,
  3593|         0|            0|            0|  0.00%|            response_description=response_description,
  3594|         0|            0|            0|  0.00%|            responses=responses,
  3595|         0|            0|            0|  0.00%|            deprecated=deprecated,
  3596|         0|            0|            0|  0.00%|            methods=["HEAD"],
  3597|         0|            0|            0|  0.00%|            operation_id=operation_id,
  3598|         0|            0|            0|  0.00%|            response_model_include=response_model_include,
  3599|         0|            0|            0|  0.00%|            response_model_exclude=response_model_exclude,
  3600|         0|            0|            0|  0.00%|            response_model_by_alias=response_model_by_alias,
  3601|         0|            0|            0|  0.00%|            response_model_exclude_unset=response_model_exclude_unset,
  3602|         0|            0|            0|  0.00%|            response_model_exclude_defaults=response_model_exclude_defaults,
  3603|         0|            0|            0|  0.00%|            response_model_exclude_none=response_model_exclude_none,
  3604|         0|            0|            0|  0.00%|            include_in_schema=include_in_schema,
  3605|         0|            0|            0|  0.00%|            response_class=response_class,
  3606|         0|            0|            0|  0.00%|            name=name,
  3607|         0|            0|            0|  0.00%|            callbacks=callbacks,
  3608|         0|            0|            0|  0.00%|            openapi_extra=openapi_extra,
  3609|         0|            0|            0|  0.00%|            generate_unique_id_function=generate_unique_id_function,
  3610|         0|            0|            0|  0.00%|        )
  3611|         0|            0|            0|  0.00%|
  3612|         0|            0|            0|  0.00%|    def patch(
  3613|         0|            0|            0|  0.00%|        self,
  3614|         0|            0|            0|  0.00%|        path: Annotated[
  3615|         0|            0|            0|  0.00%|            str,
  3616|         0|            0|            0|  0.00%|            Doc(
  3617|         0|            0|            0|  0.00%|                """
  3618|         0|            0|            0|  0.00%|                The URL path to be used for this *path operation*.
  3619|         0|            0|            0|  0.00%|
  3620|         0|            0|            0|  0.00%|                For example, in `http://example.com/items`, the path is `/items`.
  3621|         0|            0|            0|  0.00%|                """
  3622|         0|            0|            0|  0.00%|            ),
  3623|         0|            0|            0|  0.00%|        ],
  3624|         0|            0|            0|  0.00%|        *,
  3625|         0|            0|            0|  0.00%|        response_model: Annotated[
  3626|         0|            0|            0|  0.00%|            Any,
  3627|         0|            0|            0|  0.00%|            Doc(
  3628|         0|            0|            0|  0.00%|                """
  3629|         0|            0|            0|  0.00%|                The type to use for the response.
  3630|         0|            0|            0|  0.00%|
  3631|         0|            0|            0|  0.00%|                It could be any valid Pydantic *field* type. So, it doesn't have to
  3632|         0|            0|            0|  0.00%|                be a Pydantic model, it could be other things, like a `list`, `dict`,
  3633|         0|            0|            0|  0.00%|                etc.
  3634|         0|            0|            0|  0.00%|
  3635|         0|            0|            0|  0.00%|                It will be used for:
  3636|         0|            0|            0|  0.00%|
  3637|         0|            0|            0|  0.00%|                * Documentation: the generated OpenAPI (and the UI at `/docs`) will
  3638|         0|            0|            0|  0.00%|                    show it as the response (JSON Schema).
  3639|         0|            0|            0|  0.00%|                * Serialization: you could return an arbitrary object and the
  3640|         0|            0|            0|  0.00%|                    `response_model` would be used to serialize that object into the
  3641|         0|            0|            0|  0.00%|                    corresponding JSON.
  3642|         0|            0|            0|  0.00%|                * Filtering: the JSON sent to the client will only contain the data
  3643|         0|            0|            0|  0.00%|                    (fields) defined in the `response_model`. If you returned an object
  3644|         0|            0|            0|  0.00%|                    that contains an attribute `password` but the `response_model` does
  3645|         0|            0|            0|  0.00%|                    not include that field, the JSON sent to the client would not have
  3646|         0|            0|            0|  0.00%|                    that `password`.
  3647|         0|            0|            0|  0.00%|                * Validation: whatever you return will be serialized with the
  3648|         0|            0|            0|  0.00%|                    `response_model`, converting any data as necessary to generate the
  3649|         0|            0|            0|  0.00%|                    corresponding JSON. But if the data in the object returned is not
  3650|         0|            0|            0|  0.00%|                    valid, that would mean a violation of the contract with the client,
  3651|         0|            0|            0|  0.00%|                    so it's an error from the API developer. So, FastAPI will raise an
  3652|         0|            0|            0|  0.00%|                    error and return a 500 error code (Internal Server Error).
  3653|         0|            0|            0|  0.00%|
  3654|         0|            0|            0|  0.00%|                Read more about it in the
  3655|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
  3656|         0|            0|            0|  0.00%|                """
  3657|         0|            0|            0|  0.00%|            ),
  3658|         0|            0|            0|  0.00%|        ] = Default(None),
  3659|         0|            0|            0|  0.00%|        status_code: Annotated[
  3660|         0|            0|            0|  0.00%|            Optional[int],
  3661|         0|            0|            0|  0.00%|            Doc(
  3662|         0|            0|            0|  0.00%|                """
  3663|         0|            0|            0|  0.00%|                The default status code to be used for the response.
  3664|         0|            0|            0|  0.00%|
  3665|         0|            0|            0|  0.00%|                You could override the status code by returning a response directly.
  3666|         0|            0|            0|  0.00%|
  3667|         0|            0|            0|  0.00%|                Read more about it in the
  3668|         0|            0|            0|  0.00%|                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
  3669|         0|            0|            0|  0.00%|                """
  3670|         0|            0|            0|  0.00%|            ),
  3671|         0|            0|            0|  0.00%|        ] = None,
  3672|         0|            0|            0|  0.00%|        tags: Annotated[
  3673|         0|            0|            0|  0.00%|            Optional[List[Union[str, Enum]]],
  3674|         0|            0|            0|  0.00%|            Doc(
  3675|         0|            0|            0|  0.00%|                """
  3676|         0|            0|            0|  0.00%|                A list of tags to be applied to the *path operation*.
  3677|         0|            0|            0|  0.00%|
  3678|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  3679|         0|            0|            0|  0.00%|
  3680|         0|            0|            0|  0.00%|                Read more about it in the
  3681|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
  3682|         0|            0|            0|  0.00%|                """
  3683|         0|            0|            0|  0.00%|            ),
  3684|         0|            0|            0|  0.00%|        ] = None,
  3685|         0|            0|            0|  0.00%|        dependencies: Annotated[
  3686|         0|            0|            0|  0.00%|            Optional[Sequence[params.Depends]],
  3687|         0|            0|            0|  0.00%|            Doc(
  3688|         0|            0|            0|  0.00%|                """
  3689|         0|            0|            0|  0.00%|                A list of dependencies (using `Depends()`) to be applied to the
  3690|         0|            0|            0|  0.00%|                *path operation*.
  3691|         0|            0|            0|  0.00%|
  3692|         0|            0|            0|  0.00%|                Read more about it in the
  3693|         0|            0|            0|  0.00%|                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
  3694|         0|            0|            0|  0.00%|                """
  3695|         0|            0|            0|  0.00%|            ),
  3696|         0|            0|            0|  0.00%|        ] = None,
  3697|         0|            0|            0|  0.00%|        summary: Annotated[
  3698|         0|            0|            0|  0.00%|            Optional[str],
  3699|         0|            0|            0|  0.00%|            Doc(
  3700|         0|            0|            0|  0.00%|                """
  3701|         0|            0|            0|  0.00%|                A summary for the *path operation*.
  3702|         0|            0|            0|  0.00%|
  3703|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  3704|         0|            0|            0|  0.00%|
  3705|         0|            0|            0|  0.00%|                Read more about it in the
  3706|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
  3707|         0|            0|            0|  0.00%|                """
  3708|         0|            0|            0|  0.00%|            ),
  3709|         0|            0|            0|  0.00%|        ] = None,
  3710|         0|            0|            0|  0.00%|        description: Annotated[
  3711|         0|            0|            0|  0.00%|            Optional[str],
  3712|         0|            0|            0|  0.00%|            Doc(
  3713|         0|            0|            0|  0.00%|                """
  3714|         0|            0|            0|  0.00%|                A description for the *path operation*.
  3715|         0|            0|            0|  0.00%|
  3716|         0|            0|            0|  0.00%|                If not provided, it will be extracted automatically from the docstring
  3717|         0|            0|            0|  0.00%|                of the *path operation function*.
  3718|         0|            0|            0|  0.00%|
  3719|         0|            0|            0|  0.00%|                It can contain Markdown.
  3720|         0|            0|            0|  0.00%|
  3721|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  3722|         0|            0|            0|  0.00%|
  3723|         0|            0|            0|  0.00%|                Read more about it in the
  3724|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
  3725|         0|            0|            0|  0.00%|                """
  3726|         0|            0|            0|  0.00%|            ),
  3727|         0|            0|            0|  0.00%|        ] = None,
  3728|         0|            0|            0|  0.00%|        response_description: Annotated[
  3729|         0|            0|            0|  0.00%|            str,
  3730|         0|            0|            0|  0.00%|            Doc(
  3731|         0|            0|            0|  0.00%|                """
  3732|         0|            0|            0|  0.00%|                The description for the default response.
  3733|         0|            0|            0|  0.00%|
  3734|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  3735|         0|            0|            0|  0.00%|                """
  3736|         0|            0|            0|  0.00%|            ),
  3737|         0|            0|            0|  0.00%|        ] = "Successful Response",
  3738|         0|            0|            0|  0.00%|        responses: Annotated[
  3739|         0|            0|            0|  0.00%|            Optional[Dict[Union[int, str], Dict[str, Any]]],
  3740|         0|            0|            0|  0.00%|            Doc(
  3741|         0|            0|            0|  0.00%|                """
  3742|         0|            0|            0|  0.00%|                Additional responses that could be returned by this *path operation*.
  3743|         0|            0|            0|  0.00%|
  3744|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  3745|         0|            0|            0|  0.00%|                """
  3746|         0|            0|            0|  0.00%|            ),
  3747|         0|            0|            0|  0.00%|        ] = None,
  3748|         0|            0|            0|  0.00%|        deprecated: Annotated[
  3749|         0|            0|            0|  0.00%|            Optional[bool],
  3750|         0|            0|            0|  0.00%|            Doc(
  3751|         0|            0|            0|  0.00%|                """
  3752|         0|            0|            0|  0.00%|                Mark this *path operation* as deprecated.
  3753|         0|            0|            0|  0.00%|
  3754|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  3755|         0|            0|            0|  0.00%|                """
  3756|         0|            0|            0|  0.00%|            ),
  3757|         0|            0|            0|  0.00%|        ] = None,
  3758|         0|            0|            0|  0.00%|        operation_id: Annotated[
  3759|         0|            0|            0|  0.00%|            Optional[str],
  3760|         0|            0|            0|  0.00%|            Doc(
  3761|         0|            0|            0|  0.00%|                """
  3762|         0|            0|            0|  0.00%|                Custom operation ID to be used by this *path operation*.
  3763|         0|            0|            0|  0.00%|
  3764|         0|            0|            0|  0.00%|                By default, it is generated automatically.
  3765|         0|            0|            0|  0.00%|
  3766|         0|            0|            0|  0.00%|                If you provide a custom operation ID, you need to make sure it is
  3767|         0|            0|            0|  0.00%|                unique for the whole API.
  3768|         0|            0|            0|  0.00%|
  3769|         0|            0|            0|  0.00%|                You can customize the
  3770|         0|            0|            0|  0.00%|                operation ID generation with the parameter
  3771|         0|            0|            0|  0.00%|                `generate_unique_id_function` in the `FastAPI` class.
  3772|         0|            0|            0|  0.00%|
  3773|         0|            0|            0|  0.00%|                Read more about it in the
  3774|         0|            0|            0|  0.00%|                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
  3775|         0|            0|            0|  0.00%|                """
  3776|         0|            0|            0|  0.00%|            ),
  3777|         0|            0|            0|  0.00%|        ] = None,
  3778|         0|            0|            0|  0.00%|        response_model_include: Annotated[
  3779|         0|            0|            0|  0.00%|            Optional[IncEx],
  3780|         0|            0|            0|  0.00%|            Doc(
  3781|         0|            0|            0|  0.00%|                """
  3782|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to include only certain fields in the
  3783|         0|            0|            0|  0.00%|                response data.
  3784|         0|            0|            0|  0.00%|
  3785|         0|            0|            0|  0.00%|                Read more about it in the
  3786|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
  3787|         0|            0|            0|  0.00%|                """
  3788|         0|            0|            0|  0.00%|            ),
  3789|         0|            0|            0|  0.00%|        ] = None,
  3790|         0|            0|            0|  0.00%|        response_model_exclude: Annotated[
  3791|         0|            0|            0|  0.00%|            Optional[IncEx],
  3792|         0|            0|            0|  0.00%|            Doc(
  3793|         0|            0|            0|  0.00%|                """
  3794|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to exclude certain fields in the
  3795|         0|            0|            0|  0.00%|                response data.
  3796|         0|            0|            0|  0.00%|
  3797|         0|            0|            0|  0.00%|                Read more about it in the
  3798|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
  3799|         0|            0|            0|  0.00%|                """
  3800|         0|            0|            0|  0.00%|            ),
  3801|         0|            0|            0|  0.00%|        ] = None,
  3802|         0|            0|            0|  0.00%|        response_model_by_alias: Annotated[
  3803|         0|            0|            0|  0.00%|            bool,
  3804|         0|            0|            0|  0.00%|            Doc(
  3805|         0|            0|            0|  0.00%|                """
  3806|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response model
  3807|         0|            0|            0|  0.00%|                should be serialized by alias when an alias is used.
  3808|         0|            0|            0|  0.00%|
  3809|         0|            0|            0|  0.00%|                Read more about it in the
  3810|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
  3811|         0|            0|            0|  0.00%|                """
  3812|         0|            0|            0|  0.00%|            ),
  3813|         0|            0|            0|  0.00%|        ] = True,
  3814|         0|            0|            0|  0.00%|        response_model_exclude_unset: Annotated[
  3815|         0|            0|            0|  0.00%|            bool,
  3816|         0|            0|            0|  0.00%|            Doc(
  3817|         0|            0|            0|  0.00%|                """
  3818|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response data
  3819|         0|            0|            0|  0.00%|                should have all the fields, including the ones that were not set and
  3820|         0|            0|            0|  0.00%|                have their default values. This is different from
  3821|         0|            0|            0|  0.00%|                `response_model_exclude_defaults` in that if the fields are set,
  3822|         0|            0|            0|  0.00%|                they will be included in the response, even if the value is the same
  3823|         0|            0|            0|  0.00%|                as the default.
  3824|         0|            0|            0|  0.00%|
  3825|         0|            0|            0|  0.00%|                When `True`, default values are omitted from the response.
  3826|         0|            0|            0|  0.00%|
  3827|         0|            0|            0|  0.00%|                Read more about it in the
  3828|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
  3829|         0|            0|            0|  0.00%|                """
  3830|         0|            0|            0|  0.00%|            ),
  3831|         0|            0|            0|  0.00%|        ] = False,
  3832|         0|            0|            0|  0.00%|        response_model_exclude_defaults: Annotated[
  3833|         0|            0|            0|  0.00%|            bool,
  3834|         0|            0|            0|  0.00%|            Doc(
  3835|         0|            0|            0|  0.00%|                """
  3836|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response data
  3837|         0|            0|            0|  0.00%|                should have all the fields, including the ones that have the same value
  3838|         0|            0|            0|  0.00%|                as the default. This is different from `response_model_exclude_unset`
  3839|         0|            0|            0|  0.00%|                in that if the fields are set but contain the same default values,
  3840|         0|            0|            0|  0.00%|                they will be excluded from the response.
  3841|         0|            0|            0|  0.00%|
  3842|         0|            0|            0|  0.00%|                When `True`, default values are omitted from the response.
  3843|         0|            0|            0|  0.00%|
  3844|         0|            0|            0|  0.00%|                Read more about it in the
  3845|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
  3846|         0|            0|            0|  0.00%|                """
  3847|         0|            0|            0|  0.00%|            ),
  3848|         0|            0|            0|  0.00%|        ] = False,
  3849|         0|            0|            0|  0.00%|        response_model_exclude_none: Annotated[
  3850|         0|            0|            0|  0.00%|            bool,
  3851|         0|            0|            0|  0.00%|            Doc(
  3852|         0|            0|            0|  0.00%|                """
  3853|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response data should
  3854|         0|            0|            0|  0.00%|                exclude fields set to `None`.
  3855|         0|            0|            0|  0.00%|
  3856|         0|            0|            0|  0.00%|                This is much simpler (less smart) than `response_model_exclude_unset`
  3857|         0|            0|            0|  0.00%|                and `response_model_exclude_defaults`. You probably want to use one of
  3858|         0|            0|            0|  0.00%|                those two instead of this one, as those allow returning `None` values
  3859|         0|            0|            0|  0.00%|                when it makes sense.
  3860|         0|            0|            0|  0.00%|
  3861|         0|            0|            0|  0.00%|                Read more about it in the
  3862|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
  3863|         0|            0|            0|  0.00%|                """
  3864|         0|            0|            0|  0.00%|            ),
  3865|         0|            0|            0|  0.00%|        ] = False,
  3866|         0|            0|            0|  0.00%|        include_in_schema: Annotated[
  3867|         0|            0|            0|  0.00%|            bool,
  3868|         0|            0|            0|  0.00%|            Doc(
  3869|         0|            0|            0|  0.00%|                """
  3870|         0|            0|            0|  0.00%|                Include this *path operation* in the generated OpenAPI schema.
  3871|         0|            0|            0|  0.00%|
  3872|         0|            0|            0|  0.00%|                This affects the generated OpenAPI (e.g. visible at `/docs`).
  3873|         0|            0|            0|  0.00%|
  3874|         0|            0|            0|  0.00%|                Read more about it in the
  3875|         0|            0|            0|  0.00%|                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).
  3876|         0|            0|            0|  0.00%|                """
  3877|         0|            0|            0|  0.00%|            ),
  3878|         0|            0|            0|  0.00%|        ] = True,
  3879|         0|            0|            0|  0.00%|        response_class: Annotated[
  3880|         0|            0|            0|  0.00%|            Type[Response],
  3881|         0|            0|            0|  0.00%|            Doc(
  3882|         0|            0|            0|  0.00%|                """
  3883|         0|            0|            0|  0.00%|                Response class to be used for this *path operation*.
  3884|         0|            0|            0|  0.00%|
  3885|         0|            0|            0|  0.00%|                This will not be used if you return a response directly.
  3886|         0|            0|            0|  0.00%|
  3887|         0|            0|            0|  0.00%|                Read more about it in the
  3888|         0|            0|            0|  0.00%|                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
  3889|         0|            0|            0|  0.00%|                """
  3890|         0|            0|            0|  0.00%|            ),
  3891|         0|            0|            0|  0.00%|        ] = Default(JSONResponse),
  3892|         0|            0|            0|  0.00%|        name: Annotated[
  3893|         0|            0|            0|  0.00%|            Optional[str],
  3894|         0|            0|            0|  0.00%|            Doc(
  3895|         0|            0|            0|  0.00%|                """
  3896|         0|            0|            0|  0.00%|                Name for this *path operation*. Only used internally.
  3897|         0|            0|            0|  0.00%|                """
  3898|         0|            0|            0|  0.00%|            ),
  3899|         0|            0|            0|  0.00%|        ] = None,
  3900|         0|            0|            0|  0.00%|        callbacks: Annotated[
  3901|         0|            0|            0|  0.00%|            Optional[List[BaseRoute]],
  3902|         0|            0|            0|  0.00%|            Doc(
  3903|         0|            0|            0|  0.00%|                """
  3904|         0|            0|            0|  0.00%|                List of *path operations* that will be used as OpenAPI callbacks.
  3905|         0|            0|            0|  0.00%|
  3906|         0|            0|            0|  0.00%|                This is only for OpenAPI documentation, the callbacks won't be used
  3907|         0|            0|            0|  0.00%|                directly.
  3908|         0|            0|            0|  0.00%|
  3909|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  3910|         0|            0|            0|  0.00%|
  3911|         0|            0|            0|  0.00%|                Read more about it in the
  3912|         0|            0|            0|  0.00%|                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
  3913|         0|            0|            0|  0.00%|                """
  3914|         0|            0|            0|  0.00%|            ),
  3915|         0|            0|            0|  0.00%|        ] = None,
  3916|         0|            0|            0|  0.00%|        openapi_extra: Annotated[
  3917|         0|            0|            0|  0.00%|            Optional[Dict[str, Any]],
  3918|         0|            0|            0|  0.00%|            Doc(
  3919|         0|            0|            0|  0.00%|                """
  3920|         0|            0|            0|  0.00%|                Extra metadata to be included in the OpenAPI schema for this *path
  3921|         0|            0|            0|  0.00%|                operation*.
  3922|         0|            0|            0|  0.00%|
  3923|         0|            0|            0|  0.00%|                Read more about it in the
  3924|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
  3925|         0|            0|            0|  0.00%|                """
  3926|         0|            0|            0|  0.00%|            ),
  3927|         0|            0|            0|  0.00%|        ] = None,
  3928|         0|            0|            0|  0.00%|        generate_unique_id_function: Annotated[
  3929|         0|            0|            0|  0.00%|            Callable[[APIRoute], str],
  3930|         0|            0|            0|  0.00%|            Doc(
  3931|         0|            0|            0|  0.00%|                """
  3932|         0|            0|            0|  0.00%|                Customize the function used to generate unique IDs for the *path
  3933|         0|            0|            0|  0.00%|                operations* shown in the generated OpenAPI.
  3934|         0|            0|            0|  0.00%|
  3935|         0|            0|            0|  0.00%|                This is particularly useful when automatically generating clients or
  3936|         0|            0|            0|  0.00%|                SDKs for your API.
  3937|         0|            0|            0|  0.00%|
  3938|         0|            0|            0|  0.00%|                Read more about it in the
  3939|         0|            0|            0|  0.00%|                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
  3940|         0|            0|            0|  0.00%|                """
  3941|         0|            0|            0|  0.00%|            ),
  3942|         0|            0|            0|  0.00%|        ] = Default(generate_unique_id),
  3943|         0|            0|            0|  0.00%|    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
  3944|         0|            0|            0|  0.00%|        """
  3945|         0|            0|            0|  0.00%|        Add a *path operation* using an HTTP PATCH operation.
  3946|         0|            0|            0|  0.00%|
  3947|         0|            0|            0|  0.00%|        ## Example
  3948|         0|            0|            0|  0.00%|
  3949|         0|            0|            0|  0.00%|        ```python
  3950|         0|            0|            0|  0.00%|        from fastapi import APIRouter, FastAPI
  3951|         0|            0|            0|  0.00%|        from pydantic import BaseModel
  3952|         0|            0|            0|  0.00%|
  3953|         0|            0|            0|  0.00%|        class Item(BaseModel):
  3954|         0|            0|            0|  0.00%|            name: str
  3955|         0|            0|            0|  0.00%|            description: str | None = None
  3956|         0|            0|            0|  0.00%|
  3957|         0|            0|            0|  0.00%|        app = FastAPI()
  3958|         0|            0|            0|  0.00%|        router = APIRouter()
  3959|         0|            0|            0|  0.00%|
  3960|         0|            0|            0|  0.00%|        @router.patch("/items/")
  3961|         0|            0|            0|  0.00%|        def update_item(item: Item):
  3962|         0|            0|            0|  0.00%|            return {"message": "Item updated in place"}
  3963|         0|            0|            0|  0.00%|
  3964|         0|            0|            0|  0.00%|        app.include_router(router)
  3965|         0|            0|            0|  0.00%|        ```
  3966|         0|            0|            0|  0.00%|        """
  3967|         0|            0|            0|  0.00%|        return self.api_route(
  3968|         0|            0|            0|  0.00%|            path=path,
  3969|         0|            0|            0|  0.00%|            response_model=response_model,
  3970|         0|            0|            0|  0.00%|            status_code=status_code,
  3971|         0|            0|            0|  0.00%|            tags=tags,
  3972|         0|            0|            0|  0.00%|            dependencies=dependencies,
  3973|         0|            0|            0|  0.00%|            summary=summary,
  3974|         0|            0|            0|  0.00%|            description=description,
  3975|         0|            0|            0|  0.00%|            response_description=response_description,
  3976|         0|            0|            0|  0.00%|            responses=responses,
  3977|         0|            0|            0|  0.00%|            deprecated=deprecated,
  3978|         0|            0|            0|  0.00%|            methods=["PATCH"],
  3979|         0|            0|            0|  0.00%|            operation_id=operation_id,
  3980|         0|            0|            0|  0.00%|            response_model_include=response_model_include,
  3981|         0|            0|            0|  0.00%|            response_model_exclude=response_model_exclude,
  3982|         0|            0|            0|  0.00%|            response_model_by_alias=response_model_by_alias,
  3983|         0|            0|            0|  0.00%|            response_model_exclude_unset=response_model_exclude_unset,
  3984|         0|            0|            0|  0.00%|            response_model_exclude_defaults=response_model_exclude_defaults,
  3985|         0|            0|            0|  0.00%|            response_model_exclude_none=response_model_exclude_none,
  3986|         0|            0|            0|  0.00%|            include_in_schema=include_in_schema,
  3987|         0|            0|            0|  0.00%|            response_class=response_class,
  3988|         0|            0|            0|  0.00%|            name=name,
  3989|         0|            0|            0|  0.00%|            callbacks=callbacks,
  3990|         0|            0|            0|  0.00%|            openapi_extra=openapi_extra,
  3991|         0|            0|            0|  0.00%|            generate_unique_id_function=generate_unique_id_function,
  3992|         0|            0|            0|  0.00%|        )
  3993|         0|            0|            0|  0.00%|
  3994|         0|            0|            0|  0.00%|    def trace(
  3995|         0|            0|            0|  0.00%|        self,
  3996|         0|            0|            0|  0.00%|        path: Annotated[
  3997|         0|            0|            0|  0.00%|            str,
  3998|         0|            0|            0|  0.00%|            Doc(
  3999|         0|            0|            0|  0.00%|                """
  4000|         0|            0|            0|  0.00%|                The URL path to be used for this *path operation*.
  4001|         0|            0|            0|  0.00%|
  4002|         0|            0|            0|  0.00%|                For example, in `http://example.com/items`, the path is `/items`.
  4003|         0|            0|            0|  0.00%|                """
  4004|         0|            0|            0|  0.00%|            ),
  4005|         0|            0|            0|  0.00%|        ],
  4006|         0|            0|            0|  0.00%|        *,
  4007|         0|            0|            0|  0.00%|        response_model: Annotated[
  4008|         0|            0|            0|  0.00%|            Any,
  4009|         0|            0|            0|  0.00%|            Doc(
  4010|         0|            0|            0|  0.00%|                """
  4011|         0|            0|            0|  0.00%|                The type to use for the response.
  4012|         0|            0|            0|  0.00%|
  4013|         0|            0|            0|  0.00%|                It could be any valid Pydantic *field* type. So, it doesn't have to
  4014|         0|            0|            0|  0.00%|                be a Pydantic model, it could be other things, like a `list`, `dict`,
  4015|         0|            0|            0|  0.00%|                etc.
  4016|         0|            0|            0|  0.00%|
  4017|         0|            0|            0|  0.00%|                It will be used for:
  4018|         0|            0|            0|  0.00%|
  4019|         0|            0|            0|  0.00%|                * Documentation: the generated OpenAPI (and the UI at `/docs`) will
  4020|         0|            0|            0|  0.00%|                    show it as the response (JSON Schema).
  4021|         0|            0|            0|  0.00%|                * Serialization: you could return an arbitrary object and the
  4022|         0|            0|            0|  0.00%|                    `response_model` would be used to serialize that object into the
  4023|         0|            0|            0|  0.00%|                    corresponding JSON.
  4024|         0|            0|            0|  0.00%|                * Filtering: the JSON sent to the client will only contain the data
  4025|         0|            0|            0|  0.00%|                    (fields) defined in the `response_model`. If you returned an object
  4026|         0|            0|            0|  0.00%|                    that contains an attribute `password` but the `response_model` does
  4027|         0|            0|            0|  0.00%|                    not include that field, the JSON sent to the client would not have
  4028|         0|            0|            0|  0.00%|                    that `password`.
  4029|         0|            0|            0|  0.00%|                * Validation: whatever you return will be serialized with the
  4030|         0|            0|            0|  0.00%|                    `response_model`, converting any data as necessary to generate the
  4031|         0|            0|            0|  0.00%|                    corresponding JSON. But if the data in the object returned is not
  4032|         0|            0|            0|  0.00%|                    valid, that would mean a violation of the contract with the client,
  4033|         0|            0|            0|  0.00%|                    so it's an error from the API developer. So, FastAPI will raise an
  4034|         0|            0|            0|  0.00%|                    error and return a 500 error code (Internal Server Error).
  4035|         0|            0|            0|  0.00%|
  4036|         0|            0|            0|  0.00%|                Read more about it in the
  4037|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model](https://fastapi.tiangolo.com/tutorial/response-model/).
  4038|         0|            0|            0|  0.00%|                """
  4039|         0|            0|            0|  0.00%|            ),
  4040|         0|            0|            0|  0.00%|        ] = Default(None),
  4041|         0|            0|            0|  0.00%|        status_code: Annotated[
  4042|         0|            0|            0|  0.00%|            Optional[int],
  4043|         0|            0|            0|  0.00%|            Doc(
  4044|         0|            0|            0|  0.00%|                """
  4045|         0|            0|            0|  0.00%|                The default status code to be used for the response.
  4046|         0|            0|            0|  0.00%|
  4047|         0|            0|            0|  0.00%|                You could override the status code by returning a response directly.
  4048|         0|            0|            0|  0.00%|
  4049|         0|            0|            0|  0.00%|                Read more about it in the
  4050|         0|            0|            0|  0.00%|                [FastAPI docs for Response Status Code](https://fastapi.tiangolo.com/tutorial/response-status-code/).
  4051|         0|            0|            0|  0.00%|                """
  4052|         0|            0|            0|  0.00%|            ),
  4053|         0|            0|            0|  0.00%|        ] = None,
  4054|         0|            0|            0|  0.00%|        tags: Annotated[
  4055|         0|            0|            0|  0.00%|            Optional[List[Union[str, Enum]]],
  4056|         0|            0|            0|  0.00%|            Doc(
  4057|         0|            0|            0|  0.00%|                """
  4058|         0|            0|            0|  0.00%|                A list of tags to be applied to the *path operation*.
  4059|         0|            0|            0|  0.00%|
  4060|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  4061|         0|            0|            0|  0.00%|
  4062|         0|            0|            0|  0.00%|                Read more about it in the
  4063|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/#tags).
  4064|         0|            0|            0|  0.00%|                """
  4065|         0|            0|            0|  0.00%|            ),
  4066|         0|            0|            0|  0.00%|        ] = None,
  4067|         0|            0|            0|  0.00%|        dependencies: Annotated[
  4068|         0|            0|            0|  0.00%|            Optional[Sequence[params.Depends]],
  4069|         0|            0|            0|  0.00%|            Doc(
  4070|         0|            0|            0|  0.00%|                """
  4071|         0|            0|            0|  0.00%|                A list of dependencies (using `Depends()`) to be applied to the
  4072|         0|            0|            0|  0.00%|                *path operation*.
  4073|         0|            0|            0|  0.00%|
  4074|         0|            0|            0|  0.00%|                Read more about it in the
  4075|         0|            0|            0|  0.00%|                [FastAPI docs for Dependencies in path operation decorators](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/).
  4076|         0|            0|            0|  0.00%|                """
  4077|         0|            0|            0|  0.00%|            ),
  4078|         0|            0|            0|  0.00%|        ] = None,
  4079|         0|            0|            0|  0.00%|        summary: Annotated[
  4080|         0|            0|            0|  0.00%|            Optional[str],
  4081|         0|            0|            0|  0.00%|            Doc(
  4082|         0|            0|            0|  0.00%|                """
  4083|         0|            0|            0|  0.00%|                A summary for the *path operation*.
  4084|         0|            0|            0|  0.00%|
  4085|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  4086|         0|            0|            0|  0.00%|
  4087|         0|            0|            0|  0.00%|                Read more about it in the
  4088|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
  4089|         0|            0|            0|  0.00%|                """
  4090|         0|            0|            0|  0.00%|            ),
  4091|         0|            0|            0|  0.00%|        ] = None,
  4092|         0|            0|            0|  0.00%|        description: Annotated[
  4093|         0|            0|            0|  0.00%|            Optional[str],
  4094|         0|            0|            0|  0.00%|            Doc(
  4095|         0|            0|            0|  0.00%|                """
  4096|         0|            0|            0|  0.00%|                A description for the *path operation*.
  4097|         0|            0|            0|  0.00%|
  4098|         0|            0|            0|  0.00%|                If not provided, it will be extracted automatically from the docstring
  4099|         0|            0|            0|  0.00%|                of the *path operation function*.
  4100|         0|            0|            0|  0.00%|
  4101|         0|            0|            0|  0.00%|                It can contain Markdown.
  4102|         0|            0|            0|  0.00%|
  4103|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  4104|         0|            0|            0|  0.00%|
  4105|         0|            0|            0|  0.00%|                Read more about it in the
  4106|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Configuration](https://fastapi.tiangolo.com/tutorial/path-operation-configuration/).
  4107|         0|            0|            0|  0.00%|                """
  4108|         0|            0|            0|  0.00%|            ),
  4109|         0|            0|            0|  0.00%|        ] = None,
  4110|         0|            0|            0|  0.00%|        response_description: Annotated[
  4111|         0|            0|            0|  0.00%|            str,
  4112|         0|            0|            0|  0.00%|            Doc(
  4113|         0|            0|            0|  0.00%|                """
  4114|         0|            0|            0|  0.00%|                The description for the default response.
  4115|         0|            0|            0|  0.00%|
  4116|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  4117|         0|            0|            0|  0.00%|                """
  4118|         0|            0|            0|  0.00%|            ),
  4119|         0|            0|            0|  0.00%|        ] = "Successful Response",
  4120|         0|            0|            0|  0.00%|        responses: Annotated[
  4121|         0|            0|            0|  0.00%|            Optional[Dict[Union[int, str], Dict[str, Any]]],
  4122|         0|            0|            0|  0.00%|            Doc(
  4123|         0|            0|            0|  0.00%|                """
  4124|         0|            0|            0|  0.00%|                Additional responses that could be returned by this *path operation*.
  4125|         0|            0|            0|  0.00%|
  4126|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  4127|         0|            0|            0|  0.00%|                """
  4128|         0|            0|            0|  0.00%|            ),
  4129|         0|            0|            0|  0.00%|        ] = None,
  4130|         0|            0|            0|  0.00%|        deprecated: Annotated[
  4131|         0|            0|            0|  0.00%|            Optional[bool],
  4132|         0|            0|            0|  0.00%|            Doc(
  4133|         0|            0|            0|  0.00%|                """
  4134|         0|            0|            0|  0.00%|                Mark this *path operation* as deprecated.
  4135|         0|            0|            0|  0.00%|
  4136|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  4137|         0|            0|            0|  0.00%|                """
  4138|         0|            0|            0|  0.00%|            ),
  4139|         0|            0|            0|  0.00%|        ] = None,
  4140|         0|            0|            0|  0.00%|        operation_id: Annotated[
  4141|         0|            0|            0|  0.00%|            Optional[str],
  4142|         0|            0|            0|  0.00%|            Doc(
  4143|         0|            0|            0|  0.00%|                """
  4144|         0|            0|            0|  0.00%|                Custom operation ID to be used by this *path operation*.
  4145|         0|            0|            0|  0.00%|
  4146|         0|            0|            0|  0.00%|                By default, it is generated automatically.
  4147|         0|            0|            0|  0.00%|
  4148|         0|            0|            0|  0.00%|                If you provide a custom operation ID, you need to make sure it is
  4149|         0|            0|            0|  0.00%|                unique for the whole API.
  4150|         0|            0|            0|  0.00%|
  4151|         0|            0|            0|  0.00%|                You can customize the
  4152|         0|            0|            0|  0.00%|                operation ID generation with the parameter
  4153|         0|            0|            0|  0.00%|                `generate_unique_id_function` in the `FastAPI` class.
  4154|         0|            0|            0|  0.00%|
  4155|         0|            0|            0|  0.00%|                Read more about it in the
  4156|         0|            0|            0|  0.00%|                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
  4157|         0|            0|            0|  0.00%|                """
  4158|         0|            0|            0|  0.00%|            ),
  4159|         0|            0|            0|  0.00%|        ] = None,
  4160|         0|            0|            0|  0.00%|        response_model_include: Annotated[
  4161|         0|            0|            0|  0.00%|            Optional[IncEx],
  4162|         0|            0|            0|  0.00%|            Doc(
  4163|         0|            0|            0|  0.00%|                """
  4164|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to include only certain fields in the
  4165|         0|            0|            0|  0.00%|                response data.
  4166|         0|            0|            0|  0.00%|
  4167|         0|            0|            0|  0.00%|                Read more about it in the
  4168|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
  4169|         0|            0|            0|  0.00%|                """
  4170|         0|            0|            0|  0.00%|            ),
  4171|         0|            0|            0|  0.00%|        ] = None,
  4172|         0|            0|            0|  0.00%|        response_model_exclude: Annotated[
  4173|         0|            0|            0|  0.00%|            Optional[IncEx],
  4174|         0|            0|            0|  0.00%|            Doc(
  4175|         0|            0|            0|  0.00%|                """
  4176|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to exclude certain fields in the
  4177|         0|            0|            0|  0.00%|                response data.
  4178|         0|            0|            0|  0.00%|
  4179|         0|            0|            0|  0.00%|                Read more about it in the
  4180|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
  4181|         0|            0|            0|  0.00%|                """
  4182|         0|            0|            0|  0.00%|            ),
  4183|         0|            0|            0|  0.00%|        ] = None,
  4184|         0|            0|            0|  0.00%|        response_model_by_alias: Annotated[
  4185|         0|            0|            0|  0.00%|            bool,
  4186|         0|            0|            0|  0.00%|            Doc(
  4187|         0|            0|            0|  0.00%|                """
  4188|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response model
  4189|         0|            0|            0|  0.00%|                should be serialized by alias when an alias is used.
  4190|         0|            0|            0|  0.00%|
  4191|         0|            0|            0|  0.00%|                Read more about it in the
  4192|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_include-and-response_model_exclude).
  4193|         0|            0|            0|  0.00%|                """
  4194|         0|            0|            0|  0.00%|            ),
  4195|         0|            0|            0|  0.00%|        ] = True,
  4196|         0|            0|            0|  0.00%|        response_model_exclude_unset: Annotated[
  4197|         0|            0|            0|  0.00%|            bool,
  4198|         0|            0|            0|  0.00%|            Doc(
  4199|         0|            0|            0|  0.00%|                """
  4200|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response data
  4201|         0|            0|            0|  0.00%|                should have all the fields, including the ones that were not set and
  4202|         0|            0|            0|  0.00%|                have their default values. This is different from
  4203|         0|            0|            0|  0.00%|                `response_model_exclude_defaults` in that if the fields are set,
  4204|         0|            0|            0|  0.00%|                they will be included in the response, even if the value is the same
  4205|         0|            0|            0|  0.00%|                as the default.
  4206|         0|            0|            0|  0.00%|
  4207|         0|            0|            0|  0.00%|                When `True`, default values are omitted from the response.
  4208|         0|            0|            0|  0.00%|
  4209|         0|            0|            0|  0.00%|                Read more about it in the
  4210|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
  4211|         0|            0|            0|  0.00%|                """
  4212|         0|            0|            0|  0.00%|            ),
  4213|         0|            0|            0|  0.00%|        ] = False,
  4214|         0|            0|            0|  0.00%|        response_model_exclude_defaults: Annotated[
  4215|         0|            0|            0|  0.00%|            bool,
  4216|         0|            0|            0|  0.00%|            Doc(
  4217|         0|            0|            0|  0.00%|                """
  4218|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response data
  4219|         0|            0|            0|  0.00%|                should have all the fields, including the ones that have the same value
  4220|         0|            0|            0|  0.00%|                as the default. This is different from `response_model_exclude_unset`
  4221|         0|            0|            0|  0.00%|                in that if the fields are set but contain the same default values,
  4222|         0|            0|            0|  0.00%|                they will be excluded from the response.
  4223|         0|            0|            0|  0.00%|
  4224|         0|            0|            0|  0.00%|                When `True`, default values are omitted from the response.
  4225|         0|            0|            0|  0.00%|
  4226|         0|            0|            0|  0.00%|                Read more about it in the
  4227|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#use-the-response_model_exclude_unset-parameter).
  4228|         0|            0|            0|  0.00%|                """
  4229|         0|            0|            0|  0.00%|            ),
  4230|         0|            0|            0|  0.00%|        ] = False,
  4231|         0|            0|            0|  0.00%|        response_model_exclude_none: Annotated[
  4232|         0|            0|            0|  0.00%|            bool,
  4233|         0|            0|            0|  0.00%|            Doc(
  4234|         0|            0|            0|  0.00%|                """
  4235|         0|            0|            0|  0.00%|                Configuration passed to Pydantic to define if the response data should
  4236|         0|            0|            0|  0.00%|                exclude fields set to `None`.
  4237|         0|            0|            0|  0.00%|
  4238|         0|            0|            0|  0.00%|                This is much simpler (less smart) than `response_model_exclude_unset`
  4239|         0|            0|            0|  0.00%|                and `response_model_exclude_defaults`. You probably want to use one of
  4240|         0|            0|            0|  0.00%|                those two instead of this one, as those allow returning `None` values
  4241|         0|            0|            0|  0.00%|                when it makes sense.
  4242|         0|            0|            0|  0.00%|
  4243|         0|            0|            0|  0.00%|                Read more about it in the
  4244|         0|            0|            0|  0.00%|                [FastAPI docs for Response Model - Return Type](https://fastapi.tiangolo.com/tutorial/response-model/#response_model_exclude_none).
  4245|         0|            0|            0|  0.00%|                """
  4246|         0|            0|            0|  0.00%|            ),
  4247|         0|            0|            0|  0.00%|        ] = False,
  4248|         0|            0|            0|  0.00%|        include_in_schema: Annotated[
  4249|         0|            0|            0|  0.00%|            bool,
  4250|         0|            0|            0|  0.00%|            Doc(
  4251|         0|            0|            0|  0.00%|                """
  4252|         0|            0|            0|  0.00%|                Include this *path operation* in the generated OpenAPI schema.
  4253|         0|            0|            0|  0.00%|
  4254|         0|            0|            0|  0.00%|                This affects the generated OpenAPI (e.g. visible at `/docs`).
  4255|         0|            0|            0|  0.00%|
  4256|         0|            0|            0|  0.00%|                Read more about it in the
  4257|         0|            0|            0|  0.00%|                [FastAPI docs for Query Parameters and String Validations](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#exclude-from-openapi).
  4258|         0|            0|            0|  0.00%|                """
  4259|         0|            0|            0|  0.00%|            ),
  4260|         0|            0|            0|  0.00%|        ] = True,
  4261|         0|            0|            0|  0.00%|        response_class: Annotated[
  4262|         0|            0|            0|  0.00%|            Type[Response],
  4263|         0|            0|            0|  0.00%|            Doc(
  4264|         0|            0|            0|  0.00%|                """
  4265|         0|            0|            0|  0.00%|                Response class to be used for this *path operation*.
  4266|         0|            0|            0|  0.00%|
  4267|         0|            0|            0|  0.00%|                This will not be used if you return a response directly.
  4268|         0|            0|            0|  0.00%|
  4269|         0|            0|            0|  0.00%|                Read more about it in the
  4270|         0|            0|            0|  0.00%|                [FastAPI docs for Custom Response - HTML, Stream, File, others](https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse).
  4271|         0|            0|            0|  0.00%|                """
  4272|         0|            0|            0|  0.00%|            ),
  4273|         0|            0|            0|  0.00%|        ] = Default(JSONResponse),
  4274|         0|            0|            0|  0.00%|        name: Annotated[
  4275|         0|            0|            0|  0.00%|            Optional[str],
  4276|         0|            0|            0|  0.00%|            Doc(
  4277|         0|            0|            0|  0.00%|                """
  4278|         0|            0|            0|  0.00%|                Name for this *path operation*. Only used internally.
  4279|         0|            0|            0|  0.00%|                """
  4280|         0|            0|            0|  0.00%|            ),
  4281|         0|            0|            0|  0.00%|        ] = None,
  4282|         0|            0|            0|  0.00%|        callbacks: Annotated[
  4283|         0|            0|            0|  0.00%|            Optional[List[BaseRoute]],
  4284|         0|            0|            0|  0.00%|            Doc(
  4285|         0|            0|            0|  0.00%|                """
  4286|         0|            0|            0|  0.00%|                List of *path operations* that will be used as OpenAPI callbacks.
  4287|         0|            0|            0|  0.00%|
  4288|         0|            0|            0|  0.00%|                This is only for OpenAPI documentation, the callbacks won't be used
  4289|         0|            0|            0|  0.00%|                directly.
  4290|         0|            0|            0|  0.00%|
  4291|         0|            0|            0|  0.00%|                It will be added to the generated OpenAPI (e.g. visible at `/docs`).
  4292|         0|            0|            0|  0.00%|
  4293|         0|            0|            0|  0.00%|                Read more about it in the
  4294|         0|            0|            0|  0.00%|                [FastAPI docs for OpenAPI Callbacks](https://fastapi.tiangolo.com/advanced/openapi-callbacks/).
  4295|         0|            0|            0|  0.00%|                """
  4296|         0|            0|            0|  0.00%|            ),
  4297|         0|            0|            0|  0.00%|        ] = None,
  4298|         0|            0|            0|  0.00%|        openapi_extra: Annotated[
  4299|         0|            0|            0|  0.00%|            Optional[Dict[str, Any]],
  4300|         0|            0|            0|  0.00%|            Doc(
  4301|         0|            0|            0|  0.00%|                """
  4302|         0|            0|            0|  0.00%|                Extra metadata to be included in the OpenAPI schema for this *path
  4303|         0|            0|            0|  0.00%|                operation*.
  4304|         0|            0|            0|  0.00%|
  4305|         0|            0|            0|  0.00%|                Read more about it in the
  4306|         0|            0|            0|  0.00%|                [FastAPI docs for Path Operation Advanced Configuration](https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/#custom-openapi-path-operation-schema).
  4307|         0|            0|            0|  0.00%|                """
  4308|         0|            0|            0|  0.00%|            ),
  4309|         0|            0|            0|  0.00%|        ] = None,
  4310|         0|            0|            0|  0.00%|        generate_unique_id_function: Annotated[
  4311|         0|            0|            0|  0.00%|            Callable[[APIRoute], str],
  4312|         0|            0|            0|  0.00%|            Doc(
  4313|         0|            0|            0|  0.00%|                """
  4314|         0|            0|            0|  0.00%|                Customize the function used to generate unique IDs for the *path
  4315|         0|            0|            0|  0.00%|                operations* shown in the generated OpenAPI.
  4316|         0|            0|            0|  0.00%|
  4317|         0|            0|            0|  0.00%|                This is particularly useful when automatically generating clients or
  4318|         0|            0|            0|  0.00%|                SDKs for your API.
  4319|         0|            0|            0|  0.00%|
  4320|         0|            0|            0|  0.00%|                Read more about it in the
  4321|         0|            0|            0|  0.00%|                [FastAPI docs about how to Generate Clients](https://fastapi.tiangolo.com/advanced/generate-clients/#custom-generate-unique-id-function).
  4322|         0|            0|            0|  0.00%|                """
  4323|         0|            0|            0|  0.00%|            ),
  4324|         0|            0|            0|  0.00%|        ] = Default(generate_unique_id),
  4325|         0|            0|            0|  0.00%|    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
  4326|         0|            0|            0|  0.00%|        """
  4327|         0|            0|            0|  0.00%|        Add a *path operation* using an HTTP TRACE operation.
  4328|         0|            0|            0|  0.00%|
  4329|         0|            0|            0|  0.00%|        ## Example
  4330|         0|            0|            0|  0.00%|
  4331|         0|            0|            0|  0.00%|        ```python
  4332|         0|            0|            0|  0.00%|        from fastapi import APIRouter, FastAPI
  4333|         0|            0|            0|  0.00%|        from pydantic import BaseModel
  4334|         0|            0|            0|  0.00%|
  4335|         0|            0|            0|  0.00%|        class Item(BaseModel):
  4336|         0|            0|            0|  0.00%|            name: str
  4337|         0|            0|            0|  0.00%|            description: str | None = None
  4338|         0|            0|            0|  0.00%|
  4339|         0|            0|            0|  0.00%|        app = FastAPI()
  4340|         0|            0|            0|  0.00%|        router = APIRouter()
  4341|         0|            0|            0|  0.00%|
  4342|         0|            0|            0|  0.00%|        @router.trace("/items/{item_id}")
  4343|         0|            0|            0|  0.00%|        def trace_item(item_id: str):
  4344|         0|            0|            0|  0.00%|            return None
  4345|         0|            0|            0|  0.00%|
  4346|         0|            0|            0|  0.00%|        app.include_router(router)
  4347|         0|            0|            0|  0.00%|        ```
  4348|         0|            0|            0|  0.00%|        """
  4349|         0|            0|            0|  0.00%|        return self.api_route(
  4350|         0|            0|            0|  0.00%|            path=path,
  4351|         0|            0|            0|  0.00%|            response_model=response_model,
  4352|         0|            0|            0|  0.00%|            status_code=status_code,
  4353|         0|            0|            0|  0.00%|            tags=tags,
  4354|         0|            0|            0|  0.00%|            dependencies=dependencies,
  4355|         0|            0|            0|  0.00%|            summary=summary,
  4356|         0|            0|            0|  0.00%|            description=description,
  4357|         0|            0|            0|  0.00%|            response_description=response_description,
  4358|         0|            0|            0|  0.00%|            responses=responses,
  4359|         0|            0|            0|  0.00%|            deprecated=deprecated,
  4360|         0|            0|            0|  0.00%|            methods=["TRACE"],
  4361|         0|            0|            0|  0.00%|            operation_id=operation_id,
  4362|         0|            0|            0|  0.00%|            response_model_include=response_model_include,
  4363|         0|            0|            0|  0.00%|            response_model_exclude=response_model_exclude,
  4364|         0|            0|            0|  0.00%|            response_model_by_alias=response_model_by_alias,
  4365|         0|            0|            0|  0.00%|            response_model_exclude_unset=response_model_exclude_unset,
  4366|         0|            0|            0|  0.00%|            response_model_exclude_defaults=response_model_exclude_defaults,
  4367|         0|            0|            0|  0.00%|            response_model_exclude_none=response_model_exclude_none,
  4368|         0|            0|            0|  0.00%|            include_in_schema=include_in_schema,
  4369|         0|            0|            0|  0.00%|            response_class=response_class,
  4370|         0|            0|            0|  0.00%|            name=name,
  4371|         0|            0|            0|  0.00%|            callbacks=callbacks,
  4372|         0|            0|            0|  0.00%|            openapi_extra=openapi_extra,
  4373|         0|            0|            0|  0.00%|            generate_unique_id_function=generate_unique_id_function,
  4374|         0|            0|            0|  0.00%|        )
  4375|         0|            0|            0|  0.00%|
  4376|         0|            0|            0|  0.00%|    @deprecated(
  4377|         0|            0|            0|  0.00%|        """
  4378|         0|            0|            0|  0.00%|        on_event is deprecated, use lifespan event handlers instead.
  4379|         0|            0|            0|  0.00%|
  4380|         0|            0|            0|  0.00%|        Read more about it in the
  4381|         0|            0|            0|  0.00%|        [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
  4382|         0|            0|            0|  0.00%|        """
  4383|         0|            0|            0|  0.00%|    )
  4384|         0|            0|            0|  0.00%|    def on_event(
  4385|         0|            0|            0|  0.00%|        self,
  4386|         0|            0|            0|  0.00%|        event_type: Annotated[
  4387|         0|            0|            0|  0.00%|            str,
  4388|         0|            0|            0|  0.00%|            Doc(
  4389|         0|            0|            0|  0.00%|                """
  4390|         0|            0|            0|  0.00%|                The type of event. `startup` or `shutdown`.
  4391|         0|            0|            0|  0.00%|                """
  4392|         0|            0|            0|  0.00%|            ),
  4393|         0|            0|            0|  0.00%|        ],
  4394|         0|            0|            0|  0.00%|    ) -> Callable[[DecoratedCallable], DecoratedCallable]:
  4395|         0|            0|            0|  0.00%|        """
  4396|         0|            0|            0|  0.00%|        Add an event handler for the router.
  4397|         0|            0|            0|  0.00%|
  4398|         0|            0|            0|  0.00%|        `on_event` is deprecated, use `lifespan` event handlers instead.
  4399|         0|            0|            0|  0.00%|
  4400|         0|            0|            0|  0.00%|        Read more about it in the
  4401|         0|            0|            0|  0.00%|        [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/#alternative-events-deprecated).
  4402|         0|            0|            0|  0.00%|        """
  4403|         0|            0|            0|  0.00%|
  4404|         0|            0|            0|  0.00%|        def decorator(func: DecoratedCallable) -> DecoratedCallable:
  4405|         0|            0|            0|  0.00%|            self.add_event_handler(event_type, func)
  4406|         0|            0|            0|  0.00%|            return func
  4407|         0|            0|            0|  0.00%|
  4408|         0|            0|            0|  0.00%|        return decorator
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/copyreg.py
File duration: 0.000241041s (0.25%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Helper to provide extensibility for pickle.
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|This is only useful to add pickle support for extension types defined in
     4|         0|            0|            0|  0.00%|C, not for instances of user-defined classes.
     5|         0|            0|            0|  0.00%|"""
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|__all__ = ["pickle", "constructor",
     8|         0|            0|            0|  0.00%|           "add_extension", "remove_extension", "clear_extension_cache"]
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|dispatch_table = {}
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|def pickle(ob_type, pickle_function, constructor_ob=None):
    13|         0|            0|            0|  0.00%|    if not callable(pickle_function):
    14|         0|            0|            0|  0.00%|        raise TypeError("reduction functions must be callable")
    15|         0|            0|            0|  0.00%|    dispatch_table[ob_type] = pickle_function
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|    # The constructor_ob function is a vestige of safe for unpickling.
    18|         0|            0|            0|  0.00%|    # There is no reason for the caller to pass it anymore.
    19|         0|            0|            0|  0.00%|    if constructor_ob is not None:
    20|         0|            0|            0|  0.00%|        constructor(constructor_ob)
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|def constructor(object):
    23|         0|            0|            0|  0.00%|    if not callable(object):
    24|         0|            0|            0|  0.00%|        raise TypeError("constructors must be callable")
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|# Example: provide pickling support for complex numbers.
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|def pickle_complex(c):
    29|         0|            0|            0|  0.00%|    return complex, (c.real, c.imag)
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|pickle(complex, pickle_complex, complex)
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|def pickle_union(obj):
    34|         0|            0|            0|  0.00%|    import functools, operator
    35|         0|            0|            0|  0.00%|    return functools.reduce, (operator.or_, obj.__args__)
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|pickle(type(int | str), pickle_union)
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|# Support for pickling new-style objects
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|def _reconstructor(cls, base, state):
    42|         0|            0|            0|  0.00%|    if base is object:
    43|         0|            0|            0|  0.00%|        obj = object.__new__(cls)
    44|         0|            0|            0|  0.00%|    else:
    45|         0|            0|            0|  0.00%|        obj = base.__new__(cls, state)
    46|         0|            0|            0|  0.00%|        if base.__init__ != object.__init__:
    47|         0|            0|            0|  0.00%|            base.__init__(obj, state)
    48|         0|            0|            0|  0.00%|    return obj
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|_HEAPTYPE = 1<<9
    51|         0|            0|            0|  0.00%|_new_type = type(int.__new__)
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|# Python code for object.__reduce_ex__ for protocols 0 and 1
    54|         0|            0|            0|  0.00%|
    55|         0|            0|            0|  0.00%|def _reduce_ex(self, proto):
    56|         0|            0|            0|  0.00%|    assert proto < 2
    57|         0|            0|            0|  0.00%|    cls = self.__class__
    58|         0|            0|            0|  0.00%|    for base in cls.__mro__:
    59|         0|            0|            0|  0.00%|        if hasattr(base, '__flags__') and not base.__flags__ & _HEAPTYPE:
    60|         0|            0|            0|  0.00%|            break
    61|         0|            0|            0|  0.00%|        new = base.__new__
    62|         0|            0|            0|  0.00%|        if isinstance(new, _new_type) and new.__self__ is base:
    63|         0|            0|            0|  0.00%|            break
    64|         0|            0|            0|  0.00%|    else:
    65|         0|            0|            0|  0.00%|        base = object # not really reachable
    66|         0|            0|            0|  0.00%|    if base is object:
    67|         0|            0|            0|  0.00%|        state = None
    68|         0|            0|            0|  0.00%|    else:
    69|         0|            0|            0|  0.00%|        if base is cls:
    70|         0|            0|            0|  0.00%|            raise TypeError(f"cannot pickle {cls.__name__!r} object")
    71|         0|            0|            0|  0.00%|        state = base(self)
    72|         0|            0|            0|  0.00%|    args = (cls, base, state)
    73|         0|            0|            0|  0.00%|    try:
    74|         0|            0|            0|  0.00%|        getstate = self.__getstate__
    75|         0|            0|            0|  0.00%|    except AttributeError:
    76|         0|            0|            0|  0.00%|        if getattr(self, "__slots__", None):
    77|         0|            0|            0|  0.00%|            raise TypeError(f"cannot pickle {cls.__name__!r} object: "
    78|         0|            0|            0|  0.00%|                            f"a class that defines __slots__ without "
    79|         0|            0|            0|  0.00%|                            f"defining __getstate__ cannot be pickled "
    80|         0|            0|            0|  0.00%|                            f"with protocol {proto}") from None
    81|         0|            0|            0|  0.00%|        try:
    82|         0|            0|            0|  0.00%|            dict = self.__dict__
    83|         0|            0|            0|  0.00%|        except AttributeError:
    84|         0|            0|            0|  0.00%|            dict = None
    85|         0|            0|            0|  0.00%|    else:
    86|         0|            0|            0|  0.00%|        if (type(self).__getstate__ is object.__getstate__ and
    87|         0|            0|            0|  0.00%|            getattr(self, "__slots__", None)):
    88|         0|            0|            0|  0.00%|            raise TypeError("a class that defines __slots__ without "
    89|         0|            0|            0|  0.00%|                            "defining __getstate__ cannot be pickled")
    90|         0|            0|            0|  0.00%|        dict = getstate()
    91|         0|            0|            0|  0.00%|    if dict:
    92|         0|            0|            0|  0.00%|        return _reconstructor, args, dict
    93|         0|            0|            0|  0.00%|    else:
    94|         0|            0|            0|  0.00%|        return _reconstructor, args
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|# Helper for __reduce_ex__ protocol 2
    97|         0|            0|            0|  0.00%|
    98|         4|  1.33514e-05|  3.33786e-06|  0.01%|def __newobj__(cls, *args):
    99|         4|  1.09673e-05|  2.74181e-06|  0.01%|    return cls.__new__(cls, *args)
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|def __newobj_ex__(cls, args, kwargs):
   102|         0|            0|            0|  0.00%|    """Used by pickle protocol 4, instead of __newobj__ to allow classes with
   103|         0|            0|            0|  0.00%|    keyword-only arguments to be pickled correctly.
   104|         0|            0|            0|  0.00%|    """
   105|         0|            0|            0|  0.00%|    return cls.__new__(cls, *args, **kwargs)
   106|         0|            0|            0|  0.00%|
   107|         1|  5.96046e-06|  5.96046e-06|  0.01%|def _slotnames(cls):
   108|         0|            0|            0|  0.00%|    """Return a list of slot names for a given class.
   109|         0|            0|            0|  0.00%|
   110|         0|            0|            0|  0.00%|    This needs to find slots defined by the class and its bases, so we
   111|         0|            0|            0|  0.00%|    can't simply return the __slots__ attribute.  We must walk down
   112|         0|            0|            0|  0.00%|    the Method Resolution Order and concatenate the __slots__ of each
   113|         0|            0|            0|  0.00%|    class found there.  (This assumes classes don't modify their
   114|         0|            0|            0|  0.00%|    __slots__ attribute to misrepresent their slots after the class is
   115|         0|            0|            0|  0.00%|    defined.)
   116|         0|            0|            0|  0.00%|    """
   117|         0|            0|            0|  0.00%|
   118|         0|            0|            0|  0.00%|    # Get the value from a cache in the class if possible
   119|         1|  4.52995e-06|  4.52995e-06|  0.00%|    names = cls.__dict__.get("__slotnames__")
   120|         1|  2.86102e-06|  2.86102e-06|  0.00%|    if names is not None:
   121|         0|            0|            0|  0.00%|        return names
   122|         0|            0|            0|  0.00%|
   123|         0|            0|            0|  0.00%|    # Not cached -- calculate the value
   124|         1|  3.09944e-06|  3.09944e-06|  0.00%|    names = []
   125|         1|  4.05312e-06|  4.05312e-06|  0.00%|    if not hasattr(cls, "__slots__"):
   126|         0|            0|            0|  0.00%|        # This class has no slots
   127|         0|            0|            0|  0.00%|        pass
   128|         0|            0|            0|  0.00%|    else:
   129|         0|            0|            0|  0.00%|        # Slots found -- gather slot names from all base classes
   130|         6|  1.16825e-05|  1.94709e-06|  0.01%|        for c in cls.__mro__:
   131|         5|  1.00136e-05|  2.00272e-06|  0.01%|            if "__slots__" in c.__dict__:
   132|         2|  3.09944e-06|  1.54972e-06|  0.00%|                slots = c.__dict__['__slots__']
   133|         0|            0|            0|  0.00%|                # if class has a single slot, it can be given as a string
   134|         2|  6.67572e-06|  3.33786e-06|  0.01%|                if isinstance(slots, str):
   135|         0|            0|            0|  0.00%|                    slots = (slots,)
   136|        25|  4.86374e-05|   1.9455e-06|  0.05%|                for name in slots:
   137|         0|            0|            0|  0.00%|                    # special descriptors
   138|        23|  3.57628e-05|   1.5549e-06|  0.04%|                    if name in ("__dict__", "__weakref__"):
   139|         0|            0|            0|  0.00%|                        continue
   140|         0|            0|            0|  0.00%|                    # mangled names
   141|        23|  3.67165e-05|  1.59637e-06|  0.04%|                    elif name.startswith('__') and not name.endswith('__'):
   142|         0|            0|            0|  0.00%|                        stripped = c.__name__.lstrip('_')
   143|         0|            0|            0|  0.00%|                        if stripped:
   144|         0|            0|            0|  0.00%|                            names.append('_%s%s' % (stripped, name))
   145|         0|            0|            0|  0.00%|                        else:
   146|         0|            0|            0|  0.00%|                            names.append(name)
   147|         0|            0|            0|  0.00%|                    else:
   148|        23|  3.45707e-05|  1.50307e-06|  0.04%|                        names.append(name)
   149|         0|            0|            0|  0.00%|
   150|         0|            0|            0|  0.00%|    # Cache the outcome in the class if at all possible
   151|         1|  1.43051e-06|  1.43051e-06|  0.00%|    try:
   152|         1|  4.52995e-06|  4.52995e-06|  0.00%|        cls.__slotnames__ = names
   153|         0|            0|            0|  0.00%|    except:
   154|         0|            0|            0|  0.00%|        pass # But don't die if we can't
   155|         0|            0|            0|  0.00%|
   156|         1|  3.09944e-06|  3.09944e-06|  0.00%|    return names
   157|         0|            0|            0|  0.00%|
   158|         0|            0|            0|  0.00%|# A registry of extension codes.  This is an ad-hoc compression
   159|         0|            0|            0|  0.00%|# mechanism.  Whenever a global reference to <module>, <name> is about
   160|         0|            0|            0|  0.00%|# to be pickled, the (<module>, <name>) tuple is looked up here to see
   161|         0|            0|            0|  0.00%|# if it is a registered extension code for it.  Extension codes are
   162|         0|            0|            0|  0.00%|# universal, so that the meaning of a pickle does not depend on
   163|         0|            0|            0|  0.00%|# context.  (There are also some codes reserved for local use that
   164|         0|            0|            0|  0.00%|# don't have this restriction.)  Codes are positive ints; 0 is
   165|         0|            0|            0|  0.00%|# reserved.
   166|         0|            0|            0|  0.00%|
   167|         0|            0|            0|  0.00%|_extension_registry = {}                # key -> code
   168|         0|            0|            0|  0.00%|_inverted_registry = {}                 # code -> key
   169|         0|            0|            0|  0.00%|_extension_cache = {}                   # code -> object
   170|         0|            0|            0|  0.00%|# Don't ever rebind those names:  pickling grabs a reference to them when
   171|         0|            0|            0|  0.00%|# it's initialized, and won't see a rebinding.
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|def add_extension(module, name, code):
   174|         0|            0|            0|  0.00%|    """Register an extension code."""
   175|         0|            0|            0|  0.00%|    code = int(code)
   176|         0|            0|            0|  0.00%|    if not 1 <= code <= 0x7fffffff:
   177|         0|            0|            0|  0.00%|        raise ValueError("code out of range")
   178|         0|            0|            0|  0.00%|    key = (module, name)
   179|         0|            0|            0|  0.00%|    if (_extension_registry.get(key) == code and
   180|         0|            0|            0|  0.00%|        _inverted_registry.get(code) == key):
   181|         0|            0|            0|  0.00%|        return # Redundant registrations are benign
   182|         0|            0|            0|  0.00%|    if key in _extension_registry:
   183|         0|            0|            0|  0.00%|        raise ValueError("key %s is already registered with code %s" %
   184|         0|            0|            0|  0.00%|                         (key, _extension_registry[key]))
   185|         0|            0|            0|  0.00%|    if code in _inverted_registry:
   186|         0|            0|            0|  0.00%|        raise ValueError("code %s is already in use for key %s" %
   187|         0|            0|            0|  0.00%|                         (code, _inverted_registry[code]))
   188|         0|            0|            0|  0.00%|    _extension_registry[key] = code
   189|         0|            0|            0|  0.00%|    _inverted_registry[code] = key
   190|         0|            0|            0|  0.00%|
   191|         0|            0|            0|  0.00%|def remove_extension(module, name, code):
   192|         0|            0|            0|  0.00%|    """Unregister an extension code.  For testing only."""
   193|         0|            0|            0|  0.00%|    key = (module, name)
   194|         0|            0|            0|  0.00%|    if (_extension_registry.get(key) != code or
   195|         0|            0|            0|  0.00%|        _inverted_registry.get(code) != key):
   196|         0|            0|            0|  0.00%|        raise ValueError("key %s is not registered with code %s" %
   197|         0|            0|            0|  0.00%|                         (key, code))
   198|         0|            0|            0|  0.00%|    del _extension_registry[key]
   199|         0|            0|            0|  0.00%|    del _inverted_registry[code]
   200|         0|            0|            0|  0.00%|    if code in _extension_cache:
   201|         0|            0|            0|  0.00%|        del _extension_cache[code]
   202|         0|            0|            0|  0.00%|
   203|         0|            0|            0|  0.00%|def clear_extension_cache():
   204|         0|            0|            0|  0.00%|    _extension_cache.clear()
   205|         0|            0|            0|  0.00%|
   206|         0|            0|            0|  0.00%|# Standard extension code assignments
   207|         0|            0|            0|  0.00%|
   208|         0|            0|            0|  0.00%|# Reserved ranges
   209|         0|            0|            0|  0.00%|
   210|         0|            0|            0|  0.00%|# First  Last Count  Purpose
   211|         0|            0|            0|  0.00%|#     1   127   127  Reserved for Python standard library
   212|         0|            0|            0|  0.00%|#   128   191    64  Reserved for Zope
   213|         0|            0|            0|  0.00%|#   192   239    48  Reserved for 3rd parties
   214|         0|            0|            0|  0.00%|#   240   255    16  Reserved for private use (will never be assigned)
   215|         0|            0|            0|  0.00%|#   256   Inf   Inf  Reserved for future assignment
   216|         0|            0|            0|  0.00%|
   217|         0|            0|            0|  0.00%|# Extension codes are assigned by the Python Software Foundation.
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_repr.py
File duration: 0.000213146s (0.22%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Tools to provide pretty/human-readable display of objects."""
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|from __future__ import annotations as _annotations
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|import types
     6|         0|            0|            0|  0.00%|import typing
     7|         0|            0|            0|  0.00%|from typing import Any
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|import typing_extensions
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|from . import _typing_extra
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|if typing.TYPE_CHECKING:
    14|         0|            0|            0|  0.00%|    ReprArgs: typing_extensions.TypeAlias = 'typing.Iterable[tuple[str | None, Any]]'
    15|         0|            0|            0|  0.00%|    RichReprResult: typing_extensions.TypeAlias = (
    16|         0|            0|            0|  0.00%|        'typing.Iterable[Any | tuple[Any] | tuple[str, Any] | tuple[str, Any, Any]]'
    17|         0|            0|            0|  0.00%|    )
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|class PlainRepr(str):
    21|         0|            0|            0|  0.00%|    """String class where repr doesn't include quotes. Useful with Representation when you want to return a string
    22|         0|            0|            0|  0.00%|    representation of something that is valid (or pseudo-valid) python.
    23|         0|            0|            0|  0.00%|    """
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|    def __repr__(self) -> str:
    26|         0|            0|            0|  0.00%|        return str(self)
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|class Representation:
    30|         0|            0|            0|  0.00%|    # Mixin to provide `__str__`, `__repr__`, and `__pretty__` and `__rich_repr__` methods.
    31|         0|            0|            0|  0.00%|    # `__pretty__` is used by [devtools](https://python-devtools.helpmanual.io/).
    32|         0|            0|            0|  0.00%|    # `__rich_repr__` is used by [rich](https://rich.readthedocs.io/en/stable/pretty.html).
    33|         0|            0|            0|  0.00%|    # (this is not a docstring to avoid adding a docstring to classes which inherit from Representation)
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|    # we don't want to use a type annotation here as it can break get_type_hints
    36|         0|            0|            0|  0.00%|    __slots__ = tuple()  # type: typing.Collection[str]
    37|         0|            0|            0|  0.00%|
    38|         0|            0|            0|  0.00%|    def __repr_args__(self) -> ReprArgs:
    39|         0|            0|            0|  0.00%|        """Returns the attributes to show in __str__, __repr__, and __pretty__ this is generally overridden.
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|        Can either return:
    42|         0|            0|            0|  0.00%|        * name - value pairs, e.g.: `[('foo_name', 'foo'), ('bar_name', ['b', 'a', 'r'])]`
    43|         0|            0|            0|  0.00%|        * or, just values, e.g.: `[(None, 'foo'), (None, ['b', 'a', 'r'])]`
    44|         0|            0|            0|  0.00%|        """
    45|         0|            0|            0|  0.00%|        attrs_names = self.__slots__
    46|         0|            0|            0|  0.00%|        if not attrs_names and hasattr(self, '__dict__'):
    47|         0|            0|            0|  0.00%|            attrs_names = self.__dict__.keys()
    48|         0|            0|            0|  0.00%|        attrs = ((s, getattr(self, s)) for s in attrs_names)
    49|         0|            0|            0|  0.00%|        return [(a, v) for a, v in attrs if v is not None]
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|    def __repr_name__(self) -> str:
    52|         0|            0|            0|  0.00%|        """Name of the instance's class, used in __repr__."""
    53|         0|            0|            0|  0.00%|        return self.__class__.__name__
    54|         0|            0|            0|  0.00%|
    55|         0|            0|            0|  0.00%|    def __repr_str__(self, join_str: str) -> str:
    56|         0|            0|            0|  0.00%|        return join_str.join(repr(v) if a is None else f'{a}={v!r}' for a, v in self.__repr_args__())
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|    def __pretty__(self, fmt: typing.Callable[[Any], Any], **kwargs: Any) -> typing.Generator[Any, None, None]:
    59|         0|            0|            0|  0.00%|        """Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects."""
    60|         0|            0|            0|  0.00%|        yield self.__repr_name__() + '('
    61|         0|            0|            0|  0.00%|        yield 1
    62|         0|            0|            0|  0.00%|        for name, value in self.__repr_args__():
    63|         0|            0|            0|  0.00%|            if name is not None:
    64|         0|            0|            0|  0.00%|                yield name + '='
    65|         0|            0|            0|  0.00%|            yield fmt(value)
    66|         0|            0|            0|  0.00%|            yield ','
    67|         0|            0|            0|  0.00%|            yield 0
    68|         0|            0|            0|  0.00%|        yield -1
    69|         0|            0|            0|  0.00%|        yield ')'
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|    def __rich_repr__(self) -> RichReprResult:
    72|         0|            0|            0|  0.00%|        """Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects."""
    73|         0|            0|            0|  0.00%|        for name, field_repr in self.__repr_args__():
    74|         0|            0|            0|  0.00%|            if name is None:
    75|         0|            0|            0|  0.00%|                yield field_repr
    76|         0|            0|            0|  0.00%|            else:
    77|         0|            0|            0|  0.00%|                yield name, field_repr
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|    def __str__(self) -> str:
    80|         0|            0|            0|  0.00%|        return self.__repr_str__(' ')
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|    def __repr__(self) -> str:
    83|         0|            0|            0|  0.00%|        return f'{self.__repr_name__()}({self.__repr_str__(", ")})'
    84|         0|            0|            0|  0.00%|
    85|         0|            0|            0|  0.00%|
    86|         4|  1.69277e-05|  4.23193e-06|  0.02%|def display_as_type(obj: Any) -> str:
    87|         0|            0|            0|  0.00%|    """Pretty representation of a type, should be as close as possible to the original type definition string.
    88|         0|            0|            0|  0.00%|
    89|         0|            0|            0|  0.00%|    Takes some logic from `typing._type_repr`.
    90|         0|            0|            0|  0.00%|    """
    91|         4|  1.50204e-05|  3.75509e-06|  0.02%|    if isinstance(obj, types.FunctionType):
    92|         0|            0|            0|  0.00%|        return obj.__name__
    93|         4|  9.77516e-06|  2.44379e-06|  0.01%|    elif obj is ...:
    94|         0|            0|            0|  0.00%|        return '...'
    95|         4|  8.82149e-06|  2.20537e-06|  0.01%|    elif isinstance(obj, Representation):
    96|         2|  1.83582e-05|  9.17912e-06|  0.02%|        return repr(obj)
(call)|         2|  1.52588e-05|  7.62939e-06|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/params.py:131 __repr__
    97|         2|  6.19888e-06|  3.09944e-06|  0.01%|    elif isinstance(obj, typing_extensions.TypeAliasType):
    98|         0|            0|            0|  0.00%|        return str(obj)
    99|         0|            0|            0|  0.00%|
   100|         2|  5.72205e-06|  2.86102e-06|  0.01%|    if not isinstance(obj, (_typing_extra.typing_base, _typing_extra.WithArgsTypes, type)):
   101|         0|            0|            0|  0.00%|        obj = obj.__class__
   102|         0|            0|            0|  0.00%|
   103|         2|  0.000114679|  5.73397e-05|  0.12%|    if _typing_extra.origin_is_union(typing_extensions.get_origin(obj)):
(call)|         2|  2.52724e-05|  1.26362e-05|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:2310 get_origin
(call)|         2|  9.53674e-06|  4.76837e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_typing_extra.py:51 origin_is_union
   104|         0|            0|            0|  0.00%|        args = ', '.join(map(display_as_type, typing_extensions.get_args(obj)))
   105|         0|            0|            0|  0.00%|        return f'Union[{args}]'
   106|         2|  6.19888e-06|  3.09944e-06|  0.01%|    elif isinstance(obj, _typing_extra.WithArgsTypes):
   107|         0|            0|            0|  0.00%|        if typing_extensions.get_origin(obj) == typing_extensions.Literal:
   108|         0|            0|            0|  0.00%|            args = ', '.join(map(repr, typing_extensions.get_args(obj)))
   109|         0|            0|            0|  0.00%|        else:
   110|         0|            0|            0|  0.00%|            args = ', '.join(map(display_as_type, typing_extensions.get_args(obj)))
   111|         0|            0|            0|  0.00%|        try:
   112|         0|            0|            0|  0.00%|            return f'{obj.__qualname__}[{args}]'
   113|         0|            0|            0|  0.00%|        except AttributeError:
   114|         0|            0|            0|  0.00%|            return str(obj)  # handles TypeAliasType in 3.12
   115|         2|  5.24521e-06|   2.6226e-06|  0.01%|    elif isinstance(obj, type):
   116|         2|  6.19888e-06|  3.09944e-06|  0.01%|        return obj.__qualname__
   117|         0|            0|            0|  0.00%|    else:
   118|         0|            0|            0|  0.00%|        return repr(obj).replace('typing.', '').replace('typing_extensions.', '')
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/__init__.py
File duration: 0.000203371s (0.21%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|#
     2|         0|            0|            0|  0.00%|# Secret Labs' Regular Expression Engine
     3|         0|            0|            0|  0.00%|#
     4|         0|            0|            0|  0.00%|# re-compatible interface for the sre matching engine
     5|         0|            0|            0|  0.00%|#
     6|         0|            0|            0|  0.00%|# Copyright (c) 1998-2001 by Secret Labs AB.  All rights reserved.
     7|         0|            0|            0|  0.00%|#
     8|         0|            0|            0|  0.00%|# This version of the SRE library can be redistributed under CNRI's
     9|         0|            0|            0|  0.00%|# Python 1.6 license.  For any other use, please contact Secret Labs
    10|         0|            0|            0|  0.00%|# AB (info@pythonware.com).
    11|         0|            0|            0|  0.00%|#
    12|         0|            0|            0|  0.00%|# Portions of this engine have been developed in cooperation with
    13|         0|            0|            0|  0.00%|# CNRI.  Hewlett-Packard provided funding for 1.6 integration and
    14|         0|            0|            0|  0.00%|# other compatibility work.
    15|         0|            0|            0|  0.00%|#
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|r"""Support for regular expressions (RE).
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|This module provides regular expression matching operations similar to
    20|         0|            0|            0|  0.00%|those found in Perl.  It supports both 8-bit and Unicode strings; both
    21|         0|            0|            0|  0.00%|the pattern and the strings being processed can contain null bytes and
    22|         0|            0|            0|  0.00%|characters outside the US ASCII range.
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|Regular expressions can contain both special and ordinary characters.
    25|         0|            0|            0|  0.00%|Most ordinary characters, like "A", "a", or "0", are the simplest
    26|         0|            0|            0|  0.00%|regular expressions; they simply match themselves.  You can
    27|         0|            0|            0|  0.00%|concatenate ordinary characters, so last matches the string 'last'.
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|The special characters are:
    30|         0|            0|            0|  0.00%|    "."      Matches any character except a newline.
    31|         0|            0|            0|  0.00%|    "^"      Matches the start of the string.
    32|         0|            0|            0|  0.00%|    "$"      Matches the end of the string or just before the newline at
    33|         0|            0|            0|  0.00%|             the end of the string.
    34|         0|            0|            0|  0.00%|    "*"      Matches 0 or more (greedy) repetitions of the preceding RE.
    35|         0|            0|            0|  0.00%|             Greedy means that it will match as many repetitions as possible.
    36|         0|            0|            0|  0.00%|    "+"      Matches 1 or more (greedy) repetitions of the preceding RE.
    37|         0|            0|            0|  0.00%|    "?"      Matches 0 or 1 (greedy) of the preceding RE.
    38|         0|            0|            0|  0.00%|    *?,+?,?? Non-greedy versions of the previous three special characters.
    39|         0|            0|            0|  0.00%|    {m,n}    Matches from m to n repetitions of the preceding RE.
    40|         0|            0|            0|  0.00%|    {m,n}?   Non-greedy version of the above.
    41|         0|            0|            0|  0.00%|    "\\"     Either escapes special characters or signals a special sequence.
    42|         0|            0|            0|  0.00%|    []       Indicates a set of characters.
    43|         0|            0|            0|  0.00%|             A "^" as the first character indicates a complementing set.
    44|         0|            0|            0|  0.00%|    "|"      A|B, creates an RE that will match either A or B.
    45|         0|            0|            0|  0.00%|    (...)    Matches the RE inside the parentheses.
    46|         0|            0|            0|  0.00%|             The contents can be retrieved or matched later in the string.
    47|         0|            0|            0|  0.00%|    (?aiLmsux) The letters set the corresponding flags defined below.
    48|         0|            0|            0|  0.00%|    (?:...)  Non-grouping version of regular parentheses.
    49|         0|            0|            0|  0.00%|    (?P<name>...) The substring matched by the group is accessible by name.
    50|         0|            0|            0|  0.00%|    (?P=name)     Matches the text matched earlier by the group named name.
    51|         0|            0|            0|  0.00%|    (?#...)  A comment; ignored.
    52|         0|            0|            0|  0.00%|    (?=...)  Matches if ... matches next, but doesn't consume the string.
    53|         0|            0|            0|  0.00%|    (?!...)  Matches if ... doesn't match next.
    54|         0|            0|            0|  0.00%|    (?<=...) Matches if preceded by ... (must be fixed length).
    55|         0|            0|            0|  0.00%|    (?<!...) Matches if not preceded by ... (must be fixed length).
    56|         0|            0|            0|  0.00%|    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,
    57|         0|            0|            0|  0.00%|                       the (optional) no pattern otherwise.
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|The special sequences consist of "\\" and a character from the list
    60|         0|            0|            0|  0.00%|below.  If the ordinary character is not on the list, then the
    61|         0|            0|            0|  0.00%|resulting RE will match the second character.
    62|         0|            0|            0|  0.00%|    \number  Matches the contents of the group of the same number.
    63|         0|            0|            0|  0.00%|    \A       Matches only at the start of the string.
    64|         0|            0|            0|  0.00%|    \Z       Matches only at the end of the string.
    65|         0|            0|            0|  0.00%|    \b       Matches the empty string, but only at the start or end of a word.
    66|         0|            0|            0|  0.00%|    \B       Matches the empty string, but not at the start or end of a word.
    67|         0|            0|            0|  0.00%|    \d       Matches any decimal digit; equivalent to the set [0-9] in
    68|         0|            0|            0|  0.00%|             bytes patterns or string patterns with the ASCII flag.
    69|         0|            0|            0|  0.00%|             In string patterns without the ASCII flag, it will match the whole
    70|         0|            0|            0|  0.00%|             range of Unicode digits.
    71|         0|            0|            0|  0.00%|    \D       Matches any non-digit character; equivalent to [^\d].
    72|         0|            0|            0|  0.00%|    \s       Matches any whitespace character; equivalent to [ \t\n\r\f\v] in
    73|         0|            0|            0|  0.00%|             bytes patterns or string patterns with the ASCII flag.
    74|         0|            0|            0|  0.00%|             In string patterns without the ASCII flag, it will match the whole
    75|         0|            0|            0|  0.00%|             range of Unicode whitespace characters.
    76|         0|            0|            0|  0.00%|    \S       Matches any non-whitespace character; equivalent to [^\s].
    77|         0|            0|            0|  0.00%|    \w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]
    78|         0|            0|            0|  0.00%|             in bytes patterns or string patterns with the ASCII flag.
    79|         0|            0|            0|  0.00%|             In string patterns without the ASCII flag, it will match the
    80|         0|            0|            0|  0.00%|             range of Unicode alphanumeric characters (letters plus digits
    81|         0|            0|            0|  0.00%|             plus underscore).
    82|         0|            0|            0|  0.00%|             With LOCALE, it will match the set [0-9_] plus characters defined
    83|         0|            0|            0|  0.00%|             as letters for the current locale.
    84|         0|            0|            0|  0.00%|    \W       Matches the complement of \w.
    85|         0|            0|            0|  0.00%|    \\       Matches a literal backslash.
    86|         0|            0|            0|  0.00%|
    87|         0|            0|            0|  0.00%|This module exports the following functions:
    88|         0|            0|            0|  0.00%|    match     Match a regular expression pattern to the beginning of a string.
    89|         0|            0|            0|  0.00%|    fullmatch Match a regular expression pattern to all of a string.
    90|         0|            0|            0|  0.00%|    search    Search a string for the presence of a pattern.
    91|         0|            0|            0|  0.00%|    sub       Substitute occurrences of a pattern found in a string.
    92|         0|            0|            0|  0.00%|    subn      Same as sub, but also return the number of substitutions made.
    93|         0|            0|            0|  0.00%|    split     Split a string by the occurrences of a pattern.
    94|         0|            0|            0|  0.00%|    findall   Find all occurrences of a pattern in a string.
    95|         0|            0|            0|  0.00%|    finditer  Return an iterator yielding a Match object for each match.
    96|         0|            0|            0|  0.00%|    compile   Compile a pattern into a Pattern object.
    97|         0|            0|            0|  0.00%|    purge     Clear the regular expression cache.
    98|         0|            0|            0|  0.00%|    escape    Backslash all non-alphanumerics in a string.
    99|         0|            0|            0|  0.00%|
   100|         0|            0|            0|  0.00%|Each function other than purge and escape can take an optional 'flags' argument
   101|         0|            0|            0|  0.00%|consisting of one or more of the following module constants, joined by "|".
   102|         0|            0|            0|  0.00%|A, L, and U are mutually exclusive.
   103|         0|            0|            0|  0.00%|    A  ASCII       For string patterns, make \w, \W, \b, \B, \d, \D
   104|         0|            0|            0|  0.00%|                   match the corresponding ASCII character categories
   105|         0|            0|            0|  0.00%|                   (rather than the whole Unicode categories, which is the
   106|         0|            0|            0|  0.00%|                   default).
   107|         0|            0|            0|  0.00%|                   For bytes patterns, this flag is the only available
   108|         0|            0|            0|  0.00%|                   behaviour and needn't be specified.
   109|         0|            0|            0|  0.00%|    I  IGNORECASE  Perform case-insensitive matching.
   110|         0|            0|            0|  0.00%|    L  LOCALE      Make \w, \W, \b, \B, dependent on the current locale.
   111|         0|            0|            0|  0.00%|    M  MULTILINE   "^" matches the beginning of lines (after a newline)
   112|         0|            0|            0|  0.00%|                   as well as the string.
   113|         0|            0|            0|  0.00%|                   "$" matches the end of lines (before a newline) as well
   114|         0|            0|            0|  0.00%|                   as the end of the string.
   115|         0|            0|            0|  0.00%|    S  DOTALL      "." matches any character at all, including the newline.
   116|         0|            0|            0|  0.00%|    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.
   117|         0|            0|            0|  0.00%|    U  UNICODE     For compatibility only. Ignored for string patterns (it
   118|         0|            0|            0|  0.00%|                   is the default), and forbidden for bytes patterns.
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|This module also defines an exception 'error'.
   121|         0|            0|            0|  0.00%|
   122|         0|            0|            0|  0.00%|"""
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|import enum
   125|         0|            0|            0|  0.00%|from . import _compiler, _parser
   126|         0|            0|            0|  0.00%|import functools
   127|         0|            0|            0|  0.00%|import _sre
   128|         0|            0|            0|  0.00%|
   129|         0|            0|            0|  0.00%|
   130|         0|            0|            0|  0.00%|# public symbols
   131|         0|            0|            0|  0.00%|__all__ = [
   132|         0|            0|            0|  0.00%|    "match", "fullmatch", "search", "sub", "subn", "split",
   133|         0|            0|            0|  0.00%|    "findall", "finditer", "compile", "purge", "template", "escape",
   134|         0|            0|            0|  0.00%|    "error", "Pattern", "Match", "A", "I", "L", "M", "S", "X", "U",
   135|         0|            0|            0|  0.00%|    "ASCII", "IGNORECASE", "LOCALE", "MULTILINE", "DOTALL", "VERBOSE",
   136|         0|            0|            0|  0.00%|    "UNICODE", "NOFLAG", "RegexFlag",
   137|         0|            0|            0|  0.00%|]
   138|         0|            0|            0|  0.00%|
   139|         0|            0|            0|  0.00%|__version__ = "2.2.1"
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|@enum.global_enum
   142|         0|            0|            0|  0.00%|@enum._simple_enum(enum.IntFlag, boundary=enum.KEEP)
   143|         0|            0|            0|  0.00%|class RegexFlag:
   144|         0|            0|            0|  0.00%|    NOFLAG = 0
   145|         0|            0|            0|  0.00%|    ASCII = A = _compiler.SRE_FLAG_ASCII # assume ascii "locale"
   146|         0|            0|            0|  0.00%|    IGNORECASE = I = _compiler.SRE_FLAG_IGNORECASE # ignore case
   147|         0|            0|            0|  0.00%|    LOCALE = L = _compiler.SRE_FLAG_LOCALE # assume current 8-bit locale
   148|         0|            0|            0|  0.00%|    UNICODE = U = _compiler.SRE_FLAG_UNICODE # assume unicode "locale"
   149|         0|            0|            0|  0.00%|    MULTILINE = M = _compiler.SRE_FLAG_MULTILINE # make anchors look for newline
   150|         0|            0|            0|  0.00%|    DOTALL = S = _compiler.SRE_FLAG_DOTALL # make dot match newline
   151|         0|            0|            0|  0.00%|    VERBOSE = X = _compiler.SRE_FLAG_VERBOSE # ignore whitespace and comments
   152|         0|            0|            0|  0.00%|    # sre extensions (experimental, don't rely on these)
   153|         0|            0|            0|  0.00%|    TEMPLATE = T = _compiler.SRE_FLAG_TEMPLATE # unknown purpose, deprecated
   154|         0|            0|            0|  0.00%|    DEBUG = _compiler.SRE_FLAG_DEBUG # dump pattern after compilation
   155|         0|            0|            0|  0.00%|    __str__ = object.__str__
   156|         0|            0|            0|  0.00%|    _numeric_repr_ = hex
   157|         0|            0|            0|  0.00%|
   158|         0|            0|            0|  0.00%|# sre exception
   159|         0|            0|            0|  0.00%|error = _compiler.error
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|# --------------------------------------------------------------------
   162|         0|            0|            0|  0.00%|# public interface
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|def match(pattern, string, flags=0):
   165|         0|            0|            0|  0.00%|    """Try to apply the pattern at the start of the string, returning
   166|         0|            0|            0|  0.00%|    a Match object, or None if no match was found."""
   167|         0|            0|            0|  0.00%|    return _compile(pattern, flags).match(string)
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|def fullmatch(pattern, string, flags=0):
   170|         0|            0|            0|  0.00%|    """Try to apply the pattern to all of the string, returning
   171|         0|            0|            0|  0.00%|    a Match object, or None if no match was found."""
   172|         0|            0|            0|  0.00%|    return _compile(pattern, flags).fullmatch(string)
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|def search(pattern, string, flags=0):
   175|         0|            0|            0|  0.00%|    """Scan through string looking for a match to the pattern, returning
   176|         0|            0|            0|  0.00%|    a Match object, or None if no match was found."""
   177|         0|            0|            0|  0.00%|    return _compile(pattern, flags).search(string)
   178|         0|            0|            0|  0.00%|
   179|         0|            0|            0|  0.00%|def sub(pattern, repl, string, count=0, flags=0):
   180|         0|            0|            0|  0.00%|    """Return the string obtained by replacing the leftmost
   181|         0|            0|            0|  0.00%|    non-overlapping occurrences of the pattern in string by the
   182|         0|            0|            0|  0.00%|    replacement repl.  repl can be either a string or a callable;
   183|         0|            0|            0|  0.00%|    if a string, backslash escapes in it are processed.  If it is
   184|         0|            0|            0|  0.00%|    a callable, it's passed the Match object and must return
   185|         0|            0|            0|  0.00%|    a replacement string to be used."""
   186|         0|            0|            0|  0.00%|    return _compile(pattern, flags).sub(repl, string, count)
   187|         0|            0|            0|  0.00%|
   188|         0|            0|            0|  0.00%|def subn(pattern, repl, string, count=0, flags=0):
   189|         0|            0|            0|  0.00%|    """Return a 2-tuple containing (new_string, number).
   190|         0|            0|            0|  0.00%|    new_string is the string obtained by replacing the leftmost
   191|         0|            0|            0|  0.00%|    non-overlapping occurrences of the pattern in the source
   192|         0|            0|            0|  0.00%|    string by the replacement repl.  number is the number of
   193|         0|            0|            0|  0.00%|    substitutions that were made. repl can be either a string or a
   194|         0|            0|            0|  0.00%|    callable; if a string, backslash escapes in it are processed.
   195|         0|            0|            0|  0.00%|    If it is a callable, it's passed the Match object and must
   196|         0|            0|            0|  0.00%|    return a replacement string to be used."""
   197|         0|            0|            0|  0.00%|    return _compile(pattern, flags).subn(repl, string, count)
   198|         0|            0|            0|  0.00%|
   199|         0|            0|            0|  0.00%|def split(pattern, string, maxsplit=0, flags=0):
   200|         0|            0|            0|  0.00%|    """Split the source string by the occurrences of the pattern,
   201|         0|            0|            0|  0.00%|    returning a list containing the resulting substrings.  If
   202|         0|            0|            0|  0.00%|    capturing parentheses are used in pattern, then the text of all
   203|         0|            0|            0|  0.00%|    groups in the pattern are also returned as part of the resulting
   204|         0|            0|            0|  0.00%|    list.  If maxsplit is nonzero, at most maxsplit splits occur,
   205|         0|            0|            0|  0.00%|    and the remainder of the string is returned as the final element
   206|         0|            0|            0|  0.00%|    of the list."""
   207|         0|            0|            0|  0.00%|    return _compile(pattern, flags).split(string, maxsplit)
   208|         0|            0|            0|  0.00%|
   209|         1|  1.90735e-06|  1.90735e-06|  0.00%|def findall(pattern, string, flags=0):
   210|         0|            0|            0|  0.00%|    """Return a list of all non-overlapping matches in the string.
   211|         0|            0|            0|  0.00%|
   212|         0|            0|            0|  0.00%|    If one or more capturing groups are present in the pattern, return
   213|         0|            0|            0|  0.00%|    a list of groups; this will be a list of tuples if the pattern
   214|         0|            0|            0|  0.00%|    has more than one group.
   215|         0|            0|            0|  0.00%|
   216|         0|            0|            0|  0.00%|    Empty matches are included in the result."""
   217|         1|  1.50204e-05|  1.50204e-05|  0.02%|    return _compile(pattern, flags).findall(string)
(call)|         1|  1.09673e-05|  1.09673e-05|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/__init__.py:280 _compile
   218|         0|            0|            0|  0.00%|
   219|         0|            0|            0|  0.00%|def finditer(pattern, string, flags=0):
   220|         0|            0|            0|  0.00%|    """Return an iterator over all non-overlapping matches in the
   221|         0|            0|            0|  0.00%|    string.  For each match, the iterator returns a Match object.
   222|         0|            0|            0|  0.00%|
   223|         0|            0|            0|  0.00%|    Empty matches are included in the result."""
   224|         0|            0|            0|  0.00%|    return _compile(pattern, flags).finditer(string)
   225|         0|            0|            0|  0.00%|
   226|         1|  4.29153e-06|  4.29153e-06|  0.00%|def compile(pattern, flags=0):
   227|         0|            0|            0|  0.00%|    "Compile a regular expression pattern, returning a Pattern object."
   228|         1|  1.88351e-05|  1.88351e-05|  0.02%|    return _compile(pattern, flags)
(call)|         1|    0.0751691|    0.0751691| 77.27%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/__init__.py:280 _compile
   229|         0|            0|            0|  0.00%|
   230|         0|            0|            0|  0.00%|def purge():
   231|         0|            0|            0|  0.00%|    "Clear the regular expression caches"
   232|         0|            0|            0|  0.00%|    _cache.clear()
   233|         0|            0|            0|  0.00%|    _cache2.clear()
   234|         0|            0|            0|  0.00%|    _compile_template.cache_clear()
   235|         0|            0|            0|  0.00%|
   236|         0|            0|            0|  0.00%|def template(pattern, flags=0):
   237|         0|            0|            0|  0.00%|    "Compile a template pattern, returning a Pattern object, deprecated"
   238|         0|            0|            0|  0.00%|    import warnings
   239|         0|            0|            0|  0.00%|    warnings.warn("The re.template() function is deprecated "
   240|         0|            0|            0|  0.00%|                  "as it is an undocumented function "
   241|         0|            0|            0|  0.00%|                  "without an obvious purpose. "
   242|         0|            0|            0|  0.00%|                  "Use re.compile() instead.",
   243|         0|            0|            0|  0.00%|                  DeprecationWarning)
   244|         0|            0|            0|  0.00%|    with warnings.catch_warnings():
   245|         0|            0|            0|  0.00%|        warnings.simplefilter("ignore", DeprecationWarning)  # warn just once
   246|         0|            0|            0|  0.00%|        return _compile(pattern, flags|T)
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|# SPECIAL_CHARS
   249|         0|            0|            0|  0.00%|# closing ')', '}' and ']'
   250|         0|            0|            0|  0.00%|# '-' (a range in character set)
   251|         0|            0|            0|  0.00%|# '&', '~', (extended character set operations)
   252|         0|            0|            0|  0.00%|# '#' (comment) and WHITESPACE (ignored) in verbose mode
   253|         0|            0|            0|  0.00%|_special_chars_map = {i: '\\' + chr(i) for i in b'()[]{}?*+-|^$\\.&~# \t\n\r\v\f'}
   254|         0|            0|            0|  0.00%|
   255|         2|  6.67572e-06|  3.33786e-06|  0.01%|def escape(pattern):
   256|         0|            0|            0|  0.00%|    """
   257|         0|            0|            0|  0.00%|    Escape special characters in a string.
   258|         0|            0|            0|  0.00%|    """
   259|         2|  8.10623e-06|  4.05312e-06|  0.01%|    if isinstance(pattern, str):
   260|         2|  5.00679e-06|   2.5034e-06|  0.01%|        return pattern.translate(_special_chars_map)
   261|         0|            0|            0|  0.00%|    else:
   262|         0|            0|            0|  0.00%|        pattern = str(pattern, 'latin1')
   263|         0|            0|            0|  0.00%|        return pattern.translate(_special_chars_map).encode('latin1')
   264|         0|            0|            0|  0.00%|
   265|         0|            0|            0|  0.00%|Pattern = type(_compiler.compile('', 0))
   266|         0|            0|            0|  0.00%|Match = type(_compiler.compile('', 0).match(''))
   267|         0|            0|            0|  0.00%|
   268|         0|            0|            0|  0.00%|# --------------------------------------------------------------------
   269|         0|            0|            0|  0.00%|# internals
   270|         0|            0|            0|  0.00%|
   271|         0|            0|            0|  0.00%|# Use the fact that dict keeps the insertion order.
   272|         0|            0|            0|  0.00%|# _cache2 uses the simple FIFO policy which has better latency.
   273|         0|            0|            0|  0.00%|# _cache uses the LRU policy which has better hit rate.
   274|         0|            0|            0|  0.00%|_cache = {}  # LRU
   275|         0|            0|            0|  0.00%|_cache2 = {}  # FIFO
   276|         0|            0|            0|  0.00%|_MAXCACHE = 512
   277|         0|            0|            0|  0.00%|_MAXCACHE2 = 256
   278|         0|            0|            0|  0.00%|assert _MAXCACHE2 < _MAXCACHE
   279|         0|            0|            0|  0.00%|
   280|         2|  8.34465e-06|  4.17233e-06|  0.01%|def _compile(pattern, flags):
   281|         0|            0|            0|  0.00%|    # internal: compile pattern
   282|         2|  6.91414e-06|  3.45707e-06|  0.01%|    if isinstance(flags, RegexFlag):
   283|         0|            0|            0|  0.00%|        flags = flags.value
   284|         2|  5.72205e-06|  2.86102e-06|  0.01%|    try:
   285|         2|  7.15256e-06|  3.57628e-06|  0.01%|        return _cache2[type(pattern), pattern, flags]
   286|         1|  3.33786e-06|  3.33786e-06|  0.00%|    except KeyError:
   287|         1|   3.8147e-06|   3.8147e-06|  0.00%|        pass
   288|         0|            0|            0|  0.00%|
   289|         1|   3.8147e-06|   3.8147e-06|  0.00%|    key = (type(pattern), pattern, flags)
   290|         0|            0|            0|  0.00%|    # Item in _cache should be moved to the end if found.
   291|         1|  4.05312e-06|  4.05312e-06|  0.00%|    p = _cache.pop(key, None)
   292|         1|  3.33786e-06|  3.33786e-06|  0.00%|    if p is None:
   293|         1|  3.09944e-06|  3.09944e-06|  0.00%|        if isinstance(pattern, Pattern):
   294|         0|            0|            0|  0.00%|            if flags:
   295|         0|            0|            0|  0.00%|                raise ValueError(
   296|         0|            0|            0|  0.00%|                    "cannot process flags argument with a compiled pattern")
   297|         0|            0|            0|  0.00%|            return pattern
   298|         1|  1.21593e-05|  1.21593e-05|  0.01%|        if not _compiler.isstring(pattern):
(call)|         1|  1.14441e-05|  1.14441e-05|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_compiler.py:570 isstring
   299|         0|            0|            0|  0.00%|            raise TypeError("first argument must be string or compiled pattern")
   300|         1|   1.4782e-05|   1.4782e-05|  0.02%|        if flags & T:
(call)|         1|  0.000123024|  0.000123024|  0.13%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/enum.py:1562 __and__
   301|         0|            0|            0|  0.00%|            import warnings
   302|         0|            0|            0|  0.00%|            warnings.warn("The re.TEMPLATE/re.T flag is deprecated "
   303|         0|            0|            0|  0.00%|                    "as it is an undocumented flag "
   304|         0|            0|            0|  0.00%|                    "without an obvious purpose. "
   305|         0|            0|            0|  0.00%|                    "Don't use it.",
   306|         0|            0|            0|  0.00%|                    DeprecationWarning)
   307|         1|   2.0504e-05|   2.0504e-05|  0.02%|        p = _compiler.compile(pattern, flags)
(call)|         1|    0.0748317|    0.0748317| 76.93%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/_compiler.py:740 compile
   308|         1|   1.3113e-05|   1.3113e-05|  0.01%|        if flags & DEBUG:
(call)|         1|  7.03335e-05|  7.03335e-05|  0.07%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/enum.py:1562 __and__
   309|         0|            0|            0|  0.00%|            return p
   310|         1|  6.67572e-06|  6.67572e-06|  0.01%|        if len(_cache) >= _MAXCACHE:
   311|         0|            0|            0|  0.00%|            # Drop the least recently used item.
   312|         0|            0|            0|  0.00%|            # next(iter(_cache)) is known to have linear amortized time,
   313|         0|            0|            0|  0.00%|            # but it is used here to avoid a dependency from using OrderedDict.
   314|         0|            0|            0|  0.00%|            # For the small _MAXCACHE value it doesn't make much of a difference.
   315|         0|            0|            0|  0.00%|            try:
   316|         0|            0|            0|  0.00%|                del _cache[next(iter(_cache))]
   317|         0|            0|            0|  0.00%|            except (StopIteration, RuntimeError, KeyError):
   318|         0|            0|            0|  0.00%|                pass
   319|         0|            0|            0|  0.00%|    # Append to the end.
   320|         1|  4.76837e-06|  4.76837e-06|  0.00%|    _cache[key] = p
   321|         0|            0|            0|  0.00%|
   322|         1|  3.33786e-06|  3.33786e-06|  0.00%|    if len(_cache2) >= _MAXCACHE2:
   323|         0|            0|            0|  0.00%|        # Drop the oldest item.
   324|         1|  3.33786e-06|  3.33786e-06|  0.00%|        try:
   325|         1|  8.10623e-06|  8.10623e-06|  0.01%|            del _cache2[next(iter(_cache2))]
   326|         0|            0|            0|  0.00%|        except (StopIteration, RuntimeError, KeyError):
   327|         0|            0|            0|  0.00%|            pass
   328|         1|   3.8147e-06|   3.8147e-06|  0.00%|    _cache2[key] = p
   329|         1|  3.33786e-06|  3.33786e-06|  0.00%|    return p
   330|         0|            0|            0|  0.00%|
   331|         0|            0|            0|  0.00%|@functools.lru_cache(_MAXCACHE)
   332|         0|            0|            0|  0.00%|def _compile_template(pattern, repl):
   333|         0|            0|            0|  0.00%|    # internal: compile replacement pattern
   334|         0|            0|            0|  0.00%|    return _sre.template(pattern, _parser.parse_template(repl, pattern))
   335|         0|            0|            0|  0.00%|
   336|         0|            0|            0|  0.00%|# register myself for pickling
   337|         0|            0|            0|  0.00%|
   338|         0|            0|            0|  0.00%|import copyreg
   339|         0|            0|            0|  0.00%|
   340|         0|            0|            0|  0.00%|def _pickle(p):
   341|         0|            0|            0|  0.00%|    return _compile, (p.pattern, p.flags)
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|copyreg.pickle(Pattern, _pickle, _compile)
   344|         0|            0|            0|  0.00%|
   345|         0|            0|            0|  0.00%|# --------------------------------------------------------------------
   346|         0|            0|            0|  0.00%|# experimental stuff (see python-dev discussions for details)
   347|         0|            0|            0|  0.00%|
   348|         0|            0|            0|  0.00%|class Scanner:
   349|         0|            0|            0|  0.00%|    def __init__(self, lexicon, flags=0):
   350|         0|            0|            0|  0.00%|        from ._constants import BRANCH, SUBPATTERN
   351|         0|            0|            0|  0.00%|        if isinstance(flags, RegexFlag):
   352|         0|            0|            0|  0.00%|            flags = flags.value
   353|         0|            0|            0|  0.00%|        self.lexicon = lexicon
   354|         0|            0|            0|  0.00%|        # combine phrases into a compound pattern
   355|         0|            0|            0|  0.00%|        p = []
   356|         0|            0|            0|  0.00%|        s = _parser.State()
   357|         0|            0|            0|  0.00%|        s.flags = flags
   358|         0|            0|            0|  0.00%|        for phrase, action in lexicon:
   359|         0|            0|            0|  0.00%|            gid = s.opengroup()
   360|         0|            0|            0|  0.00%|            p.append(_parser.SubPattern(s, [
   361|         0|            0|            0|  0.00%|                (SUBPATTERN, (gid, 0, 0, _parser.parse(phrase, flags))),
   362|         0|            0|            0|  0.00%|                ]))
   363|         0|            0|            0|  0.00%|            s.closegroup(gid, p[-1])
   364|         0|            0|            0|  0.00%|        p = _parser.SubPattern(s, [(BRANCH, (None, p))])
   365|         0|            0|            0|  0.00%|        self.scanner = _compiler.compile(p)
   366|         0|            0|            0|  0.00%|    def scan(self, string):
   367|         0|            0|            0|  0.00%|        result = []
   368|         0|            0|            0|  0.00%|        append = result.append
   369|         0|            0|            0|  0.00%|        match = self.scanner.scanner(string).match
   370|         0|            0|            0|  0.00%|        i = 0
   371|         0|            0|            0|  0.00%|        while True:
   372|         0|            0|            0|  0.00%|            m = match()
   373|         0|            0|            0|  0.00%|            if not m:
   374|         0|            0|            0|  0.00%|                break
   375|         0|            0|            0|  0.00%|            j = m.end()
   376|         0|            0|            0|  0.00%|            if i == j:
   377|         0|            0|            0|  0.00%|                break
   378|         0|            0|            0|  0.00%|            action = self.lexicon[m.lastindex-1][1]
   379|         0|            0|            0|  0.00%|            if callable(action):
   380|         0|            0|            0|  0.00%|                self.match = m
   381|         0|            0|            0|  0.00%|                action = action(self, m.group())
   382|         0|            0|            0|  0.00%|            if action is not None:
   383|         0|            0|            0|  0.00%|                append(action)
   384|         0|            0|            0|  0.00%|            i = j
   385|         0|            0|            0|  0.00%|        return result, string[i:]
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/starlette/routing.py
File duration: 0.000169039s (0.17%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|from __future__ import annotations
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|import contextlib
     4|         0|            0|            0|  0.00%|import functools
     5|         0|            0|            0|  0.00%|import inspect
     6|         0|            0|            0|  0.00%|import re
     7|         0|            0|            0|  0.00%|import traceback
     8|         0|            0|            0|  0.00%|import types
     9|         0|            0|            0|  0.00%|import typing
    10|         0|            0|            0|  0.00%|import warnings
    11|         0|            0|            0|  0.00%|from contextlib import asynccontextmanager
    12|         0|            0|            0|  0.00%|from enum import Enum
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|from starlette._exception_handler import wrap_app_handling_exceptions
    15|         0|            0|            0|  0.00%|from starlette._utils import get_route_path, is_async_callable
    16|         0|            0|            0|  0.00%|from starlette.concurrency import run_in_threadpool
    17|         0|            0|            0|  0.00%|from starlette.convertors import CONVERTOR_TYPES, Convertor
    18|         0|            0|            0|  0.00%|from starlette.datastructures import URL, Headers, URLPath
    19|         0|            0|            0|  0.00%|from starlette.exceptions import HTTPException
    20|         0|            0|            0|  0.00%|from starlette.middleware import Middleware
    21|         0|            0|            0|  0.00%|from starlette.requests import Request
    22|         0|            0|            0|  0.00%|from starlette.responses import PlainTextResponse, RedirectResponse, Response
    23|         0|            0|            0|  0.00%|from starlette.types import ASGIApp, Lifespan, Receive, Scope, Send
    24|         0|            0|            0|  0.00%|from starlette.websockets import WebSocket, WebSocketClose
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|class NoMatchFound(Exception):
    28|         0|            0|            0|  0.00%|    """
    29|         0|            0|            0|  0.00%|    Raised by `.url_for(name, **path_params)` and `.url_path_for(name, **path_params)`
    30|         0|            0|            0|  0.00%|    if no matching route exists.
    31|         0|            0|            0|  0.00%|    """
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|    def __init__(self, name: str, path_params: dict[str, typing.Any]) -> None:
    34|         0|            0|            0|  0.00%|        params = ", ".join(list(path_params.keys()))
    35|         0|            0|            0|  0.00%|        super().__init__(f'No route exists for name "{name}" and params "{params}".')
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|
    38|         0|            0|            0|  0.00%|class Match(Enum):
    39|         0|            0|            0|  0.00%|    NONE = 0
    40|         0|            0|            0|  0.00%|    PARTIAL = 1
    41|         0|            0|            0|  0.00%|    FULL = 2
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|
    44|         0|            0|            0|  0.00%|def iscoroutinefunction_or_partial(obj: typing.Any) -> bool:  # pragma: no cover
    45|         0|            0|            0|  0.00%|    """
    46|         0|            0|            0|  0.00%|    Correctly determines if an object is a coroutine function,
    47|         0|            0|            0|  0.00%|    including those wrapped in functools.partial objects.
    48|         0|            0|            0|  0.00%|    """
    49|         0|            0|            0|  0.00%|    warnings.warn(
    50|         0|            0|            0|  0.00%|        "iscoroutinefunction_or_partial is deprecated, "
    51|         0|            0|            0|  0.00%|        "and will be removed in a future release.",
    52|         0|            0|            0|  0.00%|        DeprecationWarning,
    53|         0|            0|            0|  0.00%|    )
    54|         0|            0|            0|  0.00%|    while isinstance(obj, functools.partial):
    55|         0|            0|            0|  0.00%|        obj = obj.func
    56|         0|            0|            0|  0.00%|    return inspect.iscoroutinefunction(obj)
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|def request_response(
    60|         0|            0|            0|  0.00%|    func: typing.Callable[[Request], typing.Awaitable[Response] | Response],
    61|         0|            0|            0|  0.00%|) -> ASGIApp:
    62|         0|            0|            0|  0.00%|    """
    63|         0|            0|            0|  0.00%|    Takes a function or coroutine `func(request) -> response`,
    64|         0|            0|            0|  0.00%|    and returns an ASGI application.
    65|         0|            0|            0|  0.00%|    """
    66|         0|            0|            0|  0.00%|    f: typing.Callable[[Request], typing.Awaitable[Response]] = (
    67|         0|            0|            0|  0.00%|        func if is_async_callable(func) else functools.partial(run_in_threadpool, func)  # type:ignore
    68|         0|            0|            0|  0.00%|    )
    69|         0|            0|            0|  0.00%|
    70|         0|            0|            0|  0.00%|    async def app(scope: Scope, receive: Receive, send: Send) -> None:
    71|         0|            0|            0|  0.00%|        request = Request(scope, receive, send)
    72|         0|            0|            0|  0.00%|
    73|         0|            0|            0|  0.00%|        async def app(scope: Scope, receive: Receive, send: Send) -> None:
    74|         0|            0|            0|  0.00%|            response = await f(request)
    75|         0|            0|            0|  0.00%|            await response(scope, receive, send)
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|        await wrap_app_handling_exceptions(app, request)(scope, receive, send)
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|    return app
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|
    82|         1|  4.76837e-06|  4.76837e-06|  0.00%|def websocket_session(
    83|         0|            0|            0|  0.00%|    func: typing.Callable[[WebSocket], typing.Awaitable[None]],
    84|         0|            0|            0|  0.00%|) -> ASGIApp:
    85|         0|            0|            0|  0.00%|    """
    86|         0|            0|            0|  0.00%|    Takes a coroutine `func(session)`, and returns an ASGI application.
    87|         0|            0|            0|  0.00%|    """
    88|         0|            0|            0|  0.00%|    # assert asyncio.iscoroutinefunction(func), "WebSocket endpoints must be async"
    89|         0|            0|            0|  0.00%|
    90|         1|  3.57628e-06|  3.57628e-06|  0.00%|    async def app(scope: Scope, receive: Receive, send: Send) -> None:
    91|         0|            0|            0|  0.00%|        session = WebSocket(scope, receive=receive, send=send)
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|        async def app(scope: Scope, receive: Receive, send: Send) -> None:
    94|         0|            0|            0|  0.00%|            await func(session)
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|        await wrap_app_handling_exceptions(app, session)(scope, receive, send)
    97|         0|            0|            0|  0.00%|
    98|         1|   2.6226e-06|   2.6226e-06|  0.00%|    return app
    99|         0|            0|            0|  0.00%|
   100|         0|            0|            0|  0.00%|
   101|         1|  2.86102e-06|  2.86102e-06|  0.00%|def get_name(endpoint: typing.Callable[..., typing.Any]) -> str:
   102|         1|  5.48363e-06|  5.48363e-06|  0.01%|    return getattr(endpoint, "__name__", endpoint.__class__.__name__)
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|def replace_params(
   106|         0|            0|            0|  0.00%|    path: str,
   107|         0|            0|            0|  0.00%|    param_convertors: dict[str, Convertor[typing.Any]],
   108|         0|            0|            0|  0.00%|    path_params: dict[str, str],
   109|         0|            0|            0|  0.00%|) -> tuple[str, dict[str, str]]:
   110|         0|            0|            0|  0.00%|    for key, value in list(path_params.items()):
   111|         0|            0|            0|  0.00%|        if "{" + key + "}" in path:
   112|         0|            0|            0|  0.00%|            convertor = param_convertors[key]
   113|         0|            0|            0|  0.00%|            value = convertor.to_string(value)
   114|         0|            0|            0|  0.00%|            path = path.replace("{" + key + "}", value)
   115|         0|            0|            0|  0.00%|            path_params.pop(key)
   116|         0|            0|            0|  0.00%|    return path, path_params
   117|         0|            0|            0|  0.00%|
   118|         0|            0|            0|  0.00%|
   119|         0|            0|            0|  0.00%|# Match parameters in URL paths, eg. '{param}', and '{param:int}'
   120|         0|            0|            0|  0.00%|PARAM_REGEX = re.compile("{([a-zA-Z_][a-zA-Z0-9_]*)(:[a-zA-Z_][a-zA-Z0-9_]*)?}")
   121|         0|            0|            0|  0.00%|
   122|         0|            0|            0|  0.00%|
   123|         1|  6.91414e-06|  6.91414e-06|  0.01%|def compile_path(
   124|         0|            0|            0|  0.00%|    path: str,
   125|         0|            0|            0|  0.00%|) -> tuple[typing.Pattern[str], str, dict[str, Convertor[typing.Any]]]:
   126|         0|            0|            0|  0.00%|    """
   127|         0|            0|            0|  0.00%|    Given a path string, like: "/{username:str}",
   128|         0|            0|            0|  0.00%|    or a host string, like: "{subdomain}.mydomain.org", return a three-tuple
   129|         0|            0|            0|  0.00%|    of (regex, format, {param_name:convertor}).
   130|         0|            0|            0|  0.00%|
   131|         0|            0|            0|  0.00%|    regex:      "/(?P<username>[^/]+)"
   132|         0|            0|            0|  0.00%|    format:     "/{username}"
   133|         0|            0|            0|  0.00%|    convertors: {"username": StringConvertor()}
   134|         0|            0|            0|  0.00%|    """
   135|         1|  4.52995e-06|  4.52995e-06|  0.00%|    is_host = not path.startswith("/")
   136|         0|            0|            0|  0.00%|
   137|         1|  3.57628e-06|  3.57628e-06|  0.00%|    path_regex = "^"
   138|         1|   3.8147e-06|   3.8147e-06|  0.00%|    path_format = ""
   139|         1|  4.05312e-06|  4.05312e-06|  0.00%|    duplicated_params = set()
   140|         0|            0|            0|  0.00%|
   141|         1|  4.05312e-06|  4.05312e-06|  0.00%|    idx = 0
   142|         1|   3.8147e-06|   3.8147e-06|  0.00%|    param_convertors = {}
   143|         2|  1.38283e-05|  6.91414e-06|  0.01%|    for match in PARAM_REGEX.finditer(path):
   144|         1|  5.00679e-06|  5.00679e-06|  0.01%|        param_name, convertor_type = match.groups("str")
   145|         1|  5.96046e-06|  5.96046e-06|  0.01%|        convertor_type = convertor_type.lstrip(":")
   146|         0|            0|            0|  0.00%|        assert (
   147|         1|  4.29153e-06|  4.29153e-06|  0.00%|            convertor_type in CONVERTOR_TYPES
   148|         0|            0|            0|  0.00%|        ), f"Unknown path convertor '{convertor_type}'"
   149|         1|   3.8147e-06|   3.8147e-06|  0.00%|        convertor = CONVERTOR_TYPES[convertor_type]
   150|         0|            0|            0|  0.00%|
   151|         1|  1.54972e-05|  1.54972e-05|  0.02%|        path_regex += re.escape(path[idx : match.start()])
(call)|         1|  1.43051e-05|  1.43051e-05|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/__init__.py:255 escape
   152|         1|  5.48363e-06|  5.48363e-06|  0.01%|        path_regex += f"(?P<{param_name}>{convertor.regex})"
   153|         0|            0|            0|  0.00%|
   154|         1|  6.19888e-06|  6.19888e-06|  0.01%|        path_format += path[idx : match.start()]
   155|         1|  4.29153e-06|  4.29153e-06|  0.00%|        path_format += "{%s}" % param_name
   156|         0|            0|            0|  0.00%|
   157|         1|  4.05312e-06|  4.05312e-06|  0.00%|        if param_name in param_convertors:
   158|         0|            0|            0|  0.00%|            duplicated_params.add(param_name)
   159|         0|            0|            0|  0.00%|
   160|         1|  3.57628e-06|  3.57628e-06|  0.00%|        param_convertors[param_name] = convertor
   161|         0|            0|            0|  0.00%|
   162|         1|  4.05312e-06|  4.05312e-06|  0.00%|        idx = match.end()
   163|         0|            0|            0|  0.00%|
   164|         1|  2.38419e-06|  2.38419e-06|  0.00%|    if duplicated_params:
   165|         0|            0|            0|  0.00%|        names = ", ".join(sorted(duplicated_params))
   166|         0|            0|            0|  0.00%|        ending = "s" if len(duplicated_params) > 1 else ""
   167|         0|            0|            0|  0.00%|        raise ValueError(f"Duplicated param name{ending} {names} at path {path}")
   168|         0|            0|            0|  0.00%|
   169|         1|  6.19888e-06|  6.19888e-06|  0.01%|    if is_host:
   170|         0|            0|            0|  0.00%|        # Align with `Host.matches()` behavior, which ignores port.
   171|         0|            0|            0|  0.00%|        hostname = path[idx:].split(":")[0]
   172|         0|            0|            0|  0.00%|        path_regex += re.escape(hostname) + "$"
   173|         0|            0|            0|  0.00%|    else:
   174|         1|  1.23978e-05|  1.23978e-05|  0.01%|        path_regex += re.escape(path[idx:]) + "$"
(call)|         1|  5.48363e-06|  5.48363e-06|  0.01%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/__init__.py:255 escape
   175|         0|            0|            0|  0.00%|
   176|         1|  5.96046e-06|  5.96046e-06|  0.01%|    path_format += path[idx:]
   177|         0|            0|            0|  0.00%|
   178|         1|   1.5974e-05|   1.5974e-05|  0.02%|    return re.compile(path_regex), path_format, param_convertors
(call)|         1|    0.0751922|    0.0751922| 77.30%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/__init__.py:226 compile
   179|         0|            0|            0|  0.00%|
   180|         0|            0|            0|  0.00%|
   181|         0|            0|            0|  0.00%|class BaseRoute:
   182|         0|            0|            0|  0.00%|    def matches(self, scope: Scope) -> tuple[Match, Scope]:
   183|         0|            0|            0|  0.00%|        raise NotImplementedError()  # pragma: no cover
   184|         0|            0|            0|  0.00%|
   185|         0|            0|            0|  0.00%|    def url_path_for(self, name: str, /, **path_params: typing.Any) -> URLPath:
   186|         0|            0|            0|  0.00%|        raise NotImplementedError()  # pragma: no cover
   187|         0|            0|            0|  0.00%|
   188|         0|            0|            0|  0.00%|    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None:
   189|         0|            0|            0|  0.00%|        raise NotImplementedError()  # pragma: no cover
   190|         0|            0|            0|  0.00%|
   191|         0|            0|            0|  0.00%|    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
   192|         0|            0|            0|  0.00%|        """
   193|         0|            0|            0|  0.00%|        A route may be used in isolation as a stand-alone ASGI app.
   194|         0|            0|            0|  0.00%|        This is a somewhat contrived case, as they'll almost always be used
   195|         0|            0|            0|  0.00%|        within a Router, but could be useful for some tooling and minimal apps.
   196|         0|            0|            0|  0.00%|        """
   197|         0|            0|            0|  0.00%|        match, child_scope = self.matches(scope)
   198|         0|            0|            0|  0.00%|        if match == Match.NONE:
   199|         0|            0|            0|  0.00%|            if scope["type"] == "http":
   200|         0|            0|            0|  0.00%|                response = PlainTextResponse("Not Found", status_code=404)
   201|         0|            0|            0|  0.00%|                await response(scope, receive, send)
   202|         0|            0|            0|  0.00%|            elif scope["type"] == "websocket":
   203|         0|            0|            0|  0.00%|                websocket_close = WebSocketClose()
   204|         0|            0|            0|  0.00%|                await websocket_close(scope, receive, send)
   205|         0|            0|            0|  0.00%|            return
   206|         0|            0|            0|  0.00%|
   207|         0|            0|            0|  0.00%|        scope.update(child_scope)
   208|         0|            0|            0|  0.00%|        await self.handle(scope, receive, send)
   209|         0|            0|            0|  0.00%|
   210|         0|            0|            0|  0.00%|
   211|         0|            0|            0|  0.00%|class Route(BaseRoute):
   212|         0|            0|            0|  0.00%|    def __init__(
   213|         0|            0|            0|  0.00%|        self,
   214|         0|            0|            0|  0.00%|        path: str,
   215|         0|            0|            0|  0.00%|        endpoint: typing.Callable[..., typing.Any],
   216|         0|            0|            0|  0.00%|        *,
   217|         0|            0|            0|  0.00%|        methods: list[str] | None = None,
   218|         0|            0|            0|  0.00%|        name: str | None = None,
   219|         0|            0|            0|  0.00%|        include_in_schema: bool = True,
   220|         0|            0|            0|  0.00%|        middleware: typing.Sequence[Middleware] | None = None,
   221|         0|            0|            0|  0.00%|    ) -> None:
   222|         0|            0|            0|  0.00%|        assert path.startswith("/"), "Routed paths must start with '/'"
   223|         0|            0|            0|  0.00%|        self.path = path
   224|         0|            0|            0|  0.00%|        self.endpoint = endpoint
   225|         0|            0|            0|  0.00%|        self.name = get_name(endpoint) if name is None else name
   226|         0|            0|            0|  0.00%|        self.include_in_schema = include_in_schema
   227|         0|            0|            0|  0.00%|
   228|         0|            0|            0|  0.00%|        endpoint_handler = endpoint
   229|         0|            0|            0|  0.00%|        while isinstance(endpoint_handler, functools.partial):
   230|         0|            0|            0|  0.00%|            endpoint_handler = endpoint_handler.func
   231|         0|            0|            0|  0.00%|        if inspect.isfunction(endpoint_handler) or inspect.ismethod(endpoint_handler):
   232|         0|            0|            0|  0.00%|            # Endpoint is function or method. Treat it as `func(request) -> response`.
   233|         0|            0|            0|  0.00%|            self.app = request_response(endpoint)
   234|         0|            0|            0|  0.00%|            if methods is None:
   235|         0|            0|            0|  0.00%|                methods = ["GET"]
   236|         0|            0|            0|  0.00%|        else:
   237|         0|            0|            0|  0.00%|            # Endpoint is a class. Treat it as ASGI.
   238|         0|            0|            0|  0.00%|            self.app = endpoint
   239|         0|            0|            0|  0.00%|
   240|         0|            0|            0|  0.00%|        if middleware is not None:
   241|         0|            0|            0|  0.00%|            for cls, args, kwargs in reversed(middleware):
   242|         0|            0|            0|  0.00%|                self.app = cls(app=self.app, *args, **kwargs)
   243|         0|            0|            0|  0.00%|
   244|         0|            0|            0|  0.00%|        if methods is None:
   245|         0|            0|            0|  0.00%|            self.methods = None
   246|         0|            0|            0|  0.00%|        else:
   247|         0|            0|            0|  0.00%|            self.methods = {method.upper() for method in methods}
   248|         0|            0|            0|  0.00%|            if "GET" in self.methods:
   249|         0|            0|            0|  0.00%|                self.methods.add("HEAD")
   250|         0|            0|            0|  0.00%|
   251|         0|            0|            0|  0.00%|        self.path_regex, self.path_format, self.param_convertors = compile_path(path)
   252|         0|            0|            0|  0.00%|
   253|         0|            0|            0|  0.00%|    def matches(self, scope: Scope) -> tuple[Match, Scope]:
   254|         0|            0|            0|  0.00%|        path_params: dict[str, typing.Any]
   255|         0|            0|            0|  0.00%|        if scope["type"] == "http":
   256|         0|            0|            0|  0.00%|            route_path = get_route_path(scope)
   257|         0|            0|            0|  0.00%|            match = self.path_regex.match(route_path)
   258|         0|            0|            0|  0.00%|            if match:
   259|         0|            0|            0|  0.00%|                matched_params = match.groupdict()
   260|         0|            0|            0|  0.00%|                for key, value in matched_params.items():
   261|         0|            0|            0|  0.00%|                    matched_params[key] = self.param_convertors[key].convert(value)
   262|         0|            0|            0|  0.00%|                path_params = dict(scope.get("path_params", {}))
   263|         0|            0|            0|  0.00%|                path_params.update(matched_params)
   264|         0|            0|            0|  0.00%|                child_scope = {"endpoint": self.endpoint, "path_params": path_params}
   265|         0|            0|            0|  0.00%|                if self.methods and scope["method"] not in self.methods:
   266|         0|            0|            0|  0.00%|                    return Match.PARTIAL, child_scope
   267|         0|            0|            0|  0.00%|                else:
   268|         0|            0|            0|  0.00%|                    return Match.FULL, child_scope
   269|         0|            0|            0|  0.00%|        return Match.NONE, {}
   270|         0|            0|            0|  0.00%|
   271|         0|            0|            0|  0.00%|    def url_path_for(self, name: str, /, **path_params: typing.Any) -> URLPath:
   272|         0|            0|            0|  0.00%|        seen_params = set(path_params.keys())
   273|         0|            0|            0|  0.00%|        expected_params = set(self.param_convertors.keys())
   274|         0|            0|            0|  0.00%|
   275|         0|            0|            0|  0.00%|        if name != self.name or seen_params != expected_params:
   276|         0|            0|            0|  0.00%|            raise NoMatchFound(name, path_params)
   277|         0|            0|            0|  0.00%|
   278|         0|            0|            0|  0.00%|        path, remaining_params = replace_params(
   279|         0|            0|            0|  0.00%|            self.path_format, self.param_convertors, path_params
   280|         0|            0|            0|  0.00%|        )
   281|         0|            0|            0|  0.00%|        assert not remaining_params
   282|         0|            0|            0|  0.00%|        return URLPath(path=path, protocol="http")
   283|         0|            0|            0|  0.00%|
   284|         0|            0|            0|  0.00%|    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None:
   285|         0|            0|            0|  0.00%|        if self.methods and scope["method"] not in self.methods:
   286|         0|            0|            0|  0.00%|            headers = {"Allow": ", ".join(self.methods)}
   287|         0|            0|            0|  0.00%|            if "app" in scope:
   288|         0|            0|            0|  0.00%|                raise HTTPException(status_code=405, headers=headers)
   289|         0|            0|            0|  0.00%|            else:
   290|         0|            0|            0|  0.00%|                response = PlainTextResponse(
   291|         0|            0|            0|  0.00%|                    "Method Not Allowed", status_code=405, headers=headers
   292|         0|            0|            0|  0.00%|                )
   293|         0|            0|            0|  0.00%|            await response(scope, receive, send)
   294|         0|            0|            0|  0.00%|        else:
   295|         0|            0|            0|  0.00%|            await self.app(scope, receive, send)
   296|         0|            0|            0|  0.00%|
   297|         0|            0|            0|  0.00%|    def __eq__(self, other: typing.Any) -> bool:
   298|         0|            0|            0|  0.00%|        return (
   299|         0|            0|            0|  0.00%|            isinstance(other, Route)
   300|         0|            0|            0|  0.00%|            and self.path == other.path
   301|         0|            0|            0|  0.00%|            and self.endpoint == other.endpoint
   302|         0|            0|            0|  0.00%|            and self.methods == other.methods
   303|         0|            0|            0|  0.00%|        )
   304|         0|            0|            0|  0.00%|
   305|         0|            0|            0|  0.00%|    def __repr__(self) -> str:
   306|         0|            0|            0|  0.00%|        class_name = self.__class__.__name__
   307|         0|            0|            0|  0.00%|        methods = sorted(self.methods or [])
   308|         0|            0|            0|  0.00%|        path, name = self.path, self.name
   309|         0|            0|            0|  0.00%|        return f"{class_name}(path={path!r}, name={name!r}, methods={methods!r})"
   310|         0|            0|            0|  0.00%|
   311|         0|            0|            0|  0.00%|
   312|         0|            0|            0|  0.00%|class WebSocketRoute(BaseRoute):
   313|         0|            0|            0|  0.00%|    def __init__(
   314|         0|            0|            0|  0.00%|        self,
   315|         0|            0|            0|  0.00%|        path: str,
   316|         0|            0|            0|  0.00%|        endpoint: typing.Callable[..., typing.Any],
   317|         0|            0|            0|  0.00%|        *,
   318|         0|            0|            0|  0.00%|        name: str | None = None,
   319|         0|            0|            0|  0.00%|        middleware: typing.Sequence[Middleware] | None = None,
   320|         0|            0|            0|  0.00%|    ) -> None:
   321|         0|            0|            0|  0.00%|        assert path.startswith("/"), "Routed paths must start with '/'"
   322|         0|            0|            0|  0.00%|        self.path = path
   323|         0|            0|            0|  0.00%|        self.endpoint = endpoint
   324|         0|            0|            0|  0.00%|        self.name = get_name(endpoint) if name is None else name
   325|         0|            0|            0|  0.00%|
   326|         0|            0|            0|  0.00%|        endpoint_handler = endpoint
   327|         0|            0|            0|  0.00%|        while isinstance(endpoint_handler, functools.partial):
   328|         0|            0|            0|  0.00%|            endpoint_handler = endpoint_handler.func
   329|         0|            0|            0|  0.00%|        if inspect.isfunction(endpoint_handler) or inspect.ismethod(endpoint_handler):
   330|         0|            0|            0|  0.00%|            # Endpoint is function or method. Treat it as `func(websocket)`.
   331|         0|            0|            0|  0.00%|            self.app = websocket_session(endpoint)
   332|         0|            0|            0|  0.00%|        else:
   333|         0|            0|            0|  0.00%|            # Endpoint is a class. Treat it as ASGI.
   334|         0|            0|            0|  0.00%|            self.app = endpoint
   335|         0|            0|            0|  0.00%|
   336|         0|            0|            0|  0.00%|        if middleware is not None:
   337|         0|            0|            0|  0.00%|            for cls, args, kwargs in reversed(middleware):
   338|         0|            0|            0|  0.00%|                self.app = cls(app=self.app, *args, **kwargs)
   339|         0|            0|            0|  0.00%|
   340|         0|            0|            0|  0.00%|        self.path_regex, self.path_format, self.param_convertors = compile_path(path)
   341|         0|            0|            0|  0.00%|
   342|         0|            0|            0|  0.00%|    def matches(self, scope: Scope) -> tuple[Match, Scope]:
   343|         0|            0|            0|  0.00%|        path_params: dict[str, typing.Any]
   344|         0|            0|            0|  0.00%|        if scope["type"] == "websocket":
   345|         0|            0|            0|  0.00%|            route_path = get_route_path(scope)
   346|         0|            0|            0|  0.00%|            match = self.path_regex.match(route_path)
   347|         0|            0|            0|  0.00%|            if match:
   348|         0|            0|            0|  0.00%|                matched_params = match.groupdict()
   349|         0|            0|            0|  0.00%|                for key, value in matched_params.items():
   350|         0|            0|            0|  0.00%|                    matched_params[key] = self.param_convertors[key].convert(value)
   351|         0|            0|            0|  0.00%|                path_params = dict(scope.get("path_params", {}))
   352|         0|            0|            0|  0.00%|                path_params.update(matched_params)
   353|         0|            0|            0|  0.00%|                child_scope = {"endpoint": self.endpoint, "path_params": path_params}
   354|         0|            0|            0|  0.00%|                return Match.FULL, child_scope
   355|         0|            0|            0|  0.00%|        return Match.NONE, {}
   356|         0|            0|            0|  0.00%|
   357|         0|            0|            0|  0.00%|    def url_path_for(self, name: str, /, **path_params: typing.Any) -> URLPath:
   358|         0|            0|            0|  0.00%|        seen_params = set(path_params.keys())
   359|         0|            0|            0|  0.00%|        expected_params = set(self.param_convertors.keys())
   360|         0|            0|            0|  0.00%|
   361|         0|            0|            0|  0.00%|        if name != self.name or seen_params != expected_params:
   362|         0|            0|            0|  0.00%|            raise NoMatchFound(name, path_params)
   363|         0|            0|            0|  0.00%|
   364|         0|            0|            0|  0.00%|        path, remaining_params = replace_params(
   365|         0|            0|            0|  0.00%|            self.path_format, self.param_convertors, path_params
   366|         0|            0|            0|  0.00%|        )
   367|         0|            0|            0|  0.00%|        assert not remaining_params
   368|         0|            0|            0|  0.00%|        return URLPath(path=path, protocol="websocket")
   369|         0|            0|            0|  0.00%|
   370|         0|            0|            0|  0.00%|    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None:
   371|         0|            0|            0|  0.00%|        await self.app(scope, receive, send)
   372|         0|            0|            0|  0.00%|
   373|         0|            0|            0|  0.00%|    def __eq__(self, other: typing.Any) -> bool:
   374|         0|            0|            0|  0.00%|        return (
   375|         0|            0|            0|  0.00%|            isinstance(other, WebSocketRoute)
   376|         0|            0|            0|  0.00%|            and self.path == other.path
   377|         0|            0|            0|  0.00%|            and self.endpoint == other.endpoint
   378|         0|            0|            0|  0.00%|        )
   379|         0|            0|            0|  0.00%|
   380|         0|            0|            0|  0.00%|    def __repr__(self) -> str:
   381|         0|            0|            0|  0.00%|        return f"{self.__class__.__name__}(path={self.path!r}, name={self.name!r})"
   382|         0|            0|            0|  0.00%|
   383|         0|            0|            0|  0.00%|
   384|         0|            0|            0|  0.00%|class Mount(BaseRoute):
   385|         0|            0|            0|  0.00%|    def __init__(
   386|         0|            0|            0|  0.00%|        self,
   387|         0|            0|            0|  0.00%|        path: str,
   388|         0|            0|            0|  0.00%|        app: ASGIApp | None = None,
   389|         0|            0|            0|  0.00%|        routes: typing.Sequence[BaseRoute] | None = None,
   390|         0|            0|            0|  0.00%|        name: str | None = None,
   391|         0|            0|            0|  0.00%|        *,
   392|         0|            0|            0|  0.00%|        middleware: typing.Sequence[Middleware] | None = None,
   393|         0|            0|            0|  0.00%|    ) -> None:
   394|         0|            0|            0|  0.00%|        assert path == "" or path.startswith("/"), "Routed paths must start with '/'"
   395|         0|            0|            0|  0.00%|        assert (
   396|         0|            0|            0|  0.00%|            app is not None or routes is not None
   397|         0|            0|            0|  0.00%|        ), "Either 'app=...', or 'routes=' must be specified"
   398|         0|            0|            0|  0.00%|        self.path = path.rstrip("/")
   399|         0|            0|            0|  0.00%|        if app is not None:
   400|         0|            0|            0|  0.00%|            self._base_app: ASGIApp = app
   401|         0|            0|            0|  0.00%|        else:
   402|         0|            0|            0|  0.00%|            self._base_app = Router(routes=routes)
   403|         0|            0|            0|  0.00%|        self.app = self._base_app
   404|         0|            0|            0|  0.00%|        if middleware is not None:
   405|         0|            0|            0|  0.00%|            for cls, args, kwargs in reversed(middleware):
   406|         0|            0|            0|  0.00%|                self.app = cls(app=self.app, *args, **kwargs)
   407|         0|            0|            0|  0.00%|        self.name = name
   408|         0|            0|            0|  0.00%|        self.path_regex, self.path_format, self.param_convertors = compile_path(
   409|         0|            0|            0|  0.00%|            self.path + "/{path:path}"
   410|         0|            0|            0|  0.00%|        )
   411|         0|            0|            0|  0.00%|
   412|         0|            0|            0|  0.00%|    @property
   413|         0|            0|            0|  0.00%|    def routes(self) -> list[BaseRoute]:
   414|         0|            0|            0|  0.00%|        return getattr(self._base_app, "routes", [])
   415|         0|            0|            0|  0.00%|
   416|         0|            0|            0|  0.00%|    def matches(self, scope: Scope) -> tuple[Match, Scope]:
   417|         0|            0|            0|  0.00%|        path_params: dict[str, typing.Any]
   418|         0|            0|            0|  0.00%|        if scope["type"] in ("http", "websocket"):
   419|         0|            0|            0|  0.00%|            root_path = scope.get("root_path", "")
   420|         0|            0|            0|  0.00%|            route_path = get_route_path(scope)
   421|         0|            0|            0|  0.00%|            match = self.path_regex.match(route_path)
   422|         0|            0|            0|  0.00%|            if match:
   423|         0|            0|            0|  0.00%|                matched_params = match.groupdict()
   424|         0|            0|            0|  0.00%|                for key, value in matched_params.items():
   425|         0|            0|            0|  0.00%|                    matched_params[key] = self.param_convertors[key].convert(value)
   426|         0|            0|            0|  0.00%|                remaining_path = "/" + matched_params.pop("path")
   427|         0|            0|            0|  0.00%|                matched_path = route_path[: -len(remaining_path)]
   428|         0|            0|            0|  0.00%|                path_params = dict(scope.get("path_params", {}))
   429|         0|            0|            0|  0.00%|                path_params.update(matched_params)
   430|         0|            0|            0|  0.00%|                child_scope = {
   431|         0|            0|            0|  0.00%|                    "path_params": path_params,
   432|         0|            0|            0|  0.00%|                    # app_root_path will only be set at the top level scope,
   433|         0|            0|            0|  0.00%|                    # initialized with the (optional) value of a root_path
   434|         0|            0|            0|  0.00%|                    # set above/before Starlette. And even though any
   435|         0|            0|            0|  0.00%|                    # mount will have its own child scope with its own respective
   436|         0|            0|            0|  0.00%|                    # root_path, the app_root_path will always be available in all
   437|         0|            0|            0|  0.00%|                    # the child scopes with the same top level value because it's
   438|         0|            0|            0|  0.00%|                    # set only once here with a default, any other child scope will
   439|         0|            0|            0|  0.00%|                    # just inherit that app_root_path default value stored in the
   440|         0|            0|            0|  0.00%|                    # scope. All this is needed to support Request.url_for(), as it
   441|         0|            0|            0|  0.00%|                    # uses the app_root_path to build the URL path.
   442|         0|            0|            0|  0.00%|                    "app_root_path": scope.get("app_root_path", root_path),
   443|         0|            0|            0|  0.00%|                    "root_path": root_path + matched_path,
   444|         0|            0|            0|  0.00%|                    "endpoint": self.app,
   445|         0|            0|            0|  0.00%|                }
   446|         0|            0|            0|  0.00%|                return Match.FULL, child_scope
   447|         0|            0|            0|  0.00%|        return Match.NONE, {}
   448|         0|            0|            0|  0.00%|
   449|         0|            0|            0|  0.00%|    def url_path_for(self, name: str, /, **path_params: typing.Any) -> URLPath:
   450|         0|            0|            0|  0.00%|        if self.name is not None and name == self.name and "path" in path_params:
   451|         0|            0|            0|  0.00%|            # 'name' matches "<mount_name>".
   452|         0|            0|            0|  0.00%|            path_params["path"] = path_params["path"].lstrip("/")
   453|         0|            0|            0|  0.00%|            path, remaining_params = replace_params(
   454|         0|            0|            0|  0.00%|                self.path_format, self.param_convertors, path_params
   455|         0|            0|            0|  0.00%|            )
   456|         0|            0|            0|  0.00%|            if not remaining_params:
   457|         0|            0|            0|  0.00%|                return URLPath(path=path)
   458|         0|            0|            0|  0.00%|        elif self.name is None or name.startswith(self.name + ":"):
   459|         0|            0|            0|  0.00%|            if self.name is None:
   460|         0|            0|            0|  0.00%|                # No mount name.
   461|         0|            0|            0|  0.00%|                remaining_name = name
   462|         0|            0|            0|  0.00%|            else:
   463|         0|            0|            0|  0.00%|                # 'name' matches "<mount_name>:<child_name>".
   464|         0|            0|            0|  0.00%|                remaining_name = name[len(self.name) + 1 :]
   465|         0|            0|            0|  0.00%|            path_kwarg = path_params.get("path")
   466|         0|            0|            0|  0.00%|            path_params["path"] = ""
   467|         0|            0|            0|  0.00%|            path_prefix, remaining_params = replace_params(
   468|         0|            0|            0|  0.00%|                self.path_format, self.param_convertors, path_params
   469|         0|            0|            0|  0.00%|            )
   470|         0|            0|            0|  0.00%|            if path_kwarg is not None:
   471|         0|            0|            0|  0.00%|                remaining_params["path"] = path_kwarg
   472|         0|            0|            0|  0.00%|            for route in self.routes or []:
   473|         0|            0|            0|  0.00%|                try:
   474|         0|            0|            0|  0.00%|                    url = route.url_path_for(remaining_name, **remaining_params)
   475|         0|            0|            0|  0.00%|                    return URLPath(
   476|         0|            0|            0|  0.00%|                        path=path_prefix.rstrip("/") + str(url), protocol=url.protocol
   477|         0|            0|            0|  0.00%|                    )
   478|         0|            0|            0|  0.00%|                except NoMatchFound:
   479|         0|            0|            0|  0.00%|                    pass
   480|         0|            0|            0|  0.00%|        raise NoMatchFound(name, path_params)
   481|         0|            0|            0|  0.00%|
   482|         0|            0|            0|  0.00%|    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None:
   483|         0|            0|            0|  0.00%|        await self.app(scope, receive, send)
   484|         0|            0|            0|  0.00%|
   485|         0|            0|            0|  0.00%|    def __eq__(self, other: typing.Any) -> bool:
   486|         0|            0|            0|  0.00%|        return (
   487|         0|            0|            0|  0.00%|            isinstance(other, Mount)
   488|         0|            0|            0|  0.00%|            and self.path == other.path
   489|         0|            0|            0|  0.00%|            and self.app == other.app
   490|         0|            0|            0|  0.00%|        )
   491|         0|            0|            0|  0.00%|
   492|         0|            0|            0|  0.00%|    def __repr__(self) -> str:
   493|         0|            0|            0|  0.00%|        class_name = self.__class__.__name__
   494|         0|            0|            0|  0.00%|        name = self.name or ""
   495|         0|            0|            0|  0.00%|        return f"{class_name}(path={self.path!r}, name={name!r}, app={self.app!r})"
   496|         0|            0|            0|  0.00%|
   497|         0|            0|            0|  0.00%|
   498|         0|            0|            0|  0.00%|class Host(BaseRoute):
   499|         0|            0|            0|  0.00%|    def __init__(self, host: str, app: ASGIApp, name: str | None = None) -> None:
   500|         0|            0|            0|  0.00%|        assert not host.startswith("/"), "Host must not start with '/'"
   501|         0|            0|            0|  0.00%|        self.host = host
   502|         0|            0|            0|  0.00%|        self.app = app
   503|         0|            0|            0|  0.00%|        self.name = name
   504|         0|            0|            0|  0.00%|        self.host_regex, self.host_format, self.param_convertors = compile_path(host)
   505|         0|            0|            0|  0.00%|
   506|         0|            0|            0|  0.00%|    @property
   507|         0|            0|            0|  0.00%|    def routes(self) -> list[BaseRoute]:
   508|         0|            0|            0|  0.00%|        return getattr(self.app, "routes", [])
   509|         0|            0|            0|  0.00%|
   510|         0|            0|            0|  0.00%|    def matches(self, scope: Scope) -> tuple[Match, Scope]:
   511|         0|            0|            0|  0.00%|        if scope["type"] in ("http", "websocket"):
   512|         0|            0|            0|  0.00%|            headers = Headers(scope=scope)
   513|         0|            0|            0|  0.00%|            host = headers.get("host", "").split(":")[0]
   514|         0|            0|            0|  0.00%|            match = self.host_regex.match(host)
   515|         0|            0|            0|  0.00%|            if match:
   516|         0|            0|            0|  0.00%|                matched_params = match.groupdict()
   517|         0|            0|            0|  0.00%|                for key, value in matched_params.items():
   518|         0|            0|            0|  0.00%|                    matched_params[key] = self.param_convertors[key].convert(value)
   519|         0|            0|            0|  0.00%|                path_params = dict(scope.get("path_params", {}))
   520|         0|            0|            0|  0.00%|                path_params.update(matched_params)
   521|         0|            0|            0|  0.00%|                child_scope = {"path_params": path_params, "endpoint": self.app}
   522|         0|            0|            0|  0.00%|                return Match.FULL, child_scope
   523|         0|            0|            0|  0.00%|        return Match.NONE, {}
   524|         0|            0|            0|  0.00%|
   525|         0|            0|            0|  0.00%|    def url_path_for(self, name: str, /, **path_params: typing.Any) -> URLPath:
   526|         0|            0|            0|  0.00%|        if self.name is not None and name == self.name and "path" in path_params:
   527|         0|            0|            0|  0.00%|            # 'name' matches "<mount_name>".
   528|         0|            0|            0|  0.00%|            path = path_params.pop("path")
   529|         0|            0|            0|  0.00%|            host, remaining_params = replace_params(
   530|         0|            0|            0|  0.00%|                self.host_format, self.param_convertors, path_params
   531|         0|            0|            0|  0.00%|            )
   532|         0|            0|            0|  0.00%|            if not remaining_params:
   533|         0|            0|            0|  0.00%|                return URLPath(path=path, host=host)
   534|         0|            0|            0|  0.00%|        elif self.name is None or name.startswith(self.name + ":"):
   535|         0|            0|            0|  0.00%|            if self.name is None:
   536|         0|            0|            0|  0.00%|                # No mount name.
   537|         0|            0|            0|  0.00%|                remaining_name = name
   538|         0|            0|            0|  0.00%|            else:
   539|         0|            0|            0|  0.00%|                # 'name' matches "<mount_name>:<child_name>".
   540|         0|            0|            0|  0.00%|                remaining_name = name[len(self.name) + 1 :]
   541|         0|            0|            0|  0.00%|            host, remaining_params = replace_params(
   542|         0|            0|            0|  0.00%|                self.host_format, self.param_convertors, path_params
   543|         0|            0|            0|  0.00%|            )
   544|         0|            0|            0|  0.00%|            for route in self.routes or []:
   545|         0|            0|            0|  0.00%|                try:
   546|         0|            0|            0|  0.00%|                    url = route.url_path_for(remaining_name, **remaining_params)
   547|         0|            0|            0|  0.00%|                    return URLPath(path=str(url), protocol=url.protocol, host=host)
   548|         0|            0|            0|  0.00%|                except NoMatchFound:
   549|         0|            0|            0|  0.00%|                    pass
   550|         0|            0|            0|  0.00%|        raise NoMatchFound(name, path_params)
   551|         0|            0|            0|  0.00%|
   552|         0|            0|            0|  0.00%|    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None:
   553|         0|            0|            0|  0.00%|        await self.app(scope, receive, send)
   554|         0|            0|            0|  0.00%|
   555|         0|            0|            0|  0.00%|    def __eq__(self, other: typing.Any) -> bool:
   556|         0|            0|            0|  0.00%|        return (
   557|         0|            0|            0|  0.00%|            isinstance(other, Host)
   558|         0|            0|            0|  0.00%|            and self.host == other.host
   559|         0|            0|            0|  0.00%|            and self.app == other.app
   560|         0|            0|            0|  0.00%|        )
   561|         0|            0|            0|  0.00%|
   562|         0|            0|            0|  0.00%|    def __repr__(self) -> str:
   563|         0|            0|            0|  0.00%|        class_name = self.__class__.__name__
   564|         0|            0|            0|  0.00%|        name = self.name or ""
   565|         0|            0|            0|  0.00%|        return f"{class_name}(host={self.host!r}, name={name!r}, app={self.app!r})"
   566|         0|            0|            0|  0.00%|
   567|         0|            0|            0|  0.00%|
   568|         0|            0|            0|  0.00%|_T = typing.TypeVar("_T")
   569|         0|            0|            0|  0.00%|
   570|         0|            0|            0|  0.00%|
   571|         0|            0|            0|  0.00%|class _AsyncLiftContextManager(typing.AsyncContextManager[_T]):
   572|         0|            0|            0|  0.00%|    def __init__(self, cm: typing.ContextManager[_T]):
   573|         0|            0|            0|  0.00%|        self._cm = cm
   574|         0|            0|            0|  0.00%|
   575|         0|            0|            0|  0.00%|    async def __aenter__(self) -> _T:
   576|         0|            0|            0|  0.00%|        return self._cm.__enter__()
   577|         0|            0|            0|  0.00%|
   578|         0|            0|            0|  0.00%|    async def __aexit__(
   579|         0|            0|            0|  0.00%|        self,
   580|         0|            0|            0|  0.00%|        exc_type: type[BaseException] | None,
   581|         0|            0|            0|  0.00%|        exc_value: BaseException | None,
   582|         0|            0|            0|  0.00%|        traceback: types.TracebackType | None,
   583|         0|            0|            0|  0.00%|    ) -> bool | None:
   584|         0|            0|            0|  0.00%|        return self._cm.__exit__(exc_type, exc_value, traceback)
   585|         0|            0|            0|  0.00%|
   586|         0|            0|            0|  0.00%|
   587|         0|            0|            0|  0.00%|def _wrap_gen_lifespan_context(
   588|         0|            0|            0|  0.00%|    lifespan_context: typing.Callable[
   589|         0|            0|            0|  0.00%|        [typing.Any], typing.Generator[typing.Any, typing.Any, typing.Any]
   590|         0|            0|            0|  0.00%|    ],
   591|         0|            0|            0|  0.00%|) -> typing.Callable[[typing.Any], typing.AsyncContextManager[typing.Any]]:
   592|         0|            0|            0|  0.00%|    cmgr = contextlib.contextmanager(lifespan_context)
   593|         0|            0|            0|  0.00%|
   594|         0|            0|            0|  0.00%|    @functools.wraps(cmgr)
   595|         0|            0|            0|  0.00%|    def wrapper(app: typing.Any) -> _AsyncLiftContextManager[typing.Any]:
   596|         0|            0|            0|  0.00%|        return _AsyncLiftContextManager(cmgr(app))
   597|         0|            0|            0|  0.00%|
   598|         0|            0|            0|  0.00%|    return wrapper
   599|         0|            0|            0|  0.00%|
   600|         0|            0|            0|  0.00%|
   601|         0|            0|            0|  0.00%|class _DefaultLifespan:
   602|         0|            0|            0|  0.00%|    def __init__(self, router: Router):
   603|         0|            0|            0|  0.00%|        self._router = router
   604|         0|            0|            0|  0.00%|
   605|         0|            0|            0|  0.00%|    async def __aenter__(self) -> None:
   606|         0|            0|            0|  0.00%|        await self._router.startup()
   607|         0|            0|            0|  0.00%|
   608|         0|            0|            0|  0.00%|    async def __aexit__(self, *exc_info: object) -> None:
   609|         0|            0|            0|  0.00%|        await self._router.shutdown()
   610|         0|            0|            0|  0.00%|
   611|         0|            0|            0|  0.00%|    def __call__(self: _T, app: object) -> _T:
   612|         0|            0|            0|  0.00%|        return self
   613|         0|            0|            0|  0.00%|
   614|         0|            0|            0|  0.00%|
   615|         0|            0|            0|  0.00%|class Router:
   616|         0|            0|            0|  0.00%|    def __init__(
   617|         0|            0|            0|  0.00%|        self,
   618|         0|            0|            0|  0.00%|        routes: typing.Sequence[BaseRoute] | None = None,
   619|         0|            0|            0|  0.00%|        redirect_slashes: bool = True,
   620|         0|            0|            0|  0.00%|        default: ASGIApp | None = None,
   621|         0|            0|            0|  0.00%|        on_startup: typing.Sequence[typing.Callable[[], typing.Any]] | None = None,
   622|         0|            0|            0|  0.00%|        on_shutdown: typing.Sequence[typing.Callable[[], typing.Any]] | None = None,
   623|         0|            0|            0|  0.00%|        # the generic to Lifespan[AppType] is the type of the top level application
   624|         0|            0|            0|  0.00%|        # which the router cannot know statically, so we use typing.Any
   625|         0|            0|            0|  0.00%|        lifespan: Lifespan[typing.Any] | None = None,
   626|         0|            0|            0|  0.00%|        *,
   627|         0|            0|            0|  0.00%|        middleware: typing.Sequence[Middleware] | None = None,
   628|         0|            0|            0|  0.00%|    ) -> None:
   629|         0|            0|            0|  0.00%|        self.routes = [] if routes is None else list(routes)
   630|         0|            0|            0|  0.00%|        self.redirect_slashes = redirect_slashes
   631|         0|            0|            0|  0.00%|        self.default = self.not_found if default is None else default
   632|         0|            0|            0|  0.00%|        self.on_startup = [] if on_startup is None else list(on_startup)
   633|         0|            0|            0|  0.00%|        self.on_shutdown = [] if on_shutdown is None else list(on_shutdown)
   634|         0|            0|            0|  0.00%|
   635|         0|            0|            0|  0.00%|        if on_startup or on_shutdown:
   636|         0|            0|            0|  0.00%|            warnings.warn(
   637|         0|            0|            0|  0.00%|                "The on_startup and on_shutdown parameters are deprecated, and they "
   638|         0|            0|            0|  0.00%|                "will be removed on version 1.0. Use the lifespan parameter instead. "
   639|         0|            0|            0|  0.00%|                "See more about it on https://www.starlette.io/lifespan/.",
   640|         0|            0|            0|  0.00%|                DeprecationWarning,
   641|         0|            0|            0|  0.00%|            )
   642|         0|            0|            0|  0.00%|            if lifespan:
   643|         0|            0|            0|  0.00%|                warnings.warn(
   644|         0|            0|            0|  0.00%|                    "The `lifespan` parameter cannot be used with `on_startup` or "
   645|         0|            0|            0|  0.00%|                    "`on_shutdown`. Both `on_startup` and `on_shutdown` will be "
   646|         0|            0|            0|  0.00%|                    "ignored."
   647|         0|            0|            0|  0.00%|                )
   648|         0|            0|            0|  0.00%|
   649|         0|            0|            0|  0.00%|        if lifespan is None:
   650|         0|            0|            0|  0.00%|            self.lifespan_context: Lifespan[typing.Any] = _DefaultLifespan(self)
   651|         0|            0|            0|  0.00%|
   652|         0|            0|            0|  0.00%|        elif inspect.isasyncgenfunction(lifespan):
   653|         0|            0|            0|  0.00%|            warnings.warn(
   654|         0|            0|            0|  0.00%|                "async generator function lifespans are deprecated, "
   655|         0|            0|            0|  0.00%|                "use an @contextlib.asynccontextmanager function instead",
   656|         0|            0|            0|  0.00%|                DeprecationWarning,
   657|         0|            0|            0|  0.00%|            )
   658|         0|            0|            0|  0.00%|            self.lifespan_context = asynccontextmanager(
   659|         0|            0|            0|  0.00%|                lifespan,
   660|         0|            0|            0|  0.00%|            )
   661|         0|            0|            0|  0.00%|        elif inspect.isgeneratorfunction(lifespan):
   662|         0|            0|            0|  0.00%|            warnings.warn(
   663|         0|            0|            0|  0.00%|                "generator function lifespans are deprecated, "
   664|         0|            0|            0|  0.00%|                "use an @contextlib.asynccontextmanager function instead",
   665|         0|            0|            0|  0.00%|                DeprecationWarning,
   666|         0|            0|            0|  0.00%|            )
   667|         0|            0|            0|  0.00%|            self.lifespan_context = _wrap_gen_lifespan_context(
   668|         0|            0|            0|  0.00%|                lifespan,
   669|         0|            0|            0|  0.00%|            )
   670|         0|            0|            0|  0.00%|        else:
   671|         0|            0|            0|  0.00%|            self.lifespan_context = lifespan
   672|         0|            0|            0|  0.00%|
   673|         0|            0|            0|  0.00%|        self.middleware_stack = self.app
   674|         0|            0|            0|  0.00%|        if middleware:
   675|         0|            0|            0|  0.00%|            for cls, args, kwargs in reversed(middleware):
   676|         0|            0|            0|  0.00%|                self.middleware_stack = cls(self.middleware_stack, *args, **kwargs)
   677|         0|            0|            0|  0.00%|
   678|         0|            0|            0|  0.00%|    async def not_found(self, scope: Scope, receive: Receive, send: Send) -> None:
   679|         0|            0|            0|  0.00%|        if scope["type"] == "websocket":
   680|         0|            0|            0|  0.00%|            websocket_close = WebSocketClose()
   681|         0|            0|            0|  0.00%|            await websocket_close(scope, receive, send)
   682|         0|            0|            0|  0.00%|            return
   683|         0|            0|            0|  0.00%|
   684|         0|            0|            0|  0.00%|        # If we're running inside a starlette application then raise an
   685|         0|            0|            0|  0.00%|        # exception, so that the configurable exception handler can deal with
   686|         0|            0|            0|  0.00%|        # returning the response. For plain ASGI apps, just return the response.
   687|         0|            0|            0|  0.00%|        if "app" in scope:
   688|         0|            0|            0|  0.00%|            raise HTTPException(status_code=404)
   689|         0|            0|            0|  0.00%|        else:
   690|         0|            0|            0|  0.00%|            response = PlainTextResponse("Not Found", status_code=404)
   691|         0|            0|            0|  0.00%|        await response(scope, receive, send)
   692|         0|            0|            0|  0.00%|
   693|         0|            0|            0|  0.00%|    def url_path_for(self, name: str, /, **path_params: typing.Any) -> URLPath:
   694|         0|            0|            0|  0.00%|        for route in self.routes:
   695|         0|            0|            0|  0.00%|            try:
   696|         0|            0|            0|  0.00%|                return route.url_path_for(name, **path_params)
   697|         0|            0|            0|  0.00%|            except NoMatchFound:
   698|         0|            0|            0|  0.00%|                pass
   699|         0|            0|            0|  0.00%|        raise NoMatchFound(name, path_params)
   700|         0|            0|            0|  0.00%|
   701|         0|            0|            0|  0.00%|    async def startup(self) -> None:
   702|         0|            0|            0|  0.00%|        """
   703|         0|            0|            0|  0.00%|        Run any `.on_startup` event handlers.
   704|         0|            0|            0|  0.00%|        """
   705|         0|            0|            0|  0.00%|        for handler in self.on_startup:
   706|         0|            0|            0|  0.00%|            if is_async_callable(handler):
   707|         0|            0|            0|  0.00%|                await handler()
   708|         0|            0|            0|  0.00%|            else:
   709|         0|            0|            0|  0.00%|                handler()
   710|         0|            0|            0|  0.00%|
   711|         0|            0|            0|  0.00%|    async def shutdown(self) -> None:
   712|         0|            0|            0|  0.00%|        """
   713|         0|            0|            0|  0.00%|        Run any `.on_shutdown` event handlers.
   714|         0|            0|            0|  0.00%|        """
   715|         0|            0|            0|  0.00%|        for handler in self.on_shutdown:
   716|         0|            0|            0|  0.00%|            if is_async_callable(handler):
   717|         0|            0|            0|  0.00%|                await handler()
   718|         0|            0|            0|  0.00%|            else:
   719|         0|            0|            0|  0.00%|                handler()
   720|         0|            0|            0|  0.00%|
   721|         0|            0|            0|  0.00%|    async def lifespan(self, scope: Scope, receive: Receive, send: Send) -> None:
   722|         0|            0|            0|  0.00%|        """
   723|         0|            0|            0|  0.00%|        Handle ASGI lifespan messages, which allows us to manage application
   724|         0|            0|            0|  0.00%|        startup and shutdown events.
   725|         0|            0|            0|  0.00%|        """
   726|         0|            0|            0|  0.00%|        started = False
   727|         0|            0|            0|  0.00%|        app: typing.Any = scope.get("app")
   728|         0|            0|            0|  0.00%|        await receive()
   729|         0|            0|            0|  0.00%|        try:
   730|         0|            0|            0|  0.00%|            async with self.lifespan_context(app) as maybe_state:
   731|         0|            0|            0|  0.00%|                if maybe_state is not None:
   732|         0|            0|            0|  0.00%|                    if "state" not in scope:
   733|         0|            0|            0|  0.00%|                        raise RuntimeError(
   734|         0|            0|            0|  0.00%|                            'The server does not support "state" in the lifespan scope.'
   735|         0|            0|            0|  0.00%|                        )
   736|         0|            0|            0|  0.00%|                    scope["state"].update(maybe_state)
   737|         0|            0|            0|  0.00%|                await send({"type": "lifespan.startup.complete"})
   738|         0|            0|            0|  0.00%|                started = True
   739|         0|            0|            0|  0.00%|                await receive()
   740|         0|            0|            0|  0.00%|        except BaseException:
   741|         0|            0|            0|  0.00%|            exc_text = traceback.format_exc()
   742|         0|            0|            0|  0.00%|            if started:
   743|         0|            0|            0|  0.00%|                await send({"type": "lifespan.shutdown.failed", "message": exc_text})
   744|         0|            0|            0|  0.00%|            else:
   745|         0|            0|            0|  0.00%|                await send({"type": "lifespan.startup.failed", "message": exc_text})
   746|         0|            0|            0|  0.00%|            raise
   747|         0|            0|            0|  0.00%|        else:
   748|         0|            0|            0|  0.00%|            await send({"type": "lifespan.shutdown.complete"})
   749|         0|            0|            0|  0.00%|
   750|         0|            0|            0|  0.00%|    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
   751|         0|            0|            0|  0.00%|        """
   752|         0|            0|            0|  0.00%|        The main entry point to the Router class.
   753|         0|            0|            0|  0.00%|        """
   754|         0|            0|            0|  0.00%|        await self.middleware_stack(scope, receive, send)
   755|         0|            0|            0|  0.00%|
   756|         0|            0|            0|  0.00%|    async def app(self, scope: Scope, receive: Receive, send: Send) -> None:
   757|         0|            0|            0|  0.00%|        assert scope["type"] in ("http", "websocket", "lifespan")
   758|         0|            0|            0|  0.00%|
   759|         0|            0|            0|  0.00%|        if "router" not in scope:
   760|         0|            0|            0|  0.00%|            scope["router"] = self
   761|         0|            0|            0|  0.00%|
   762|         0|            0|            0|  0.00%|        if scope["type"] == "lifespan":
   763|         0|            0|            0|  0.00%|            await self.lifespan(scope, receive, send)
   764|         0|            0|            0|  0.00%|            return
   765|         0|            0|            0|  0.00%|
   766|         0|            0|            0|  0.00%|        partial = None
   767|         0|            0|            0|  0.00%|
   768|         0|            0|            0|  0.00%|        for route in self.routes:
   769|         0|            0|            0|  0.00%|            # Determine if any route matches the incoming scope,
   770|         0|            0|            0|  0.00%|            # and hand over to the matching route if found.
   771|         0|            0|            0|  0.00%|            match, child_scope = route.matches(scope)
   772|         0|            0|            0|  0.00%|            if match == Match.FULL:
   773|         0|            0|            0|  0.00%|                scope.update(child_scope)
   774|         0|            0|            0|  0.00%|                await route.handle(scope, receive, send)
   775|         0|            0|            0|  0.00%|                return
   776|         0|            0|            0|  0.00%|            elif match == Match.PARTIAL and partial is None:
   777|         0|            0|            0|  0.00%|                partial = route
   778|         0|            0|            0|  0.00%|                partial_scope = child_scope
   779|         0|            0|            0|  0.00%|
   780|         0|            0|            0|  0.00%|        if partial is not None:
   781|         0|            0|            0|  0.00%|            #  Handle partial matches. These are cases where an endpoint is
   782|         0|            0|            0|  0.00%|            # able to handle the request, but is not a preferred option.
   783|         0|            0|            0|  0.00%|            # We use this in particular to deal with "405 Method Not Allowed".
   784|         0|            0|            0|  0.00%|            scope.update(partial_scope)
   785|         0|            0|            0|  0.00%|            await partial.handle(scope, receive, send)
   786|         0|            0|            0|  0.00%|            return
   787|         0|            0|            0|  0.00%|
   788|         0|            0|            0|  0.00%|        route_path = get_route_path(scope)
   789|         0|            0|            0|  0.00%|        if scope["type"] == "http" and self.redirect_slashes and route_path != "/":
   790|         0|            0|            0|  0.00%|            redirect_scope = dict(scope)
   791|         0|            0|            0|  0.00%|            if route_path.endswith("/"):
   792|         0|            0|            0|  0.00%|                redirect_scope["path"] = redirect_scope["path"].rstrip("/")
   793|         0|            0|            0|  0.00%|            else:
   794|         0|            0|            0|  0.00%|                redirect_scope["path"] = redirect_scope["path"] + "/"
   795|         0|            0|            0|  0.00%|
   796|         0|            0|            0|  0.00%|            for route in self.routes:
   797|         0|            0|            0|  0.00%|                match, child_scope = route.matches(redirect_scope)
   798|         0|            0|            0|  0.00%|                if match != Match.NONE:
   799|         0|            0|            0|  0.00%|                    redirect_url = URL(scope=redirect_scope)
   800|         0|            0|            0|  0.00%|                    response = RedirectResponse(url=str(redirect_url))
   801|         0|            0|            0|  0.00%|                    await response(scope, receive, send)
   802|         0|            0|            0|  0.00%|                    return
   803|         0|            0|            0|  0.00%|
   804|         0|            0|            0|  0.00%|        await self.default(scope, receive, send)
   805|         0|            0|            0|  0.00%|
   806|         0|            0|            0|  0.00%|    def __eq__(self, other: typing.Any) -> bool:
   807|         0|            0|            0|  0.00%|        return isinstance(other, Router) and self.routes == other.routes
   808|         0|            0|            0|  0.00%|
   809|         0|            0|            0|  0.00%|    def mount(
   810|         0|            0|            0|  0.00%|        self, path: str, app: ASGIApp, name: str | None = None
   811|         0|            0|            0|  0.00%|    ) -> None:  # pragma: nocover
   812|         0|            0|            0|  0.00%|        route = Mount(path, app=app, name=name)
   813|         0|            0|            0|  0.00%|        self.routes.append(route)
   814|         0|            0|            0|  0.00%|
   815|         0|            0|            0|  0.00%|    def host(
   816|         0|            0|            0|  0.00%|        self, host: str, app: ASGIApp, name: str | None = None
   817|         0|            0|            0|  0.00%|    ) -> None:  # pragma: no cover
   818|         0|            0|            0|  0.00%|        route = Host(host, app=app, name=name)
   819|         0|            0|            0|  0.00%|        self.routes.append(route)
   820|         0|            0|            0|  0.00%|
   821|         0|            0|            0|  0.00%|    def add_route(
   822|         0|            0|            0|  0.00%|        self,
   823|         0|            0|            0|  0.00%|        path: str,
   824|         0|            0|            0|  0.00%|        endpoint: typing.Callable[[Request], typing.Awaitable[Response] | Response],
   825|         0|            0|            0|  0.00%|        methods: list[str] | None = None,
   826|         0|            0|            0|  0.00%|        name: str | None = None,
   827|         0|            0|            0|  0.00%|        include_in_schema: bool = True,
   828|         0|            0|            0|  0.00%|    ) -> None:  # pragma: nocover
   829|         0|            0|            0|  0.00%|        route = Route(
   830|         0|            0|            0|  0.00%|            path,
   831|         0|            0|            0|  0.00%|            endpoint=endpoint,
   832|         0|            0|            0|  0.00%|            methods=methods,
   833|         0|            0|            0|  0.00%|            name=name,
   834|         0|            0|            0|  0.00%|            include_in_schema=include_in_schema,
   835|         0|            0|            0|  0.00%|        )
   836|         0|            0|            0|  0.00%|        self.routes.append(route)
   837|         0|            0|            0|  0.00%|
   838|         0|            0|            0|  0.00%|    def add_websocket_route(
   839|         0|            0|            0|  0.00%|        self,
   840|         0|            0|            0|  0.00%|        path: str,
   841|         0|            0|            0|  0.00%|        endpoint: typing.Callable[[WebSocket], typing.Awaitable[None]],
   842|         0|            0|            0|  0.00%|        name: str | None = None,
   843|         0|            0|            0|  0.00%|    ) -> None:  # pragma: no cover
   844|         0|            0|            0|  0.00%|        route = WebSocketRoute(path, endpoint=endpoint, name=name)
   845|         0|            0|            0|  0.00%|        self.routes.append(route)
   846|         0|            0|            0|  0.00%|
   847|         0|            0|            0|  0.00%|    def route(
   848|         0|            0|            0|  0.00%|        self,
   849|         0|            0|            0|  0.00%|        path: str,
   850|         0|            0|            0|  0.00%|        methods: list[str] | None = None,
   851|         0|            0|            0|  0.00%|        name: str | None = None,
   852|         0|            0|            0|  0.00%|        include_in_schema: bool = True,
   853|         0|            0|            0|  0.00%|    ) -> typing.Callable:  # type: ignore[type-arg]
   854|         0|            0|            0|  0.00%|        """
   855|         0|            0|            0|  0.00%|        We no longer document this decorator style API, and its usage is discouraged.
   856|         0|            0|            0|  0.00%|        Instead you should use the following approach:
   857|         0|            0|            0|  0.00%|
   858|         0|            0|            0|  0.00%|        >>> routes = [Route(path, endpoint=...), ...]
   859|         0|            0|            0|  0.00%|        >>> app = Starlette(routes=routes)
   860|         0|            0|            0|  0.00%|        """
   861|         0|            0|            0|  0.00%|        warnings.warn(
   862|         0|            0|            0|  0.00%|            "The `route` decorator is deprecated, and will be removed in version 1.0.0."
   863|         0|            0|            0|  0.00%|            "Refer to https://www.starlette.io/routing/#http-routing for the recommended approach.",  # noqa: E501
   864|         0|            0|            0|  0.00%|            DeprecationWarning,
   865|         0|            0|            0|  0.00%|        )
   866|         0|            0|            0|  0.00%|
   867|         0|            0|            0|  0.00%|        def decorator(func: typing.Callable) -> typing.Callable:  # type: ignore[type-arg]  # noqa: E501
   868|         0|            0|            0|  0.00%|            self.add_route(
   869|         0|            0|            0|  0.00%|                path,
   870|         0|            0|            0|  0.00%|                func,
   871|         0|            0|            0|  0.00%|                methods=methods,
   872|         0|            0|            0|  0.00%|                name=name,
   873|         0|            0|            0|  0.00%|                include_in_schema=include_in_schema,
   874|         0|            0|            0|  0.00%|            )
   875|         0|            0|            0|  0.00%|            return func
   876|         0|            0|            0|  0.00%|
   877|         0|            0|            0|  0.00%|        return decorator
   878|         0|            0|            0|  0.00%|
   879|         0|            0|            0|  0.00%|    def websocket_route(self, path: str, name: str | None = None) -> typing.Callable:  # type: ignore[type-arg]
   880|         0|            0|            0|  0.00%|        """
   881|         0|            0|            0|  0.00%|        We no longer document this decorator style API, and its usage is discouraged.
   882|         0|            0|            0|  0.00%|        Instead you should use the following approach:
   883|         0|            0|            0|  0.00%|
   884|         0|            0|            0|  0.00%|        >>> routes = [WebSocketRoute(path, endpoint=...), ...]
   885|         0|            0|            0|  0.00%|        >>> app = Starlette(routes=routes)
   886|         0|            0|            0|  0.00%|        """
   887|         0|            0|            0|  0.00%|        warnings.warn(
   888|         0|            0|            0|  0.00%|            "The `websocket_route` decorator is deprecated, and will be removed in version 1.0.0. Refer to "  # noqa: E501
   889|         0|            0|            0|  0.00%|            "https://www.starlette.io/routing/#websocket-routing for the recommended approach.",  # noqa: E501
   890|         0|            0|            0|  0.00%|            DeprecationWarning,
   891|         0|            0|            0|  0.00%|        )
   892|         0|            0|            0|  0.00%|
   893|         0|            0|            0|  0.00%|        def decorator(func: typing.Callable) -> typing.Callable:  # type: ignore[type-arg]  # noqa: E501
   894|         0|            0|            0|  0.00%|            self.add_websocket_route(path, func, name=name)
   895|         0|            0|            0|  0.00%|            return func
   896|         0|            0|            0|  0.00%|
   897|         0|            0|            0|  0.00%|        return decorator
   898|         0|            0|            0|  0.00%|
   899|         0|            0|            0|  0.00%|    def add_event_handler(
   900|         0|            0|            0|  0.00%|        self, event_type: str, func: typing.Callable[[], typing.Any]
   901|         0|            0|            0|  0.00%|    ) -> None:  # pragma: no cover
   902|         0|            0|            0|  0.00%|        assert event_type in ("startup", "shutdown")
   903|         0|            0|            0|  0.00%|
   904|         0|            0|            0|  0.00%|        if event_type == "startup":
   905|         0|            0|            0|  0.00%|            self.on_startup.append(func)
   906|         0|            0|            0|  0.00%|        else:
   907|         0|            0|            0|  0.00%|            self.on_shutdown.append(func)
   908|         0|            0|            0|  0.00%|
   909|         0|            0|            0|  0.00%|    def on_event(self, event_type: str) -> typing.Callable:  # type: ignore[type-arg]
   910|         0|            0|            0|  0.00%|        warnings.warn(
   911|         0|            0|            0|  0.00%|            "The `on_event` decorator is deprecated, and will be removed in version 1.0.0. "  # noqa: E501
   912|         0|            0|            0|  0.00%|            "Refer to https://www.starlette.io/lifespan/ for recommended approach.",
   913|         0|            0|            0|  0.00%|            DeprecationWarning,
   914|         0|            0|            0|  0.00%|        )
   915|         0|            0|            0|  0.00%|
   916|         0|            0|            0|  0.00%|        def decorator(func: typing.Callable) -> typing.Callable:  # type: ignore[type-arg]  # noqa: E501
   917|         0|            0|            0|  0.00%|            self.add_event_handler(event_type, func)
   918|         0|            0|            0|  0.00%|            return func
   919|         0|            0|            0|  0.00%|
   920|         0|            0|            0|  0.00%|        return decorator
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_typing_extra.py
File duration: 0.000165939s (0.17%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Logic for interacting with type annotations, mostly extensions, shims and hacks to wrap python's typing module."""
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|from __future__ import annotations as _annotations
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|import dataclasses
     6|         0|            0|            0|  0.00%|import re
     7|         0|            0|            0|  0.00%|import sys
     8|         0|            0|            0|  0.00%|import types
     9|         0|            0|            0|  0.00%|import typing
    10|         0|            0|            0|  0.00%|import warnings
    11|         0|            0|            0|  0.00%|from collections.abc import Callable
    12|         0|            0|            0|  0.00%|from functools import partial
    13|         0|            0|            0|  0.00%|from types import GetSetDescriptorType
    14|         0|            0|            0|  0.00%|from typing import TYPE_CHECKING, Any, Final
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|from typing_extensions import Annotated, Literal, TypeAliasType, TypeGuard, deprecated, get_args, get_origin
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|if TYPE_CHECKING:
    19|         0|            0|            0|  0.00%|    from ._dataclasses import StandardDataclass
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|try:
    22|         0|            0|            0|  0.00%|    from typing import _TypingBase  # type: ignore[attr-defined]
    23|         0|            0|            0|  0.00%|except ImportError:
    24|         0|            0|            0|  0.00%|    from typing import _Final as _TypingBase  # type: ignore[attr-defined]
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|typing_base = _TypingBase
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|if sys.version_info < (3, 9):
    30|         0|            0|            0|  0.00%|    # python < 3.9 does not have GenericAlias (list[int], tuple[str, ...] and so on)
    31|         0|            0|            0|  0.00%|    TypingGenericAlias = ()
    32|         0|            0|            0|  0.00%|else:
    33|         0|            0|            0|  0.00%|    from typing import GenericAlias as TypingGenericAlias  # type: ignore
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|if sys.version_info < (3, 11):
    37|         0|            0|            0|  0.00%|    from typing_extensions import NotRequired, Required
    38|         0|            0|            0|  0.00%|else:
    39|         0|            0|            0|  0.00%|    from typing import NotRequired, Required  # noqa: F401
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|if sys.version_info < (3, 10):
    43|         0|            0|            0|  0.00%|
    44|         0|            0|            0|  0.00%|    def origin_is_union(tp: type[Any] | None) -> bool:
    45|         0|            0|            0|  0.00%|        return tp is typing.Union
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|    WithArgsTypes = (TypingGenericAlias,)
    48|         0|            0|            0|  0.00%|
    49|         0|            0|            0|  0.00%|else:
    50|         0|            0|            0|  0.00%|
    51|         2|  5.24521e-06|   2.6226e-06|  0.01%|    def origin_is_union(tp: type[Any] | None) -> bool:
    52|         2|  4.29153e-06|  2.14577e-06|  0.00%|        return tp is typing.Union or tp is types.UnionType
    53|         0|            0|            0|  0.00%|
    54|         0|            0|            0|  0.00%|    WithArgsTypes = typing._GenericAlias, types.GenericAlias, types.UnionType  # type: ignore[attr-defined]
    55|         0|            0|            0|  0.00%|
    56|         0|            0|            0|  0.00%|
    57|         0|            0|            0|  0.00%|if sys.version_info < (3, 10):
    58|         0|            0|            0|  0.00%|    NoneType = type(None)
    59|         0|            0|            0|  0.00%|    EllipsisType = type(Ellipsis)
    60|         0|            0|            0|  0.00%|else:
    61|         0|            0|            0|  0.00%|    from types import NoneType as NoneType
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|LITERAL_TYPES: set[Any] = {Literal}
    65|         0|            0|            0|  0.00%|if hasattr(typing, 'Literal'):
    66|         0|            0|            0|  0.00%|    LITERAL_TYPES.add(typing.Literal)  # type: ignore
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|# Check if `deprecated` is a type to prevent errors when using typing_extensions < 4.9.0
    69|         0|            0|            0|  0.00%|DEPRECATED_TYPES: tuple[Any, ...] = (deprecated,) if isinstance(deprecated, type) else ()
    70|         0|            0|            0|  0.00%|if hasattr(warnings, 'deprecated'):
    71|         0|            0|            0|  0.00%|    DEPRECATED_TYPES = (*DEPRECATED_TYPES, warnings.deprecated)  # type: ignore
    72|         0|            0|            0|  0.00%|
    73|         0|            0|            0|  0.00%|NONE_TYPES: tuple[Any, ...] = (None, NoneType, *(tp[None] for tp in LITERAL_TYPES))
    74|         0|            0|            0|  0.00%|
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|TypeVarType = Any  # since mypy doesn't allow the use of TypeVar as a type
    77|         0|            0|            0|  0.00%|
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|def is_none_type(type_: Any) -> bool:
    80|         0|            0|            0|  0.00%|    return type_ in NONE_TYPES
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|
    83|         0|            0|            0|  0.00%|def is_callable_type(type_: type[Any]) -> bool:
    84|         0|            0|            0|  0.00%|    return type_ is Callable or get_origin(type_) is Callable
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|
    87|         0|            0|            0|  0.00%|def is_literal_type(type_: type[Any]) -> bool:
    88|         0|            0|            0|  0.00%|    return Literal is not None and get_origin(type_) in LITERAL_TYPES
    89|         0|            0|            0|  0.00%|
    90|         0|            0|            0|  0.00%|
    91|         0|            0|            0|  0.00%|def is_deprecated_instance(instance: Any) -> TypeGuard[deprecated]:
    92|         0|            0|            0|  0.00%|    return isinstance(instance, DEPRECATED_TYPES)
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|
    95|         0|            0|            0|  0.00%|def literal_values(type_: type[Any]) -> tuple[Any, ...]:
    96|         0|            0|            0|  0.00%|    return get_args(type_)
    97|         0|            0|            0|  0.00%|
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|def all_literal_values(type_: type[Any]) -> list[Any]:
   100|         0|            0|            0|  0.00%|    """This method is used to retrieve all Literal values as
   101|         0|            0|            0|  0.00%|    Literal can be used recursively (see https://www.python.org/dev/peps/pep-0586)
   102|         0|            0|            0|  0.00%|    e.g. `Literal[Literal[Literal[1, 2, 3], "foo"], 5, None]`.
   103|         0|            0|            0|  0.00%|    """
   104|         0|            0|            0|  0.00%|    if not is_literal_type(type_):
   105|         0|            0|            0|  0.00%|        return [type_]
   106|         0|            0|            0|  0.00%|
   107|         0|            0|            0|  0.00%|    values = literal_values(type_)
   108|         0|            0|            0|  0.00%|    return list(x for value in values for x in all_literal_values(value))
   109|         0|            0|            0|  0.00%|
   110|         0|            0|            0|  0.00%|
   111|         6|  1.12057e-05|  1.86761e-06|  0.01%|def is_annotated(ann_type: Any) -> bool:
   112|         6|  3.19481e-05|  5.32468e-06|  0.03%|    return get_origin(ann_type) is Annotated
(call)|         6|  4.33922e-05|  7.23203e-06|  0.04%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:2310 get_origin
   113|         0|            0|            0|  0.00%|
   114|         0|            0|            0|  0.00%|
   115|         4|  8.58307e-06|  2.14577e-06|  0.01%|def annotated_type(type_: Any) -> Any | None:
   116|         4|  3.43323e-05|  8.58307e-06|  0.04%|    return get_args(type_)[0] if is_annotated(type_) else None
(call)|         4|  4.33922e-05|   1.0848e-05|  0.04%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_typing_extra.py:111 is_annotated
(call)|         4|  2.12193e-05|  5.30481e-06|  0.02%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/typing.py:2340 get_args
   117|         0|            0|            0|  0.00%|
   118|         0|            0|            0|  0.00%|
   119|         0|            0|            0|  0.00%|def is_namedtuple(type_: type[Any]) -> bool:
   120|         0|            0|            0|  0.00%|    """Check if a given class is a named tuple.
   121|         0|            0|            0|  0.00%|    It can be either a `typing.NamedTuple` or `collections.namedtuple`.
   122|         0|            0|            0|  0.00%|    """
   123|         0|            0|            0|  0.00%|    from ._utils import lenient_issubclass
   124|         0|            0|            0|  0.00%|
   125|         0|            0|            0|  0.00%|    return lenient_issubclass(type_, tuple) and hasattr(type_, '_fields')
   126|         0|            0|            0|  0.00%|
   127|         0|            0|            0|  0.00%|
   128|         0|            0|            0|  0.00%|test_new_type = typing.NewType('test_new_type', str)
   129|         0|            0|            0|  0.00%|
   130|         0|            0|            0|  0.00%|
   131|         0|            0|            0|  0.00%|def is_new_type(type_: type[Any]) -> bool:
   132|         0|            0|            0|  0.00%|    """Check whether type_ was created using typing.NewType.
   133|         0|            0|            0|  0.00%|
   134|         0|            0|            0|  0.00%|    Can't use isinstance because it fails <3.10.
   135|         0|            0|            0|  0.00%|    """
   136|         0|            0|            0|  0.00%|    return isinstance(type_, test_new_type.__class__) and hasattr(type_, '__supertype__')  # type: ignore[arg-type]
   137|         0|            0|            0|  0.00%|
   138|         0|            0|            0|  0.00%|
   139|         0|            0|            0|  0.00%|def _check_classvar(v: type[Any] | None) -> bool:
   140|         0|            0|            0|  0.00%|    if v is None:
   141|         0|            0|            0|  0.00%|        return False
   142|         0|            0|            0|  0.00%|
   143|         0|            0|            0|  0.00%|    return v.__class__ == typing.ClassVar.__class__ and getattr(v, '_name', None) == 'ClassVar'
   144|         0|            0|            0|  0.00%|
   145|         0|            0|            0|  0.00%|
   146|         0|            0|            0|  0.00%|def is_classvar(ann_type: type[Any]) -> bool:
   147|         0|            0|            0|  0.00%|    if _check_classvar(ann_type) or _check_classvar(get_origin(ann_type)):
   148|         0|            0|            0|  0.00%|        return True
   149|         0|            0|            0|  0.00%|
   150|         0|            0|            0|  0.00%|    # this is an ugly workaround for class vars that contain forward references and are therefore themselves
   151|         0|            0|            0|  0.00%|    # forward references, see #3679
   152|         0|            0|            0|  0.00%|    if ann_type.__class__ == typing.ForwardRef and re.match(
   153|         0|            0|            0|  0.00%|        r'(\w+\.)?ClassVar\[',
   154|         0|            0|            0|  0.00%|        ann_type.__forward_arg__,  # type: ignore
   155|         0|            0|            0|  0.00%|    ):
   156|         0|            0|            0|  0.00%|        return True
   157|         0|            0|            0|  0.00%|
   158|         0|            0|            0|  0.00%|    return False
   159|         0|            0|            0|  0.00%|
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|def _check_finalvar(v: type[Any] | None) -> bool:
   162|         0|            0|            0|  0.00%|    """Check if a given type is a `typing.Final` type."""
   163|         0|            0|            0|  0.00%|    if v is None:
   164|         0|            0|            0|  0.00%|        return False
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|    return v.__class__ == Final.__class__ and (sys.version_info < (3, 8) or getattr(v, '_name', None) == 'Final')
   167|         0|            0|            0|  0.00%|
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|def is_finalvar(ann_type: Any) -> bool:
   170|         0|            0|            0|  0.00%|    return _check_finalvar(ann_type) or _check_finalvar(get_origin(ann_type))
   171|         0|            0|            0|  0.00%|
   172|         0|            0|            0|  0.00%|
   173|         2|  1.28746e-05|   6.4373e-06|  0.01%|def parent_frame_namespace(*, parent_depth: int = 2) -> dict[str, Any] | None:
   174|         0|            0|            0|  0.00%|    """We allow use of items in parent namespace to get around the issue with `get_type_hints` only looking in the
   175|         0|            0|            0|  0.00%|    global module namespace. See https://github.com/pydantic/pydantic/issues/2678#issuecomment-1008139014 -> Scope
   176|         0|            0|            0|  0.00%|    and suggestion at the end of the next comment by @gvanrossum.
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|    WARNING 1: it matters exactly where this is called. By default, this function will build a namespace from the
   179|         0|            0|            0|  0.00%|    parent of where it is called.
   180|         0|            0|            0|  0.00%|
   181|         0|            0|            0|  0.00%|    WARNING 2: this only looks in the parent namespace, not other parents since (AFAIK) there's no way to collect a
   182|         0|            0|            0|  0.00%|    dict of exactly what's in scope. Using `f_back` would work sometimes but would be very wrong and confusing in many
   183|         0|            0|            0|  0.00%|    other cases. See https://discuss.python.org/t/is-there-a-way-to-access-parent-nested-namespaces/20659.
   184|         0|            0|            0|  0.00%|    """
   185|         2|  4.29153e-06|  2.14577e-06|  0.00%|    frame = sys._getframe(parent_depth)
   186|         0|            0|            0|  0.00%|    # if f_back is None, it's the global module namespace and we don't need to include it here
   187|         2|  2.86102e-06|  1.43051e-06|  0.00%|    if frame.f_back is None:
   188|         0|            0|            0|  0.00%|        return None
   189|         0|            0|            0|  0.00%|    else:
   190|         2|  3.57628e-06|  1.78814e-06|  0.00%|        return frame.f_locals
   191|         0|            0|            0|  0.00%|
   192|         0|            0|            0|  0.00%|
   193|         0|            0|            0|  0.00%|def add_module_globals(obj: Any, globalns: dict[str, Any] | None = None) -> dict[str, Any]:
   194|         0|            0|            0|  0.00%|    module_name = getattr(obj, '__module__', None)
   195|         0|            0|            0|  0.00%|    if module_name:
   196|         0|            0|            0|  0.00%|        try:
   197|         0|            0|            0|  0.00%|            module_globalns = sys.modules[module_name].__dict__
   198|         0|            0|            0|  0.00%|        except KeyError:
   199|         0|            0|            0|  0.00%|            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363
   200|         0|            0|            0|  0.00%|            pass
   201|         0|            0|            0|  0.00%|        else:
   202|         0|            0|            0|  0.00%|            if globalns:
   203|         0|            0|            0|  0.00%|                return {**module_globalns, **globalns}
   204|         0|            0|            0|  0.00%|            else:
   205|         0|            0|            0|  0.00%|                # copy module globals to make sure it can't be updated later
   206|         0|            0|            0|  0.00%|                return module_globalns.copy()
   207|         0|            0|            0|  0.00%|
   208|         0|            0|            0|  0.00%|    return globalns or {}
   209|         0|            0|            0|  0.00%|
   210|         0|            0|            0|  0.00%|
   211|         0|            0|            0|  0.00%|def get_cls_types_namespace(cls: type[Any], parent_namespace: dict[str, Any] | None = None) -> dict[str, Any]:
   212|         0|            0|            0|  0.00%|    ns = add_module_globals(cls, parent_namespace)
   213|         0|            0|            0|  0.00%|    ns[cls.__name__] = cls
   214|         0|            0|            0|  0.00%|    return ns
   215|         0|            0|            0|  0.00%|
   216|         0|            0|            0|  0.00%|
   217|         0|            0|            0|  0.00%|def get_cls_type_hints_lenient(obj: Any, globalns: dict[str, Any] | None = None) -> dict[str, Any]:
   218|         0|            0|            0|  0.00%|    """Collect annotations from a class, including those from parent classes.
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|    Unlike `typing.get_type_hints`, this function will not error if a forward reference is not resolvable.
   221|         0|            0|            0|  0.00%|    """
   222|         0|            0|            0|  0.00%|    hints = {}
   223|         0|            0|            0|  0.00%|    for base in reversed(obj.__mro__):
   224|         0|            0|            0|  0.00%|        ann = base.__dict__.get('__annotations__')
   225|         0|            0|            0|  0.00%|        localns = dict(vars(base))
   226|         0|            0|            0|  0.00%|        if ann is not None and ann is not GetSetDescriptorType:
   227|         0|            0|            0|  0.00%|            for name, value in ann.items():
   228|         0|            0|            0|  0.00%|                hints[name] = eval_type_lenient(value, globalns, localns)
   229|         0|            0|            0|  0.00%|    return hints
   230|         0|            0|            0|  0.00%|
   231|         0|            0|            0|  0.00%|
   232|         0|            0|            0|  0.00%|def eval_type_lenient(value: Any, globalns: dict[str, Any] | None = None, localns: dict[str, Any] | None = None) -> Any:
   233|         0|            0|            0|  0.00%|    """Behaves like typing._eval_type, except it won't raise an error if a forward reference can't be resolved."""
   234|         0|            0|            0|  0.00%|    if value is None:
   235|         0|            0|            0|  0.00%|        value = NoneType
   236|         0|            0|            0|  0.00%|    elif isinstance(value, str):
   237|         0|            0|            0|  0.00%|        value = _make_forward_ref(value, is_argument=False, is_class=True)
   238|         0|            0|            0|  0.00%|
   239|         0|            0|            0|  0.00%|    try:
   240|         0|            0|            0|  0.00%|        return eval_type_backport(value, globalns, localns)
   241|         0|            0|            0|  0.00%|    except NameError:
   242|         0|            0|            0|  0.00%|        # the point of this function is to be tolerant to this case
   243|         0|            0|            0|  0.00%|        return value
   244|         0|            0|            0|  0.00%|
   245|         0|            0|            0|  0.00%|
   246|         0|            0|            0|  0.00%|def eval_type_backport(
   247|         0|            0|            0|  0.00%|    value: Any,
   248|         0|            0|            0|  0.00%|    globalns: dict[str, Any] | None = None,
   249|         0|            0|            0|  0.00%|    localns: dict[str, Any] | None = None,
   250|         0|            0|            0|  0.00%|    type_params: tuple[Any] | None = None,
   251|         0|            0|            0|  0.00%|) -> Any:
   252|         0|            0|            0|  0.00%|    """Like `typing._eval_type`, but falls back to the `eval_type_backport` package if it's
   253|         0|            0|            0|  0.00%|    installed to let older Python versions use newer typing features.
   254|         0|            0|            0|  0.00%|    Specifically, this transforms `X | Y` into `typing.Union[X, Y]`
   255|         0|            0|            0|  0.00%|    and `list[X]` into `typing.List[X]` etc. (for all the types made generic in PEP 585)
   256|         0|            0|            0|  0.00%|    if the original syntax is not supported in the current Python version.
   257|         0|            0|            0|  0.00%|    """
   258|         0|            0|            0|  0.00%|    try:
   259|         0|            0|            0|  0.00%|        if sys.version_info >= (3, 13):
   260|         0|            0|            0|  0.00%|            return typing._eval_type(  # type: ignore
   261|         0|            0|            0|  0.00%|                value, globalns, localns, type_params=type_params
   262|         0|            0|            0|  0.00%|            )
   263|         0|            0|            0|  0.00%|        else:
   264|         0|            0|            0|  0.00%|            return typing._eval_type(  # type: ignore
   265|         0|            0|            0|  0.00%|                value, globalns, localns
   266|         0|            0|            0|  0.00%|            )
   267|         0|            0|            0|  0.00%|    except TypeError as e:
   268|         0|            0|            0|  0.00%|        if not (isinstance(value, typing.ForwardRef) and is_backport_fixable_error(e)):
   269|         0|            0|            0|  0.00%|            raise
   270|         0|            0|            0|  0.00%|        try:
   271|         0|            0|            0|  0.00%|            from eval_type_backport import eval_type_backport
   272|         0|            0|            0|  0.00%|        except ImportError:
   273|         0|            0|            0|  0.00%|            raise TypeError(
   274|         0|            0|            0|  0.00%|                f'You have a type annotation {value.__forward_arg__!r} '
   275|         0|            0|            0|  0.00%|                f'which makes use of newer typing features than are supported in your version of Python. '
   276|         0|            0|            0|  0.00%|                f'To handle this error, you should either remove the use of new syntax '
   277|         0|            0|            0|  0.00%|                f'or install the `eval_type_backport` package.'
   278|         0|            0|            0|  0.00%|            ) from e
   279|         0|            0|            0|  0.00%|
   280|         0|            0|            0|  0.00%|        return eval_type_backport(value, globalns, localns, try_default=False)
   281|         0|            0|            0|  0.00%|
   282|         0|            0|            0|  0.00%|
   283|         0|            0|            0|  0.00%|def is_backport_fixable_error(e: TypeError) -> bool:
   284|         0|            0|            0|  0.00%|    msg = str(e)
   285|         0|            0|            0|  0.00%|    return msg.startswith('unsupported operand type(s) for |: ') or "' object is not subscriptable" in msg
   286|         0|            0|            0|  0.00%|
   287|         0|            0|            0|  0.00%|
   288|         0|            0|            0|  0.00%|def get_function_type_hints(
   289|         0|            0|            0|  0.00%|    function: Callable[..., Any], *, include_keys: set[str] | None = None, types_namespace: dict[str, Any] | None = None
   290|         0|            0|            0|  0.00%|) -> dict[str, Any]:
   291|         0|            0|            0|  0.00%|    """Like `typing.get_type_hints`, but doesn't convert `X` to `Optional[X]` if the default value is `None`, also
   292|         0|            0|            0|  0.00%|    copes with `partial`.
   293|         0|            0|            0|  0.00%|    """
   294|         0|            0|            0|  0.00%|    try:
   295|         0|            0|            0|  0.00%|        if isinstance(function, partial):
   296|         0|            0|            0|  0.00%|            annotations = function.func.__annotations__
   297|         0|            0|            0|  0.00%|        else:
   298|         0|            0|            0|  0.00%|            annotations = function.__annotations__
   299|         0|            0|            0|  0.00%|    except AttributeError:
   300|         0|            0|            0|  0.00%|        type_hints = get_type_hints(function)
   301|         0|            0|            0|  0.00%|        if isinstance(function, type):
   302|         0|            0|            0|  0.00%|            # `type[...]` is a callable, which returns an instance of itself.
   303|         0|            0|            0|  0.00%|            # At some point, we might even look into the return type of `__new__`
   304|         0|            0|            0|  0.00%|            # if it returns something else.
   305|         0|            0|            0|  0.00%|            type_hints.setdefault('return', function)
   306|         0|            0|            0|  0.00%|        return type_hints
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|    globalns = add_module_globals(function)
   309|         0|            0|            0|  0.00%|    type_hints = {}
   310|         0|            0|            0|  0.00%|    type_params: tuple[Any] = getattr(function, '__type_params__', ())  # type: ignore
   311|         0|            0|            0|  0.00%|    for name, value in annotations.items():
   312|         0|            0|            0|  0.00%|        if include_keys is not None and name not in include_keys:
   313|         0|            0|            0|  0.00%|            continue
   314|         0|            0|            0|  0.00%|        if value is None:
   315|         0|            0|            0|  0.00%|            value = NoneType
   316|         0|            0|            0|  0.00%|        elif isinstance(value, str):
   317|         0|            0|            0|  0.00%|            value = _make_forward_ref(value)
   318|         0|            0|            0|  0.00%|
   319|         0|            0|            0|  0.00%|        type_hints[name] = eval_type_backport(value, globalns, types_namespace, type_params)
   320|         0|            0|            0|  0.00%|
   321|         0|            0|            0|  0.00%|    return type_hints
   322|         0|            0|            0|  0.00%|
   323|         0|            0|            0|  0.00%|
   324|         0|            0|            0|  0.00%|if sys.version_info < (3, 9, 8) or (3, 10) <= sys.version_info < (3, 10, 1):
   325|         0|            0|            0|  0.00%|
   326|         0|            0|            0|  0.00%|    def _make_forward_ref(
   327|         0|            0|            0|  0.00%|        arg: Any,
   328|         0|            0|            0|  0.00%|        is_argument: bool = True,
   329|         0|            0|            0|  0.00%|        *,
   330|         0|            0|            0|  0.00%|        is_class: bool = False,
   331|         0|            0|            0|  0.00%|    ) -> typing.ForwardRef:
   332|         0|            0|            0|  0.00%|        """Wrapper for ForwardRef that accounts for the `is_class` argument missing in older versions.
   333|         0|            0|            0|  0.00%|        The `module` argument is omitted as it breaks <3.9.8, =3.10.0 and isn't used in the calls below.
   334|         0|            0|            0|  0.00%|
   335|         0|            0|            0|  0.00%|        See https://github.com/python/cpython/pull/28560 for some background.
   336|         0|            0|            0|  0.00%|        The backport happened on 3.9.8, see:
   337|         0|            0|            0|  0.00%|        https://github.com/pydantic/pydantic/discussions/6244#discussioncomment-6275458,
   338|         0|            0|            0|  0.00%|        and on 3.10.1 for the 3.10 branch, see:
   339|         0|            0|            0|  0.00%|        https://github.com/pydantic/pydantic/issues/6912
   340|         0|            0|            0|  0.00%|
   341|         0|            0|            0|  0.00%|        Implemented as EAFP with memory.
   342|         0|            0|            0|  0.00%|        """
   343|         0|            0|            0|  0.00%|        return typing.ForwardRef(arg, is_argument)
   344|         0|            0|            0|  0.00%|
   345|         0|            0|            0|  0.00%|else:
   346|         0|            0|            0|  0.00%|    _make_forward_ref = typing.ForwardRef
   347|         0|            0|            0|  0.00%|
   348|         0|            0|            0|  0.00%|
   349|         0|            0|            0|  0.00%|if sys.version_info >= (3, 10):
   350|         0|            0|            0|  0.00%|    get_type_hints = typing.get_type_hints
   351|         0|            0|            0|  0.00%|
   352|         0|            0|            0|  0.00%|else:
   353|         0|            0|            0|  0.00%|    """
   354|         0|            0|            0|  0.00%|    For older versions of python, we have a custom implementation of `get_type_hints` which is a close as possible to
   355|         0|            0|            0|  0.00%|    the implementation in CPython 3.10.8.
   356|         0|            0|            0|  0.00%|    """
   357|         0|            0|            0|  0.00%|
   358|         0|            0|            0|  0.00%|    @typing.no_type_check
   359|         0|            0|            0|  0.00%|    def get_type_hints(  # noqa: C901
   360|         0|            0|            0|  0.00%|        obj: Any,
   361|         0|            0|            0|  0.00%|        globalns: dict[str, Any] | None = None,
   362|         0|            0|            0|  0.00%|        localns: dict[str, Any] | None = None,
   363|         0|            0|            0|  0.00%|        include_extras: bool = False,
   364|         0|            0|            0|  0.00%|    ) -> dict[str, Any]:  # pragma: no cover
   365|         0|            0|            0|  0.00%|        """Taken verbatim from python 3.10.8 unchanged, except:
   366|         0|            0|            0|  0.00%|        * type annotations of the function definition above.
   367|         0|            0|            0|  0.00%|        * prefixing `typing.` where appropriate
   368|         0|            0|            0|  0.00%|        * Use `_make_forward_ref` instead of `typing.ForwardRef` to handle the `is_class` argument.
   369|         0|            0|            0|  0.00%|
   370|         0|            0|            0|  0.00%|        https://github.com/python/cpython/blob/aaaf5174241496afca7ce4d4584570190ff972fe/Lib/typing.py#L1773-L1875
   371|         0|            0|            0|  0.00%|
   372|         0|            0|            0|  0.00%|        DO NOT CHANGE THIS METHOD UNLESS ABSOLUTELY NECESSARY.
   373|         0|            0|            0|  0.00%|        ======================================================
   374|         0|            0|            0|  0.00%|
   375|         0|            0|            0|  0.00%|        Return type hints for an object.
   376|         0|            0|            0|  0.00%|
   377|         0|            0|            0|  0.00%|        This is often the same as obj.__annotations__, but it handles
   378|         0|            0|            0|  0.00%|        forward references encoded as string literals, adds Optional[t] if a
   379|         0|            0|            0|  0.00%|        default value equal to None is set and recursively replaces all
   380|         0|            0|            0|  0.00%|        'Annotated[T, ...]' with 'T' (unless 'include_extras=True').
   381|         0|            0|            0|  0.00%|
   382|         0|            0|            0|  0.00%|        The argument may be a module, class, method, or function. The annotations
   383|         0|            0|            0|  0.00%|        are returned as a dictionary. For classes, annotations include also
   384|         0|            0|            0|  0.00%|        inherited members.
   385|         0|            0|            0|  0.00%|
   386|         0|            0|            0|  0.00%|        TypeError is raised if the argument is not of a type that can contain
   387|         0|            0|            0|  0.00%|        annotations, and an empty dictionary is returned if no annotations are
   388|         0|            0|            0|  0.00%|        present.
   389|         0|            0|            0|  0.00%|
   390|         0|            0|            0|  0.00%|        BEWARE -- the behavior of globalns and localns is counterintuitive
   391|         0|            0|            0|  0.00%|        (unless you are familiar with how eval() and exec() work).  The
   392|         0|            0|            0|  0.00%|        search order is locals first, then globals.
   393|         0|            0|            0|  0.00%|
   394|         0|            0|            0|  0.00%|        - If no dict arguments are passed, an attempt is made to use the
   395|         0|            0|            0|  0.00%|          globals from obj (or the respective module's globals for classes),
   396|         0|            0|            0|  0.00%|          and these are also used as the locals.  If the object does not appear
   397|         0|            0|            0|  0.00%|          to have globals, an empty dictionary is used.  For classes, the search
   398|         0|            0|            0|  0.00%|          order is globals first then locals.
   399|         0|            0|            0|  0.00%|
   400|         0|            0|            0|  0.00%|        - If one dict argument is passed, it is used for both globals and
   401|         0|            0|            0|  0.00%|          locals.
   402|         0|            0|            0|  0.00%|
   403|         0|            0|            0|  0.00%|        - If two dict arguments are passed, they specify globals and
   404|         0|            0|            0|  0.00%|          locals, respectively.
   405|         0|            0|            0|  0.00%|        """
   406|         0|            0|            0|  0.00%|        if getattr(obj, '__no_type_check__', None):
   407|         0|            0|            0|  0.00%|            return {}
   408|         0|            0|            0|  0.00%|        # Classes require a special treatment.
   409|         0|            0|            0|  0.00%|        if isinstance(obj, type):
   410|         0|            0|            0|  0.00%|            hints = {}
   411|         0|            0|            0|  0.00%|            for base in reversed(obj.__mro__):
   412|         0|            0|            0|  0.00%|                if globalns is None:
   413|         0|            0|            0|  0.00%|                    base_globals = getattr(sys.modules.get(base.__module__, None), '__dict__', {})
   414|         0|            0|            0|  0.00%|                else:
   415|         0|            0|            0|  0.00%|                    base_globals = globalns
   416|         0|            0|            0|  0.00%|                ann = base.__dict__.get('__annotations__', {})
   417|         0|            0|            0|  0.00%|                if isinstance(ann, types.GetSetDescriptorType):
   418|         0|            0|            0|  0.00%|                    ann = {}
   419|         0|            0|            0|  0.00%|                base_locals = dict(vars(base)) if localns is None else localns
   420|         0|            0|            0|  0.00%|                if localns is None and globalns is None:
   421|         0|            0|            0|  0.00%|                    # This is surprising, but required.  Before Python 3.10,
   422|         0|            0|            0|  0.00%|                    # get_type_hints only evaluated the globalns of
   423|         0|            0|            0|  0.00%|                    # a class.  To maintain backwards compatibility, we reverse
   424|         0|            0|            0|  0.00%|                    # the globalns and localns order so that eval() looks into
   425|         0|            0|            0|  0.00%|                    # *base_globals* first rather than *base_locals*.
   426|         0|            0|            0|  0.00%|                    # This only affects ForwardRefs.
   427|         0|            0|            0|  0.00%|                    base_globals, base_locals = base_locals, base_globals
   428|         0|            0|            0|  0.00%|                for name, value in ann.items():
   429|         0|            0|            0|  0.00%|                    if value is None:
   430|         0|            0|            0|  0.00%|                        value = type(None)
   431|         0|            0|            0|  0.00%|                    if isinstance(value, str):
   432|         0|            0|            0|  0.00%|                        value = _make_forward_ref(value, is_argument=False, is_class=True)
   433|         0|            0|            0|  0.00%|
   434|         0|            0|            0|  0.00%|                    value = eval_type_backport(value, base_globals, base_locals)
   435|         0|            0|            0|  0.00%|                    hints[name] = value
   436|         0|            0|            0|  0.00%|            if not include_extras and hasattr(typing, '_strip_annotations'):
   437|         0|            0|            0|  0.00%|                return {
   438|         0|            0|            0|  0.00%|                    k: typing._strip_annotations(t)  # type: ignore
   439|         0|            0|            0|  0.00%|                    for k, t in hints.items()
   440|         0|            0|            0|  0.00%|                }
   441|         0|            0|            0|  0.00%|            else:
   442|         0|            0|            0|  0.00%|                return hints
   443|         0|            0|            0|  0.00%|
   444|         0|            0|            0|  0.00%|        if globalns is None:
   445|         0|            0|            0|  0.00%|            if isinstance(obj, types.ModuleType):
   446|         0|            0|            0|  0.00%|                globalns = obj.__dict__
   447|         0|            0|            0|  0.00%|            else:
   448|         0|            0|            0|  0.00%|                nsobj = obj
   449|         0|            0|            0|  0.00%|                # Find globalns for the unwrapped object.
   450|         0|            0|            0|  0.00%|                while hasattr(nsobj, '__wrapped__'):
   451|         0|            0|            0|  0.00%|                    nsobj = nsobj.__wrapped__
   452|         0|            0|            0|  0.00%|                globalns = getattr(nsobj, '__globals__', {})
   453|         0|            0|            0|  0.00%|            if localns is None:
   454|         0|            0|            0|  0.00%|                localns = globalns
   455|         0|            0|            0|  0.00%|        elif localns is None:
   456|         0|            0|            0|  0.00%|            localns = globalns
   457|         0|            0|            0|  0.00%|        hints = getattr(obj, '__annotations__', None)
   458|         0|            0|            0|  0.00%|        if hints is None:
   459|         0|            0|            0|  0.00%|            # Return empty annotations for something that _could_ have them.
   460|         0|            0|            0|  0.00%|            if isinstance(obj, typing._allowed_types):  # type: ignore
   461|         0|            0|            0|  0.00%|                return {}
   462|         0|            0|            0|  0.00%|            else:
   463|         0|            0|            0|  0.00%|                raise TypeError(f'{obj!r} is not a module, class, method, ' 'or function.')
   464|         0|            0|            0|  0.00%|        defaults = typing._get_defaults(obj)  # type: ignore
   465|         0|            0|            0|  0.00%|        hints = dict(hints)
   466|         0|            0|            0|  0.00%|        for name, value in hints.items():
   467|         0|            0|            0|  0.00%|            if value is None:
   468|         0|            0|            0|  0.00%|                value = type(None)
   469|         0|            0|            0|  0.00%|            if isinstance(value, str):
   470|         0|            0|            0|  0.00%|                # class-level forward refs were handled above, this must be either
   471|         0|            0|            0|  0.00%|                # a module-level annotation or a function argument annotation
   472|         0|            0|            0|  0.00%|
   473|         0|            0|            0|  0.00%|                value = _make_forward_ref(
   474|         0|            0|            0|  0.00%|                    value,
   475|         0|            0|            0|  0.00%|                    is_argument=not isinstance(obj, types.ModuleType),
   476|         0|            0|            0|  0.00%|                    is_class=False,
   477|         0|            0|            0|  0.00%|                )
   478|         0|            0|            0|  0.00%|            value = eval_type_backport(value, globalns, localns)
   479|         0|            0|            0|  0.00%|            if name in defaults and defaults[name] is None:
   480|         0|            0|            0|  0.00%|                value = typing.Optional[value]
   481|         0|            0|            0|  0.00%|            hints[name] = value
   482|         0|            0|            0|  0.00%|        return hints if include_extras else {k: typing._strip_annotations(t) for k, t in hints.items()}  # type: ignore
   483|         0|            0|            0|  0.00%|
   484|         0|            0|            0|  0.00%|
   485|         0|            0|            0|  0.00%|def is_dataclass(_cls: type[Any]) -> TypeGuard[type[StandardDataclass]]:
   486|         0|            0|            0|  0.00%|    # The dataclasses.is_dataclass function doesn't seem to provide TypeGuard functionality,
   487|         0|            0|            0|  0.00%|    # so I created this convenience function
   488|         0|            0|            0|  0.00%|    return dataclasses.is_dataclass(_cls)
   489|         0|            0|            0|  0.00%|
   490|         0|            0|            0|  0.00%|
   491|         0|            0|            0|  0.00%|def origin_is_type_alias_type(origin: Any) -> TypeGuard[TypeAliasType]:
   492|         0|            0|            0|  0.00%|    return isinstance(origin, TypeAliasType)
   493|         0|            0|            0|  0.00%|
   494|         0|            0|            0|  0.00%|
   495|         0|            0|            0|  0.00%|if sys.version_info >= (3, 10):
   496|         0|            0|            0|  0.00%|
   497|         4|  1.04904e-05|   2.6226e-06|  0.01%|    def is_generic_alias(type_: type[Any]) -> bool:
   498|         4|  9.77516e-06|  2.44379e-06|  0.01%|        return isinstance(type_, (types.GenericAlias, typing._GenericAlias))  # type: ignore[attr-defined]
   499|         0|            0|            0|  0.00%|
   500|         0|            0|            0|  0.00%|else:
   501|         0|            0|            0|  0.00%|
   502|         0|            0|            0|  0.00%|    def is_generic_alias(type_: type[Any]) -> bool:
   503|         0|            0|            0|  0.00%|        return isinstance(type_, typing._GenericAlias)  # type: ignore
   504|         0|            0|            0|  0.00%|
   505|         0|            0|            0|  0.00%|
   506|         4|  1.57356e-05|  3.93391e-06|  0.02%|def is_self_type(tp: Any) -> bool:
   507|         0|            0|            0|  0.00%|    """Check if a given class is a Self type (from `typing` or `typing_extensions`)"""
   508|         4|  1.07288e-05|  2.68221e-06|  0.01%|    return isinstance(tp, typing_base) and getattr(tp, '_name', None) == 'Self'
File: <frozen importlib._bootstrap>
File duration: 0.000164509s (0.17%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|
    44|         0|            0|            0|  0.00%|
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|
    48|         0|            0|            0|  0.00%|
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|
    54|         0|            0|            0|  0.00%|
    55|         0|            0|            0|  0.00%|
    56|         0|            0|            0|  0.00%|
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|
    69|         0|            0|            0|  0.00%|
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|
    72|         0|            0|            0|  0.00%|
    73|         0|            0|            0|  0.00%|
    74|         0|            0|            0|  0.00%|
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|
    83|         0|            0|            0|  0.00%|
    84|         0|            0|            0|  0.00%|
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|
    87|         0|            0|            0|  0.00%|
    88|         0|            0|            0|  0.00%|
    89|         0|            0|            0|  0.00%|
    90|         0|            0|            0|  0.00%|
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|
   106|         0|            0|            0|  0.00%|
   107|         0|            0|            0|  0.00%|
   108|         0|            0|            0|  0.00%|
   109|         0|            0|            0|  0.00%|
   110|         0|            0|            0|  0.00%|
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|
   113|         0|            0|            0|  0.00%|
   114|         0|            0|            0|  0.00%|
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|
   117|         0|            0|            0|  0.00%|
   118|         0|            0|            0|  0.00%|
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|
   121|         0|            0|            0|  0.00%|
   122|         0|            0|            0|  0.00%|
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|
   125|         0|            0|            0|  0.00%|
   126|         0|            0|            0|  0.00%|
   127|         0|            0|            0|  0.00%|
   128|         0|            0|            0|  0.00%|
   129|         0|            0|            0|  0.00%|
   130|         0|            0|            0|  0.00%|
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|
   133|         0|            0|            0|  0.00%|
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|
   136|         0|            0|            0|  0.00%|
   137|         0|            0|            0|  0.00%|
   138|         0|            0|            0|  0.00%|
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|
   142|         0|            0|            0|  0.00%|
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|
   145|         0|            0|            0|  0.00%|
   146|         0|            0|            0|  0.00%|
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|
   149|         0|            0|            0|  0.00%|
   150|         0|            0|            0|  0.00%|
   151|         0|            0|            0|  0.00%|
   152|         0|            0|            0|  0.00%|
   153|         0|            0|            0|  0.00%|
   154|         0|            0|            0|  0.00%|
   155|         0|            0|            0|  0.00%|
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|
   158|         0|            0|            0|  0.00%|
   159|         0|            0|            0|  0.00%|
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|
   167|         0|            0|            0|  0.00%|
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|
   170|         0|            0|            0|  0.00%|
   171|         0|            0|            0|  0.00%|
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|
   175|         0|            0|            0|  0.00%|
   176|         0|            0|            0|  0.00%|
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|
   179|         0|            0|            0|  0.00%|
   180|         0|            0|            0|  0.00%|
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|
   184|         0|            0|            0|  0.00%|
   185|         0|            0|            0|  0.00%|
   186|         0|            0|            0|  0.00%|
   187|         0|            0|            0|  0.00%|
   188|         0|            0|            0|  0.00%|
   189|         0|            0|            0|  0.00%|
   190|         0|            0|            0|  0.00%|
   191|         0|            0|            0|  0.00%|
   192|         0|            0|            0|  0.00%|
   193|         0|            0|            0|  0.00%|
   194|         0|            0|            0|  0.00%|
   195|         0|            0|            0|  0.00%|
   196|         0|            0|            0|  0.00%|
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|
   199|         0|            0|            0|  0.00%|
   200|         0|            0|            0|  0.00%|
   201|         0|            0|            0|  0.00%|
   202|         0|            0|            0|  0.00%|
   203|         0|            0|            0|  0.00%|
   204|         0|            0|            0|  0.00%|
   205|         0|            0|            0|  0.00%|
   206|         0|            0|            0|  0.00%|
   207|         0|            0|            0|  0.00%|
   208|         0|            0|            0|  0.00%|
   209|         0|            0|            0|  0.00%|
   210|         0|            0|            0|  0.00%|
   211|         0|            0|            0|  0.00%|
   212|         0|            0|            0|  0.00%|
   213|         0|            0|            0|  0.00%|
   214|         0|            0|            0|  0.00%|
   215|         0|            0|            0|  0.00%|
   216|         0|            0|            0|  0.00%|
   217|         0|            0|            0|  0.00%|
   218|         0|            0|            0|  0.00%|
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|
   221|         0|            0|            0|  0.00%|
   222|         0|            0|            0|  0.00%|
   223|         0|            0|            0|  0.00%|
   224|         0|            0|            0|  0.00%|
   225|         0|            0|            0|  0.00%|
   226|         0|            0|            0|  0.00%|
   227|         0|            0|            0|  0.00%|
   228|         0|            0|            0|  0.00%|
   229|         0|            0|            0|  0.00%|
   230|         0|            0|            0|  0.00%|
   231|         0|            0|            0|  0.00%|
   232|         0|            0|            0|  0.00%|
   233|         0|            0|            0|  0.00%|
   234|         0|            0|            0|  0.00%|
   235|         0|            0|            0|  0.00%|
   236|         0|            0|            0|  0.00%|
   237|         0|            0|            0|  0.00%|
   238|         0|            0|            0|  0.00%|
   239|         0|            0|            0|  0.00%|
   240|         0|            0|            0|  0.00%|
   241|         0|            0|            0|  0.00%|
   242|         0|            0|            0|  0.00%|
   243|         0|            0|            0|  0.00%|
   244|         0|            0|            0|  0.00%|
   245|         0|            0|            0|  0.00%|
   246|         0|            0|            0|  0.00%|
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|
   249|         0|            0|            0|  0.00%|
   250|         0|            0|            0|  0.00%|
   251|         0|            0|            0|  0.00%|
   252|         0|            0|            0|  0.00%|
   253|         0|            0|            0|  0.00%|
   254|         0|            0|            0|  0.00%|
   255|         0|            0|            0|  0.00%|
   256|         0|            0|            0|  0.00%|
   257|         0|            0|            0|  0.00%|
   258|         0|            0|            0|  0.00%|
   259|         0|            0|            0|  0.00%|
   260|         0|            0|            0|  0.00%|
   261|         0|            0|            0|  0.00%|
   262|         0|            0|            0|  0.00%|
   263|         0|            0|            0|  0.00%|
   264|         0|            0|            0|  0.00%|
   265|         0|            0|            0|  0.00%|
   266|         0|            0|            0|  0.00%|
   267|         0|            0|            0|  0.00%|
   268|         0|            0|            0|  0.00%|
   269|         0|            0|            0|  0.00%|
   270|         0|            0|            0|  0.00%|
   271|         0|            0|            0|  0.00%|
   272|         0|            0|            0|  0.00%|
   273|         0|            0|            0|  0.00%|
   274|         0|            0|            0|  0.00%|
   275|         0|            0|            0|  0.00%|
   276|         0|            0|            0|  0.00%|
   277|         0|            0|            0|  0.00%|
   278|         0|            0|            0|  0.00%|
   279|         0|            0|            0|  0.00%|
   280|         0|            0|            0|  0.00%|
   281|         0|            0|            0|  0.00%|
   282|         0|            0|            0|  0.00%|
   283|         0|            0|            0|  0.00%|
   284|         0|            0|            0|  0.00%|
   285|         0|            0|            0|  0.00%|
   286|         0|            0|            0|  0.00%|
   287|         0|            0|            0|  0.00%|
   288|         0|            0|            0|  0.00%|
   289|         0|            0|            0|  0.00%|
   290|         0|            0|            0|  0.00%|
   291|         0|            0|            0|  0.00%|
   292|         0|            0|            0|  0.00%|
   293|         0|            0|            0|  0.00%|
   294|         0|            0|            0|  0.00%|
   295|         0|            0|            0|  0.00%|
   296|         0|            0|            0|  0.00%|
   297|         0|            0|            0|  0.00%|
   298|         0|            0|            0|  0.00%|
   299|         0|            0|            0|  0.00%|
   300|         0|            0|            0|  0.00%|
   301|         0|            0|            0|  0.00%|
   302|         0|            0|            0|  0.00%|
   303|         0|            0|            0|  0.00%|
   304|         0|            0|            0|  0.00%|
   305|         0|            0|            0|  0.00%|
   306|         0|            0|            0|  0.00%|
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|
   309|         0|            0|            0|  0.00%|
   310|         0|            0|            0|  0.00%|
   311|         0|            0|            0|  0.00%|
   312|         0|            0|            0|  0.00%|
   313|         0|            0|            0|  0.00%|
   314|         0|            0|            0|  0.00%|
   315|         0|            0|            0|  0.00%|
   316|         0|            0|            0|  0.00%|
   317|         0|            0|            0|  0.00%|
   318|         0|            0|            0|  0.00%|
   319|         0|            0|            0|  0.00%|
   320|         0|            0|            0|  0.00%|
   321|         0|            0|            0|  0.00%|
   322|         0|            0|            0|  0.00%|
   323|         0|            0|            0|  0.00%|
   324|         0|            0|            0|  0.00%|
   325|         0|            0|            0|  0.00%|
   326|         0|            0|            0|  0.00%|
   327|         0|            0|            0|  0.00%|
   328|         0|            0|            0|  0.00%|
   329|         0|            0|            0|  0.00%|
   330|         0|            0|            0|  0.00%|
   331|         0|            0|            0|  0.00%|
   332|         0|            0|            0|  0.00%|
   333|         0|            0|            0|  0.00%|
   334|         0|            0|            0|  0.00%|
   335|         0|            0|            0|  0.00%|
   336|         0|            0|            0|  0.00%|
   337|         0|            0|            0|  0.00%|
   338|         0|            0|            0|  0.00%|
   339|         0|            0|            0|  0.00%|
   340|         0|            0|            0|  0.00%|
   341|         0|            0|            0|  0.00%|
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|
   344|         0|            0|            0|  0.00%|
   345|         0|            0|            0|  0.00%|
   346|         0|            0|            0|  0.00%|
   347|         0|            0|            0|  0.00%|
   348|         0|            0|            0|  0.00%|
   349|         0|            0|            0|  0.00%|
   350|         0|            0|            0|  0.00%|
   351|         0|            0|            0|  0.00%|
   352|         0|            0|            0|  0.00%|
   353|         0|            0|            0|  0.00%|
   354|         0|            0|            0|  0.00%|
   355|         0|            0|            0|  0.00%|
   356|         0|            0|            0|  0.00%|
   357|         0|            0|            0|  0.00%|
   358|         0|            0|            0|  0.00%|
   359|         0|            0|            0|  0.00%|
   360|         0|            0|            0|  0.00%|
   361|         0|            0|            0|  0.00%|
   362|         0|            0|            0|  0.00%|
   363|         0|            0|            0|  0.00%|
   364|         0|            0|            0|  0.00%|
   365|         0|            0|            0|  0.00%|
   366|         0|            0|            0|  0.00%|
   367|         0|            0|            0|  0.00%|
   368|         0|            0|            0|  0.00%|
   369|         0|            0|            0|  0.00%|
   370|         0|            0|            0|  0.00%|
   371|         0|            0|            0|  0.00%|
   372|         0|            0|            0|  0.00%|
   373|         0|            0|            0|  0.00%|
   374|         0|            0|            0|  0.00%|
   375|         0|            0|            0|  0.00%|
   376|         0|            0|            0|  0.00%|
   377|         0|            0|            0|  0.00%|
   378|         0|            0|            0|  0.00%|
   379|         0|            0|            0|  0.00%|
   380|         0|            0|            0|  0.00%|
   381|         0|            0|            0|  0.00%|
   382|         0|            0|            0|  0.00%|
   383|         0|            0|            0|  0.00%|
   384|         0|            0|            0|  0.00%|
   385|         0|            0|            0|  0.00%|
   386|         0|            0|            0|  0.00%|
   387|         0|            0|            0|  0.00%|
   388|         0|            0|            0|  0.00%|
   389|         0|            0|            0|  0.00%|
   390|         0|            0|            0|  0.00%|
   391|         0|            0|            0|  0.00%|
   392|         0|            0|            0|  0.00%|
   393|         0|            0|            0|  0.00%|
   394|         0|            0|            0|  0.00%|
   395|         0|            0|            0|  0.00%|
   396|         0|            0|            0|  0.00%|
   397|         0|            0|            0|  0.00%|
   398|         0|            0|            0|  0.00%|
   399|         0|            0|            0|  0.00%|
   400|         0|            0|            0|  0.00%|
   401|         0|            0|            0|  0.00%|
   402|         0|            0|            0|  0.00%|
   403|         0|            0|            0|  0.00%|
   404|         0|            0|            0|  0.00%|
   405|         0|            0|            0|  0.00%|
   406|         0|            0|            0|  0.00%|
   407|         0|            0|            0|  0.00%|
   408|         0|            0|            0|  0.00%|
   409|         0|            0|            0|  0.00%|
   410|         0|            0|            0|  0.00%|
   411|         0|            0|            0|  0.00%|
   412|         0|            0|            0|  0.00%|
   413|         0|            0|            0|  0.00%|
   414|         0|            0|            0|  0.00%|
   415|         0|            0|            0|  0.00%|
   416|         0|            0|            0|  0.00%|
   417|         0|            0|            0|  0.00%|
   418|         0|            0|            0|  0.00%|
   419|         0|            0|            0|  0.00%|
   420|         0|            0|            0|  0.00%|
   421|         0|            0|            0|  0.00%|
   422|         0|            0|            0|  0.00%|
   423|         0|            0|            0|  0.00%|
   424|         0|            0|            0|  0.00%|
   425|         0|            0|            0|  0.00%|
   426|         0|            0|            0|  0.00%|
   427|         0|            0|            0|  0.00%|
   428|         0|            0|            0|  0.00%|
   429|         0|            0|            0|  0.00%|
   430|         0|            0|            0|  0.00%|
   431|         0|            0|            0|  0.00%|
   432|         0|            0|            0|  0.00%|
   433|         0|            0|            0|  0.00%|
   434|         0|            0|            0|  0.00%|
   435|         0|            0|            0|  0.00%|
   436|         0|            0|            0|  0.00%|
   437|         0|            0|            0|  0.00%|
   438|         0|            0|            0|  0.00%|
   439|         0|            0|            0|  0.00%|
   440|         0|            0|            0|  0.00%|
   441|         0|            0|            0|  0.00%|
   442|         0|            0|            0|  0.00%|
   443|         0|            0|            0|  0.00%|
   444|         0|            0|            0|  0.00%|
   445|         0|            0|            0|  0.00%|
   446|         0|            0|            0|  0.00%|
   447|         0|            0|            0|  0.00%|
   448|         0|            0|            0|  0.00%|
   449|         0|            0|            0|  0.00%|
   450|         0|            0|            0|  0.00%|
   451|         0|            0|            0|  0.00%|
   452|         0|            0|            0|  0.00%|
   453|         0|            0|            0|  0.00%|
   454|         0|            0|            0|  0.00%|
   455|         0|            0|            0|  0.00%|
   456|         0|            0|            0|  0.00%|
   457|         0|            0|            0|  0.00%|
   458|         0|            0|            0|  0.00%|
   459|         0|            0|            0|  0.00%|
   460|         0|            0|            0|  0.00%|
   461|         0|            0|            0|  0.00%|
   462|         0|            0|            0|  0.00%|
   463|         0|            0|            0|  0.00%|
   464|         0|            0|            0|  0.00%|
   465|         0|            0|            0|  0.00%|
   466|         0|            0|            0|  0.00%|
   467|         0|            0|            0|  0.00%|
   468|         0|            0|            0|  0.00%|
   469|         0|            0|            0|  0.00%|
   470|         0|            0|            0|  0.00%|
   471|         0|            0|            0|  0.00%|
   472|         0|            0|            0|  0.00%|
   473|         0|            0|            0|  0.00%|
   474|         0|            0|            0|  0.00%|
   475|         0|            0|            0|  0.00%|
   476|         0|            0|            0|  0.00%|
   477|         0|            0|            0|  0.00%|
   478|         0|            0|            0|  0.00%|
   479|         0|            0|            0|  0.00%|
   480|         0|            0|            0|  0.00%|
   481|         0|            0|            0|  0.00%|
   482|         0|            0|            0|  0.00%|
   483|         0|            0|            0|  0.00%|
   484|         0|            0|            0|  0.00%|
   485|         0|            0|            0|  0.00%|
   486|         0|            0|            0|  0.00%|
   487|         0|            0|            0|  0.00%|
   488|         0|            0|            0|  0.00%|
   489|         0|            0|            0|  0.00%|
   490|         0|            0|            0|  0.00%|
   491|         0|            0|            0|  0.00%|
   492|         0|            0|            0|  0.00%|
   493|         0|            0|            0|  0.00%|
   494|         0|            0|            0|  0.00%|
   495|         0|            0|            0|  0.00%|
   496|         0|            0|            0|  0.00%|
   497|         0|            0|            0|  0.00%|
   498|         0|            0|            0|  0.00%|
   499|         0|            0|            0|  0.00%|
   500|         0|            0|            0|  0.00%|
   501|         0|            0|            0|  0.00%|
   502|         0|            0|            0|  0.00%|
   503|         0|            0|            0|  0.00%|
   504|         0|            0|            0|  0.00%|
   505|         0|            0|            0|  0.00%|
   506|         0|            0|            0|  0.00%|
   507|         0|            0|            0|  0.00%|
   508|         0|            0|            0|  0.00%|
   509|         0|            0|            0|  0.00%|
   510|         0|            0|            0|  0.00%|
   511|         0|            0|            0|  0.00%|
   512|         0|            0|            0|  0.00%|
   513|         0|            0|            0|  0.00%|
   514|         0|            0|            0|  0.00%|
   515|         0|            0|            0|  0.00%|
   516|         0|            0|            0|  0.00%|
   517|         0|            0|            0|  0.00%|
   518|         0|            0|            0|  0.00%|
   519|         0|            0|            0|  0.00%|
   520|         0|            0|            0|  0.00%|
   521|         0|            0|            0|  0.00%|
   522|         0|            0|            0|  0.00%|
   523|         0|            0|            0|  0.00%|
   524|         0|            0|            0|  0.00%|
   525|         0|            0|            0|  0.00%|
   526|         0|            0|            0|  0.00%|
   527|         0|            0|            0|  0.00%|
   528|         0|            0|            0|  0.00%|
   529|         0|            0|            0|  0.00%|
   530|         0|            0|            0|  0.00%|
   531|         0|            0|            0|  0.00%|
   532|         0|            0|            0|  0.00%|
   533|         0|            0|            0|  0.00%|
   534|         0|            0|            0|  0.00%|
   535|         0|            0|            0|  0.00%|
   536|         0|            0|            0|  0.00%|
   537|         0|            0|            0|  0.00%|
   538|         0|            0|            0|  0.00%|
   539|         0|            0|            0|  0.00%|
   540|         0|            0|            0|  0.00%|
   541|         0|            0|            0|  0.00%|
   542|         0|            0|            0|  0.00%|
   543|         0|            0|            0|  0.00%|
   544|         0|            0|            0|  0.00%|
   545|         0|            0|            0|  0.00%|
   546|         0|            0|            0|  0.00%|
   547|         0|            0|            0|  0.00%|
   548|         0|            0|            0|  0.00%|
   549|         0|            0|            0|  0.00%|
   550|         0|            0|            0|  0.00%|
   551|         0|            0|            0|  0.00%|
   552|         0|            0|            0|  0.00%|
   553|         0|            0|            0|  0.00%|
   554|         0|            0|            0|  0.00%|
   555|         0|            0|            0|  0.00%|
   556|         0|            0|            0|  0.00%|
   557|         0|            0|            0|  0.00%|
   558|         0|            0|            0|  0.00%|
   559|         0|            0|            0|  0.00%|
   560|         0|            0|            0|  0.00%|
   561|         0|            0|            0|  0.00%|
   562|         0|            0|            0|  0.00%|
   563|         0|            0|            0|  0.00%|
   564|         0|            0|            0|  0.00%|
   565|         0|            0|            0|  0.00%|
   566|         0|            0|            0|  0.00%|
   567|         0|            0|            0|  0.00%|
   568|         0|            0|            0|  0.00%|
   569|         0|            0|            0|  0.00%|
   570|         0|            0|            0|  0.00%|
   571|         0|            0|            0|  0.00%|
   572|         0|            0|            0|  0.00%|
   573|         0|            0|            0|  0.00%|
   574|         0|            0|            0|  0.00%|
   575|         0|            0|            0|  0.00%|
   576|         0|            0|            0|  0.00%|
   577|         0|            0|            0|  0.00%|
   578|         0|            0|            0|  0.00%|
   579|         0|            0|            0|  0.00%|
   580|         0|            0|            0|  0.00%|
   581|         0|            0|            0|  0.00%|
   582|         0|            0|            0|  0.00%|
   583|         0|            0|            0|  0.00%|
   584|         0|            0|            0|  0.00%|
   585|         0|            0|            0|  0.00%|
   586|         0|            0|            0|  0.00%|
   587|         0|            0|            0|  0.00%|
   588|         0|            0|            0|  0.00%|
   589|         0|            0|            0|  0.00%|
   590|         0|            0|            0|  0.00%|
   591|         0|            0|            0|  0.00%|
   592|         0|            0|            0|  0.00%|
   593|         0|            0|            0|  0.00%|
   594|         0|            0|            0|  0.00%|
   595|         0|            0|            0|  0.00%|
   596|         0|            0|            0|  0.00%|
   597|         0|            0|            0|  0.00%|
   598|         0|            0|            0|  0.00%|
   599|         0|            0|            0|  0.00%|
   600|         0|            0|            0|  0.00%|
   601|         0|            0|            0|  0.00%|
   602|         0|            0|            0|  0.00%|
   603|         0|            0|            0|  0.00%|
   604|         0|            0|            0|  0.00%|
   605|         0|            0|            0|  0.00%|
   606|         0|            0|            0|  0.00%|
   607|         0|            0|            0|  0.00%|
   608|         0|            0|            0|  0.00%|
   609|         0|            0|            0|  0.00%|
   610|         0|            0|            0|  0.00%|
   611|         0|            0|            0|  0.00%|
   612|         0|            0|            0|  0.00%|
   613|         0|            0|            0|  0.00%|
   614|         0|            0|            0|  0.00%|
   615|         0|            0|            0|  0.00%|
   616|         0|            0|            0|  0.00%|
   617|         0|            0|            0|  0.00%|
   618|         0|            0|            0|  0.00%|
   619|         0|            0|            0|  0.00%|
   620|         0|            0|            0|  0.00%|
   621|         0|            0|            0|  0.00%|
   622|         0|            0|            0|  0.00%|
   623|         0|            0|            0|  0.00%|
   624|         0|            0|            0|  0.00%|
   625|         0|            0|            0|  0.00%|
   626|         0|            0|            0|  0.00%|
   627|         0|            0|            0|  0.00%|
   628|         0|            0|            0|  0.00%|
   629|         0|            0|            0|  0.00%|
   630|         0|            0|            0|  0.00%|
   631|         0|            0|            0|  0.00%|
   632|         0|            0|            0|  0.00%|
   633|         0|            0|            0|  0.00%|
   634|         0|            0|            0|  0.00%|
   635|         0|            0|            0|  0.00%|
   636|         0|            0|            0|  0.00%|
   637|         0|            0|            0|  0.00%|
   638|         0|            0|            0|  0.00%|
   639|         0|            0|            0|  0.00%|
   640|         0|            0|            0|  0.00%|
   641|         0|            0|            0|  0.00%|
   642|         0|            0|            0|  0.00%|
   643|         0|            0|            0|  0.00%|
   644|         0|            0|            0|  0.00%|
   645|        14|  3.52859e-05|  2.52042e-06|  0.04%|
   646|         0|            0|            0|  0.00%|
   647|         0|            0|            0|  0.00%|
   648|        14|  2.71797e-05|  1.94141e-06|  0.03%|
   649|        14|  2.36034e-05|  1.68596e-06|  0.02%|
   650|         0|            0|            0|  0.00%|
   651|         0|            0|            0|  0.00%|
   652|         0|            0|            0|  0.00%|
   653|         0|            0|            0|  0.00%|
   654|         0|            0|            0|  0.00%|
   655|         0|            0|            0|  0.00%|
   656|         0|            0|            0|  0.00%|
   657|         0|            0|            0|  0.00%|
   658|         0|            0|            0|  0.00%|
   659|         0|            0|            0|  0.00%|
   660|         0|            0|            0|  0.00%|
   661|         0|            0|            0|  0.00%|
   662|         0|            0|            0|  0.00%|
   663|         0|            0|            0|  0.00%|
   664|         0|            0|            0|  0.00%|
   665|         0|            0|            0|  0.00%|
   666|         0|            0|            0|  0.00%|
   667|         0|            0|            0|  0.00%|
   668|         0|            0|            0|  0.00%|
   669|         0|            0|            0|  0.00%|
   670|         0|            0|            0|  0.00%|
   671|         0|            0|            0|  0.00%|
   672|         0|            0|            0|  0.00%|
   673|         0|            0|            0|  0.00%|
   674|         0|            0|            0|  0.00%|
   675|         0|            0|            0|  0.00%|
   676|         0|            0|            0|  0.00%|
   677|         0|            0|            0|  0.00%|
   678|         0|            0|            0|  0.00%|
   679|         0|            0|            0|  0.00%|
   680|         0|            0|            0|  0.00%|
   681|         0|            0|            0|  0.00%|
   682|         0|            0|            0|  0.00%|
   683|         0|            0|            0|  0.00%|
   684|         0|            0|            0|  0.00%|
   685|         0|            0|            0|  0.00%|
   686|         0|            0|            0|  0.00%|
   687|         0|            0|            0|  0.00%|
   688|         0|            0|            0|  0.00%|
   689|         0|            0|            0|  0.00%|
   690|         0|            0|            0|  0.00%|
   691|         0|            0|            0|  0.00%|
   692|         0|            0|            0|  0.00%|
   693|         0|            0|            0|  0.00%|
   694|         0|            0|            0|  0.00%|
   695|         0|            0|            0|  0.00%|
   696|         0|            0|            0|  0.00%|
   697|         0|            0|            0|  0.00%|
   698|         0|            0|            0|  0.00%|
   699|         0|            0|            0|  0.00%|
   700|         0|            0|            0|  0.00%|
   701|         0|            0|            0|  0.00%|
   702|         0|            0|            0|  0.00%|
   703|         0|            0|            0|  0.00%|
   704|         0|            0|            0|  0.00%|
   705|         0|            0|            0|  0.00%|
   706|         0|            0|            0|  0.00%|
   707|         0|            0|            0|  0.00%|
   708|         0|            0|            0|  0.00%|
   709|         0|            0|            0|  0.00%|
   710|         0|            0|            0|  0.00%|
   711|         0|            0|            0|  0.00%|
   712|         0|            0|            0|  0.00%|
   713|         0|            0|            0|  0.00%|
   714|         0|            0|            0|  0.00%|
   715|         0|            0|            0|  0.00%|
   716|         0|            0|            0|  0.00%|
   717|         0|            0|            0|  0.00%|
   718|         0|            0|            0|  0.00%|
   719|         0|            0|            0|  0.00%|
   720|         0|            0|            0|  0.00%|
   721|         0|            0|            0|  0.00%|
   722|         0|            0|            0|  0.00%|
   723|         0|            0|            0|  0.00%|
   724|         0|            0|            0|  0.00%|
   725|         0|            0|            0|  0.00%|
   726|         0|            0|            0|  0.00%|
   727|         0|            0|            0|  0.00%|
   728|         0|            0|            0|  0.00%|
   729|         0|            0|            0|  0.00%|
   730|         0|            0|            0|  0.00%|
   731|         0|            0|            0|  0.00%|
   732|         0|            0|            0|  0.00%|
   733|         0|            0|            0|  0.00%|
   734|         0|            0|            0|  0.00%|
   735|         0|            0|            0|  0.00%|
   736|         0|            0|            0|  0.00%|
   737|         0|            0|            0|  0.00%|
   738|         0|            0|            0|  0.00%|
   739|         0|            0|            0|  0.00%|
   740|         0|            0|            0|  0.00%|
   741|         0|            0|            0|  0.00%|
   742|         0|            0|            0|  0.00%|
   743|         0|            0|            0|  0.00%|
   744|         0|            0|            0|  0.00%|
   745|         0|            0|            0|  0.00%|
   746|         0|            0|            0|  0.00%|
   747|         0|            0|            0|  0.00%|
   748|         0|            0|            0|  0.00%|
   749|         0|            0|            0|  0.00%|
   750|         0|            0|            0|  0.00%|
   751|         0|            0|            0|  0.00%|
   752|         0|            0|            0|  0.00%|
   753|         0|            0|            0|  0.00%|
   754|         0|            0|            0|  0.00%|
   755|         0|            0|            0|  0.00%|
   756|         0|            0|            0|  0.00%|
   757|         0|            0|            0|  0.00%|
   758|         0|            0|            0|  0.00%|
   759|         0|            0|            0|  0.00%|
   760|         0|            0|            0|  0.00%|
   761|         0|            0|            0|  0.00%|
   762|         0|            0|            0|  0.00%|
   763|         0|            0|            0|  0.00%|
   764|         0|            0|            0|  0.00%|
   765|         0|            0|            0|  0.00%|
   766|         0|            0|            0|  0.00%|
   767|         0|            0|            0|  0.00%|
   768|         0|            0|            0|  0.00%|
   769|         0|            0|            0|  0.00%|
   770|         0|            0|            0|  0.00%|
   771|         0|            0|            0|  0.00%|
   772|         0|            0|            0|  0.00%|
   773|         0|            0|            0|  0.00%|
   774|         0|            0|            0|  0.00%|
   775|         0|            0|            0|  0.00%|
   776|         0|            0|            0|  0.00%|
   777|         0|            0|            0|  0.00%|
   778|         0|            0|            0|  0.00%|
   779|         0|            0|            0|  0.00%|
   780|         0|            0|            0|  0.00%|
   781|         0|            0|            0|  0.00%|
   782|         0|            0|            0|  0.00%|
   783|         0|            0|            0|  0.00%|
   784|         0|            0|            0|  0.00%|
   785|         0|            0|            0|  0.00%|
   786|         0|            0|            0|  0.00%|
   787|         0|            0|            0|  0.00%|
   788|         0|            0|            0|  0.00%|
   789|         0|            0|            0|  0.00%|
   790|         0|            0|            0|  0.00%|
   791|         0|            0|            0|  0.00%|
   792|         0|            0|            0|  0.00%|
   793|         0|            0|            0|  0.00%|
   794|         0|            0|            0|  0.00%|
   795|         0|            0|            0|  0.00%|
   796|         0|            0|            0|  0.00%|
   797|         0|            0|            0|  0.00%|
   798|         0|            0|            0|  0.00%|
   799|         0|            0|            0|  0.00%|
   800|         0|            0|            0|  0.00%|
   801|         0|            0|            0|  0.00%|
   802|         0|            0|            0|  0.00%|
   803|         0|            0|            0|  0.00%|
   804|         0|            0|            0|  0.00%|
   805|         0|            0|            0|  0.00%|
   806|         0|            0|            0|  0.00%|
   807|         0|            0|            0|  0.00%|
   808|         0|            0|            0|  0.00%|
   809|         0|            0|            0|  0.00%|
   810|         0|            0|            0|  0.00%|
   811|         0|            0|            0|  0.00%|
   812|         0|            0|            0|  0.00%|
   813|         0|            0|            0|  0.00%|
   814|         0|            0|            0|  0.00%|
   815|         0|            0|            0|  0.00%|
   816|         0|            0|            0|  0.00%|
   817|         0|            0|            0|  0.00%|
   818|         0|            0|            0|  0.00%|
   819|         0|            0|            0|  0.00%|
   820|         0|            0|            0|  0.00%|
   821|         0|            0|            0|  0.00%|
   822|         0|            0|            0|  0.00%|
   823|         0|            0|            0|  0.00%|
   824|         0|            0|            0|  0.00%|
   825|         0|            0|            0|  0.00%|
   826|         0|            0|            0|  0.00%|
   827|         0|            0|            0|  0.00%|
   828|         0|            0|            0|  0.00%|
   829|         0|            0|            0|  0.00%|
   830|         0|            0|            0|  0.00%|
   831|         0|            0|            0|  0.00%|
   832|         0|            0|            0|  0.00%|
   833|         0|            0|            0|  0.00%|
   834|         0|            0|            0|  0.00%|
   835|         0|            0|            0|  0.00%|
   836|         0|            0|            0|  0.00%|
   837|         0|            0|            0|  0.00%|
   838|         0|            0|            0|  0.00%|
   839|         0|            0|            0|  0.00%|
   840|         0|            0|            0|  0.00%|
   841|         0|            0|            0|  0.00%|
   842|         0|            0|            0|  0.00%|
   843|         0|            0|            0|  0.00%|
   844|         0|            0|            0|  0.00%|
   845|         0|            0|            0|  0.00%|
   846|         0|            0|            0|  0.00%|
   847|         0|            0|            0|  0.00%|
   848|         0|            0|            0|  0.00%|
   849|         0|            0|            0|  0.00%|
   850|         0|            0|            0|  0.00%|
   851|         0|            0|            0|  0.00%|
   852|         0|            0|            0|  0.00%|
   853|         0|            0|            0|  0.00%|
   854|         0|            0|            0|  0.00%|
   855|         0|            0|            0|  0.00%|
   856|         0|            0|            0|  0.00%|
   857|         0|            0|            0|  0.00%|
   858|         0|            0|            0|  0.00%|
   859|         0|            0|            0|  0.00%|
   860|         0|            0|            0|  0.00%|
   861|         0|            0|            0|  0.00%|
   862|         0|            0|            0|  0.00%|
   863|         0|            0|            0|  0.00%|
   864|         0|            0|            0|  0.00%|
   865|         0|            0|            0|  0.00%|
   866|         0|            0|            0|  0.00%|
   867|         0|            0|            0|  0.00%|
   868|         0|            0|            0|  0.00%|
   869|         0|            0|            0|  0.00%|
   870|         0|            0|            0|  0.00%|
   871|         0|            0|            0|  0.00%|
   872|         0|            0|            0|  0.00%|
   873|         0|            0|            0|  0.00%|
   874|         0|            0|            0|  0.00%|
   875|         0|            0|            0|  0.00%|
   876|         0|            0|            0|  0.00%|
   877|         0|            0|            0|  0.00%|
   878|         0|            0|            0|  0.00%|
   879|         0|            0|            0|  0.00%|
   880|         0|            0|            0|  0.00%|
   881|         0|            0|            0|  0.00%|
   882|         0|            0|            0|  0.00%|
   883|         0|            0|            0|  0.00%|
   884|         0|            0|            0|  0.00%|
   885|         0|            0|            0|  0.00%|
   886|         0|            0|            0|  0.00%|
   887|         0|            0|            0|  0.00%|
   888|         0|            0|            0|  0.00%|
   889|         0|            0|            0|  0.00%|
   890|         0|            0|            0|  0.00%|
   891|         0|            0|            0|  0.00%|
   892|         0|            0|            0|  0.00%|
   893|         0|            0|            0|  0.00%|
   894|         0|            0|            0|  0.00%|
   895|         0|            0|            0|  0.00%|
   896|         0|            0|            0|  0.00%|
   897|         0|            0|            0|  0.00%|
   898|         0|            0|            0|  0.00%|
   899|         0|            0|            0|  0.00%|
   900|         0|            0|            0|  0.00%|
   901|         0|            0|            0|  0.00%|
   902|         0|            0|            0|  0.00%|
   903|         0|            0|            0|  0.00%|
   904|         0|            0|            0|  0.00%|
   905|         0|            0|            0|  0.00%|
   906|         0|            0|            0|  0.00%|
   907|         0|            0|            0|  0.00%|
   908|         0|            0|            0|  0.00%|
   909|         0|            0|            0|  0.00%|
   910|         0|            0|            0|  0.00%|
   911|         0|            0|            0|  0.00%|
   912|         0|            0|            0|  0.00%|
   913|         0|            0|            0|  0.00%|
   914|         0|            0|            0|  0.00%|
   915|         0|            0|            0|  0.00%|
   916|         0|            0|            0|  0.00%|
   917|         0|            0|            0|  0.00%|
   918|         0|            0|            0|  0.00%|
   919|         0|            0|            0|  0.00%|
   920|         0|            0|            0|  0.00%|
   921|         0|            0|            0|  0.00%|
   922|         0|            0|            0|  0.00%|
   923|         0|            0|            0|  0.00%|
   924|         0|            0|            0|  0.00%|
   925|         0|            0|            0|  0.00%|
   926|         0|            0|            0|  0.00%|
   927|         0|            0|            0|  0.00%|
   928|         0|            0|            0|  0.00%|
   929|         0|            0|            0|  0.00%|
   930|         0|            0|            0|  0.00%|
   931|         0|            0|            0|  0.00%|
   932|         0|            0|            0|  0.00%|
   933|         0|            0|            0|  0.00%|
   934|         0|            0|            0|  0.00%|
   935|         0|            0|            0|  0.00%|
   936|         0|            0|            0|  0.00%|
   937|         0|            0|            0|  0.00%|
   938|         0|            0|            0|  0.00%|
   939|         0|            0|            0|  0.00%|
   940|         0|            0|            0|  0.00%|
   941|         0|            0|            0|  0.00%|
   942|         0|            0|            0|  0.00%|
   943|         0|            0|            0|  0.00%|
   944|         0|            0|            0|  0.00%|
   945|         0|            0|            0|  0.00%|
   946|         0|            0|            0|  0.00%|
   947|         0|            0|            0|  0.00%|
   948|         0|            0|            0|  0.00%|
   949|         0|            0|            0|  0.00%|
   950|         0|            0|            0|  0.00%|
   951|         0|            0|            0|  0.00%|
   952|         0|            0|            0|  0.00%|
   953|         0|            0|            0|  0.00%|
   954|         0|            0|            0|  0.00%|
   955|         0|            0|            0|  0.00%|
   956|         0|            0|            0|  0.00%|
   957|         0|            0|            0|  0.00%|
   958|         0|            0|            0|  0.00%|
   959|         0|            0|            0|  0.00%|
   960|         0|            0|            0|  0.00%|
   961|         0|            0|            0|  0.00%|
   962|         0|            0|            0|  0.00%|
   963|         0|            0|            0|  0.00%|
   964|         0|            0|            0|  0.00%|
   965|         0|            0|            0|  0.00%|
   966|         0|            0|            0|  0.00%|
   967|         0|            0|            0|  0.00%|
   968|         0|            0|            0|  0.00%|
   969|         0|            0|            0|  0.00%|
   970|         0|            0|            0|  0.00%|
   971|         0|            0|            0|  0.00%|
   972|         0|            0|            0|  0.00%|
   973|         0|            0|            0|  0.00%|
   974|         0|            0|            0|  0.00%|
   975|         0|            0|            0|  0.00%|
   976|         0|            0|            0|  0.00%|
   977|         0|            0|            0|  0.00%|
   978|         0|            0|            0|  0.00%|
   979|         0|            0|            0|  0.00%|
   980|         0|            0|            0|  0.00%|
   981|         0|            0|            0|  0.00%|
   982|         0|            0|            0|  0.00%|
   983|         0|            0|            0|  0.00%|
   984|         0|            0|            0|  0.00%|
   985|         0|            0|            0|  0.00%|
   986|         0|            0|            0|  0.00%|
   987|         0|            0|            0|  0.00%|
   988|         0|            0|            0|  0.00%|
   989|         0|            0|            0|  0.00%|
   990|         0|            0|            0|  0.00%|
   991|         0|            0|            0|  0.00%|
   992|         0|            0|            0|  0.00%|
   993|         0|            0|            0|  0.00%|
   994|         0|            0|            0|  0.00%|
   995|         0|            0|            0|  0.00%|
   996|         0|            0|            0|  0.00%|
   997|         0|            0|            0|  0.00%|
   998|         0|            0|            0|  0.00%|
   999|         0|            0|            0|  0.00%|
  1000|         0|            0|            0|  0.00%|
  1001|         0|            0|            0|  0.00%|
  1002|         0|            0|            0|  0.00%|
  1003|         0|            0|            0|  0.00%|
  1004|         0|            0|            0|  0.00%|
  1005|         0|            0|            0|  0.00%|
  1006|         0|            0|            0|  0.00%|
  1007|         0|            0|            0|  0.00%|
  1008|         0|            0|            0|  0.00%|
  1009|         0|            0|            0|  0.00%|
  1010|         0|            0|            0|  0.00%|
  1011|         0|            0|            0|  0.00%|
  1012|         0|            0|            0|  0.00%|
  1013|         0|            0|            0|  0.00%|
  1014|         0|            0|            0|  0.00%|
  1015|         0|            0|            0|  0.00%|
  1016|         0|            0|            0|  0.00%|
  1017|         0|            0|            0|  0.00%|
  1018|         0|            0|            0|  0.00%|
  1019|         0|            0|            0|  0.00%|
  1020|         0|            0|            0|  0.00%|
  1021|         0|            0|            0|  0.00%|
  1022|         0|            0|            0|  0.00%|
  1023|         0|            0|            0|  0.00%|
  1024|         0|            0|            0|  0.00%|
  1025|         0|            0|            0|  0.00%|
  1026|         0|            0|            0|  0.00%|
  1027|         0|            0|            0|  0.00%|
  1028|         0|            0|            0|  0.00%|
  1029|         0|            0|            0|  0.00%|
  1030|         0|            0|            0|  0.00%|
  1031|         0|            0|            0|  0.00%|
  1032|         0|            0|            0|  0.00%|
  1033|         0|            0|            0|  0.00%|
  1034|         0|            0|            0|  0.00%|
  1035|         0|            0|            0|  0.00%|
  1036|         0|            0|            0|  0.00%|
  1037|         0|            0|            0|  0.00%|
  1038|         0|            0|            0|  0.00%|
  1039|         0|            0|            0|  0.00%|
  1040|         0|            0|            0|  0.00%|
  1041|         0|            0|            0|  0.00%|
  1042|         0|            0|            0|  0.00%|
  1043|         0|            0|            0|  0.00%|
  1044|         0|            0|            0|  0.00%|
  1045|         0|            0|            0|  0.00%|
  1046|         0|            0|            0|  0.00%|
  1047|         0|            0|            0|  0.00%|
  1048|         0|            0|            0|  0.00%|
  1049|         0|            0|            0|  0.00%|
  1050|         0|            0|            0|  0.00%|
  1051|         0|            0|            0|  0.00%|
  1052|         0|            0|            0|  0.00%|
  1053|         0|            0|            0|  0.00%|
  1054|         0|            0|            0|  0.00%|
  1055|         0|            0|            0|  0.00%|
  1056|         0|            0|            0|  0.00%|
  1057|         0|            0|            0|  0.00%|
  1058|         0|            0|            0|  0.00%|
  1059|         0|            0|            0|  0.00%|
  1060|         0|            0|            0|  0.00%|
  1061|         0|            0|            0|  0.00%|
  1062|         0|            0|            0|  0.00%|
  1063|         0|            0|            0|  0.00%|
  1064|         0|            0|            0|  0.00%|
  1065|         0|            0|            0|  0.00%|
  1066|         0|            0|            0|  0.00%|
  1067|         0|            0|            0|  0.00%|
  1068|         0|            0|            0|  0.00%|
  1069|         0|            0|            0|  0.00%|
  1070|         0|            0|            0|  0.00%|
  1071|         0|            0|            0|  0.00%|
  1072|         0|            0|            0|  0.00%|
  1073|         0|            0|            0|  0.00%|
  1074|         0|            0|            0|  0.00%|
  1075|         0|            0|            0|  0.00%|
  1076|         0|            0|            0|  0.00%|
  1077|         0|            0|            0|  0.00%|
  1078|         0|            0|            0|  0.00%|
  1079|         0|            0|            0|  0.00%|
  1080|         0|            0|            0|  0.00%|
  1081|         0|            0|            0|  0.00%|
  1082|         0|            0|            0|  0.00%|
  1083|         0|            0|            0|  0.00%|
  1084|         0|            0|            0|  0.00%|
  1085|         0|            0|            0|  0.00%|
  1086|         0|            0|            0|  0.00%|
  1087|         0|            0|            0|  0.00%|
  1088|         0|            0|            0|  0.00%|
  1089|         0|            0|            0|  0.00%|
  1090|         0|            0|            0|  0.00%|
  1091|         0|            0|            0|  0.00%|
  1092|         0|            0|            0|  0.00%|
  1093|         0|            0|            0|  0.00%|
  1094|         0|            0|            0|  0.00%|
  1095|         0|            0|            0|  0.00%|
  1096|         0|            0|            0|  0.00%|
  1097|         0|            0|            0|  0.00%|
  1098|         0|            0|            0|  0.00%|
  1099|         0|            0|            0|  0.00%|
  1100|         0|            0|            0|  0.00%|
  1101|         0|            0|            0|  0.00%|
  1102|         0|            0|            0|  0.00%|
  1103|         0|            0|            0|  0.00%|
  1104|         0|            0|            0|  0.00%|
  1105|         0|            0|            0|  0.00%|
  1106|         0|            0|            0|  0.00%|
  1107|         0|            0|            0|  0.00%|
  1108|         0|            0|            0|  0.00%|
  1109|         0|            0|            0|  0.00%|
  1110|         0|            0|            0|  0.00%|
  1111|         0|            0|            0|  0.00%|
  1112|         0|            0|            0|  0.00%|
  1113|         0|            0|            0|  0.00%|
  1114|         0|            0|            0|  0.00%|
  1115|         0|            0|            0|  0.00%|
  1116|         0|            0|            0|  0.00%|
  1117|         0|            0|            0|  0.00%|
  1118|         0|            0|            0|  0.00%|
  1119|         0|            0|            0|  0.00%|
  1120|         0|            0|            0|  0.00%|
  1121|         0|            0|            0|  0.00%|
  1122|         0|            0|            0|  0.00%|
  1123|         0|            0|            0|  0.00%|
  1124|         0|            0|            0|  0.00%|
  1125|         0|            0|            0|  0.00%|
  1126|         0|            0|            0|  0.00%|
  1127|         0|            0|            0|  0.00%|
  1128|         0|            0|            0|  0.00%|
  1129|         0|            0|            0|  0.00%|
  1130|         0|            0|            0|  0.00%|
  1131|         0|            0|            0|  0.00%|
  1132|         0|            0|            0|  0.00%|
  1133|         0|            0|            0|  0.00%|
  1134|         0|            0|            0|  0.00%|
  1135|         0|            0|            0|  0.00%|
  1136|         0|            0|            0|  0.00%|
  1137|         0|            0|            0|  0.00%|
  1138|         0|            0|            0|  0.00%|
  1139|         0|            0|            0|  0.00%|
  1140|         0|            0|            0|  0.00%|
  1141|         0|            0|            0|  0.00%|
  1142|         0|            0|            0|  0.00%|
  1143|         0|            0|            0|  0.00%|
  1144|         0|            0|            0|  0.00%|
  1145|         0|            0|            0|  0.00%|
  1146|         0|            0|            0|  0.00%|
  1147|         0|            0|            0|  0.00%|
  1148|         0|            0|            0|  0.00%|
  1149|         0|            0|            0|  0.00%|
  1150|         0|            0|            0|  0.00%|
  1151|         0|            0|            0|  0.00%|
  1152|         0|            0|            0|  0.00%|
  1153|         0|            0|            0|  0.00%|
  1154|         0|            0|            0|  0.00%|
  1155|         0|            0|            0|  0.00%|
  1156|         0|            0|            0|  0.00%|
  1157|         0|            0|            0|  0.00%|
  1158|         0|            0|            0|  0.00%|
  1159|         0|            0|            0|  0.00%|
  1160|         0|            0|            0|  0.00%|
  1161|         0|            0|            0|  0.00%|
  1162|         0|            0|            0|  0.00%|
  1163|         0|            0|            0|  0.00%|
  1164|         0|            0|            0|  0.00%|
  1165|         0|            0|            0|  0.00%|
  1166|         0|            0|            0|  0.00%|
  1167|         0|            0|            0|  0.00%|
  1168|         0|            0|            0|  0.00%|
  1169|         0|            0|            0|  0.00%|
  1170|         0|            0|            0|  0.00%|
  1171|         0|            0|            0|  0.00%|
  1172|         0|            0|            0|  0.00%|
  1173|         0|            0|            0|  0.00%|
  1174|         0|            0|            0|  0.00%|
  1175|         0|            0|            0|  0.00%|
  1176|         0|            0|            0|  0.00%|
  1177|         0|            0|            0|  0.00%|
  1178|         0|            0|            0|  0.00%|
  1179|         0|            0|            0|  0.00%|
  1180|         0|            0|            0|  0.00%|
  1181|         0|            0|            0|  0.00%|
  1182|         0|            0|            0|  0.00%|
  1183|         0|            0|            0|  0.00%|
  1184|         0|            0|            0|  0.00%|
  1185|         0|            0|            0|  0.00%|
  1186|         0|            0|            0|  0.00%|
  1187|         0|            0|            0|  0.00%|
  1188|         0|            0|            0|  0.00%|
  1189|         0|            0|            0|  0.00%|
  1190|         0|            0|            0|  0.00%|
  1191|         0|            0|            0|  0.00%|
  1192|         0|            0|            0|  0.00%|
  1193|         0|            0|            0|  0.00%|
  1194|         0|            0|            0|  0.00%|
  1195|         0|            0|            0|  0.00%|
  1196|         0|            0|            0|  0.00%|
  1197|         0|            0|            0|  0.00%|
  1198|         0|            0|            0|  0.00%|
  1199|         0|            0|            0|  0.00%|
  1200|         0|            0|            0|  0.00%|
  1201|         0|            0|            0|  0.00%|
  1202|         0|            0|            0|  0.00%|
  1203|         0|            0|            0|  0.00%|
  1204|         0|            0|            0|  0.00%|
  1205|         0|            0|            0|  0.00%|
  1206|         0|            0|            0|  0.00%|
  1207|         0|            0|            0|  0.00%|
  1208|         0|            0|            0|  0.00%|
  1209|         0|            0|            0|  0.00%|
  1210|         0|            0|            0|  0.00%|
  1211|         0|            0|            0|  0.00%|
  1212|         0|            0|            0|  0.00%|
  1213|         0|            0|            0|  0.00%|
  1214|         0|            0|            0|  0.00%|
  1215|         0|            0|            0|  0.00%|
  1216|         0|            0|            0|  0.00%|
  1217|         0|            0|            0|  0.00%|
  1218|         0|            0|            0|  0.00%|
  1219|         0|            0|            0|  0.00%|
  1220|         0|            0|            0|  0.00%|
  1221|         0|            0|            0|  0.00%|
  1222|         0|            0|            0|  0.00%|
  1223|         0|            0|            0|  0.00%|
  1224|         0|            0|            0|  0.00%|
  1225|         0|            0|            0|  0.00%|
  1226|         0|            0|            0|  0.00%|
  1227|         0|            0|            0|  0.00%|
  1228|         0|            0|            0|  0.00%|
  1229|         0|            0|            0|  0.00%|
  1230|         0|            0|            0|  0.00%|
  1231|         0|            0|            0|  0.00%|
  1232|         0|            0|            0|  0.00%|
  1233|         0|            0|            0|  0.00%|
  1234|         0|            0|            0|  0.00%|
  1235|         0|            0|            0|  0.00%|
  1236|         0|            0|            0|  0.00%|
  1237|         0|            0|            0|  0.00%|
  1238|         0|            0|            0|  0.00%|
  1239|         0|            0|            0|  0.00%|
  1240|         0|            0|            0|  0.00%|
  1241|         0|            0|            0|  0.00%|
  1242|         0|            0|            0|  0.00%|
  1243|         0|            0|            0|  0.00%|
  1244|         0|            0|            0|  0.00%|
  1245|         0|            0|            0|  0.00%|
  1246|         0|            0|            0|  0.00%|
  1247|         0|            0|            0|  0.00%|
  1248|         0|            0|            0|  0.00%|
  1249|         0|            0|            0|  0.00%|
  1250|         0|            0|            0|  0.00%|
  1251|         0|            0|            0|  0.00%|
  1252|         0|            0|            0|  0.00%|
  1253|         0|            0|            0|  0.00%|
  1254|         0|            0|            0|  0.00%|
  1255|         0|            0|            0|  0.00%|
  1256|         0|            0|            0|  0.00%|
  1257|         0|            0|            0|  0.00%|
  1258|         0|            0|            0|  0.00%|
  1259|         0|            0|            0|  0.00%|
  1260|         0|            0|            0|  0.00%|
  1261|         0|            0|            0|  0.00%|
  1262|         0|            0|            0|  0.00%|
  1263|         0|            0|            0|  0.00%|
  1264|         0|            0|            0|  0.00%|
  1265|         0|            0|            0|  0.00%|
  1266|         0|            0|            0|  0.00%|
  1267|         0|            0|            0|  0.00%|
  1268|         0|            0|            0|  0.00%|
  1269|         0|            0|            0|  0.00%|
  1270|         0|            0|            0|  0.00%|
  1271|         0|            0|            0|  0.00%|
  1272|         0|            0|            0|  0.00%|
  1273|         0|            0|            0|  0.00%|
  1274|         0|            0|            0|  0.00%|
  1275|         0|            0|            0|  0.00%|
  1276|         0|            0|            0|  0.00%|
  1277|         0|            0|            0|  0.00%|
  1278|         0|            0|            0|  0.00%|
  1279|         0|            0|            0|  0.00%|
  1280|         0|            0|            0|  0.00%|
  1281|         0|            0|            0|  0.00%|
  1282|         0|            0|            0|  0.00%|
  1283|         0|            0|            0|  0.00%|
  1284|         0|            0|            0|  0.00%|
  1285|         0|            0|            0|  0.00%|
  1286|         0|            0|            0|  0.00%|
  1287|         0|            0|            0|  0.00%|
  1288|         0|            0|            0|  0.00%|
  1289|         0|            0|            0|  0.00%|
  1290|         0|            0|            0|  0.00%|
  1291|         0|            0|            0|  0.00%|
  1292|         0|            0|            0|  0.00%|
  1293|         0|            0|            0|  0.00%|
  1294|         0|            0|            0|  0.00%|
  1295|         0|            0|            0|  0.00%|
  1296|         0|            0|            0|  0.00%|
  1297|         0|            0|            0|  0.00%|
  1298|         0|            0|            0|  0.00%|
  1299|         0|            0|            0|  0.00%|
  1300|         0|            0|            0|  0.00%|
  1301|         0|            0|            0|  0.00%|
  1302|         0|            0|            0|  0.00%|
  1303|         0|            0|            0|  0.00%|
  1304|         0|            0|            0|  0.00%|
  1305|         0|            0|            0|  0.00%|
  1306|         0|            0|            0|  0.00%|
  1307|         0|            0|            0|  0.00%|
  1308|         0|            0|            0|  0.00%|
  1309|         0|            0|            0|  0.00%|
  1310|         0|            0|            0|  0.00%|
  1311|         0|            0|            0|  0.00%|
  1312|         0|            0|            0|  0.00%|
  1313|         0|            0|            0|  0.00%|
  1314|         0|            0|            0|  0.00%|
  1315|         0|            0|            0|  0.00%|
  1316|         0|            0|            0|  0.00%|
  1317|         0|            0|            0|  0.00%|
  1318|         0|            0|            0|  0.00%|
  1319|         0|            0|            0|  0.00%|
  1320|         0|            0|            0|  0.00%|
  1321|         0|            0|            0|  0.00%|
  1322|         0|            0|            0|  0.00%|
  1323|         0|            0|            0|  0.00%|
  1324|         0|            0|            0|  0.00%|
  1325|         0|            0|            0|  0.00%|
  1326|         0|            0|            0|  0.00%|
  1327|         0|            0|            0|  0.00%|
  1328|         0|            0|            0|  0.00%|
  1329|         0|            0|            0|  0.00%|
  1330|         0|            0|            0|  0.00%|
  1331|         0|            0|            0|  0.00%|
  1332|         0|            0|            0|  0.00%|
  1333|         0|            0|            0|  0.00%|
  1334|         0|            0|            0|  0.00%|
  1335|         0|            0|            0|  0.00%|
  1336|         0|            0|            0|  0.00%|
  1337|         0|            0|            0|  0.00%|
  1338|         0|            0|            0|  0.00%|
  1339|         0|            0|            0|  0.00%|
  1340|         0|            0|            0|  0.00%|
  1341|         0|            0|            0|  0.00%|
  1342|         0|            0|            0|  0.00%|
  1343|         0|            0|            0|  0.00%|
  1344|         0|            0|            0|  0.00%|
  1345|         0|            0|            0|  0.00%|
  1346|         0|            0|            0|  0.00%|
  1347|         0|            0|            0|  0.00%|
  1348|         0|            0|            0|  0.00%|
  1349|         0|            0|            0|  0.00%|
  1350|         0|            0|            0|  0.00%|
  1351|         0|            0|            0|  0.00%|
  1352|         0|            0|            0|  0.00%|
  1353|         0|            0|            0|  0.00%|
  1354|         0|            0|            0|  0.00%|
  1355|         0|            0|            0|  0.00%|
  1356|         0|            0|            0|  0.00%|
  1357|         0|            0|            0|  0.00%|
  1358|         0|            0|            0|  0.00%|
  1359|         0|            0|            0|  0.00%|
  1360|         0|            0|            0|  0.00%|
  1361|         0|            0|            0|  0.00%|
  1362|         0|            0|            0|  0.00%|
  1363|         0|            0|            0|  0.00%|
  1364|         0|            0|            0|  0.00%|
  1365|         0|            0|            0|  0.00%|
  1366|         0|            0|            0|  0.00%|
  1367|         0|            0|            0|  0.00%|
  1368|         0|            0|            0|  0.00%|
  1369|         0|            0|            0|  0.00%|
  1370|         0|            0|            0|  0.00%|
  1371|         0|            0|            0|  0.00%|
  1372|         0|            0|            0|  0.00%|
  1373|         0|            0|            0|  0.00%|
  1374|         0|            0|            0|  0.00%|
  1375|         0|            0|            0|  0.00%|
  1376|         0|            0|            0|  0.00%|
  1377|         0|            0|            0|  0.00%|
  1378|         0|            0|            0|  0.00%|
  1379|         0|            0|            0|  0.00%|
  1380|         0|            0|            0|  0.00%|
  1381|         0|            0|            0|  0.00%|
  1382|         0|            0|            0|  0.00%|
  1383|         0|            0|            0|  0.00%|
  1384|         0|            0|            0|  0.00%|
  1385|         0|            0|            0|  0.00%|
  1386|         0|            0|            0|  0.00%|
  1387|         0|            0|            0|  0.00%|
  1388|         0|            0|            0|  0.00%|
  1389|         0|            0|            0|  0.00%|
  1390|         4|  1.52588e-05|   3.8147e-06|  0.02%|
  1391|         0|            0|            0|  0.00%|
  1392|         0|            0|            0|  0.00%|
  1393|         0|            0|            0|  0.00%|
  1394|         0|            0|            0|  0.00%|
  1395|         0|            0|            0|  0.00%|
  1396|         0|            0|            0|  0.00%|
  1397|         0|            0|            0|  0.00%|
  1398|         0|            0|            0|  0.00%|
  1399|         0|            0|            0|  0.00%|
  1400|         8|  2.26498e-05|  2.83122e-06|  0.02%|
  1401|         4|  9.53674e-06|  2.38419e-06|  0.01%|
  1402|         0|            0|            0|  0.00%|
  1403|         0|            0|            0|  0.00%|
  1404|         0|            0|            0|  0.00%|
  1405|         0|            0|            0|  0.00%|
  1406|         0|            0|            0|  0.00%|
  1407|         0|            0|            0|  0.00%|
  1408|         4|  1.14441e-05|  2.86102e-06|  0.01%|
  1409|         0|            0|            0|  0.00%|
  1410|         0|            0|            0|  0.00%|
  1411|         0|            0|            0|  0.00%|
  1412|         4|  1.23978e-05|  3.09944e-06|  0.01%|
  1413|         0|            0|            0|  0.00%|
  1414|         0|            0|            0|  0.00%|
  1415|         0|            0|            0|  0.00%|
  1416|         0|            0|            0|  0.00%|
  1417|         0|            0|            0|  0.00%|
  1418|         0|            0|            0|  0.00%|
  1419|         0|            0|            0|  0.00%|
  1420|         0|            0|            0|  0.00%|
  1421|         0|            0|            0|  0.00%|
  1422|         0|            0|            0|  0.00%|
  1423|         0|            0|            0|  0.00%|
  1424|         4|  7.15256e-06|  1.78814e-06|  0.01%|
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_discriminated_union.py
File duration: 0.000137091s (0.14%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|from __future__ import annotations as _annotations
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|from typing import TYPE_CHECKING, Any, Hashable, Sequence
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|from pydantic_core import CoreSchema, core_schema
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|from ..errors import PydanticUserError
     8|         0|            0|            0|  0.00%|from . import _core_utils
     9|         0|            0|            0|  0.00%|from ._core_utils import (
    10|         0|            0|            0|  0.00%|    CoreSchemaField,
    11|         0|            0|            0|  0.00%|    collect_definitions,
    12|         0|            0|            0|  0.00%|)
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|if TYPE_CHECKING:
    15|         0|            0|            0|  0.00%|    from ..types import Discriminator
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|CORE_SCHEMA_METADATA_DISCRIMINATOR_PLACEHOLDER_KEY = 'pydantic.internal.union_discriminator'
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|class MissingDefinitionForUnionRef(Exception):
    21|         0|            0|            0|  0.00%|    """Raised when applying a discriminated union discriminator to a schema
    22|         0|            0|            0|  0.00%|    requires a definition that is not yet defined
    23|         0|            0|            0|  0.00%|    """
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|    def __init__(self, ref: str) -> None:
    26|         0|            0|            0|  0.00%|        self.ref = ref
    27|         0|            0|            0|  0.00%|        super().__init__(f'Missing definition for ref {self.ref!r}')
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|
    30|         0|            0|            0|  0.00%|def set_discriminator_in_metadata(schema: CoreSchema, discriminator: Any) -> None:
    31|         0|            0|            0|  0.00%|    schema.setdefault('metadata', {})
    32|         0|            0|            0|  0.00%|    metadata = schema.get('metadata')
    33|         0|            0|            0|  0.00%|    assert metadata is not None
    34|         0|            0|            0|  0.00%|    metadata[CORE_SCHEMA_METADATA_DISCRIMINATOR_PLACEHOLDER_KEY] = discriminator
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|
    37|         2|  3.17097e-05|  1.58548e-05|  0.03%|def apply_discriminators(schema: core_schema.CoreSchema) -> core_schema.CoreSchema:
    38|         0|            0|            0|  0.00%|    # We recursively walk through the `schema` passed to `apply_discriminators`, applying discriminators
    39|         0|            0|            0|  0.00%|    # where necessary at each level. During this recursion, we allow references to be resolved from the definitions
    40|         0|            0|            0|  0.00%|    # that are originally present on the original, outermost `schema`. Before `apply_discriminators` is called,
    41|         0|            0|            0|  0.00%|    # `simplify_schema_references` is called on the schema (in the `clean_schema` function),
    42|         0|            0|            0|  0.00%|    # which often puts the definitions in the outermost schema.
    43|         2|  1.71661e-05|  8.58307e-06|  0.02%|    global_definitions: dict[str, CoreSchema] = collect_definitions(schema)
(call)|         2|  0.000146866|  7.34329e-05|  0.15%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:122 collect_definitions
    44|         0|            0|            0|  0.00%|
    45|         6|  1.12057e-05|  1.86761e-06|  0.01%|    def inner(s: core_schema.CoreSchema, recurse: _core_utils.Recurse) -> core_schema.CoreSchema:
    46|         0|            0|            0|  0.00%|        nonlocal global_definitions
    47|         0|            0|            0|  0.00%|
    48|         4|  2.09808e-05|  5.24521e-06|  0.02%|        s = recurse(s, inner)
(call)|         2|  4.50611e-05|  2.25306e-05|  0.05%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:199 _walk
(call)|         2|  0.000102282|  5.11408e-05|  0.11%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:196 walk
    49|         4|  7.62939e-06|  1.90735e-06|  0.01%|        if s['type'] == 'tagged-union':
    50|         0|            0|            0|  0.00%|            return s
    51|         0|            0|            0|  0.00%|
    52|         4|   1.3113e-05|  3.27826e-06|  0.01%|        metadata = s.get('metadata', {})
    53|         4|  8.10623e-06|  2.02656e-06|  0.01%|        discriminator = metadata.pop(CORE_SCHEMA_METADATA_DISCRIMINATOR_PLACEHOLDER_KEY, None)
    54|         4|  7.86781e-06|  1.96695e-06|  0.01%|        if discriminator is not None:
    55|         0|            0|            0|  0.00%|            s = apply_discriminator(s, discriminator, global_definitions)
    56|         4|  7.15256e-06|  1.78814e-06|  0.01%|        return s
    57|         0|            0|            0|  0.00%|
    58|         2|  1.21593e-05|  6.07967e-06|  0.01%|    return _core_utils.walk_core_schema(schema, inner)
(call)|         2|  0.000146866|  7.34329e-05|  0.15%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_core_utils.py:400 walk_core_schema
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|
    61|         0|            0|            0|  0.00%|def apply_discriminator(
    62|         0|            0|            0|  0.00%|    schema: core_schema.CoreSchema,
    63|         0|            0|            0|  0.00%|    discriminator: str | Discriminator,
    64|         0|            0|            0|  0.00%|    definitions: dict[str, core_schema.CoreSchema] | None = None,
    65|         0|            0|            0|  0.00%|) -> core_schema.CoreSchema:
    66|         0|            0|            0|  0.00%|    """Applies the discriminator and returns a new core schema.
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|    Args:
    69|         0|            0|            0|  0.00%|        schema: The input schema.
    70|         0|            0|            0|  0.00%|        discriminator: The name of the field which will serve as the discriminator.
    71|         0|            0|            0|  0.00%|        definitions: A mapping of schema ref to schema.
    72|         0|            0|            0|  0.00%|
    73|         0|            0|            0|  0.00%|    Returns:
    74|         0|            0|            0|  0.00%|        The new core schema.
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|    Raises:
    77|         0|            0|            0|  0.00%|        TypeError:
    78|         0|            0|            0|  0.00%|            - If `discriminator` is used with invalid union variant.
    79|         0|            0|            0|  0.00%|            - If `discriminator` is used with `Union` type with one variant.
    80|         0|            0|            0|  0.00%|            - If `discriminator` value mapped to multiple choices.
    81|         0|            0|            0|  0.00%|        MissingDefinitionForUnionRef:
    82|         0|            0|            0|  0.00%|            If the definition for ref is missing.
    83|         0|            0|            0|  0.00%|        PydanticUserError:
    84|         0|            0|            0|  0.00%|            - If a model in union doesn't have a discriminator field.
    85|         0|            0|            0|  0.00%|            - If discriminator field has a non-string alias.
    86|         0|            0|            0|  0.00%|            - If discriminator fields have different aliases.
    87|         0|            0|            0|  0.00%|            - If discriminator field not of type `Literal`.
    88|         0|            0|            0|  0.00%|    """
    89|         0|            0|            0|  0.00%|    from ..types import Discriminator
    90|         0|            0|            0|  0.00%|
    91|         0|            0|            0|  0.00%|    if isinstance(discriminator, Discriminator):
    92|         0|            0|            0|  0.00%|        if isinstance(discriminator.discriminator, str):
    93|         0|            0|            0|  0.00%|            discriminator = discriminator.discriminator
    94|         0|            0|            0|  0.00%|        else:
    95|         0|            0|            0|  0.00%|            return discriminator._convert_schema(schema)
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|    return _ApplyInferredDiscriminator(discriminator, definitions or {}).apply(schema)
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|
   100|         0|            0|            0|  0.00%|class _ApplyInferredDiscriminator:
   101|         0|            0|            0|  0.00%|    """This class is used to convert an input schema containing a union schema into one where that union is
   102|         0|            0|            0|  0.00%|    replaced with a tagged-union, with all the associated debugging and performance benefits.
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|    This is done by:
   105|         0|            0|            0|  0.00%|    * Validating that the input schema is compatible with the provided discriminator
   106|         0|            0|            0|  0.00%|    * Introspecting the schema to determine which discriminator values should map to which union choices
   107|         0|            0|            0|  0.00%|    * Handling various edge cases such as 'definitions', 'default', 'nullable' schemas, and more
   108|         0|            0|            0|  0.00%|
   109|         0|            0|            0|  0.00%|    I have chosen to implement the conversion algorithm in this class, rather than a function,
   110|         0|            0|            0|  0.00%|    to make it easier to maintain state while recursively walking the provided CoreSchema.
   111|         0|            0|            0|  0.00%|    """
   112|         0|            0|            0|  0.00%|
   113|         0|            0|            0|  0.00%|    def __init__(self, discriminator: str, definitions: dict[str, core_schema.CoreSchema]):
   114|         0|            0|            0|  0.00%|        # `discriminator` should be the name of the field which will serve as the discriminator.
   115|         0|            0|            0|  0.00%|        # It must be the python name of the field, and *not* the field's alias. Note that as of now,
   116|         0|            0|            0|  0.00%|        # all members of a discriminated union _must_ use a field with the same name as the discriminator.
   117|         0|            0|            0|  0.00%|        # This may change if/when we expose a way to manually specify the TaggedUnionSchema's choices.
   118|         0|            0|            0|  0.00%|        self.discriminator = discriminator
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|        # `definitions` should contain a mapping of schema ref to schema for all schemas which might
   121|         0|            0|            0|  0.00%|        # be referenced by some choice
   122|         0|            0|            0|  0.00%|        self.definitions = definitions
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|        # `_discriminator_alias` will hold the value, if present, of the alias for the discriminator
   125|         0|            0|            0|  0.00%|        #
   126|         0|            0|            0|  0.00%|        # Note: following the v1 implementation, we currently disallow the use of different aliases
   127|         0|            0|            0|  0.00%|        # for different choices. This is not a limitation of pydantic_core, but if we try to handle
   128|         0|            0|            0|  0.00%|        # this, the inference logic gets complicated very quickly, and could result in confusing
   129|         0|            0|            0|  0.00%|        # debugging challenges for users making subtle mistakes.
   130|         0|            0|            0|  0.00%|        #
   131|         0|            0|            0|  0.00%|        # Rather than trying to do the most powerful inference possible, I think we should eventually
   132|         0|            0|            0|  0.00%|        # expose a way to more-manually control the way the TaggedUnionSchema is constructed through
   133|         0|            0|            0|  0.00%|        # the use of a new type which would be placed as an Annotation on the Union type. This would
   134|         0|            0|            0|  0.00%|        # provide the full flexibility/power of pydantic_core's TaggedUnionSchema where necessary for
   135|         0|            0|            0|  0.00%|        # more complex cases, without over-complicating the inference logic for the common cases.
   136|         0|            0|            0|  0.00%|        self._discriminator_alias: str | None = None
   137|         0|            0|            0|  0.00%|
   138|         0|            0|            0|  0.00%|        # `_should_be_nullable` indicates whether the converted union has `None` as an allowed value.
   139|         0|            0|            0|  0.00%|        # If `None` is an acceptable value of the (possibly-wrapped) union, we ignore it while
   140|         0|            0|            0|  0.00%|        # constructing the TaggedUnionSchema, but set the `_should_be_nullable` attribute to True.
   141|         0|            0|            0|  0.00%|        # Once we have constructed the TaggedUnionSchema, if `_should_be_nullable` is True, we ensure
   142|         0|            0|            0|  0.00%|        # that the final schema gets wrapped as a NullableSchema. This has the same semantics on the
   143|         0|            0|            0|  0.00%|        # python side, but resolves the issue that `None` cannot correspond to any discriminator values.
   144|         0|            0|            0|  0.00%|        self._should_be_nullable = False
   145|         0|            0|            0|  0.00%|
   146|         0|            0|            0|  0.00%|        # `_is_nullable` is used to track if the final produced schema will definitely be nullable;
   147|         0|            0|            0|  0.00%|        # we set it to True if the input schema is wrapped in a nullable schema that we know will be preserved
   148|         0|            0|            0|  0.00%|        # as an indication that, even if None is discovered as one of the union choices, we will not need to wrap
   149|         0|            0|            0|  0.00%|        # the final value in another nullable schema.
   150|         0|            0|            0|  0.00%|        #
   151|         0|            0|            0|  0.00%|        # This is more complicated than just checking for the final outermost schema having type 'nullable' thanks
   152|         0|            0|            0|  0.00%|        # to the possible presence of other wrapper schemas such as DefinitionsSchema, WithDefaultSchema, etc.
   153|         0|            0|            0|  0.00%|        self._is_nullable = False
   154|         0|            0|            0|  0.00%|
   155|         0|            0|            0|  0.00%|        # `_choices_to_handle` serves as a stack of choices to add to the tagged union. Initially, choices
   156|         0|            0|            0|  0.00%|        # from the union in the wrapped schema will be appended to this list, and the recursive choice-handling
   157|         0|            0|            0|  0.00%|        # algorithm may add more choices to this stack as (nested) unions are encountered.
   158|         0|            0|            0|  0.00%|        self._choices_to_handle: list[core_schema.CoreSchema] = []
   159|         0|            0|            0|  0.00%|
   160|         0|            0|            0|  0.00%|        # `_tagged_union_choices` is built during the call to `apply`, and will hold the choices to be included
   161|         0|            0|            0|  0.00%|        # in the output TaggedUnionSchema that will replace the union from the input schema
   162|         0|            0|            0|  0.00%|        self._tagged_union_choices: dict[Hashable, core_schema.CoreSchema] = {}
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|        # `_used` is changed to True after applying the discriminator to prevent accidental re-use
   165|         0|            0|            0|  0.00%|        self._used = False
   166|         0|            0|            0|  0.00%|
   167|         0|            0|            0|  0.00%|    def apply(self, schema: core_schema.CoreSchema) -> core_schema.CoreSchema:
   168|         0|            0|            0|  0.00%|        """Return a new CoreSchema based on `schema` that uses a tagged-union with the discriminator provided
   169|         0|            0|            0|  0.00%|        to this class.
   170|         0|            0|            0|  0.00%|
   171|         0|            0|            0|  0.00%|        Args:
   172|         0|            0|            0|  0.00%|            schema: The input schema.
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|        Returns:
   175|         0|            0|            0|  0.00%|            The new core schema.
   176|         0|            0|            0|  0.00%|
   177|         0|            0|            0|  0.00%|        Raises:
   178|         0|            0|            0|  0.00%|            TypeError:
   179|         0|            0|            0|  0.00%|                - If `discriminator` is used with invalid union variant.
   180|         0|            0|            0|  0.00%|                - If `discriminator` is used with `Union` type with one variant.
   181|         0|            0|            0|  0.00%|                - If `discriminator` value mapped to multiple choices.
   182|         0|            0|            0|  0.00%|            ValueError:
   183|         0|            0|            0|  0.00%|                If the definition for ref is missing.
   184|         0|            0|            0|  0.00%|            PydanticUserError:
   185|         0|            0|            0|  0.00%|                - If a model in union doesn't have a discriminator field.
   186|         0|            0|            0|  0.00%|                - If discriminator field has a non-string alias.
   187|         0|            0|            0|  0.00%|                - If discriminator fields have different aliases.
   188|         0|            0|            0|  0.00%|                - If discriminator field not of type `Literal`.
   189|         0|            0|            0|  0.00%|        """
   190|         0|            0|            0|  0.00%|        assert not self._used
   191|         0|            0|            0|  0.00%|        schema = self._apply_to_root(schema)
   192|         0|            0|            0|  0.00%|        if self._should_be_nullable and not self._is_nullable:
   193|         0|            0|            0|  0.00%|            schema = core_schema.nullable_schema(schema)
   194|         0|            0|            0|  0.00%|        self._used = True
   195|         0|            0|            0|  0.00%|        return schema
   196|         0|            0|            0|  0.00%|
   197|         0|            0|            0|  0.00%|    def _apply_to_root(self, schema: core_schema.CoreSchema) -> core_schema.CoreSchema:
   198|         0|            0|            0|  0.00%|        """This method handles the outer-most stage of recursion over the input schema:
   199|         0|            0|            0|  0.00%|        unwrapping nullable or definitions schemas, and calling the `_handle_choice`
   200|         0|            0|            0|  0.00%|        method iteratively on the choices extracted (recursively) from the possibly-wrapped union.
   201|         0|            0|            0|  0.00%|        """
   202|         0|            0|            0|  0.00%|        if schema['type'] == 'nullable':
   203|         0|            0|            0|  0.00%|            self._is_nullable = True
   204|         0|            0|            0|  0.00%|            wrapped = self._apply_to_root(schema['schema'])
   205|         0|            0|            0|  0.00%|            nullable_wrapper = schema.copy()
   206|         0|            0|            0|  0.00%|            nullable_wrapper['schema'] = wrapped
   207|         0|            0|            0|  0.00%|            return nullable_wrapper
   208|         0|            0|            0|  0.00%|
   209|         0|            0|            0|  0.00%|        if schema['type'] == 'definitions':
   210|         0|            0|            0|  0.00%|            wrapped = self._apply_to_root(schema['schema'])
   211|         0|            0|            0|  0.00%|            definitions_wrapper = schema.copy()
   212|         0|            0|            0|  0.00%|            definitions_wrapper['schema'] = wrapped
   213|         0|            0|            0|  0.00%|            return definitions_wrapper
   214|         0|            0|            0|  0.00%|
   215|         0|            0|            0|  0.00%|        if schema['type'] != 'union':
   216|         0|            0|            0|  0.00%|            # If the schema is not a union, it probably means it just had a single member and
   217|         0|            0|            0|  0.00%|            # was flattened by pydantic_core.
   218|         0|            0|            0|  0.00%|            # However, it still may make sense to apply the discriminator to this schema,
   219|         0|            0|            0|  0.00%|            # as a way to get discriminated-union-style error messages, so we allow this here.
   220|         0|            0|            0|  0.00%|            schema = core_schema.union_schema([schema])
   221|         0|            0|            0|  0.00%|
   222|         0|            0|            0|  0.00%|        # Reverse the choices list before extending the stack so that they get handled in the order they occur
   223|         0|            0|            0|  0.00%|        choices_schemas = [v[0] if isinstance(v, tuple) else v for v in schema['choices'][::-1]]
   224|         0|            0|            0|  0.00%|        self._choices_to_handle.extend(choices_schemas)
   225|         0|            0|            0|  0.00%|        while self._choices_to_handle:
   226|         0|            0|            0|  0.00%|            choice = self._choices_to_handle.pop()
   227|         0|            0|            0|  0.00%|            self._handle_choice(choice)
   228|         0|            0|            0|  0.00%|
   229|         0|            0|            0|  0.00%|        if self._discriminator_alias is not None and self._discriminator_alias != self.discriminator:
   230|         0|            0|            0|  0.00%|            # * We need to annotate `discriminator` as a union here to handle both branches of this conditional
   231|         0|            0|            0|  0.00%|            # * We need to annotate `discriminator` as list[list[str | int]] and not list[list[str]] due to the
   232|         0|            0|            0|  0.00%|            #   invariance of list, and because list[list[str | int]] is the type of the discriminator argument
   233|         0|            0|            0|  0.00%|            #   to tagged_union_schema below
   234|         0|            0|            0|  0.00%|            # * See the docstring of pydantic_core.core_schema.tagged_union_schema for more details about how to
   235|         0|            0|            0|  0.00%|            #   interpret the value of the discriminator argument to tagged_union_schema. (The list[list[str]] here
   236|         0|            0|            0|  0.00%|            #   is the appropriate way to provide a list of fallback attributes to check for a discriminator value.)
   237|         0|            0|            0|  0.00%|            discriminator: str | list[list[str | int]] = [[self.discriminator], [self._discriminator_alias]]
   238|         0|            0|            0|  0.00%|        else:
   239|         0|            0|            0|  0.00%|            discriminator = self.discriminator
   240|         0|            0|            0|  0.00%|        return core_schema.tagged_union_schema(
   241|         0|            0|            0|  0.00%|            choices=self._tagged_union_choices,
   242|         0|            0|            0|  0.00%|            discriminator=discriminator,
   243|         0|            0|            0|  0.00%|            custom_error_type=schema.get('custom_error_type'),
   244|         0|            0|            0|  0.00%|            custom_error_message=schema.get('custom_error_message'),
   245|         0|            0|            0|  0.00%|            custom_error_context=schema.get('custom_error_context'),
   246|         0|            0|            0|  0.00%|            strict=False,
   247|         0|            0|            0|  0.00%|            from_attributes=True,
   248|         0|            0|            0|  0.00%|            ref=schema.get('ref'),
   249|         0|            0|            0|  0.00%|            metadata=schema.get('metadata'),
   250|         0|            0|            0|  0.00%|            serialization=schema.get('serialization'),
   251|         0|            0|            0|  0.00%|        )
   252|         0|            0|            0|  0.00%|
   253|         0|            0|            0|  0.00%|    def _handle_choice(self, choice: core_schema.CoreSchema) -> None:
   254|         0|            0|            0|  0.00%|        """This method handles the "middle" stage of recursion over the input schema.
   255|         0|            0|            0|  0.00%|        Specifically, it is responsible for handling each choice of the outermost union
   256|         0|            0|            0|  0.00%|        (and any "coalesced" choices obtained from inner unions).
   257|         0|            0|            0|  0.00%|
   258|         0|            0|            0|  0.00%|        Here, "handling" entails:
   259|         0|            0|            0|  0.00%|        * Coalescing nested unions and compatible tagged-unions
   260|         0|            0|            0|  0.00%|        * Tracking the presence of 'none' and 'nullable' schemas occurring as choices
   261|         0|            0|            0|  0.00%|        * Validating that each allowed discriminator value maps to a unique choice
   262|         0|            0|            0|  0.00%|        * Updating the _tagged_union_choices mapping that will ultimately be used to build the TaggedUnionSchema.
   263|         0|            0|            0|  0.00%|        """
   264|         0|            0|            0|  0.00%|        if choice['type'] == 'definition-ref':
   265|         0|            0|            0|  0.00%|            if choice['schema_ref'] not in self.definitions:
   266|         0|            0|            0|  0.00%|                raise MissingDefinitionForUnionRef(choice['schema_ref'])
   267|         0|            0|            0|  0.00%|
   268|         0|            0|            0|  0.00%|        if choice['type'] == 'none':
   269|         0|            0|            0|  0.00%|            self._should_be_nullable = True
   270|         0|            0|            0|  0.00%|        elif choice['type'] == 'definitions':
   271|         0|            0|            0|  0.00%|            self._handle_choice(choice['schema'])
   272|         0|            0|            0|  0.00%|        elif choice['type'] == 'nullable':
   273|         0|            0|            0|  0.00%|            self._should_be_nullable = True
   274|         0|            0|            0|  0.00%|            self._handle_choice(choice['schema'])  # unwrap the nullable schema
   275|         0|            0|            0|  0.00%|        elif choice['type'] == 'union':
   276|         0|            0|            0|  0.00%|            # Reverse the choices list before extending the stack so that they get handled in the order they occur
   277|         0|            0|            0|  0.00%|            choices_schemas = [v[0] if isinstance(v, tuple) else v for v in choice['choices'][::-1]]
   278|         0|            0|            0|  0.00%|            self._choices_to_handle.extend(choices_schemas)
   279|         0|            0|            0|  0.00%|        elif choice['type'] not in {
   280|         0|            0|            0|  0.00%|            'model',
   281|         0|            0|            0|  0.00%|            'typed-dict',
   282|         0|            0|            0|  0.00%|            'tagged-union',
   283|         0|            0|            0|  0.00%|            'lax-or-strict',
   284|         0|            0|            0|  0.00%|            'dataclass',
   285|         0|            0|            0|  0.00%|            'dataclass-args',
   286|         0|            0|            0|  0.00%|            'definition-ref',
   287|         0|            0|            0|  0.00%|        } and not _core_utils.is_function_with_inner_schema(choice):
   288|         0|            0|            0|  0.00%|            # We should eventually handle 'definition-ref' as well
   289|         0|            0|            0|  0.00%|            raise TypeError(
   290|         0|            0|            0|  0.00%|                f'{choice["type"]!r} is not a valid discriminated union variant;'
   291|         0|            0|            0|  0.00%|                ' should be a `BaseModel` or `dataclass`'
   292|         0|            0|            0|  0.00%|            )
   293|         0|            0|            0|  0.00%|        else:
   294|         0|            0|            0|  0.00%|            if choice['type'] == 'tagged-union' and self._is_discriminator_shared(choice):
   295|         0|            0|            0|  0.00%|                # In this case, this inner tagged-union is compatible with the outer tagged-union,
   296|         0|            0|            0|  0.00%|                # and its choices can be coalesced into the outer TaggedUnionSchema.
   297|         0|            0|            0|  0.00%|                subchoices = [x for x in choice['choices'].values() if not isinstance(x, (str, int))]
   298|         0|            0|            0|  0.00%|                # Reverse the choices list before extending the stack so that they get handled in the order they occur
   299|         0|            0|            0|  0.00%|                self._choices_to_handle.extend(subchoices[::-1])
   300|         0|            0|            0|  0.00%|                return
   301|         0|            0|            0|  0.00%|
   302|         0|            0|            0|  0.00%|            inferred_discriminator_values = self._infer_discriminator_values_for_choice(choice, source_name=None)
   303|         0|            0|            0|  0.00%|            self._set_unique_choice_for_values(choice, inferred_discriminator_values)
   304|         0|            0|            0|  0.00%|
   305|         0|            0|            0|  0.00%|    def _is_discriminator_shared(self, choice: core_schema.TaggedUnionSchema) -> bool:
   306|         0|            0|            0|  0.00%|        """This method returns a boolean indicating whether the discriminator for the `choice`
   307|         0|            0|            0|  0.00%|        is the same as that being used for the outermost tagged union. This is used to
   308|         0|            0|            0|  0.00%|        determine whether this TaggedUnionSchema choice should be "coalesced" into the top level,
   309|         0|            0|            0|  0.00%|        or whether it should be treated as a separate (nested) choice.
   310|         0|            0|            0|  0.00%|        """
   311|         0|            0|            0|  0.00%|        inner_discriminator = choice['discriminator']
   312|         0|            0|            0|  0.00%|        return inner_discriminator == self.discriminator or (
   313|         0|            0|            0|  0.00%|            isinstance(inner_discriminator, list)
   314|         0|            0|            0|  0.00%|            and (self.discriminator in inner_discriminator or [self.discriminator] in inner_discriminator)
   315|         0|            0|            0|  0.00%|        )
   316|         0|            0|            0|  0.00%|
   317|         0|            0|            0|  0.00%|    def _infer_discriminator_values_for_choice(  # noqa C901
   318|         0|            0|            0|  0.00%|        self, choice: core_schema.CoreSchema, source_name: str | None
   319|         0|            0|            0|  0.00%|    ) -> list[str | int]:
   320|         0|            0|            0|  0.00%|        """This function recurses over `choice`, extracting all discriminator values that should map to this choice.
   321|         0|            0|            0|  0.00%|
   322|         0|            0|            0|  0.00%|        `model_name` is accepted for the purpose of producing useful error messages.
   323|         0|            0|            0|  0.00%|        """
   324|         0|            0|            0|  0.00%|        if choice['type'] == 'definitions':
   325|         0|            0|            0|  0.00%|            return self._infer_discriminator_values_for_choice(choice['schema'], source_name=source_name)
   326|         0|            0|            0|  0.00%|        elif choice['type'] == 'function-plain':
   327|         0|            0|            0|  0.00%|            raise TypeError(
   328|         0|            0|            0|  0.00%|                f'{choice["type"]!r} is not a valid discriminated union variant;'
   329|         0|            0|            0|  0.00%|                ' should be a `BaseModel` or `dataclass`'
   330|         0|            0|            0|  0.00%|            )
   331|         0|            0|            0|  0.00%|        elif _core_utils.is_function_with_inner_schema(choice):
   332|         0|            0|            0|  0.00%|            return self._infer_discriminator_values_for_choice(choice['schema'], source_name=source_name)
   333|         0|            0|            0|  0.00%|        elif choice['type'] == 'lax-or-strict':
   334|         0|            0|            0|  0.00%|            return sorted(
   335|         0|            0|            0|  0.00%|                set(
   336|         0|            0|            0|  0.00%|                    self._infer_discriminator_values_for_choice(choice['lax_schema'], source_name=None)
   337|         0|            0|            0|  0.00%|                    + self._infer_discriminator_values_for_choice(choice['strict_schema'], source_name=None)
   338|         0|            0|            0|  0.00%|                )
   339|         0|            0|            0|  0.00%|            )
   340|         0|            0|            0|  0.00%|
   341|         0|            0|            0|  0.00%|        elif choice['type'] == 'tagged-union':
   342|         0|            0|            0|  0.00%|            values: list[str | int] = []
   343|         0|            0|            0|  0.00%|            # Ignore str/int "choices" since these are just references to other choices
   344|         0|            0|            0|  0.00%|            subchoices = [x for x in choice['choices'].values() if not isinstance(x, (str, int))]
   345|         0|            0|            0|  0.00%|            for subchoice in subchoices:
   346|         0|            0|            0|  0.00%|                subchoice_values = self._infer_discriminator_values_for_choice(subchoice, source_name=None)
   347|         0|            0|            0|  0.00%|                values.extend(subchoice_values)
   348|         0|            0|            0|  0.00%|            return values
   349|         0|            0|            0|  0.00%|
   350|         0|            0|            0|  0.00%|        elif choice['type'] == 'union':
   351|         0|            0|            0|  0.00%|            values = []
   352|         0|            0|            0|  0.00%|            for subchoice in choice['choices']:
   353|         0|            0|            0|  0.00%|                subchoice_schema = subchoice[0] if isinstance(subchoice, tuple) else subchoice
   354|         0|            0|            0|  0.00%|                subchoice_values = self._infer_discriminator_values_for_choice(subchoice_schema, source_name=None)
   355|         0|            0|            0|  0.00%|                values.extend(subchoice_values)
   356|         0|            0|            0|  0.00%|            return values
   357|         0|            0|            0|  0.00%|
   358|         0|            0|            0|  0.00%|        elif choice['type'] == 'nullable':
   359|         0|            0|            0|  0.00%|            self._should_be_nullable = True
   360|         0|            0|            0|  0.00%|            return self._infer_discriminator_values_for_choice(choice['schema'], source_name=None)
   361|         0|            0|            0|  0.00%|
   362|         0|            0|            0|  0.00%|        elif choice['type'] == 'model':
   363|         0|            0|            0|  0.00%|            return self._infer_discriminator_values_for_choice(choice['schema'], source_name=choice['cls'].__name__)
   364|         0|            0|            0|  0.00%|
   365|         0|            0|            0|  0.00%|        elif choice['type'] == 'dataclass':
   366|         0|            0|            0|  0.00%|            return self._infer_discriminator_values_for_choice(choice['schema'], source_name=choice['cls'].__name__)
   367|         0|            0|            0|  0.00%|
   368|         0|            0|            0|  0.00%|        elif choice['type'] == 'model-fields':
   369|         0|            0|            0|  0.00%|            return self._infer_discriminator_values_for_model_choice(choice, source_name=source_name)
   370|         0|            0|            0|  0.00%|
   371|         0|            0|            0|  0.00%|        elif choice['type'] == 'dataclass-args':
   372|         0|            0|            0|  0.00%|            return self._infer_discriminator_values_for_dataclass_choice(choice, source_name=source_name)
   373|         0|            0|            0|  0.00%|
   374|         0|            0|            0|  0.00%|        elif choice['type'] == 'typed-dict':
   375|         0|            0|            0|  0.00%|            return self._infer_discriminator_values_for_typed_dict_choice(choice, source_name=source_name)
   376|         0|            0|            0|  0.00%|
   377|         0|            0|            0|  0.00%|        elif choice['type'] == 'definition-ref':
   378|         0|            0|            0|  0.00%|            schema_ref = choice['schema_ref']
   379|         0|            0|            0|  0.00%|            if schema_ref not in self.definitions:
   380|         0|            0|            0|  0.00%|                raise MissingDefinitionForUnionRef(schema_ref)
   381|         0|            0|            0|  0.00%|            return self._infer_discriminator_values_for_choice(self.definitions[schema_ref], source_name=source_name)
   382|         0|            0|            0|  0.00%|        else:
   383|         0|            0|            0|  0.00%|            raise TypeError(
   384|         0|            0|            0|  0.00%|                f'{choice["type"]!r} is not a valid discriminated union variant;'
   385|         0|            0|            0|  0.00%|                ' should be a `BaseModel` or `dataclass`'
   386|         0|            0|            0|  0.00%|            )
   387|         0|            0|            0|  0.00%|
   388|         0|            0|            0|  0.00%|    def _infer_discriminator_values_for_typed_dict_choice(
   389|         0|            0|            0|  0.00%|        self, choice: core_schema.TypedDictSchema, source_name: str | None = None
   390|         0|            0|            0|  0.00%|    ) -> list[str | int]:
   391|         0|            0|            0|  0.00%|        """This method just extracts the _infer_discriminator_values_for_choice logic specific to TypedDictSchema
   392|         0|            0|            0|  0.00%|        for the sake of readability.
   393|         0|            0|            0|  0.00%|        """
   394|         0|            0|            0|  0.00%|        source = 'TypedDict' if source_name is None else f'TypedDict {source_name!r}'
   395|         0|            0|            0|  0.00%|        field = choice['fields'].get(self.discriminator)
   396|         0|            0|            0|  0.00%|        if field is None:
   397|         0|            0|            0|  0.00%|            raise PydanticUserError(
   398|         0|            0|            0|  0.00%|                f'{source} needs a discriminator field for key {self.discriminator!r}', code='discriminator-no-field'
   399|         0|            0|            0|  0.00%|            )
   400|         0|            0|            0|  0.00%|        return self._infer_discriminator_values_for_field(field, source)
   401|         0|            0|            0|  0.00%|
   402|         0|            0|            0|  0.00%|    def _infer_discriminator_values_for_model_choice(
   403|         0|            0|            0|  0.00%|        self, choice: core_schema.ModelFieldsSchema, source_name: str | None = None
   404|         0|            0|            0|  0.00%|    ) -> list[str | int]:
   405|         0|            0|            0|  0.00%|        source = 'ModelFields' if source_name is None else f'Model {source_name!r}'
   406|         0|            0|            0|  0.00%|        field = choice['fields'].get(self.discriminator)
   407|         0|            0|            0|  0.00%|        if field is None:
   408|         0|            0|            0|  0.00%|            raise PydanticUserError(
   409|         0|            0|            0|  0.00%|                f'{source} needs a discriminator field for key {self.discriminator!r}', code='discriminator-no-field'
   410|         0|            0|            0|  0.00%|            )
   411|         0|            0|            0|  0.00%|        return self._infer_discriminator_values_for_field(field, source)
   412|         0|            0|            0|  0.00%|
   413|         0|            0|            0|  0.00%|    def _infer_discriminator_values_for_dataclass_choice(
   414|         0|            0|            0|  0.00%|        self, choice: core_schema.DataclassArgsSchema, source_name: str | None = None
   415|         0|            0|            0|  0.00%|    ) -> list[str | int]:
   416|         0|            0|            0|  0.00%|        source = 'DataclassArgs' if source_name is None else f'Dataclass {source_name!r}'
   417|         0|            0|            0|  0.00%|        for field in choice['fields']:
   418|         0|            0|            0|  0.00%|            if field['name'] == self.discriminator:
   419|         0|            0|            0|  0.00%|                break
   420|         0|            0|            0|  0.00%|        else:
   421|         0|            0|            0|  0.00%|            raise PydanticUserError(
   422|         0|            0|            0|  0.00%|                f'{source} needs a discriminator field for key {self.discriminator!r}', code='discriminator-no-field'
   423|         0|            0|            0|  0.00%|            )
   424|         0|            0|            0|  0.00%|        return self._infer_discriminator_values_for_field(field, source)
   425|         0|            0|            0|  0.00%|
   426|         0|            0|            0|  0.00%|    def _infer_discriminator_values_for_field(self, field: CoreSchemaField, source: str) -> list[str | int]:
   427|         0|            0|            0|  0.00%|        if field['type'] == 'computed-field':
   428|         0|            0|            0|  0.00%|            # This should never occur as a discriminator, as it is only relevant to serialization
   429|         0|            0|            0|  0.00%|            return []
   430|         0|            0|            0|  0.00%|        alias = field.get('validation_alias', self.discriminator)
   431|         0|            0|            0|  0.00%|        if not isinstance(alias, str):
   432|         0|            0|            0|  0.00%|            raise PydanticUserError(
   433|         0|            0|            0|  0.00%|                f'Alias {alias!r} is not supported in a discriminated union', code='discriminator-alias-type'
   434|         0|            0|            0|  0.00%|            )
   435|         0|            0|            0|  0.00%|        if self._discriminator_alias is None:
   436|         0|            0|            0|  0.00%|            self._discriminator_alias = alias
   437|         0|            0|            0|  0.00%|        elif self._discriminator_alias != alias:
   438|         0|            0|            0|  0.00%|            raise PydanticUserError(
   439|         0|            0|            0|  0.00%|                f'Aliases for discriminator {self.discriminator!r} must be the same '
   440|         0|            0|            0|  0.00%|                f'(got {alias}, {self._discriminator_alias})',
   441|         0|            0|            0|  0.00%|                code='discriminator-alias',
   442|         0|            0|            0|  0.00%|            )
   443|         0|            0|            0|  0.00%|        return self._infer_discriminator_values_for_inner_schema(field['schema'], source)
   444|         0|            0|            0|  0.00%|
   445|         0|            0|            0|  0.00%|    def _infer_discriminator_values_for_inner_schema(
   446|         0|            0|            0|  0.00%|        self, schema: core_schema.CoreSchema, source: str
   447|         0|            0|            0|  0.00%|    ) -> list[str | int]:
   448|         0|            0|            0|  0.00%|        """When inferring discriminator values for a field, we typically extract the expected values from a literal
   449|         0|            0|            0|  0.00%|        schema. This function does that, but also handles nested unions and defaults.
   450|         0|            0|            0|  0.00%|        """
   451|         0|            0|            0|  0.00%|        if schema['type'] == 'literal':
   452|         0|            0|            0|  0.00%|            return schema['expected']
   453|         0|            0|            0|  0.00%|
   454|         0|            0|            0|  0.00%|        elif schema['type'] == 'union':
   455|         0|            0|            0|  0.00%|            # Generally when multiple values are allowed they should be placed in a single `Literal`, but
   456|         0|            0|            0|  0.00%|            # we add this case to handle the situation where a field is annotated as a `Union` of `Literal`s.
   457|         0|            0|            0|  0.00%|            # For example, this lets us handle `Union[Literal['key'], Union[Literal['Key'], Literal['KEY']]]`
   458|         0|            0|            0|  0.00%|            values: list[Any] = []
   459|         0|            0|            0|  0.00%|            for choice in schema['choices']:
   460|         0|            0|            0|  0.00%|                choice_schema = choice[0] if isinstance(choice, tuple) else choice
   461|         0|            0|            0|  0.00%|                choice_values = self._infer_discriminator_values_for_inner_schema(choice_schema, source)
   462|         0|            0|            0|  0.00%|                values.extend(choice_values)
   463|         0|            0|            0|  0.00%|            return values
   464|         0|            0|            0|  0.00%|
   465|         0|            0|            0|  0.00%|        elif schema['type'] == 'default':
   466|         0|            0|            0|  0.00%|            # This will happen if the field has a default value; we ignore it while extracting the discriminator values
   467|         0|            0|            0|  0.00%|            return self._infer_discriminator_values_for_inner_schema(schema['schema'], source)
   468|         0|            0|            0|  0.00%|
   469|         0|            0|            0|  0.00%|        elif schema['type'] == 'function-after':
   470|         0|            0|            0|  0.00%|            # After validators don't affect the discriminator values
   471|         0|            0|            0|  0.00%|            return self._infer_discriminator_values_for_inner_schema(schema['schema'], source)
   472|         0|            0|            0|  0.00%|
   473|         0|            0|            0|  0.00%|        elif schema['type'] in {'function-before', 'function-wrap', 'function-plain'}:
   474|         0|            0|            0|  0.00%|            validator_type = repr(schema['type'].split('-')[1])
   475|         0|            0|            0|  0.00%|            raise PydanticUserError(
   476|         0|            0|            0|  0.00%|                f'Cannot use a mode={validator_type} validator in the'
   477|         0|            0|            0|  0.00%|                f' discriminator field {self.discriminator!r} of {source}',
   478|         0|            0|            0|  0.00%|                code='discriminator-validator',
   479|         0|            0|            0|  0.00%|            )
   480|         0|            0|            0|  0.00%|
   481|         0|            0|            0|  0.00%|        else:
   482|         0|            0|            0|  0.00%|            raise PydanticUserError(
   483|         0|            0|            0|  0.00%|                f'{source} needs field {self.discriminator!r} to be of type `Literal`',
   484|         0|            0|            0|  0.00%|                code='discriminator-needs-literal',
   485|         0|            0|            0|  0.00%|            )
   486|         0|            0|            0|  0.00%|
   487|         0|            0|            0|  0.00%|    def _set_unique_choice_for_values(self, choice: core_schema.CoreSchema, values: Sequence[str | int]) -> None:
   488|         0|            0|            0|  0.00%|        """This method updates `self.tagged_union_choices` so that all provided (discriminator) `values` map to the
   489|         0|            0|            0|  0.00%|        provided `choice`, validating that none of these values already map to another (different) choice.
   490|         0|            0|            0|  0.00%|        """
   491|         0|            0|            0|  0.00%|        for discriminator_value in values:
   492|         0|            0|            0|  0.00%|            if discriminator_value in self._tagged_union_choices:
   493|         0|            0|            0|  0.00%|                # It is okay if `value` is already in tagged_union_choices as long as it maps to the same value.
   494|         0|            0|            0|  0.00%|                # Because tagged_union_choices may map values to other values, we need to walk the choices dict
   495|         0|            0|            0|  0.00%|                # until we get to a "real" choice, and confirm that is equal to the one assigned.
   496|         0|            0|            0|  0.00%|                existing_choice = self._tagged_union_choices[discriminator_value]
   497|         0|            0|            0|  0.00%|                if existing_choice != choice:
   498|         0|            0|            0|  0.00%|                    raise TypeError(
   499|         0|            0|            0|  0.00%|                        f'Value {discriminator_value!r} for discriminator '
   500|         0|            0|            0|  0.00%|                        f'{self.discriminator!r} mapped to multiple choices'
   501|         0|            0|            0|  0.00%|                    )
   502|         0|            0|            0|  0.00%|            else:
   503|         0|            0|            0|  0.00%|                self._tagged_union_choices[discriminator_value] = choice
File: <frozen os>
File duration: 0.000130653s (0.13%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|
    44|         0|            0|            0|  0.00%|
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|
    48|         0|            0|            0|  0.00%|
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|
    54|         0|            0|            0|  0.00%|
    55|         0|            0|            0|  0.00%|
    56|         0|            0|            0|  0.00%|
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|
    69|         0|            0|            0|  0.00%|
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|
    72|         0|            0|            0|  0.00%|
    73|         0|            0|            0|  0.00%|
    74|         0|            0|            0|  0.00%|
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|
    83|         0|            0|            0|  0.00%|
    84|         0|            0|            0|  0.00%|
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|
    87|         0|            0|            0|  0.00%|
    88|         0|            0|            0|  0.00%|
    89|         0|            0|            0|  0.00%|
    90|         0|            0|            0|  0.00%|
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|
   106|         0|            0|            0|  0.00%|
   107|         0|            0|            0|  0.00%|
   108|         0|            0|            0|  0.00%|
   109|         0|            0|            0|  0.00%|
   110|         0|            0|            0|  0.00%|
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|
   113|         0|            0|            0|  0.00%|
   114|         0|            0|            0|  0.00%|
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|
   117|         0|            0|            0|  0.00%|
   118|         0|            0|            0|  0.00%|
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|
   121|         0|            0|            0|  0.00%|
   122|         0|            0|            0|  0.00%|
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|
   125|         0|            0|            0|  0.00%|
   126|         0|            0|            0|  0.00%|
   127|         0|            0|            0|  0.00%|
   128|         0|            0|            0|  0.00%|
   129|         0|            0|            0|  0.00%|
   130|         0|            0|            0|  0.00%|
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|
   133|         0|            0|            0|  0.00%|
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|
   136|         0|            0|            0|  0.00%|
   137|         0|            0|            0|  0.00%|
   138|         0|            0|            0|  0.00%|
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|
   142|         0|            0|            0|  0.00%|
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|
   145|         0|            0|            0|  0.00%|
   146|         0|            0|            0|  0.00%|
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|
   149|         0|            0|            0|  0.00%|
   150|         0|            0|            0|  0.00%|
   151|         0|            0|            0|  0.00%|
   152|         0|            0|            0|  0.00%|
   153|         0|            0|            0|  0.00%|
   154|         0|            0|            0|  0.00%|
   155|         0|            0|            0|  0.00%|
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|
   158|         0|            0|            0|  0.00%|
   159|         0|            0|            0|  0.00%|
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|
   167|         0|            0|            0|  0.00%|
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|
   170|         0|            0|            0|  0.00%|
   171|         0|            0|            0|  0.00%|
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|
   175|         0|            0|            0|  0.00%|
   176|         0|            0|            0|  0.00%|
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|
   179|         0|            0|            0|  0.00%|
   180|         0|            0|            0|  0.00%|
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|
   184|         0|            0|            0|  0.00%|
   185|         0|            0|            0|  0.00%|
   186|         0|            0|            0|  0.00%|
   187|         0|            0|            0|  0.00%|
   188|         0|            0|            0|  0.00%|
   189|         0|            0|            0|  0.00%|
   190|         0|            0|            0|  0.00%|
   191|         0|            0|            0|  0.00%|
   192|         0|            0|            0|  0.00%|
   193|         0|            0|            0|  0.00%|
   194|         0|            0|            0|  0.00%|
   195|         0|            0|            0|  0.00%|
   196|         0|            0|            0|  0.00%|
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|
   199|         0|            0|            0|  0.00%|
   200|         0|            0|            0|  0.00%|
   201|         0|            0|            0|  0.00%|
   202|         0|            0|            0|  0.00%|
   203|         0|            0|            0|  0.00%|
   204|         0|            0|            0|  0.00%|
   205|         0|            0|            0|  0.00%|
   206|         0|            0|            0|  0.00%|
   207|         0|            0|            0|  0.00%|
   208|         0|            0|            0|  0.00%|
   209|         0|            0|            0|  0.00%|
   210|         0|            0|            0|  0.00%|
   211|         0|            0|            0|  0.00%|
   212|         0|            0|            0|  0.00%|
   213|         0|            0|            0|  0.00%|
   214|         0|            0|            0|  0.00%|
   215|         0|            0|            0|  0.00%|
   216|         0|            0|            0|  0.00%|
   217|         0|            0|            0|  0.00%|
   218|         0|            0|            0|  0.00%|
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|
   221|         0|            0|            0|  0.00%|
   222|         0|            0|            0|  0.00%|
   223|         0|            0|            0|  0.00%|
   224|         0|            0|            0|  0.00%|
   225|         0|            0|            0|  0.00%|
   226|         0|            0|            0|  0.00%|
   227|         0|            0|            0|  0.00%|
   228|         0|            0|            0|  0.00%|
   229|         0|            0|            0|  0.00%|
   230|         0|            0|            0|  0.00%|
   231|         0|            0|            0|  0.00%|
   232|         0|            0|            0|  0.00%|
   233|         0|            0|            0|  0.00%|
   234|         0|            0|            0|  0.00%|
   235|         0|            0|            0|  0.00%|
   236|         0|            0|            0|  0.00%|
   237|         0|            0|            0|  0.00%|
   238|         0|            0|            0|  0.00%|
   239|         0|            0|            0|  0.00%|
   240|         0|            0|            0|  0.00%|
   241|         0|            0|            0|  0.00%|
   242|         0|            0|            0|  0.00%|
   243|         0|            0|            0|  0.00%|
   244|         0|            0|            0|  0.00%|
   245|         0|            0|            0|  0.00%|
   246|         0|            0|            0|  0.00%|
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|
   249|         0|            0|            0|  0.00%|
   250|         0|            0|            0|  0.00%|
   251|         0|            0|            0|  0.00%|
   252|         0|            0|            0|  0.00%|
   253|         0|            0|            0|  0.00%|
   254|         0|            0|            0|  0.00%|
   255|         0|            0|            0|  0.00%|
   256|         0|            0|            0|  0.00%|
   257|         0|            0|            0|  0.00%|
   258|         0|            0|            0|  0.00%|
   259|         0|            0|            0|  0.00%|
   260|         0|            0|            0|  0.00%|
   261|         0|            0|            0|  0.00%|
   262|         0|            0|            0|  0.00%|
   263|         0|            0|            0|  0.00%|
   264|         0|            0|            0|  0.00%|
   265|         0|            0|            0|  0.00%|
   266|         0|            0|            0|  0.00%|
   267|         0|            0|            0|  0.00%|
   268|         0|            0|            0|  0.00%|
   269|         0|            0|            0|  0.00%|
   270|         0|            0|            0|  0.00%|
   271|         0|            0|            0|  0.00%|
   272|         0|            0|            0|  0.00%|
   273|         0|            0|            0|  0.00%|
   274|         0|            0|            0|  0.00%|
   275|         0|            0|            0|  0.00%|
   276|         0|            0|            0|  0.00%|
   277|         0|            0|            0|  0.00%|
   278|         0|            0|            0|  0.00%|
   279|         0|            0|            0|  0.00%|
   280|         0|            0|            0|  0.00%|
   281|         0|            0|            0|  0.00%|
   282|         0|            0|            0|  0.00%|
   283|         0|            0|            0|  0.00%|
   284|         0|            0|            0|  0.00%|
   285|         0|            0|            0|  0.00%|
   286|         0|            0|            0|  0.00%|
   287|         0|            0|            0|  0.00%|
   288|         0|            0|            0|  0.00%|
   289|         0|            0|            0|  0.00%|
   290|         0|            0|            0|  0.00%|
   291|         0|            0|            0|  0.00%|
   292|         0|            0|            0|  0.00%|
   293|         0|            0|            0|  0.00%|
   294|         0|            0|            0|  0.00%|
   295|         0|            0|            0|  0.00%|
   296|         0|            0|            0|  0.00%|
   297|         0|            0|            0|  0.00%|
   298|         0|            0|            0|  0.00%|
   299|         0|            0|            0|  0.00%|
   300|         0|            0|            0|  0.00%|
   301|         0|            0|            0|  0.00%|
   302|         0|            0|            0|  0.00%|
   303|         0|            0|            0|  0.00%|
   304|         0|            0|            0|  0.00%|
   305|         0|            0|            0|  0.00%|
   306|         0|            0|            0|  0.00%|
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|
   309|         0|            0|            0|  0.00%|
   310|         0|            0|            0|  0.00%|
   311|         0|            0|            0|  0.00%|
   312|         0|            0|            0|  0.00%|
   313|         0|            0|            0|  0.00%|
   314|         0|            0|            0|  0.00%|
   315|         0|            0|            0|  0.00%|
   316|         0|            0|            0|  0.00%|
   317|         0|            0|            0|  0.00%|
   318|         0|            0|            0|  0.00%|
   319|         0|            0|            0|  0.00%|
   320|         0|            0|            0|  0.00%|
   321|         0|            0|            0|  0.00%|
   322|         0|            0|            0|  0.00%|
   323|         0|            0|            0|  0.00%|
   324|         0|            0|            0|  0.00%|
   325|         0|            0|            0|  0.00%|
   326|         0|            0|            0|  0.00%|
   327|         0|            0|            0|  0.00%|
   328|         0|            0|            0|  0.00%|
   329|         0|            0|            0|  0.00%|
   330|         0|            0|            0|  0.00%|
   331|         0|            0|            0|  0.00%|
   332|         0|            0|            0|  0.00%|
   333|         0|            0|            0|  0.00%|
   334|         0|            0|            0|  0.00%|
   335|         0|            0|            0|  0.00%|
   336|         0|            0|            0|  0.00%|
   337|         0|            0|            0|  0.00%|
   338|         0|            0|            0|  0.00%|
   339|         0|            0|            0|  0.00%|
   340|         0|            0|            0|  0.00%|
   341|         0|            0|            0|  0.00%|
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|
   344|         0|            0|            0|  0.00%|
   345|         0|            0|            0|  0.00%|
   346|         0|            0|            0|  0.00%|
   347|         0|            0|            0|  0.00%|
   348|         0|            0|            0|  0.00%|
   349|         0|            0|            0|  0.00%|
   350|         0|            0|            0|  0.00%|
   351|         0|            0|            0|  0.00%|
   352|         0|            0|            0|  0.00%|
   353|         0|            0|            0|  0.00%|
   354|         0|            0|            0|  0.00%|
   355|         0|            0|            0|  0.00%|
   356|         0|            0|            0|  0.00%|
   357|         0|            0|            0|  0.00%|
   358|         0|            0|            0|  0.00%|
   359|         0|            0|            0|  0.00%|
   360|         0|            0|            0|  0.00%|
   361|         0|            0|            0|  0.00%|
   362|         0|            0|            0|  0.00%|
   363|         0|            0|            0|  0.00%|
   364|         0|            0|            0|  0.00%|
   365|         0|            0|            0|  0.00%|
   366|         0|            0|            0|  0.00%|
   367|         0|            0|            0|  0.00%|
   368|         0|            0|            0|  0.00%|
   369|         0|            0|            0|  0.00%|
   370|         0|            0|            0|  0.00%|
   371|         0|            0|            0|  0.00%|
   372|         0|            0|            0|  0.00%|
   373|         0|            0|            0|  0.00%|
   374|         0|            0|            0|  0.00%|
   375|         0|            0|            0|  0.00%|
   376|         0|            0|            0|  0.00%|
   377|         0|            0|            0|  0.00%|
   378|         0|            0|            0|  0.00%|
   379|         0|            0|            0|  0.00%|
   380|         0|            0|            0|  0.00%|
   381|         0|            0|            0|  0.00%|
   382|         0|            0|            0|  0.00%|
   383|         0|            0|            0|  0.00%|
   384|         0|            0|            0|  0.00%|
   385|         0|            0|            0|  0.00%|
   386|         0|            0|            0|  0.00%|
   387|         0|            0|            0|  0.00%|
   388|         0|            0|            0|  0.00%|
   389|         0|            0|            0|  0.00%|
   390|         0|            0|            0|  0.00%|
   391|         0|            0|            0|  0.00%|
   392|         0|            0|            0|  0.00%|
   393|         0|            0|            0|  0.00%|
   394|         0|            0|            0|  0.00%|
   395|         0|            0|            0|  0.00%|
   396|         0|            0|            0|  0.00%|
   397|         0|            0|            0|  0.00%|
   398|         0|            0|            0|  0.00%|
   399|         0|            0|            0|  0.00%|
   400|         0|            0|            0|  0.00%|
   401|         0|            0|            0|  0.00%|
   402|         0|            0|            0|  0.00%|
   403|         0|            0|            0|  0.00%|
   404|         0|            0|            0|  0.00%|
   405|         0|            0|            0|  0.00%|
   406|         0|            0|            0|  0.00%|
   407|         0|            0|            0|  0.00%|
   408|         0|            0|            0|  0.00%|
   409|         0|            0|            0|  0.00%|
   410|         0|            0|            0|  0.00%|
   411|         0|            0|            0|  0.00%|
   412|         0|            0|            0|  0.00%|
   413|         0|            0|            0|  0.00%|
   414|         0|            0|            0|  0.00%|
   415|         0|            0|            0|  0.00%|
   416|         0|            0|            0|  0.00%|
   417|         0|            0|            0|  0.00%|
   418|         0|            0|            0|  0.00%|
   419|         0|            0|            0|  0.00%|
   420|         0|            0|            0|  0.00%|
   421|         0|            0|            0|  0.00%|
   422|         0|            0|            0|  0.00%|
   423|         0|            0|            0|  0.00%|
   424|         0|            0|            0|  0.00%|
   425|         0|            0|            0|  0.00%|
   426|         0|            0|            0|  0.00%|
   427|         0|            0|            0|  0.00%|
   428|         0|            0|            0|  0.00%|
   429|         0|            0|            0|  0.00%|
   430|         0|            0|            0|  0.00%|
   431|         0|            0|            0|  0.00%|
   432|         0|            0|            0|  0.00%|
   433|         0|            0|            0|  0.00%|
   434|         0|            0|            0|  0.00%|
   435|         0|            0|            0|  0.00%|
   436|         0|            0|            0|  0.00%|
   437|         0|            0|            0|  0.00%|
   438|         0|            0|            0|  0.00%|
   439|         0|            0|            0|  0.00%|
   440|         0|            0|            0|  0.00%|
   441|         0|            0|            0|  0.00%|
   442|         0|            0|            0|  0.00%|
   443|         0|            0|            0|  0.00%|
   444|         0|            0|            0|  0.00%|
   445|         0|            0|            0|  0.00%|
   446|         0|            0|            0|  0.00%|
   447|         0|            0|            0|  0.00%|
   448|         0|            0|            0|  0.00%|
   449|         0|            0|            0|  0.00%|
   450|         0|            0|            0|  0.00%|
   451|         0|            0|            0|  0.00%|
   452|         0|            0|            0|  0.00%|
   453|         0|            0|            0|  0.00%|
   454|         0|            0|            0|  0.00%|
   455|         0|            0|            0|  0.00%|
   456|         0|            0|            0|  0.00%|
   457|         0|            0|            0|  0.00%|
   458|         0|            0|            0|  0.00%|
   459|         0|            0|            0|  0.00%|
   460|         0|            0|            0|  0.00%|
   461|         0|            0|            0|  0.00%|
   462|         0|            0|            0|  0.00%|
   463|         0|            0|            0|  0.00%|
   464|         0|            0|            0|  0.00%|
   465|         0|            0|            0|  0.00%|
   466|         0|            0|            0|  0.00%|
   467|         0|            0|            0|  0.00%|
   468|         0|            0|            0|  0.00%|
   469|         0|            0|            0|  0.00%|
   470|         0|            0|            0|  0.00%|
   471|         0|            0|            0|  0.00%|
   472|         0|            0|            0|  0.00%|
   473|         0|            0|            0|  0.00%|
   474|         0|            0|            0|  0.00%|
   475|         0|            0|            0|  0.00%|
   476|         0|            0|            0|  0.00%|
   477|         0|            0|            0|  0.00%|
   478|         0|            0|            0|  0.00%|
   479|         0|            0|            0|  0.00%|
   480|         0|            0|            0|  0.00%|
   481|         0|            0|            0|  0.00%|
   482|         0|            0|            0|  0.00%|
   483|         0|            0|            0|  0.00%|
   484|         0|            0|            0|  0.00%|
   485|         0|            0|            0|  0.00%|
   486|         0|            0|            0|  0.00%|
   487|         0|            0|            0|  0.00%|
   488|         0|            0|            0|  0.00%|
   489|         0|            0|            0|  0.00%|
   490|         0|            0|            0|  0.00%|
   491|         0|            0|            0|  0.00%|
   492|         0|            0|            0|  0.00%|
   493|         0|            0|            0|  0.00%|
   494|         0|            0|            0|  0.00%|
   495|         0|            0|            0|  0.00%|
   496|         0|            0|            0|  0.00%|
   497|         0|            0|            0|  0.00%|
   498|         0|            0|            0|  0.00%|
   499|         0|            0|            0|  0.00%|
   500|         0|            0|            0|  0.00%|
   501|         0|            0|            0|  0.00%|
   502|         0|            0|            0|  0.00%|
   503|         0|            0|            0|  0.00%|
   504|         0|            0|            0|  0.00%|
   505|         0|            0|            0|  0.00%|
   506|         0|            0|            0|  0.00%|
   507|         0|            0|            0|  0.00%|
   508|         0|            0|            0|  0.00%|
   509|         0|            0|            0|  0.00%|
   510|         0|            0|            0|  0.00%|
   511|         0|            0|            0|  0.00%|
   512|         0|            0|            0|  0.00%|
   513|         0|            0|            0|  0.00%|
   514|         0|            0|            0|  0.00%|
   515|         0|            0|            0|  0.00%|
   516|         0|            0|            0|  0.00%|
   517|         0|            0|            0|  0.00%|
   518|         0|            0|            0|  0.00%|
   519|         0|            0|            0|  0.00%|
   520|         0|            0|            0|  0.00%|
   521|         0|            0|            0|  0.00%|
   522|         0|            0|            0|  0.00%|
   523|         0|            0|            0|  0.00%|
   524|         0|            0|            0|  0.00%|
   525|         0|            0|            0|  0.00%|
   526|         0|            0|            0|  0.00%|
   527|         0|            0|            0|  0.00%|
   528|         0|            0|            0|  0.00%|
   529|         0|            0|            0|  0.00%|
   530|         0|            0|            0|  0.00%|
   531|         0|            0|            0|  0.00%|
   532|         0|            0|            0|  0.00%|
   533|         0|            0|            0|  0.00%|
   534|         0|            0|            0|  0.00%|
   535|         0|            0|            0|  0.00%|
   536|         0|            0|            0|  0.00%|
   537|         0|            0|            0|  0.00%|
   538|         0|            0|            0|  0.00%|
   539|         0|            0|            0|  0.00%|
   540|         0|            0|            0|  0.00%|
   541|         0|            0|            0|  0.00%|
   542|         0|            0|            0|  0.00%|
   543|         0|            0|            0|  0.00%|
   544|         0|            0|            0|  0.00%|
   545|         0|            0|            0|  0.00%|
   546|         0|            0|            0|  0.00%|
   547|         0|            0|            0|  0.00%|
   548|         0|            0|            0|  0.00%|
   549|         0|            0|            0|  0.00%|
   550|         0|            0|            0|  0.00%|
   551|         0|            0|            0|  0.00%|
   552|         0|            0|            0|  0.00%|
   553|         0|            0|            0|  0.00%|
   554|         0|            0|            0|  0.00%|
   555|         0|            0|            0|  0.00%|
   556|         0|            0|            0|  0.00%|
   557|         0|            0|            0|  0.00%|
   558|         0|            0|            0|  0.00%|
   559|         0|            0|            0|  0.00%|
   560|         0|            0|            0|  0.00%|
   561|         0|            0|            0|  0.00%|
   562|         0|            0|            0|  0.00%|
   563|         0|            0|            0|  0.00%|
   564|         0|            0|            0|  0.00%|
   565|         0|            0|            0|  0.00%|
   566|         0|            0|            0|  0.00%|
   567|         0|            0|            0|  0.00%|
   568|         0|            0|            0|  0.00%|
   569|         0|            0|            0|  0.00%|
   570|         0|            0|            0|  0.00%|
   571|         0|            0|            0|  0.00%|
   572|         0|            0|            0|  0.00%|
   573|         0|            0|            0|  0.00%|
   574|         0|            0|            0|  0.00%|
   575|         0|            0|            0|  0.00%|
   576|         0|            0|            0|  0.00%|
   577|         0|            0|            0|  0.00%|
   578|         0|            0|            0|  0.00%|
   579|         0|            0|            0|  0.00%|
   580|         0|            0|            0|  0.00%|
   581|         0|            0|            0|  0.00%|
   582|         0|            0|            0|  0.00%|
   583|         0|            0|            0|  0.00%|
   584|         0|            0|            0|  0.00%|
   585|         0|            0|            0|  0.00%|
   586|         0|            0|            0|  0.00%|
   587|         0|            0|            0|  0.00%|
   588|         0|            0|            0|  0.00%|
   589|         0|            0|            0|  0.00%|
   590|         0|            0|            0|  0.00%|
   591|         0|            0|            0|  0.00%|
   592|         0|            0|            0|  0.00%|
   593|         0|            0|            0|  0.00%|
   594|         0|            0|            0|  0.00%|
   595|         0|            0|            0|  0.00%|
   596|         0|            0|            0|  0.00%|
   597|         0|            0|            0|  0.00%|
   598|         0|            0|            0|  0.00%|
   599|         0|            0|            0|  0.00%|
   600|         0|            0|            0|  0.00%|
   601|         0|            0|            0|  0.00%|
   602|         0|            0|            0|  0.00%|
   603|         0|            0|            0|  0.00%|
   604|         0|            0|            0|  0.00%|
   605|         0|            0|            0|  0.00%|
   606|         0|            0|            0|  0.00%|
   607|         0|            0|            0|  0.00%|
   608|         0|            0|            0|  0.00%|
   609|         0|            0|            0|  0.00%|
   610|         0|            0|            0|  0.00%|
   611|         0|            0|            0|  0.00%|
   612|         0|            0|            0|  0.00%|
   613|         0|            0|            0|  0.00%|
   614|         0|            0|            0|  0.00%|
   615|         0|            0|            0|  0.00%|
   616|         0|            0|            0|  0.00%|
   617|         0|            0|            0|  0.00%|
   618|         0|            0|            0|  0.00%|
   619|         0|            0|            0|  0.00%|
   620|         0|            0|            0|  0.00%|
   621|         0|            0|            0|  0.00%|
   622|         0|            0|            0|  0.00%|
   623|         0|            0|            0|  0.00%|
   624|         0|            0|            0|  0.00%|
   625|         0|            0|            0|  0.00%|
   626|         0|            0|            0|  0.00%|
   627|         0|            0|            0|  0.00%|
   628|         0|            0|            0|  0.00%|
   629|         0|            0|            0|  0.00%|
   630|         0|            0|            0|  0.00%|
   631|         0|            0|            0|  0.00%|
   632|         0|            0|            0|  0.00%|
   633|         0|            0|            0|  0.00%|
   634|         0|            0|            0|  0.00%|
   635|         0|            0|            0|  0.00%|
   636|         0|            0|            0|  0.00%|
   637|         0|            0|            0|  0.00%|
   638|         0|            0|            0|  0.00%|
   639|         0|            0|            0|  0.00%|
   640|         0|            0|            0|  0.00%|
   641|         0|            0|            0|  0.00%|
   642|         0|            0|            0|  0.00%|
   643|         0|            0|            0|  0.00%|
   644|         0|            0|            0|  0.00%|
   645|         0|            0|            0|  0.00%|
   646|         0|            0|            0|  0.00%|
   647|         0|            0|            0|  0.00%|
   648|         0|            0|            0|  0.00%|
   649|         0|            0|            0|  0.00%|
   650|         0|            0|            0|  0.00%|
   651|         0|            0|            0|  0.00%|
   652|         0|            0|            0|  0.00%|
   653|         0|            0|            0|  0.00%|
   654|         0|            0|            0|  0.00%|
   655|         0|            0|            0|  0.00%|
   656|         0|            0|            0|  0.00%|
   657|         0|            0|            0|  0.00%|
   658|         0|            0|            0|  0.00%|
   659|         0|            0|            0|  0.00%|
   660|         0|            0|            0|  0.00%|
   661|         0|            0|            0|  0.00%|
   662|         0|            0|            0|  0.00%|
   663|         0|            0|            0|  0.00%|
   664|         0|            0|            0|  0.00%|
   665|         0|            0|            0|  0.00%|
   666|         0|            0|            0|  0.00%|
   667|         0|            0|            0|  0.00%|
   668|         0|            0|            0|  0.00%|
   669|         0|            0|            0|  0.00%|
   670|         0|            0|            0|  0.00%|
   671|         0|            0|            0|  0.00%|
   672|         0|            0|            0|  0.00%|
   673|         0|            0|            0|  0.00%|
   674|         0|            0|            0|  0.00%|
   675|         0|            0|            0|  0.00%|
   676|         0|            0|            0|  0.00%|
   677|         0|            0|            0|  0.00%|
   678|         0|            0|            0|  0.00%|
   679|         0|            0|            0|  0.00%|
   680|         4|  1.04904e-05|   2.6226e-06|  0.01%|
   681|         4|  1.07288e-05|  2.68221e-06|  0.01%|
   682|         4|  3.24249e-05|  8.10623e-06|  0.03%|
(call)|         4|  2.83718e-05|  7.09295e-06|  0.03%|# <frozen os>:762 encode
   683|         4|  1.07288e-05|  2.68221e-06|  0.01%|
   684|         0|            0|            0|  0.00%|
   685|         4|  1.97887e-05|  4.94719e-06|  0.02%|
   686|         0|            0|            0|  0.00%|
   687|         0|            0|            0|  0.00%|
   688|         0|            0|            0|  0.00%|
   689|         0|            0|            0|  0.00%|
   690|         0|            0|            0|  0.00%|
   691|         0|            0|            0|  0.00%|
   692|         0|            0|            0|  0.00%|
   693|         0|            0|            0|  0.00%|
   694|         0|            0|            0|  0.00%|
   695|         0|            0|            0|  0.00%|
   696|         0|            0|            0|  0.00%|
   697|         0|            0|            0|  0.00%|
   698|         0|            0|            0|  0.00%|
   699|         0|            0|            0|  0.00%|
   700|         0|            0|            0|  0.00%|
   701|         0|            0|            0|  0.00%|
   702|         0|            0|            0|  0.00%|
   703|         0|            0|            0|  0.00%|
   704|         0|            0|            0|  0.00%|
   705|         0|            0|            0|  0.00%|
   706|         0|            0|            0|  0.00%|
   707|         0|            0|            0|  0.00%|
   708|         0|            0|            0|  0.00%|
   709|         0|            0|            0|  0.00%|
   710|         0|            0|            0|  0.00%|
   711|         0|            0|            0|  0.00%|
   712|         0|            0|            0|  0.00%|
   713|         0|            0|            0|  0.00%|
   714|         0|            0|            0|  0.00%|
   715|         0|            0|            0|  0.00%|
   716|         0|            0|            0|  0.00%|
   717|         0|            0|            0|  0.00%|
   718|         0|            0|            0|  0.00%|
   719|         0|            0|            0|  0.00%|
   720|         0|            0|            0|  0.00%|
   721|         0|            0|            0|  0.00%|
   722|         0|            0|            0|  0.00%|
   723|         0|            0|            0|  0.00%|
   724|         0|            0|            0|  0.00%|
   725|         0|            0|            0|  0.00%|
   726|         0|            0|            0|  0.00%|
   727|         0|            0|            0|  0.00%|
   728|         0|            0|            0|  0.00%|
   729|         0|            0|            0|  0.00%|
   730|         0|            0|            0|  0.00%|
   731|         0|            0|            0|  0.00%|
   732|         0|            0|            0|  0.00%|
   733|         0|            0|            0|  0.00%|
   734|         0|            0|            0|  0.00%|
   735|         0|            0|            0|  0.00%|
   736|         0|            0|            0|  0.00%|
   737|         0|            0|            0|  0.00%|
   738|         0|            0|            0|  0.00%|
   739|         0|            0|            0|  0.00%|
   740|         0|            0|            0|  0.00%|
   741|         0|            0|            0|  0.00%|
   742|         0|            0|            0|  0.00%|
   743|         0|            0|            0|  0.00%|
   744|         0|            0|            0|  0.00%|
   745|         0|            0|            0|  0.00%|
   746|         0|            0|            0|  0.00%|
   747|         0|            0|            0|  0.00%|
   748|         0|            0|            0|  0.00%|
   749|         0|            0|            0|  0.00%|
   750|         0|            0|            0|  0.00%|
   751|         0|            0|            0|  0.00%|
   752|         0|            0|            0|  0.00%|
   753|         0|            0|            0|  0.00%|
   754|         0|            0|            0|  0.00%|
   755|         0|            0|            0|  0.00%|
   756|         0|            0|            0|  0.00%|
   757|         0|            0|            0|  0.00%|
   758|         0|            0|            0|  0.00%|
   759|         0|            0|            0|  0.00%|
   760|         0|            0|            0|  0.00%|
   761|         0|            0|            0|  0.00%|
   762|         4|  7.62939e-06|  1.90735e-06|  0.01%|
   763|         4|  1.16825e-05|  2.92063e-06|  0.01%|
   764|         0|            0|            0|  0.00%|
   765|         4|  9.05991e-06|  2.26498e-06|  0.01%|
   766|         0|            0|            0|  0.00%|
   767|         0|            0|            0|  0.00%|
   768|         0|            0|            0|  0.00%|
   769|         0|            0|            0|  0.00%|
   770|         0|            0|            0|  0.00%|
   771|         0|            0|            0|  0.00%|
   772|         0|            0|            0|  0.00%|
   773|         0|            0|            0|  0.00%|
   774|         0|            0|            0|  0.00%|
   775|         0|            0|            0|  0.00%|
   776|         0|            0|            0|  0.00%|
   777|         0|            0|            0|  0.00%|
   778|         0|            0|            0|  0.00%|
   779|         2|  5.48363e-06|  2.74181e-06|  0.01%|
   780|         0|            0|            0|  0.00%|
   781|         0|            0|            0|  0.00%|
   782|         0|            0|            0|  0.00%|
   783|         2|  1.26362e-05|  6.31809e-06|  0.01%|
(call)|         2|  6.50883e-05|  3.25441e-05|  0.07%|# <frozen _collections_abc>:804 get
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/utils.py
File duration: 0.000129461s (0.13%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|import re
     2|         0|            0|            0|  0.00%|import warnings
     3|         0|            0|            0|  0.00%|from dataclasses import is_dataclass
     4|         0|            0|            0|  0.00%|from typing import (
     5|         0|            0|            0|  0.00%|    TYPE_CHECKING,
     6|         0|            0|            0|  0.00%|    Any,
     7|         0|            0|            0|  0.00%|    Dict,
     8|         0|            0|            0|  0.00%|    MutableMapping,
     9|         0|            0|            0|  0.00%|    Optional,
    10|         0|            0|            0|  0.00%|    Set,
    11|         0|            0|            0|  0.00%|    Type,
    12|         0|            0|            0|  0.00%|    Union,
    13|         0|            0|            0|  0.00%|    cast,
    14|         0|            0|            0|  0.00%|)
    15|         0|            0|            0|  0.00%|from weakref import WeakKeyDictionary
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|import fastapi
    18|         0|            0|            0|  0.00%|from fastapi._compat import (
    19|         0|            0|            0|  0.00%|    PYDANTIC_V2,
    20|         0|            0|            0|  0.00%|    BaseConfig,
    21|         0|            0|            0|  0.00%|    ModelField,
    22|         0|            0|            0|  0.00%|    PydanticSchemaGenerationError,
    23|         0|            0|            0|  0.00%|    Undefined,
    24|         0|            0|            0|  0.00%|    UndefinedType,
    25|         0|            0|            0|  0.00%|    Validator,
    26|         0|            0|            0|  0.00%|    lenient_issubclass,
    27|         0|            0|            0|  0.00%|)
    28|         0|            0|            0|  0.00%|from fastapi.datastructures import DefaultPlaceholder, DefaultType
    29|         0|            0|            0|  0.00%|from pydantic import BaseModel, create_model
    30|         0|            0|            0|  0.00%|from pydantic.fields import FieldInfo
    31|         0|            0|            0|  0.00%|from typing_extensions import Literal
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|if TYPE_CHECKING:  # pragma: nocover
    34|         0|            0|            0|  0.00%|    from .routing import APIRoute
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|# Cache for `create_cloned_field`
    37|         0|            0|            0|  0.00%|_CLONED_TYPES_CACHE: MutableMapping[Type[BaseModel], Type[BaseModel]] = (
    38|         0|            0|            0|  0.00%|    WeakKeyDictionary()
    39|         0|            0|            0|  0.00%|)
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|def is_body_allowed_for_status_code(status_code: Union[int, str, None]) -> bool:
    43|         0|            0|            0|  0.00%|    if status_code is None:
    44|         0|            0|            0|  0.00%|        return True
    45|         0|            0|            0|  0.00%|    # Ref: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#patterned-fields-1
    46|         0|            0|            0|  0.00%|    if status_code in {
    47|         0|            0|            0|  0.00%|        "default",
    48|         0|            0|            0|  0.00%|        "1XX",
    49|         0|            0|            0|  0.00%|        "2XX",
    50|         0|            0|            0|  0.00%|        "3XX",
    51|         0|            0|            0|  0.00%|        "4XX",
    52|         0|            0|            0|  0.00%|        "5XX",
    53|         0|            0|            0|  0.00%|    }:
    54|         0|            0|            0|  0.00%|        return True
    55|         0|            0|            0|  0.00%|    current_status_code = int(status_code)
    56|         0|            0|            0|  0.00%|    return not (current_status_code < 200 or current_status_code in {204, 205, 304})
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|
    59|         1|  5.72205e-06|  5.72205e-06|  0.01%|def get_path_param_names(path: str) -> Set[str]:
    60|         1|  1.43051e-05|  1.43051e-05|  0.01%|    return set(re.findall("{(.*?)}", path))
(call)|         1|   2.7895e-05|   2.7895e-05|  0.03%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/re/__init__.py:209 findall
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|
    63|         2|  1.38283e-05|  6.91414e-06|  0.01%|def create_response_field(
    64|         0|            0|            0|  0.00%|    name: str,
    65|         0|            0|            0|  0.00%|    type_: Type[Any],
    66|         0|            0|            0|  0.00%|    class_validators: Optional[Dict[str, Validator]] = None,
    67|         0|            0|            0|  0.00%|    default: Optional[Any] = Undefined,
    68|         0|            0|            0|  0.00%|    required: Union[bool, UndefinedType] = Undefined,
    69|         0|            0|            0|  0.00%|    model_config: Type[BaseConfig] = BaseConfig,
    70|         0|            0|            0|  0.00%|    field_info: Optional[FieldInfo] = None,
    71|         0|            0|            0|  0.00%|    alias: Optional[str] = None,
    72|         0|            0|            0|  0.00%|    mode: Literal["validation", "serialization"] = "validation",
    73|         0|            0|            0|  0.00%|) -> ModelField:
    74|         0|            0|            0|  0.00%|    """
    75|         0|            0|            0|  0.00%|    Create a new response field. Raises if type_ is invalid.
    76|         0|            0|            0|  0.00%|    """
    77|         2|  2.40803e-05|  1.20401e-05|  0.02%|    class_validators = class_validators or {}
    78|         2|  4.52995e-06|  2.26498e-06|  0.00%|    if PYDANTIC_V2:
    79|         2|  4.52995e-06|  2.26498e-06|  0.00%|        field_info = field_info or FieldInfo(
    80|         0|            0|            0|  0.00%|            annotation=type_, default=default, alias=alias
    81|         0|            0|            0|  0.00%|        )
    82|         0|            0|            0|  0.00%|    else:
    83|         0|            0|            0|  0.00%|        field_info = field_info or FieldInfo()
    84|         2|  5.24521e-06|   2.6226e-06|  0.01%|    kwargs = {"name": name, "field_info": field_info}
    85|         2|  5.48363e-06|  2.74181e-06|  0.01%|    if PYDANTIC_V2:
    86|         2|  5.48363e-06|  2.74181e-06|  0.01%|        kwargs.update({"mode": mode})
    87|         0|            0|            0|  0.00%|    else:
    88|         0|            0|            0|  0.00%|        kwargs.update(
    89|         0|            0|            0|  0.00%|            {
    90|         0|            0|            0|  0.00%|                "type_": type_,
    91|         0|            0|            0|  0.00%|                "class_validators": class_validators,
    92|         0|            0|            0|  0.00%|                "default": default,
    93|         0|            0|            0|  0.00%|                "required": required,
    94|         0|            0|            0|  0.00%|                "model_config": model_config,
    95|         0|            0|            0|  0.00%|                "alias": alias,
    96|         0|            0|            0|  0.00%|            }
    97|         0|            0|            0|  0.00%|        )
    98|         2|   3.8147e-06|  1.90735e-06|  0.00%|    try:
    99|         2|  4.24385e-05|  2.12193e-05|  0.04%|        return ModelField(**kwargs)  # type: ignore[arg-type]
(call)|         2|    0.0130911|   0.00654554| 13.46%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/_compat.py:2 __init__
   100|         0|            0|            0|  0.00%|    except (RuntimeError, PydanticSchemaGenerationError):
   101|         0|            0|            0|  0.00%|        raise fastapi.exceptions.FastAPIError(
   102|         0|            0|            0|  0.00%|            "Invalid args for response field! Hint: "
   103|         0|            0|            0|  0.00%|            f"check that {type_} is a valid Pydantic field type. "
   104|         0|            0|            0|  0.00%|            "If you are using a return type annotation that is not a valid Pydantic "
   105|         0|            0|            0|  0.00%|            "field (e.g. Union[Response, dict, None]) you can disable generating the "
   106|         0|            0|            0|  0.00%|            "response model from the type annotation with the path operation decorator "
   107|         0|            0|            0|  0.00%|            "parameter response_model=None. Read more: "
   108|         0|            0|            0|  0.00%|            "https://fastapi.tiangolo.com/tutorial/response-model/"
   109|         0|            0|            0|  0.00%|        ) from None
   110|         0|            0|            0|  0.00%|
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|def create_cloned_field(
   113|         0|            0|            0|  0.00%|    field: ModelField,
   114|         0|            0|            0|  0.00%|    *,
   115|         0|            0|            0|  0.00%|    cloned_types: Optional[MutableMapping[Type[BaseModel], Type[BaseModel]]] = None,
   116|         0|            0|            0|  0.00%|) -> ModelField:
   117|         0|            0|            0|  0.00%|    if PYDANTIC_V2:
   118|         0|            0|            0|  0.00%|        return field
   119|         0|            0|            0|  0.00%|    # cloned_types caches already cloned types to support recursive models and improve
   120|         0|            0|            0|  0.00%|    # performance by avoiding unnecessary cloning
   121|         0|            0|            0|  0.00%|    if cloned_types is None:
   122|         0|            0|            0|  0.00%|        cloned_types = _CLONED_TYPES_CACHE
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|    original_type = field.type_
   125|         0|            0|            0|  0.00%|    if is_dataclass(original_type) and hasattr(original_type, "__pydantic_model__"):
   126|         0|            0|            0|  0.00%|        original_type = original_type.__pydantic_model__
   127|         0|            0|            0|  0.00%|    use_type = original_type
   128|         0|            0|            0|  0.00%|    if lenient_issubclass(original_type, BaseModel):
   129|         0|            0|            0|  0.00%|        original_type = cast(Type[BaseModel], original_type)
   130|         0|            0|            0|  0.00%|        use_type = cloned_types.get(original_type)
   131|         0|            0|            0|  0.00%|        if use_type is None:
   132|         0|            0|            0|  0.00%|            use_type = create_model(original_type.__name__, __base__=original_type)
   133|         0|            0|            0|  0.00%|            cloned_types[original_type] = use_type
   134|         0|            0|            0|  0.00%|            for f in original_type.__fields__.values():
   135|         0|            0|            0|  0.00%|                use_type.__fields__[f.name] = create_cloned_field(
   136|         0|            0|            0|  0.00%|                    f, cloned_types=cloned_types
   137|         0|            0|            0|  0.00%|                )
   138|         0|            0|            0|  0.00%|    new_field = create_response_field(name=field.name, type_=use_type)
   139|         0|            0|            0|  0.00%|    new_field.has_alias = field.has_alias  # type: ignore[attr-defined]
   140|         0|            0|            0|  0.00%|    new_field.alias = field.alias  # type: ignore[misc]
   141|         0|            0|            0|  0.00%|    new_field.class_validators = field.class_validators  # type: ignore[attr-defined]
   142|         0|            0|            0|  0.00%|    new_field.default = field.default  # type: ignore[misc]
   143|         0|            0|            0|  0.00%|    new_field.required = field.required  # type: ignore[misc]
   144|         0|            0|            0|  0.00%|    new_field.model_config = field.model_config  # type: ignore[attr-defined]
   145|         0|            0|            0|  0.00%|    new_field.field_info = field.field_info
   146|         0|            0|            0|  0.00%|    new_field.allow_none = field.allow_none  # type: ignore[attr-defined]
   147|         0|            0|            0|  0.00%|    new_field.validate_always = field.validate_always  # type: ignore[attr-defined]
   148|         0|            0|            0|  0.00%|    if field.sub_fields:  # type: ignore[attr-defined]
   149|         0|            0|            0|  0.00%|        new_field.sub_fields = [  # type: ignore[attr-defined]
   150|         0|            0|            0|  0.00%|            create_cloned_field(sub_field, cloned_types=cloned_types)
   151|         0|            0|            0|  0.00%|            for sub_field in field.sub_fields  # type: ignore[attr-defined]
   152|         0|            0|            0|  0.00%|        ]
   153|         0|            0|            0|  0.00%|    if field.key_field:  # type: ignore[attr-defined]
   154|         0|            0|            0|  0.00%|        new_field.key_field = create_cloned_field(  # type: ignore[attr-defined]
   155|         0|            0|            0|  0.00%|            field.key_field,  # type: ignore[attr-defined]
   156|         0|            0|            0|  0.00%|            cloned_types=cloned_types,
   157|         0|            0|            0|  0.00%|        )
   158|         0|            0|            0|  0.00%|    new_field.validators = field.validators  # type: ignore[attr-defined]
   159|         0|            0|            0|  0.00%|    new_field.pre_validators = field.pre_validators  # type: ignore[attr-defined]
   160|         0|            0|            0|  0.00%|    new_field.post_validators = field.post_validators  # type: ignore[attr-defined]
   161|         0|            0|            0|  0.00%|    new_field.parse_json = field.parse_json  # type: ignore[attr-defined]
   162|         0|            0|            0|  0.00%|    new_field.shape = field.shape  # type: ignore[attr-defined]
   163|         0|            0|            0|  0.00%|    new_field.populate_validators()  # type: ignore[attr-defined]
   164|         0|            0|            0|  0.00%|    return new_field
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|
   167|         0|            0|            0|  0.00%|def generate_operation_id_for_path(
   168|         0|            0|            0|  0.00%|    *, name: str, path: str, method: str
   169|         0|            0|            0|  0.00%|) -> str:  # pragma: nocover
   170|         0|            0|            0|  0.00%|    warnings.warn(
   171|         0|            0|            0|  0.00%|        "fastapi.utils.generate_operation_id_for_path() was deprecated, "
   172|         0|            0|            0|  0.00%|        "it is not used internally, and will be removed soon",
   173|         0|            0|            0|  0.00%|        DeprecationWarning,
   174|         0|            0|            0|  0.00%|        stacklevel=2,
   175|         0|            0|            0|  0.00%|    )
   176|         0|            0|            0|  0.00%|    operation_id = f"{name}{path}"
   177|         0|            0|            0|  0.00%|    operation_id = re.sub(r"\W", "_", operation_id)
   178|         0|            0|            0|  0.00%|    operation_id = f"{operation_id}_{method.lower()}"
   179|         0|            0|            0|  0.00%|    return operation_id
   180|         0|            0|            0|  0.00%|
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|def generate_unique_id(route: "APIRoute") -> str:
   183|         0|            0|            0|  0.00%|    operation_id = f"{route.name}{route.path_format}"
   184|         0|            0|            0|  0.00%|    operation_id = re.sub(r"\W", "_", operation_id)
   185|         0|            0|            0|  0.00%|    assert route.methods
   186|         0|            0|            0|  0.00%|    operation_id = f"{operation_id}_{list(route.methods)[0].lower()}"
   187|         0|            0|            0|  0.00%|    return operation_id
   188|         0|            0|            0|  0.00%|
   189|         0|            0|            0|  0.00%|
   190|         0|            0|            0|  0.00%|def deep_dict_update(main_dict: Dict[Any, Any], update_dict: Dict[Any, Any]) -> None:
   191|         0|            0|            0|  0.00%|    for key, value in update_dict.items():
   192|         0|            0|            0|  0.00%|        if (
   193|         0|            0|            0|  0.00%|            key in main_dict
   194|         0|            0|            0|  0.00%|            and isinstance(main_dict[key], dict)
   195|         0|            0|            0|  0.00%|            and isinstance(value, dict)
   196|         0|            0|            0|  0.00%|        ):
   197|         0|            0|            0|  0.00%|            deep_dict_update(main_dict[key], value)
   198|         0|            0|            0|  0.00%|        elif (
   199|         0|            0|            0|  0.00%|            key in main_dict
   200|         0|            0|            0|  0.00%|            and isinstance(main_dict[key], list)
   201|         0|            0|            0|  0.00%|            and isinstance(update_dict[key], list)
   202|         0|            0|            0|  0.00%|        ):
   203|         0|            0|            0|  0.00%|            main_dict[key] = main_dict[key] + update_dict[key]
   204|         0|            0|            0|  0.00%|        else:
   205|         0|            0|            0|  0.00%|            main_dict[key] = value
   206|         0|            0|            0|  0.00%|
   207|         0|            0|            0|  0.00%|
   208|         0|            0|            0|  0.00%|def get_value_or_default(
   209|         0|            0|            0|  0.00%|    first_item: Union[DefaultPlaceholder, DefaultType],
   210|         0|            0|            0|  0.00%|    *extra_items: Union[DefaultPlaceholder, DefaultType],
   211|         0|            0|            0|  0.00%|) -> Union[DefaultPlaceholder, DefaultType]:
   212|         0|            0|            0|  0.00%|    """
   213|         0|            0|            0|  0.00%|    Pass items or `DefaultPlaceholder`s by descending priority.
   214|         0|            0|            0|  0.00%|
   215|         0|            0|            0|  0.00%|    The first one to _not_ be a `DefaultPlaceholder` will be returned.
   216|         0|            0|            0|  0.00%|
   217|         0|            0|            0|  0.00%|    Otherwise, the first item (a `DefaultPlaceholder`) will be returned.
   218|         0|            0|            0|  0.00%|    """
   219|         0|            0|            0|  0.00%|    items = (first_item,) + extra_items
   220|         0|            0|            0|  0.00%|    for item in items:
   221|         0|            0|            0|  0.00%|        if not isinstance(item, DefaultPlaceholder):
   222|         0|            0|            0|  0.00%|            return item
   223|         0|            0|            0|  0.00%|    return first_item
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/typing_extensions.py
File duration: 0.000127792s (0.13%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|import abc
     2|         0|            0|            0|  0.00%|import collections
     3|         0|            0|            0|  0.00%|import collections.abc
     4|         0|            0|            0|  0.00%|import contextlib
     5|         0|            0|            0|  0.00%|import functools
     6|         0|            0|            0|  0.00%|import inspect
     7|         0|            0|            0|  0.00%|import operator
     8|         0|            0|            0|  0.00%|import sys
     9|         0|            0|            0|  0.00%|import types as _types
    10|         0|            0|            0|  0.00%|import typing
    11|         0|            0|            0|  0.00%|import warnings
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|__all__ = [
    14|         0|            0|            0|  0.00%|    # Super-special typing primitives.
    15|         0|            0|            0|  0.00%|    'Any',
    16|         0|            0|            0|  0.00%|    'ClassVar',
    17|         0|            0|            0|  0.00%|    'Concatenate',
    18|         0|            0|            0|  0.00%|    'Final',
    19|         0|            0|            0|  0.00%|    'LiteralString',
    20|         0|            0|            0|  0.00%|    'ParamSpec',
    21|         0|            0|            0|  0.00%|    'ParamSpecArgs',
    22|         0|            0|            0|  0.00%|    'ParamSpecKwargs',
    23|         0|            0|            0|  0.00%|    'Self',
    24|         0|            0|            0|  0.00%|    'Type',
    25|         0|            0|            0|  0.00%|    'TypeVar',
    26|         0|            0|            0|  0.00%|    'TypeVarTuple',
    27|         0|            0|            0|  0.00%|    'Unpack',
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|    # ABCs (from collections.abc).
    30|         0|            0|            0|  0.00%|    'Awaitable',
    31|         0|            0|            0|  0.00%|    'AsyncIterator',
    32|         0|            0|            0|  0.00%|    'AsyncIterable',
    33|         0|            0|            0|  0.00%|    'Coroutine',
    34|         0|            0|            0|  0.00%|    'AsyncGenerator',
    35|         0|            0|            0|  0.00%|    'AsyncContextManager',
    36|         0|            0|            0|  0.00%|    'Buffer',
    37|         0|            0|            0|  0.00%|    'ChainMap',
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|    # Concrete collection types.
    40|         0|            0|            0|  0.00%|    'ContextManager',
    41|         0|            0|            0|  0.00%|    'Counter',
    42|         0|            0|            0|  0.00%|    'Deque',
    43|         0|            0|            0|  0.00%|    'DefaultDict',
    44|         0|            0|            0|  0.00%|    'NamedTuple',
    45|         0|            0|            0|  0.00%|    'OrderedDict',
    46|         0|            0|            0|  0.00%|    'TypedDict',
    47|         0|            0|            0|  0.00%|
    48|         0|            0|            0|  0.00%|    # Structural checks, a.k.a. protocols.
    49|         0|            0|            0|  0.00%|    'SupportsAbs',
    50|         0|            0|            0|  0.00%|    'SupportsBytes',
    51|         0|            0|            0|  0.00%|    'SupportsComplex',
    52|         0|            0|            0|  0.00%|    'SupportsFloat',
    53|         0|            0|            0|  0.00%|    'SupportsIndex',
    54|         0|            0|            0|  0.00%|    'SupportsInt',
    55|         0|            0|            0|  0.00%|    'SupportsRound',
    56|         0|            0|            0|  0.00%|
    57|         0|            0|            0|  0.00%|    # One-off things.
    58|         0|            0|            0|  0.00%|    'Annotated',
    59|         0|            0|            0|  0.00%|    'assert_never',
    60|         0|            0|            0|  0.00%|    'assert_type',
    61|         0|            0|            0|  0.00%|    'clear_overloads',
    62|         0|            0|            0|  0.00%|    'dataclass_transform',
    63|         0|            0|            0|  0.00%|    'deprecated',
    64|         0|            0|            0|  0.00%|    'Doc',
    65|         0|            0|            0|  0.00%|    'get_overloads',
    66|         0|            0|            0|  0.00%|    'final',
    67|         0|            0|            0|  0.00%|    'get_args',
    68|         0|            0|            0|  0.00%|    'get_origin',
    69|         0|            0|            0|  0.00%|    'get_original_bases',
    70|         0|            0|            0|  0.00%|    'get_protocol_members',
    71|         0|            0|            0|  0.00%|    'get_type_hints',
    72|         0|            0|            0|  0.00%|    'IntVar',
    73|         0|            0|            0|  0.00%|    'is_protocol',
    74|         0|            0|            0|  0.00%|    'is_typeddict',
    75|         0|            0|            0|  0.00%|    'Literal',
    76|         0|            0|            0|  0.00%|    'NewType',
    77|         0|            0|            0|  0.00%|    'overload',
    78|         0|            0|            0|  0.00%|    'override',
    79|         0|            0|            0|  0.00%|    'Protocol',
    80|         0|            0|            0|  0.00%|    'reveal_type',
    81|         0|            0|            0|  0.00%|    'runtime',
    82|         0|            0|            0|  0.00%|    'runtime_checkable',
    83|         0|            0|            0|  0.00%|    'Text',
    84|         0|            0|            0|  0.00%|    'TypeAlias',
    85|         0|            0|            0|  0.00%|    'TypeAliasType',
    86|         0|            0|            0|  0.00%|    'TypeGuard',
    87|         0|            0|            0|  0.00%|    'TypeIs',
    88|         0|            0|            0|  0.00%|    'TYPE_CHECKING',
    89|         0|            0|            0|  0.00%|    'Never',
    90|         0|            0|            0|  0.00%|    'NoReturn',
    91|         0|            0|            0|  0.00%|    'ReadOnly',
    92|         0|            0|            0|  0.00%|    'Required',
    93|         0|            0|            0|  0.00%|    'NotRequired',
    94|         0|            0|            0|  0.00%|
    95|         0|            0|            0|  0.00%|    # Pure aliases, have always been in typing
    96|         0|            0|            0|  0.00%|    'AbstractSet',
    97|         0|            0|            0|  0.00%|    'AnyStr',
    98|         0|            0|            0|  0.00%|    'BinaryIO',
    99|         0|            0|            0|  0.00%|    'Callable',
   100|         0|            0|            0|  0.00%|    'Collection',
   101|         0|            0|            0|  0.00%|    'Container',
   102|         0|            0|            0|  0.00%|    'Dict',
   103|         0|            0|            0|  0.00%|    'ForwardRef',
   104|         0|            0|            0|  0.00%|    'FrozenSet',
   105|         0|            0|            0|  0.00%|    'Generator',
   106|         0|            0|            0|  0.00%|    'Generic',
   107|         0|            0|            0|  0.00%|    'Hashable',
   108|         0|            0|            0|  0.00%|    'IO',
   109|         0|            0|            0|  0.00%|    'ItemsView',
   110|         0|            0|            0|  0.00%|    'Iterable',
   111|         0|            0|            0|  0.00%|    'Iterator',
   112|         0|            0|            0|  0.00%|    'KeysView',
   113|         0|            0|            0|  0.00%|    'List',
   114|         0|            0|            0|  0.00%|    'Mapping',
   115|         0|            0|            0|  0.00%|    'MappingView',
   116|         0|            0|            0|  0.00%|    'Match',
   117|         0|            0|            0|  0.00%|    'MutableMapping',
   118|         0|            0|            0|  0.00%|    'MutableSequence',
   119|         0|            0|            0|  0.00%|    'MutableSet',
   120|         0|            0|            0|  0.00%|    'NoDefault',
   121|         0|            0|            0|  0.00%|    'Optional',
   122|         0|            0|            0|  0.00%|    'Pattern',
   123|         0|            0|            0|  0.00%|    'Reversible',
   124|         0|            0|            0|  0.00%|    'Sequence',
   125|         0|            0|            0|  0.00%|    'Set',
   126|         0|            0|            0|  0.00%|    'Sized',
   127|         0|            0|            0|  0.00%|    'TextIO',
   128|         0|            0|            0|  0.00%|    'Tuple',
   129|         0|            0|            0|  0.00%|    'Union',
   130|         0|            0|            0|  0.00%|    'ValuesView',
   131|         0|            0|            0|  0.00%|    'cast',
   132|         0|            0|            0|  0.00%|    'no_type_check',
   133|         0|            0|            0|  0.00%|    'no_type_check_decorator',
   134|         0|            0|            0|  0.00%|]
   135|         0|            0|            0|  0.00%|
   136|         0|            0|            0|  0.00%|# for backward compatibility
   137|         0|            0|            0|  0.00%|PEP_560 = True
   138|         0|            0|            0|  0.00%|GenericMeta = type
   139|         0|            0|            0|  0.00%|_PEP_696_IMPLEMENTED = sys.version_info >= (3, 13, 0, "beta")
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|# The functions below are modified copies of typing internal helpers.
   142|         0|            0|            0|  0.00%|# They are needed by _ProtocolMeta and they provide support for PEP 646.
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|
   145|         0|            0|            0|  0.00%|class _Sentinel:
   146|         0|            0|            0|  0.00%|    def __repr__(self):
   147|         0|            0|            0|  0.00%|        return "<sentinel>"
   148|         0|            0|            0|  0.00%|
   149|         0|            0|            0|  0.00%|
   150|         0|            0|            0|  0.00%|_marker = _Sentinel()
   151|         0|            0|            0|  0.00%|
   152|         0|            0|            0|  0.00%|
   153|         0|            0|            0|  0.00%|if sys.version_info >= (3, 10):
   154|         0|            0|            0|  0.00%|    def _should_collect_from_parameters(t):
   155|         0|            0|            0|  0.00%|        return isinstance(
   156|         0|            0|            0|  0.00%|            t, (typing._GenericAlias, _types.GenericAlias, _types.UnionType)
   157|         0|            0|            0|  0.00%|        )
   158|         0|            0|            0|  0.00%|elif sys.version_info >= (3, 9):
   159|         0|            0|            0|  0.00%|    def _should_collect_from_parameters(t):
   160|         0|            0|            0|  0.00%|        return isinstance(t, (typing._GenericAlias, _types.GenericAlias))
   161|         0|            0|            0|  0.00%|else:
   162|         0|            0|            0|  0.00%|    def _should_collect_from_parameters(t):
   163|         0|            0|            0|  0.00%|        return isinstance(t, typing._GenericAlias) and not t._special
   164|         0|            0|            0|  0.00%|
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|NoReturn = typing.NoReturn
   167|         0|            0|            0|  0.00%|
   168|         0|            0|            0|  0.00%|# Some unconstrained type variables.  These are used by the container types.
   169|         0|            0|            0|  0.00%|# (These are not for export.)
   170|         0|            0|            0|  0.00%|T = typing.TypeVar('T')  # Any type.
   171|         0|            0|            0|  0.00%|KT = typing.TypeVar('KT')  # Key type.
   172|         0|            0|            0|  0.00%|VT = typing.TypeVar('VT')  # Value type.
   173|         0|            0|            0|  0.00%|T_co = typing.TypeVar('T_co', covariant=True)  # Any type covariant containers.
   174|         0|            0|            0|  0.00%|T_contra = typing.TypeVar('T_contra', contravariant=True)  # Ditto contravariant.
   175|         0|            0|            0|  0.00%|
   176|         0|            0|            0|  0.00%|
   177|         0|            0|            0|  0.00%|if sys.version_info >= (3, 11):
   178|         0|            0|            0|  0.00%|    from typing import Any
   179|         0|            0|            0|  0.00%|else:
   180|         0|            0|            0|  0.00%|
   181|         0|            0|            0|  0.00%|    class _AnyMeta(type):
   182|         0|            0|            0|  0.00%|        def __instancecheck__(self, obj):
   183|         0|            0|            0|  0.00%|            if self is Any:
   184|         0|            0|            0|  0.00%|                raise TypeError("typing_extensions.Any cannot be used with isinstance()")
   185|         0|            0|            0|  0.00%|            return super().__instancecheck__(obj)
   186|         0|            0|            0|  0.00%|
   187|         0|            0|            0|  0.00%|        def __repr__(self):
   188|         0|            0|            0|  0.00%|            if self is Any:
   189|         0|            0|            0|  0.00%|                return "typing_extensions.Any"
   190|         0|            0|            0|  0.00%|            return super().__repr__()
   191|         0|            0|            0|  0.00%|
   192|         0|            0|            0|  0.00%|    class Any(metaclass=_AnyMeta):
   193|         0|            0|            0|  0.00%|        """Special type indicating an unconstrained type.
   194|         0|            0|            0|  0.00%|        - Any is compatible with every type.
   195|         0|            0|            0|  0.00%|        - Any assumed to have all methods.
   196|         0|            0|            0|  0.00%|        - All values assumed to be instances of Any.
   197|         0|            0|            0|  0.00%|        Note that all the above statements are true from the point of view of
   198|         0|            0|            0|  0.00%|        static type checkers. At runtime, Any should not be used with instance
   199|         0|            0|            0|  0.00%|        checks.
   200|         0|            0|            0|  0.00%|        """
   201|         0|            0|            0|  0.00%|        def __new__(cls, *args, **kwargs):
   202|         0|            0|            0|  0.00%|            if cls is Any:
   203|         0|            0|            0|  0.00%|                raise TypeError("Any cannot be instantiated")
   204|         0|            0|            0|  0.00%|            return super().__new__(cls, *args, **kwargs)
   205|         0|            0|            0|  0.00%|
   206|         0|            0|            0|  0.00%|
   207|         0|            0|            0|  0.00%|ClassVar = typing.ClassVar
   208|         0|            0|            0|  0.00%|
   209|         0|            0|            0|  0.00%|
   210|         0|            0|            0|  0.00%|class _ExtensionsSpecialForm(typing._SpecialForm, _root=True):
   211|         0|            0|            0|  0.00%|    def __repr__(self):
   212|         0|            0|            0|  0.00%|        return 'typing_extensions.' + self._name
   213|         0|            0|            0|  0.00%|
   214|         0|            0|            0|  0.00%|
   215|         0|            0|            0|  0.00%|Final = typing.Final
   216|         0|            0|            0|  0.00%|
   217|         0|            0|            0|  0.00%|if sys.version_info >= (3, 11):
   218|         0|            0|            0|  0.00%|    final = typing.final
   219|         0|            0|            0|  0.00%|else:
   220|         0|            0|            0|  0.00%|    # @final exists in 3.8+, but we backport it for all versions
   221|         0|            0|            0|  0.00%|    # before 3.11 to keep support for the __final__ attribute.
   222|         0|            0|            0|  0.00%|    # See https://bugs.python.org/issue46342
   223|         0|            0|            0|  0.00%|    def final(f):
   224|         0|            0|            0|  0.00%|        """This decorator can be used to indicate to type checkers that
   225|         0|            0|            0|  0.00%|        the decorated method cannot be overridden, and decorated class
   226|         0|            0|            0|  0.00%|        cannot be subclassed. For example:
   227|         0|            0|            0|  0.00%|
   228|         0|            0|            0|  0.00%|            class Base:
   229|         0|            0|            0|  0.00%|                @final
   230|         0|            0|            0|  0.00%|                def done(self) -> None:
   231|         0|            0|            0|  0.00%|                    ...
   232|         0|            0|            0|  0.00%|            class Sub(Base):
   233|         0|            0|            0|  0.00%|                def done(self) -> None:  # Error reported by type checker
   234|         0|            0|            0|  0.00%|                    ...
   235|         0|            0|            0|  0.00%|            @final
   236|         0|            0|            0|  0.00%|            class Leaf:
   237|         0|            0|            0|  0.00%|                ...
   238|         0|            0|            0|  0.00%|            class Other(Leaf):  # Error reported by type checker
   239|         0|            0|            0|  0.00%|                ...
   240|         0|            0|            0|  0.00%|
   241|         0|            0|            0|  0.00%|        There is no runtime checking of these properties. The decorator
   242|         0|            0|            0|  0.00%|        sets the ``__final__`` attribute to ``True`` on the decorated object
   243|         0|            0|            0|  0.00%|        to allow runtime introspection.
   244|         0|            0|            0|  0.00%|        """
   245|         0|            0|            0|  0.00%|        try:
   246|         0|            0|            0|  0.00%|            f.__final__ = True
   247|         0|            0|            0|  0.00%|        except (AttributeError, TypeError):
   248|         0|            0|            0|  0.00%|            # Skip the attribute silently if it is not writable.
   249|         0|            0|            0|  0.00%|            # AttributeError happens if the object has __slots__ or a
   250|         0|            0|            0|  0.00%|            # read-only property, TypeError if it's a builtin class.
   251|         0|            0|            0|  0.00%|            pass
   252|         0|            0|            0|  0.00%|        return f
   253|         0|            0|            0|  0.00%|
   254|         0|            0|            0|  0.00%|
   255|         0|            0|            0|  0.00%|def IntVar(name):
   256|         0|            0|            0|  0.00%|    return typing.TypeVar(name)
   257|         0|            0|            0|  0.00%|
   258|         0|            0|            0|  0.00%|
   259|         0|            0|            0|  0.00%|# A Literal bug was fixed in 3.11.0, 3.10.1 and 3.9.8
   260|         0|            0|            0|  0.00%|if sys.version_info >= (3, 10, 1):
   261|         0|            0|            0|  0.00%|    Literal = typing.Literal
   262|         0|            0|            0|  0.00%|else:
   263|         0|            0|            0|  0.00%|    def _flatten_literal_params(parameters):
   264|         0|            0|            0|  0.00%|        """An internal helper for Literal creation: flatten Literals among parameters"""
   265|         0|            0|            0|  0.00%|        params = []
   266|         0|            0|            0|  0.00%|        for p in parameters:
   267|         0|            0|            0|  0.00%|            if isinstance(p, _LiteralGenericAlias):
   268|         0|            0|            0|  0.00%|                params.extend(p.__args__)
   269|         0|            0|            0|  0.00%|            else:
   270|         0|            0|            0|  0.00%|                params.append(p)
   271|         0|            0|            0|  0.00%|        return tuple(params)
   272|         0|            0|            0|  0.00%|
   273|         0|            0|            0|  0.00%|    def _value_and_type_iter(params):
   274|         0|            0|            0|  0.00%|        for p in params:
   275|         0|            0|            0|  0.00%|            yield p, type(p)
   276|         0|            0|            0|  0.00%|
   277|         0|            0|            0|  0.00%|    class _LiteralGenericAlias(typing._GenericAlias, _root=True):
   278|         0|            0|            0|  0.00%|        def __eq__(self, other):
   279|         0|            0|            0|  0.00%|            if not isinstance(other, _LiteralGenericAlias):
   280|         0|            0|            0|  0.00%|                return NotImplemented
   281|         0|            0|            0|  0.00%|            these_args_deduped = set(_value_and_type_iter(self.__args__))
   282|         0|            0|            0|  0.00%|            other_args_deduped = set(_value_and_type_iter(other.__args__))
   283|         0|            0|            0|  0.00%|            return these_args_deduped == other_args_deduped
   284|         0|            0|            0|  0.00%|
   285|         0|            0|            0|  0.00%|        def __hash__(self):
   286|         0|            0|            0|  0.00%|            return hash(frozenset(_value_and_type_iter(self.__args__)))
   287|         0|            0|            0|  0.00%|
   288|         0|            0|            0|  0.00%|    class _LiteralForm(_ExtensionsSpecialForm, _root=True):
   289|         0|            0|            0|  0.00%|        def __init__(self, doc: str):
   290|         0|            0|            0|  0.00%|            self._name = 'Literal'
   291|         0|            0|            0|  0.00%|            self._doc = self.__doc__ = doc
   292|         0|            0|            0|  0.00%|
   293|         0|            0|            0|  0.00%|        def __getitem__(self, parameters):
   294|         0|            0|            0|  0.00%|            if not isinstance(parameters, tuple):
   295|         0|            0|            0|  0.00%|                parameters = (parameters,)
   296|         0|            0|            0|  0.00%|
   297|         0|            0|            0|  0.00%|            parameters = _flatten_literal_params(parameters)
   298|         0|            0|            0|  0.00%|
   299|         0|            0|            0|  0.00%|            val_type_pairs = list(_value_and_type_iter(parameters))
   300|         0|            0|            0|  0.00%|            try:
   301|         0|            0|            0|  0.00%|                deduped_pairs = set(val_type_pairs)
   302|         0|            0|            0|  0.00%|            except TypeError:
   303|         0|            0|            0|  0.00%|                # unhashable parameters
   304|         0|            0|            0|  0.00%|                pass
   305|         0|            0|            0|  0.00%|            else:
   306|         0|            0|            0|  0.00%|                # similar logic to typing._deduplicate on Python 3.9+
   307|         0|            0|            0|  0.00%|                if len(deduped_pairs) < len(val_type_pairs):
   308|         0|            0|            0|  0.00%|                    new_parameters = []
   309|         0|            0|            0|  0.00%|                    for pair in val_type_pairs:
   310|         0|            0|            0|  0.00%|                        if pair in deduped_pairs:
   311|         0|            0|            0|  0.00%|                            new_parameters.append(pair[0])
   312|         0|            0|            0|  0.00%|                            deduped_pairs.remove(pair)
   313|         0|            0|            0|  0.00%|                    assert not deduped_pairs, deduped_pairs
   314|         0|            0|            0|  0.00%|                    parameters = tuple(new_parameters)
   315|         0|            0|            0|  0.00%|
   316|         0|            0|            0|  0.00%|            return _LiteralGenericAlias(self, parameters)
   317|         0|            0|            0|  0.00%|
   318|         0|            0|            0|  0.00%|    Literal = _LiteralForm(doc="""\
   319|         0|            0|            0|  0.00%|                           A type that can be used to indicate to type checkers
   320|         0|            0|            0|  0.00%|                           that the corresponding value has a value literally equivalent
   321|         0|            0|            0|  0.00%|                           to the provided parameter. For example:
   322|         0|            0|            0|  0.00%|
   323|         0|            0|            0|  0.00%|                               var: Literal[4] = 4
   324|         0|            0|            0|  0.00%|
   325|         0|            0|            0|  0.00%|                           The type checker understands that 'var' is literally equal to
   326|         0|            0|            0|  0.00%|                           the value 4 and no other value.
   327|         0|            0|            0|  0.00%|
   328|         0|            0|            0|  0.00%|                           Literal[...] cannot be subclassed. There is no runtime
   329|         0|            0|            0|  0.00%|                           checking verifying that the parameter is actually a value
   330|         0|            0|            0|  0.00%|                           instead of a type.""")
   331|         0|            0|            0|  0.00%|
   332|         0|            0|            0|  0.00%|
   333|         0|            0|            0|  0.00%|_overload_dummy = typing._overload_dummy
   334|         0|            0|            0|  0.00%|
   335|         0|            0|            0|  0.00%|
   336|         0|            0|            0|  0.00%|if hasattr(typing, "get_overloads"):  # 3.11+
   337|         0|            0|            0|  0.00%|    overload = typing.overload
   338|         0|            0|            0|  0.00%|    get_overloads = typing.get_overloads
   339|         0|            0|            0|  0.00%|    clear_overloads = typing.clear_overloads
   340|         0|            0|            0|  0.00%|else:
   341|         0|            0|            0|  0.00%|    # {module: {qualname: {firstlineno: func}}}
   342|         0|            0|            0|  0.00%|    _overload_registry = collections.defaultdict(
   343|         0|            0|            0|  0.00%|        functools.partial(collections.defaultdict, dict)
   344|         0|            0|            0|  0.00%|    )
   345|         0|            0|            0|  0.00%|
   346|         0|            0|            0|  0.00%|    def overload(func):
   347|         0|            0|            0|  0.00%|        """Decorator for overloaded functions/methods.
   348|         0|            0|            0|  0.00%|
   349|         0|            0|            0|  0.00%|        In a stub file, place two or more stub definitions for the same
   350|         0|            0|            0|  0.00%|        function in a row, each decorated with @overload.  For example:
   351|         0|            0|            0|  0.00%|
   352|         0|            0|            0|  0.00%|        @overload
   353|         0|            0|            0|  0.00%|        def utf8(value: None) -> None: ...
   354|         0|            0|            0|  0.00%|        @overload
   355|         0|            0|            0|  0.00%|        def utf8(value: bytes) -> bytes: ...
   356|         0|            0|            0|  0.00%|        @overload
   357|         0|            0|            0|  0.00%|        def utf8(value: str) -> bytes: ...
   358|         0|            0|            0|  0.00%|
   359|         0|            0|            0|  0.00%|        In a non-stub file (i.e. a regular .py file), do the same but
   360|         0|            0|            0|  0.00%|        follow it with an implementation.  The implementation should *not*
   361|         0|            0|            0|  0.00%|        be decorated with @overload.  For example:
   362|         0|            0|            0|  0.00%|
   363|         0|            0|            0|  0.00%|        @overload
   364|         0|            0|            0|  0.00%|        def utf8(value: None) -> None: ...
   365|         0|            0|            0|  0.00%|        @overload
   366|         0|            0|            0|  0.00%|        def utf8(value: bytes) -> bytes: ...
   367|         0|            0|            0|  0.00%|        @overload
   368|         0|            0|            0|  0.00%|        def utf8(value: str) -> bytes: ...
   369|         0|            0|            0|  0.00%|        def utf8(value):
   370|         0|            0|            0|  0.00%|            # implementation goes here
   371|         0|            0|            0|  0.00%|
   372|         0|            0|            0|  0.00%|        The overloads for a function can be retrieved at runtime using the
   373|         0|            0|            0|  0.00%|        get_overloads() function.
   374|         0|            0|            0|  0.00%|        """
   375|         0|            0|            0|  0.00%|        # classmethod and staticmethod
   376|         0|            0|            0|  0.00%|        f = getattr(func, "__func__", func)
   377|         0|            0|            0|  0.00%|        try:
   378|         0|            0|            0|  0.00%|            _overload_registry[f.__module__][f.__qualname__][
   379|         0|            0|            0|  0.00%|                f.__code__.co_firstlineno
   380|         0|            0|            0|  0.00%|            ] = func
   381|         0|            0|            0|  0.00%|        except AttributeError:
   382|         0|            0|            0|  0.00%|            # Not a normal function; ignore.
   383|         0|            0|            0|  0.00%|            pass
   384|         0|            0|            0|  0.00%|        return _overload_dummy
   385|         0|            0|            0|  0.00%|
   386|         0|            0|            0|  0.00%|    def get_overloads(func):
   387|         0|            0|            0|  0.00%|        """Return all defined overloads for *func* as a sequence."""
   388|         0|            0|            0|  0.00%|        # classmethod and staticmethod
   389|         0|            0|            0|  0.00%|        f = getattr(func, "__func__", func)
   390|         0|            0|            0|  0.00%|        if f.__module__ not in _overload_registry:
   391|         0|            0|            0|  0.00%|            return []
   392|         0|            0|            0|  0.00%|        mod_dict = _overload_registry[f.__module__]
   393|         0|            0|            0|  0.00%|        if f.__qualname__ not in mod_dict:
   394|         0|            0|            0|  0.00%|            return []
   395|         0|            0|            0|  0.00%|        return list(mod_dict[f.__qualname__].values())
   396|         0|            0|            0|  0.00%|
   397|         0|            0|            0|  0.00%|    def clear_overloads():
   398|         0|            0|            0|  0.00%|        """Clear all overloads in the registry."""
   399|         0|            0|            0|  0.00%|        _overload_registry.clear()
   400|         0|            0|            0|  0.00%|
   401|         0|            0|            0|  0.00%|
   402|         0|            0|            0|  0.00%|# This is not a real generic class.  Don't use outside annotations.
   403|         0|            0|            0|  0.00%|Type = typing.Type
   404|         0|            0|            0|  0.00%|
   405|         0|            0|            0|  0.00%|# Various ABCs mimicking those in collections.abc.
   406|         0|            0|            0|  0.00%|# A few are simply re-exported for completeness.
   407|         0|            0|            0|  0.00%|Awaitable = typing.Awaitable
   408|         0|            0|            0|  0.00%|Coroutine = typing.Coroutine
   409|         0|            0|            0|  0.00%|AsyncIterable = typing.AsyncIterable
   410|         0|            0|            0|  0.00%|AsyncIterator = typing.AsyncIterator
   411|         0|            0|            0|  0.00%|Deque = typing.Deque
   412|         0|            0|            0|  0.00%|DefaultDict = typing.DefaultDict
   413|         0|            0|            0|  0.00%|OrderedDict = typing.OrderedDict
   414|         0|            0|            0|  0.00%|Counter = typing.Counter
   415|         0|            0|            0|  0.00%|ChainMap = typing.ChainMap
   416|         0|            0|            0|  0.00%|Text = typing.Text
   417|         0|            0|            0|  0.00%|TYPE_CHECKING = typing.TYPE_CHECKING
   418|         0|            0|            0|  0.00%|
   419|         0|            0|            0|  0.00%|
   420|         0|            0|            0|  0.00%|if sys.version_info >= (3, 13, 0, "beta"):
   421|         0|            0|            0|  0.00%|    from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator
   422|         0|            0|            0|  0.00%|else:
   423|         0|            0|            0|  0.00%|    def _is_dunder(attr):
   424|         0|            0|            0|  0.00%|        return attr.startswith('__') and attr.endswith('__')
   425|         0|            0|            0|  0.00%|
   426|         0|            0|            0|  0.00%|    # Python <3.9 doesn't have typing._SpecialGenericAlias
   427|         0|            0|            0|  0.00%|    _special_generic_alias_base = getattr(
   428|         0|            0|            0|  0.00%|        typing, "_SpecialGenericAlias", typing._GenericAlias
   429|         0|            0|            0|  0.00%|    )
   430|         0|            0|            0|  0.00%|
   431|         0|            0|            0|  0.00%|    class _SpecialGenericAlias(_special_generic_alias_base, _root=True):
   432|         0|            0|            0|  0.00%|        def __init__(self, origin, nparams, *, inst=True, name=None, defaults=()):
   433|         0|            0|            0|  0.00%|            if _special_generic_alias_base is typing._GenericAlias:
   434|         0|            0|            0|  0.00%|                # Python <3.9
   435|         0|            0|            0|  0.00%|                self.__origin__ = origin
   436|         0|            0|            0|  0.00%|                self._nparams = nparams
   437|         0|            0|            0|  0.00%|                super().__init__(origin, nparams, special=True, inst=inst, name=name)
   438|         0|            0|            0|  0.00%|            else:
   439|         0|            0|            0|  0.00%|                # Python >= 3.9
   440|         0|            0|            0|  0.00%|                super().__init__(origin, nparams, inst=inst, name=name)
   441|         0|            0|            0|  0.00%|            self._defaults = defaults
   442|         0|            0|            0|  0.00%|
   443|         0|            0|            0|  0.00%|        def __setattr__(self, attr, val):
   444|         0|            0|            0|  0.00%|            allowed_attrs = {'_name', '_inst', '_nparams', '_defaults'}
   445|         0|            0|            0|  0.00%|            if _special_generic_alias_base is typing._GenericAlias:
   446|         0|            0|            0|  0.00%|                # Python <3.9
   447|         0|            0|            0|  0.00%|                allowed_attrs.add("__origin__")
   448|         0|            0|            0|  0.00%|            if _is_dunder(attr) or attr in allowed_attrs:
   449|         0|            0|            0|  0.00%|                object.__setattr__(self, attr, val)
   450|         0|            0|            0|  0.00%|            else:
   451|         0|            0|            0|  0.00%|                setattr(self.__origin__, attr, val)
   452|         0|            0|            0|  0.00%|
   453|         0|            0|            0|  0.00%|        @typing._tp_cache
   454|         0|            0|            0|  0.00%|        def __getitem__(self, params):
   455|         0|            0|            0|  0.00%|            if not isinstance(params, tuple):
   456|         0|            0|            0|  0.00%|                params = (params,)
   457|         0|            0|            0|  0.00%|            msg = "Parameters to generic types must be types."
   458|         0|            0|            0|  0.00%|            params = tuple(typing._type_check(p, msg) for p in params)
   459|         0|            0|            0|  0.00%|            if (
   460|         0|            0|            0|  0.00%|                self._defaults
   461|         0|            0|            0|  0.00%|                and len(params) < self._nparams
   462|         0|            0|            0|  0.00%|                and len(params) + len(self._defaults) >= self._nparams
   463|         0|            0|            0|  0.00%|            ):
   464|         0|            0|            0|  0.00%|                params = (*params, *self._defaults[len(params) - self._nparams:])
   465|         0|            0|            0|  0.00%|            actual_len = len(params)
   466|         0|            0|            0|  0.00%|
   467|         0|            0|            0|  0.00%|            if actual_len != self._nparams:
   468|         0|            0|            0|  0.00%|                if self._defaults:
   469|         0|            0|            0|  0.00%|                    expected = f"at least {self._nparams - len(self._defaults)}"
   470|         0|            0|            0|  0.00%|                else:
   471|         0|            0|            0|  0.00%|                    expected = str(self._nparams)
   472|         0|            0|            0|  0.00%|                if not self._nparams:
   473|         0|            0|            0|  0.00%|                    raise TypeError(f"{self} is not a generic class")
   474|         0|            0|            0|  0.00%|                raise TypeError(
   475|         0|            0|            0|  0.00%|                    f"Too {'many' if actual_len > self._nparams else 'few'}"
   476|         0|            0|            0|  0.00%|                    f" arguments for {self};"
   477|         0|            0|            0|  0.00%|                    f" actual {actual_len}, expected {expected}"
   478|         0|            0|            0|  0.00%|                )
   479|         0|            0|            0|  0.00%|            return self.copy_with(params)
   480|         0|            0|            0|  0.00%|
   481|         0|            0|            0|  0.00%|    _NoneType = type(None)
   482|         0|            0|            0|  0.00%|    Generator = _SpecialGenericAlias(
   483|         0|            0|            0|  0.00%|        collections.abc.Generator, 3, defaults=(_NoneType, _NoneType)
   484|         0|            0|            0|  0.00%|    )
   485|         0|            0|            0|  0.00%|    AsyncGenerator = _SpecialGenericAlias(
   486|         0|            0|            0|  0.00%|        collections.abc.AsyncGenerator, 2, defaults=(_NoneType,)
   487|         0|            0|            0|  0.00%|    )
   488|         0|            0|            0|  0.00%|    ContextManager = _SpecialGenericAlias(
   489|         0|            0|            0|  0.00%|        contextlib.AbstractContextManager,
   490|         0|            0|            0|  0.00%|        2,
   491|         0|            0|            0|  0.00%|        name="ContextManager",
   492|         0|            0|            0|  0.00%|        defaults=(typing.Optional[bool],)
   493|         0|            0|            0|  0.00%|    )
   494|         0|            0|            0|  0.00%|    AsyncContextManager = _SpecialGenericAlias(
   495|         0|            0|            0|  0.00%|        contextlib.AbstractAsyncContextManager,
   496|         0|            0|            0|  0.00%|        2,
   497|         0|            0|            0|  0.00%|        name="AsyncContextManager",
   498|         0|            0|            0|  0.00%|        defaults=(typing.Optional[bool],)
   499|         0|            0|            0|  0.00%|    )
   500|         0|            0|            0|  0.00%|
   501|         0|            0|            0|  0.00%|
   502|         0|            0|            0|  0.00%|_PROTO_ALLOWLIST = {
   503|         0|            0|            0|  0.00%|    'collections.abc': [
   504|         0|            0|            0|  0.00%|        'Callable', 'Awaitable', 'Iterable', 'Iterator', 'AsyncIterable',
   505|         0|            0|            0|  0.00%|        'Hashable', 'Sized', 'Container', 'Collection', 'Reversible', 'Buffer',
   506|         0|            0|            0|  0.00%|    ],
   507|         0|            0|            0|  0.00%|    'contextlib': ['AbstractContextManager', 'AbstractAsyncContextManager'],
   508|         0|            0|            0|  0.00%|    'typing_extensions': ['Buffer'],
   509|         0|            0|            0|  0.00%|}
   510|         0|            0|            0|  0.00%|
   511|         0|            0|            0|  0.00%|
   512|         0|            0|            0|  0.00%|_EXCLUDED_ATTRS = frozenset(typing.EXCLUDED_ATTRIBUTES) | {
   513|         0|            0|            0|  0.00%|    "__match_args__", "__protocol_attrs__", "__non_callable_proto_members__",
   514|         0|            0|            0|  0.00%|    "__final__",
   515|         0|            0|            0|  0.00%|}
   516|         0|            0|            0|  0.00%|
   517|         0|            0|            0|  0.00%|
   518|         0|            0|            0|  0.00%|def _get_protocol_attrs(cls):
   519|         0|            0|            0|  0.00%|    attrs = set()
   520|         0|            0|            0|  0.00%|    for base in cls.__mro__[:-1]:  # without object
   521|         0|            0|            0|  0.00%|        if base.__name__ in {'Protocol', 'Generic'}:
   522|         0|            0|            0|  0.00%|            continue
   523|         0|            0|            0|  0.00%|        annotations = getattr(base, '__annotations__', {})
   524|         0|            0|            0|  0.00%|        for attr in (*base.__dict__, *annotations):
   525|         0|            0|            0|  0.00%|            if (not attr.startswith('_abc_') and attr not in _EXCLUDED_ATTRS):
   526|         0|            0|            0|  0.00%|                attrs.add(attr)
   527|         0|            0|            0|  0.00%|    return attrs
   528|         0|            0|            0|  0.00%|
   529|         0|            0|            0|  0.00%|
   530|         0|            0|            0|  0.00%|def _caller(depth=2):
   531|         0|            0|            0|  0.00%|    try:
   532|         0|            0|            0|  0.00%|        return sys._getframe(depth).f_globals.get('__name__', '__main__')
   533|         0|            0|            0|  0.00%|    except (AttributeError, ValueError):  # For platforms without _getframe()
   534|         0|            0|            0|  0.00%|        return None
   535|         0|            0|            0|  0.00%|
   536|         0|            0|            0|  0.00%|
   537|         0|            0|            0|  0.00%|# `__match_args__` attribute was removed from protocol members in 3.13,
   538|         0|            0|            0|  0.00%|# we want to backport this change to older Python versions.
   539|         0|            0|            0|  0.00%|if sys.version_info >= (3, 13):
   540|         0|            0|            0|  0.00%|    Protocol = typing.Protocol
   541|         0|            0|            0|  0.00%|else:
   542|         0|            0|            0|  0.00%|    def _allow_reckless_class_checks(depth=3):
   543|         0|            0|            0|  0.00%|        """Allow instance and class checks for special stdlib modules.
   544|         0|            0|            0|  0.00%|        The abc and functools modules indiscriminately call isinstance() and
   545|         0|            0|            0|  0.00%|        issubclass() on the whole MRO of a user class, which may contain protocols.
   546|         0|            0|            0|  0.00%|        """
   547|         0|            0|            0|  0.00%|        return _caller(depth) in {'abc', 'functools', None}
   548|         0|            0|            0|  0.00%|
   549|         0|            0|            0|  0.00%|    def _no_init(self, *args, **kwargs):
   550|         0|            0|            0|  0.00%|        if type(self)._is_protocol:
   551|         0|            0|            0|  0.00%|            raise TypeError('Protocols cannot be instantiated')
   552|         0|            0|            0|  0.00%|
   553|         0|            0|            0|  0.00%|    def _type_check_issubclass_arg_1(arg):
   554|         0|            0|            0|  0.00%|        """Raise TypeError if `arg` is not an instance of `type`
   555|         0|            0|            0|  0.00%|        in `issubclass(arg, <protocol>)`.
   556|         0|            0|            0|  0.00%|
   557|         0|            0|            0|  0.00%|        In most cases, this is verified by type.__subclasscheck__.
   558|         0|            0|            0|  0.00%|        Checking it again unnecessarily would slow down issubclass() checks,
   559|         0|            0|            0|  0.00%|        so, we don't perform this check unless we absolutely have to.
   560|         0|            0|            0|  0.00%|
   561|         0|            0|            0|  0.00%|        For various error paths, however,
   562|         0|            0|            0|  0.00%|        we want to ensure that *this* error message is shown to the user
   563|         0|            0|            0|  0.00%|        where relevant, rather than a typing.py-specific error message.
   564|         0|            0|            0|  0.00%|        """
   565|         0|            0|            0|  0.00%|        if not isinstance(arg, type):
   566|         0|            0|            0|  0.00%|            # Same error message as for issubclass(1, int).
   567|         0|            0|            0|  0.00%|            raise TypeError('issubclass() arg 1 must be a class')
   568|         0|            0|            0|  0.00%|
   569|         0|            0|            0|  0.00%|    # Inheriting from typing._ProtocolMeta isn't actually desirable,
   570|         0|            0|            0|  0.00%|    # but is necessary to allow typing.Protocol and typing_extensions.Protocol
   571|         0|            0|            0|  0.00%|    # to mix without getting TypeErrors about "metaclass conflict"
   572|         0|            0|            0|  0.00%|    class _ProtocolMeta(type(typing.Protocol)):
   573|         0|            0|            0|  0.00%|        # This metaclass is somewhat unfortunate,
   574|         0|            0|            0|  0.00%|        # but is necessary for several reasons...
   575|         0|            0|            0|  0.00%|        #
   576|         0|            0|            0|  0.00%|        # NOTE: DO NOT call super() in any methods in this class
   577|         0|            0|            0|  0.00%|        # That would call the methods on typing._ProtocolMeta on Python 3.8-3.11
   578|         0|            0|            0|  0.00%|        # and those are slow
   579|         0|            0|            0|  0.00%|        def __new__(mcls, name, bases, namespace, **kwargs):
   580|         0|            0|            0|  0.00%|            if name == "Protocol" and len(bases) < 2:
   581|         0|            0|            0|  0.00%|                pass
   582|         0|            0|            0|  0.00%|            elif {Protocol, typing.Protocol} & set(bases):
   583|         0|            0|            0|  0.00%|                for base in bases:
   584|         0|            0|            0|  0.00%|                    if not (
   585|         0|            0|            0|  0.00%|                        base in {object, typing.Generic, Protocol, typing.Protocol}
   586|         0|            0|            0|  0.00%|                        or base.__name__ in _PROTO_ALLOWLIST.get(base.__module__, [])
   587|         0|            0|            0|  0.00%|                        or is_protocol(base)
   588|         0|            0|            0|  0.00%|                    ):
   589|         0|            0|            0|  0.00%|                        raise TypeError(
   590|         0|            0|            0|  0.00%|                            f"Protocols can only inherit from other protocols, "
   591|         0|            0|            0|  0.00%|                            f"got {base!r}"
   592|         0|            0|            0|  0.00%|                        )
   593|         0|            0|            0|  0.00%|            return abc.ABCMeta.__new__(mcls, name, bases, namespace, **kwargs)
   594|         0|            0|            0|  0.00%|
   595|         0|            0|            0|  0.00%|        def __init__(cls, *args, **kwargs):
   596|         0|            0|            0|  0.00%|            abc.ABCMeta.__init__(cls, *args, **kwargs)
   597|         0|            0|            0|  0.00%|            if getattr(cls, "_is_protocol", False):
   598|         0|            0|            0|  0.00%|                cls.__protocol_attrs__ = _get_protocol_attrs(cls)
   599|         0|            0|            0|  0.00%|
   600|         0|            0|            0|  0.00%|        def __subclasscheck__(cls, other):
   601|         0|            0|            0|  0.00%|            if cls is Protocol:
   602|         0|            0|            0|  0.00%|                return type.__subclasscheck__(cls, other)
   603|         0|            0|            0|  0.00%|            if (
   604|         0|            0|            0|  0.00%|                getattr(cls, '_is_protocol', False)
   605|         0|            0|            0|  0.00%|                and not _allow_reckless_class_checks()
   606|         0|            0|            0|  0.00%|            ):
   607|         0|            0|            0|  0.00%|                if not getattr(cls, '_is_runtime_protocol', False):
   608|         0|            0|            0|  0.00%|                    _type_check_issubclass_arg_1(other)
   609|         0|            0|            0|  0.00%|                    raise TypeError(
   610|         0|            0|            0|  0.00%|                        "Instance and class checks can only be used with "
   611|         0|            0|            0|  0.00%|                        "@runtime_checkable protocols"
   612|         0|            0|            0|  0.00%|                    )
   613|         0|            0|            0|  0.00%|                if (
   614|         0|            0|            0|  0.00%|                    # this attribute is set by @runtime_checkable:
   615|         0|            0|            0|  0.00%|                    cls.__non_callable_proto_members__
   616|         0|            0|            0|  0.00%|                    and cls.__dict__.get("__subclasshook__") is _proto_hook
   617|         0|            0|            0|  0.00%|                ):
   618|         0|            0|            0|  0.00%|                    _type_check_issubclass_arg_1(other)
   619|         0|            0|            0|  0.00%|                    non_method_attrs = sorted(cls.__non_callable_proto_members__)
   620|         0|            0|            0|  0.00%|                    raise TypeError(
   621|         0|            0|            0|  0.00%|                        "Protocols with non-method members don't support issubclass()."
   622|         0|            0|            0|  0.00%|                        f" Non-method members: {str(non_method_attrs)[1:-1]}."
   623|         0|            0|            0|  0.00%|                    )
   624|         0|            0|            0|  0.00%|            return abc.ABCMeta.__subclasscheck__(cls, other)
   625|         0|            0|            0|  0.00%|
   626|         0|            0|            0|  0.00%|        def __instancecheck__(cls, instance):
   627|         0|            0|            0|  0.00%|            # We need this method for situations where attributes are
   628|         0|            0|            0|  0.00%|            # assigned in __init__.
   629|         0|            0|            0|  0.00%|            if cls is Protocol:
   630|         0|            0|            0|  0.00%|                return type.__instancecheck__(cls, instance)
   631|         0|            0|            0|  0.00%|            if not getattr(cls, "_is_protocol", False):
   632|         0|            0|            0|  0.00%|                # i.e., it's a concrete subclass of a protocol
   633|         0|            0|            0|  0.00%|                return abc.ABCMeta.__instancecheck__(cls, instance)
   634|         0|            0|            0|  0.00%|
   635|         0|            0|            0|  0.00%|            if (
   636|         0|            0|            0|  0.00%|                not getattr(cls, '_is_runtime_protocol', False) and
   637|         0|            0|            0|  0.00%|                not _allow_reckless_class_checks()
   638|         0|            0|            0|  0.00%|            ):
   639|         0|            0|            0|  0.00%|                raise TypeError("Instance and class checks can only be used with"
   640|         0|            0|            0|  0.00%|                                " @runtime_checkable protocols")
   641|         0|            0|            0|  0.00%|
   642|         0|            0|            0|  0.00%|            if abc.ABCMeta.__instancecheck__(cls, instance):
   643|         0|            0|            0|  0.00%|                return True
   644|         0|            0|            0|  0.00%|
   645|         0|            0|            0|  0.00%|            for attr in cls.__protocol_attrs__:
   646|         0|            0|            0|  0.00%|                try:
   647|         0|            0|            0|  0.00%|                    val = inspect.getattr_static(instance, attr)
   648|         0|            0|            0|  0.00%|                except AttributeError:
   649|         0|            0|            0|  0.00%|                    break
   650|         0|            0|            0|  0.00%|                # this attribute is set by @runtime_checkable:
   651|         0|            0|            0|  0.00%|                if val is None and attr not in cls.__non_callable_proto_members__:
   652|         0|            0|            0|  0.00%|                    break
   653|         0|            0|            0|  0.00%|            else:
   654|         0|            0|            0|  0.00%|                return True
   655|         0|            0|            0|  0.00%|
   656|         0|            0|            0|  0.00%|            return False
   657|         0|            0|            0|  0.00%|
   658|         0|            0|            0|  0.00%|        def __eq__(cls, other):
   659|         0|            0|            0|  0.00%|            # Hack so that typing.Generic.__class_getitem__
   660|         0|            0|            0|  0.00%|            # treats typing_extensions.Protocol
   661|         0|            0|            0|  0.00%|            # as equivalent to typing.Protocol
   662|         0|            0|            0|  0.00%|            if abc.ABCMeta.__eq__(cls, other) is True:
   663|         0|            0|            0|  0.00%|                return True
   664|         0|            0|            0|  0.00%|            return cls is Protocol and other is typing.Protocol
   665|         0|            0|            0|  0.00%|
   666|         0|            0|            0|  0.00%|        # This has to be defined, or the abc-module cache
   667|         0|            0|            0|  0.00%|        # complains about classes with this metaclass being unhashable,
   668|         0|            0|            0|  0.00%|        # if we define only __eq__!
   669|         0|            0|            0|  0.00%|        def __hash__(cls) -> int:
   670|         0|            0|            0|  0.00%|            return type.__hash__(cls)
   671|         0|            0|            0|  0.00%|
   672|         0|            0|            0|  0.00%|    @classmethod
   673|         0|            0|            0|  0.00%|    def _proto_hook(cls, other):
   674|         0|            0|            0|  0.00%|        if not cls.__dict__.get('_is_protocol', False):
   675|         0|            0|            0|  0.00%|            return NotImplemented
   676|         0|            0|            0|  0.00%|
   677|         0|            0|            0|  0.00%|        for attr in cls.__protocol_attrs__:
   678|         0|            0|            0|  0.00%|            for base in other.__mro__:
   679|         0|            0|            0|  0.00%|                # Check if the members appears in the class dictionary...
   680|         0|            0|            0|  0.00%|                if attr in base.__dict__:
   681|         0|            0|            0|  0.00%|                    if base.__dict__[attr] is None:
   682|         0|            0|            0|  0.00%|                        return NotImplemented
   683|         0|            0|            0|  0.00%|                    break
   684|         0|            0|            0|  0.00%|
   685|         0|            0|            0|  0.00%|                # ...or in annotations, if it is a sub-protocol.
   686|         0|            0|            0|  0.00%|                annotations = getattr(base, '__annotations__', {})
   687|         0|            0|            0|  0.00%|                if (
   688|         0|            0|            0|  0.00%|                    isinstance(annotations, collections.abc.Mapping)
   689|         0|            0|            0|  0.00%|                    and attr in annotations
   690|         0|            0|            0|  0.00%|                    and is_protocol(other)
   691|         0|            0|            0|  0.00%|                ):
   692|         0|            0|            0|  0.00%|                    break
   693|         0|            0|            0|  0.00%|            else:
   694|         0|            0|            0|  0.00%|                return NotImplemented
   695|         0|            0|            0|  0.00%|        return True
   696|         0|            0|            0|  0.00%|
   697|         0|            0|            0|  0.00%|    class Protocol(typing.Generic, metaclass=_ProtocolMeta):
   698|         0|            0|            0|  0.00%|        __doc__ = typing.Protocol.__doc__
   699|         0|            0|            0|  0.00%|        __slots__ = ()
   700|         0|            0|            0|  0.00%|        _is_protocol = True
   701|         0|            0|            0|  0.00%|        _is_runtime_protocol = False
   702|         0|            0|            0|  0.00%|
   703|         0|            0|            0|  0.00%|        def __init_subclass__(cls, *args, **kwargs):
   704|         0|            0|            0|  0.00%|            super().__init_subclass__(*args, **kwargs)
   705|         0|            0|            0|  0.00%|
   706|         0|            0|            0|  0.00%|            # Determine if this is a protocol or a concrete subclass.
   707|         0|            0|            0|  0.00%|            if not cls.__dict__.get('_is_protocol', False):
   708|         0|            0|            0|  0.00%|                cls._is_protocol = any(b is Protocol for b in cls.__bases__)
   709|         0|            0|            0|  0.00%|
   710|         0|            0|            0|  0.00%|            # Set (or override) the protocol subclass hook.
   711|         0|            0|            0|  0.00%|            if '__subclasshook__' not in cls.__dict__:
   712|         0|            0|            0|  0.00%|                cls.__subclasshook__ = _proto_hook
   713|         0|            0|            0|  0.00%|
   714|         0|            0|            0|  0.00%|            # Prohibit instantiation for protocol classes
   715|         0|            0|            0|  0.00%|            if cls._is_protocol and cls.__init__ is Protocol.__init__:
   716|         0|            0|            0|  0.00%|                cls.__init__ = _no_init
   717|         0|            0|            0|  0.00%|
   718|         0|            0|            0|  0.00%|
   719|         0|            0|            0|  0.00%|if sys.version_info >= (3, 13):
   720|         0|            0|            0|  0.00%|    runtime_checkable = typing.runtime_checkable
   721|         0|            0|            0|  0.00%|else:
   722|         0|            0|            0|  0.00%|    def runtime_checkable(cls):
   723|         0|            0|            0|  0.00%|        """Mark a protocol class as a runtime protocol.
   724|         0|            0|            0|  0.00%|
   725|         0|            0|            0|  0.00%|        Such protocol can be used with isinstance() and issubclass().
   726|         0|            0|            0|  0.00%|        Raise TypeError if applied to a non-protocol class.
   727|         0|            0|            0|  0.00%|        This allows a simple-minded structural check very similar to
   728|         0|            0|            0|  0.00%|        one trick ponies in collections.abc such as Iterable.
   729|         0|            0|            0|  0.00%|
   730|         0|            0|            0|  0.00%|        For example::
   731|         0|            0|            0|  0.00%|
   732|         0|            0|            0|  0.00%|            @runtime_checkable
   733|         0|            0|            0|  0.00%|            class Closable(Protocol):
   734|         0|            0|            0|  0.00%|                def close(self): ...
   735|         0|            0|            0|  0.00%|
   736|         0|            0|            0|  0.00%|            assert isinstance(open('/some/file'), Closable)
   737|         0|            0|            0|  0.00%|
   738|         0|            0|            0|  0.00%|        Warning: this will check only the presence of the required methods,
   739|         0|            0|            0|  0.00%|        not their type signatures!
   740|         0|            0|            0|  0.00%|        """
   741|         0|            0|            0|  0.00%|        if not issubclass(cls, typing.Generic) or not getattr(cls, '_is_protocol', False):
   742|         0|            0|            0|  0.00%|            raise TypeError(f'@runtime_checkable can be only applied to protocol classes,'
   743|         0|            0|            0|  0.00%|                            f' got {cls!r}')
   744|         0|            0|            0|  0.00%|        cls._is_runtime_protocol = True
   745|         0|            0|            0|  0.00%|
   746|         0|            0|            0|  0.00%|        # typing.Protocol classes on <=3.11 break if we execute this block,
   747|         0|            0|            0|  0.00%|        # because typing.Protocol classes on <=3.11 don't have a
   748|         0|            0|            0|  0.00%|        # `__protocol_attrs__` attribute, and this block relies on the
   749|         0|            0|            0|  0.00%|        # `__protocol_attrs__` attribute. Meanwhile, typing.Protocol classes on 3.12.2+
   750|         0|            0|            0|  0.00%|        # break if we *don't* execute this block, because *they* assume that all
   751|         0|            0|            0|  0.00%|        # protocol classes have a `__non_callable_proto_members__` attribute
   752|         0|            0|            0|  0.00%|        # (which this block sets)
   753|         0|            0|            0|  0.00%|        if isinstance(cls, _ProtocolMeta) or sys.version_info >= (3, 12, 2):
   754|         0|            0|            0|  0.00%|            # PEP 544 prohibits using issubclass()
   755|         0|            0|            0|  0.00%|            # with protocols that have non-method members.
   756|         0|            0|            0|  0.00%|            # See gh-113320 for why we compute this attribute here,
   757|         0|            0|            0|  0.00%|            # rather than in `_ProtocolMeta.__init__`
   758|         0|            0|            0|  0.00%|            cls.__non_callable_proto_members__ = set()
   759|         0|            0|            0|  0.00%|            for attr in cls.__protocol_attrs__:
   760|         0|            0|            0|  0.00%|                try:
   761|         0|            0|            0|  0.00%|                    is_callable = callable(getattr(cls, attr, None))
   762|         0|            0|            0|  0.00%|                except Exception as e:
   763|         0|            0|            0|  0.00%|                    raise TypeError(
   764|         0|            0|            0|  0.00%|                        f"Failed to determine whether protocol member {attr!r} "
   765|         0|            0|            0|  0.00%|                        "is a method member"
   766|         0|            0|            0|  0.00%|                    ) from e
   767|         0|            0|            0|  0.00%|                else:
   768|         0|            0|            0|  0.00%|                    if not is_callable:
   769|         0|            0|            0|  0.00%|                        cls.__non_callable_proto_members__.add(attr)
   770|         0|            0|            0|  0.00%|
   771|         0|            0|            0|  0.00%|        return cls
   772|         0|            0|            0|  0.00%|
   773|         0|            0|            0|  0.00%|
   774|         0|            0|            0|  0.00%|# The "runtime" alias exists for backwards compatibility.
   775|         0|            0|            0|  0.00%|runtime = runtime_checkable
   776|         0|            0|            0|  0.00%|
   777|         0|            0|            0|  0.00%|
   778|         0|            0|            0|  0.00%|# Our version of runtime-checkable protocols is faster on Python 3.8-3.11
   779|         0|            0|            0|  0.00%|if sys.version_info >= (3, 12):
   780|         0|            0|            0|  0.00%|    SupportsInt = typing.SupportsInt
   781|         0|            0|            0|  0.00%|    SupportsFloat = typing.SupportsFloat
   782|         0|            0|            0|  0.00%|    SupportsComplex = typing.SupportsComplex
   783|         0|            0|            0|  0.00%|    SupportsBytes = typing.SupportsBytes
   784|         0|            0|            0|  0.00%|    SupportsIndex = typing.SupportsIndex
   785|         0|            0|            0|  0.00%|    SupportsAbs = typing.SupportsAbs
   786|         0|            0|            0|  0.00%|    SupportsRound = typing.SupportsRound
   787|         0|            0|            0|  0.00%|else:
   788|         0|            0|            0|  0.00%|    @runtime_checkable
   789|         0|            0|            0|  0.00%|    class SupportsInt(Protocol):
   790|         0|            0|            0|  0.00%|        """An ABC with one abstract method __int__."""
   791|         0|            0|            0|  0.00%|        __slots__ = ()
   792|         0|            0|            0|  0.00%|
   793|         0|            0|            0|  0.00%|        @abc.abstractmethod
   794|         0|            0|            0|  0.00%|        def __int__(self) -> int:
   795|         0|            0|            0|  0.00%|            pass
   796|         0|            0|            0|  0.00%|
   797|         0|            0|            0|  0.00%|    @runtime_checkable
   798|         0|            0|            0|  0.00%|    class SupportsFloat(Protocol):
   799|         0|            0|            0|  0.00%|        """An ABC with one abstract method __float__."""
   800|         0|            0|            0|  0.00%|        __slots__ = ()
   801|         0|            0|            0|  0.00%|
   802|         0|            0|            0|  0.00%|        @abc.abstractmethod
   803|         0|            0|            0|  0.00%|        def __float__(self) -> float:
   804|         0|            0|            0|  0.00%|            pass
   805|         0|            0|            0|  0.00%|
   806|         0|            0|            0|  0.00%|    @runtime_checkable
   807|         0|            0|            0|  0.00%|    class SupportsComplex(Protocol):
   808|         0|            0|            0|  0.00%|        """An ABC with one abstract method __complex__."""
   809|         0|            0|            0|  0.00%|        __slots__ = ()
   810|         0|            0|            0|  0.00%|
   811|         0|            0|            0|  0.00%|        @abc.abstractmethod
   812|         0|            0|            0|  0.00%|        def __complex__(self) -> complex:
   813|         0|            0|            0|  0.00%|            pass
   814|         0|            0|            0|  0.00%|
   815|         0|            0|            0|  0.00%|    @runtime_checkable
   816|         0|            0|            0|  0.00%|    class SupportsBytes(Protocol):
   817|         0|            0|            0|  0.00%|        """An ABC with one abstract method __bytes__."""
   818|         0|            0|            0|  0.00%|        __slots__ = ()
   819|         0|            0|            0|  0.00%|
   820|         0|            0|            0|  0.00%|        @abc.abstractmethod
   821|         0|            0|            0|  0.00%|        def __bytes__(self) -> bytes:
   822|         0|            0|            0|  0.00%|            pass
   823|         0|            0|            0|  0.00%|
   824|         0|            0|            0|  0.00%|    @runtime_checkable
   825|         0|            0|            0|  0.00%|    class SupportsIndex(Protocol):
   826|         0|            0|            0|  0.00%|        __slots__ = ()
   827|         0|            0|            0|  0.00%|
   828|         0|            0|            0|  0.00%|        @abc.abstractmethod
   829|         0|            0|            0|  0.00%|        def __index__(self) -> int:
   830|         0|            0|            0|  0.00%|            pass
   831|         0|            0|            0|  0.00%|
   832|         0|            0|            0|  0.00%|    @runtime_checkable
   833|         0|            0|            0|  0.00%|    class SupportsAbs(Protocol[T_co]):
   834|         0|            0|            0|  0.00%|        """
   835|         0|            0|            0|  0.00%|        An ABC with one abstract method __abs__ that is covariant in its return type.
   836|         0|            0|            0|  0.00%|        """
   837|         0|            0|            0|  0.00%|        __slots__ = ()
   838|         0|            0|            0|  0.00%|
   839|         0|            0|            0|  0.00%|        @abc.abstractmethod
   840|         0|            0|            0|  0.00%|        def __abs__(self) -> T_co:
   841|         0|            0|            0|  0.00%|            pass
   842|         0|            0|            0|  0.00%|
   843|         0|            0|            0|  0.00%|    @runtime_checkable
   844|         0|            0|            0|  0.00%|    class SupportsRound(Protocol[T_co]):
   845|         0|            0|            0|  0.00%|        """
   846|         0|            0|            0|  0.00%|        An ABC with one abstract method __round__ that is covariant in its return type.
   847|         0|            0|            0|  0.00%|        """
   848|         0|            0|            0|  0.00%|        __slots__ = ()
   849|         0|            0|            0|  0.00%|
   850|         0|            0|            0|  0.00%|        @abc.abstractmethod
   851|         0|            0|            0|  0.00%|        def __round__(self, ndigits: int = 0) -> T_co:
   852|         0|            0|            0|  0.00%|            pass
   853|         0|            0|            0|  0.00%|
   854|         0|            0|            0|  0.00%|
   855|         0|            0|            0|  0.00%|def _ensure_subclassable(mro_entries):
   856|         0|            0|            0|  0.00%|    def inner(func):
   857|         0|            0|            0|  0.00%|        if sys.implementation.name == "pypy" and sys.version_info < (3, 9):
   858|         0|            0|            0|  0.00%|            cls_dict = {
   859|         0|            0|            0|  0.00%|                "__call__": staticmethod(func),
   860|         0|            0|            0|  0.00%|                "__mro_entries__": staticmethod(mro_entries)
   861|         0|            0|            0|  0.00%|            }
   862|         0|            0|            0|  0.00%|            t = type(func.__name__, (), cls_dict)
   863|         0|            0|            0|  0.00%|            return functools.update_wrapper(t(), func)
   864|         0|            0|            0|  0.00%|        else:
   865|         0|            0|            0|  0.00%|            func.__mro_entries__ = mro_entries
   866|         0|            0|            0|  0.00%|            return func
   867|         0|            0|            0|  0.00%|    return inner
   868|         0|            0|            0|  0.00%|
   869|         0|            0|            0|  0.00%|
   870|         0|            0|            0|  0.00%|# Update this to something like >=3.13.0b1 if and when
   871|         0|            0|            0|  0.00%|# PEP 728 is implemented in CPython
   872|         0|            0|            0|  0.00%|_PEP_728_IMPLEMENTED = False
   873|         0|            0|            0|  0.00%|
   874|         0|            0|            0|  0.00%|if _PEP_728_IMPLEMENTED:
   875|         0|            0|            0|  0.00%|    # The standard library TypedDict in Python 3.8 does not store runtime information
   876|         0|            0|            0|  0.00%|    # about which (if any) keys are optional.  See https://bugs.python.org/issue38834
   877|         0|            0|            0|  0.00%|    # The standard library TypedDict in Python 3.9.0/1 does not honour the "total"
   878|         0|            0|            0|  0.00%|    # keyword with old-style TypedDict().  See https://bugs.python.org/issue42059
   879|         0|            0|            0|  0.00%|    # The standard library TypedDict below Python 3.11 does not store runtime
   880|         0|            0|            0|  0.00%|    # information about optional and required keys when using Required or NotRequired.
   881|         0|            0|            0|  0.00%|    # Generic TypedDicts are also impossible using typing.TypedDict on Python <3.11.
   882|         0|            0|            0|  0.00%|    # Aaaand on 3.12 we add __orig_bases__ to TypedDict
   883|         0|            0|            0|  0.00%|    # to enable better runtime introspection.
   884|         0|            0|            0|  0.00%|    # On 3.13 we deprecate some odd ways of creating TypedDicts.
   885|         0|            0|            0|  0.00%|    # Also on 3.13, PEP 705 adds the ReadOnly[] qualifier.
   886|         0|            0|            0|  0.00%|    # PEP 728 (still pending) makes more changes.
   887|         0|            0|            0|  0.00%|    TypedDict = typing.TypedDict
   888|         0|            0|            0|  0.00%|    _TypedDictMeta = typing._TypedDictMeta
   889|         0|            0|            0|  0.00%|    is_typeddict = typing.is_typeddict
   890|         0|            0|            0|  0.00%|else:
   891|         0|            0|            0|  0.00%|    # 3.10.0 and later
   892|         0|            0|            0|  0.00%|    _TAKES_MODULE = "module" in inspect.signature(typing._type_check).parameters
   893|         0|            0|            0|  0.00%|
   894|         0|            0|            0|  0.00%|    def _get_typeddict_qualifiers(annotation_type):
   895|         0|            0|            0|  0.00%|        while True:
   896|         0|            0|            0|  0.00%|            annotation_origin = get_origin(annotation_type)
   897|         0|            0|            0|  0.00%|            if annotation_origin is Annotated:
   898|         0|            0|            0|  0.00%|                annotation_args = get_args(annotation_type)
   899|         0|            0|            0|  0.00%|                if annotation_args:
   900|         0|            0|            0|  0.00%|                    annotation_type = annotation_args[0]
   901|         0|            0|            0|  0.00%|                else:
   902|         0|            0|            0|  0.00%|                    break
   903|         0|            0|            0|  0.00%|            elif annotation_origin is Required:
   904|         0|            0|            0|  0.00%|                yield Required
   905|         0|            0|            0|  0.00%|                annotation_type, = get_args(annotation_type)
   906|         0|            0|            0|  0.00%|            elif annotation_origin is NotRequired:
   907|         0|            0|            0|  0.00%|                yield NotRequired
   908|         0|            0|            0|  0.00%|                annotation_type, = get_args(annotation_type)
   909|         0|            0|            0|  0.00%|            elif annotation_origin is ReadOnly:
   910|         0|            0|            0|  0.00%|                yield ReadOnly
   911|         0|            0|            0|  0.00%|                annotation_type, = get_args(annotation_type)
   912|         0|            0|            0|  0.00%|            else:
   913|         0|            0|            0|  0.00%|                break
   914|         0|            0|            0|  0.00%|
   915|         0|            0|            0|  0.00%|    class _TypedDictMeta(type):
   916|         0|            0|            0|  0.00%|        def __new__(cls, name, bases, ns, *, total=True, closed=False):
   917|         0|            0|            0|  0.00%|            """Create new typed dict class object.
   918|         0|            0|            0|  0.00%|
   919|         0|            0|            0|  0.00%|            This method is called when TypedDict is subclassed,
   920|         0|            0|            0|  0.00%|            or when TypedDict is instantiated. This way
   921|         0|            0|            0|  0.00%|            TypedDict supports all three syntax forms described in its docstring.
   922|         0|            0|            0|  0.00%|            Subclasses and instances of TypedDict return actual dictionaries.
   923|         0|            0|            0|  0.00%|            """
   924|         0|            0|            0|  0.00%|            for base in bases:
   925|         0|            0|            0|  0.00%|                if type(base) is not _TypedDictMeta and base is not typing.Generic:
   926|         0|            0|            0|  0.00%|                    raise TypeError('cannot inherit from both a TypedDict type '
   927|         0|            0|            0|  0.00%|                                    'and a non-TypedDict base class')
   928|         0|            0|            0|  0.00%|
   929|         0|            0|            0|  0.00%|            if any(issubclass(b, typing.Generic) for b in bases):
   930|         0|            0|            0|  0.00%|                generic_base = (typing.Generic,)
   931|         0|            0|            0|  0.00%|            else:
   932|         0|            0|            0|  0.00%|                generic_base = ()
   933|         0|            0|            0|  0.00%|
   934|         0|            0|            0|  0.00%|            # typing.py generally doesn't let you inherit from plain Generic, unless
   935|         0|            0|            0|  0.00%|            # the name of the class happens to be "Protocol"
   936|         0|            0|            0|  0.00%|            tp_dict = type.__new__(_TypedDictMeta, "Protocol", (*generic_base, dict), ns)
   937|         0|            0|            0|  0.00%|            tp_dict.__name__ = name
   938|         0|            0|            0|  0.00%|            if tp_dict.__qualname__ == "Protocol":
   939|         0|            0|            0|  0.00%|                tp_dict.__qualname__ = name
   940|         0|            0|            0|  0.00%|
   941|         0|            0|            0|  0.00%|            if not hasattr(tp_dict, '__orig_bases__'):
   942|         0|            0|            0|  0.00%|                tp_dict.__orig_bases__ = bases
   943|         0|            0|            0|  0.00%|
   944|         0|            0|            0|  0.00%|            annotations = {}
   945|         0|            0|            0|  0.00%|            if "__annotations__" in ns:
   946|         0|            0|            0|  0.00%|                own_annotations = ns["__annotations__"]
   947|         0|            0|            0|  0.00%|            elif "__annotate__" in ns:
   948|         0|            0|            0|  0.00%|                # TODO: Use inspect.VALUE here, and make the annotations lazily evaluated
   949|         0|            0|            0|  0.00%|                own_annotations = ns["__annotate__"](1)
   950|         0|            0|            0|  0.00%|            else:
   951|         0|            0|            0|  0.00%|                own_annotations = {}
   952|         0|            0|            0|  0.00%|            msg = "TypedDict('Name', {f0: t0, f1: t1, ...}); each t must be a type"
   953|         0|            0|            0|  0.00%|            if _TAKES_MODULE:
   954|         0|            0|            0|  0.00%|                own_annotations = {
   955|         0|            0|            0|  0.00%|                    n: typing._type_check(tp, msg, module=tp_dict.__module__)
   956|         0|            0|            0|  0.00%|                    for n, tp in own_annotations.items()
   957|         0|            0|            0|  0.00%|                }
   958|         0|            0|            0|  0.00%|            else:
   959|         0|            0|            0|  0.00%|                own_annotations = {
   960|         0|            0|            0|  0.00%|                    n: typing._type_check(tp, msg)
   961|         0|            0|            0|  0.00%|                    for n, tp in own_annotations.items()
   962|         0|            0|            0|  0.00%|                }
   963|         0|            0|            0|  0.00%|            required_keys = set()
   964|         0|            0|            0|  0.00%|            optional_keys = set()
   965|         0|            0|            0|  0.00%|            readonly_keys = set()
   966|         0|            0|            0|  0.00%|            mutable_keys = set()
   967|         0|            0|            0|  0.00%|            extra_items_type = None
   968|         0|            0|            0|  0.00%|
   969|         0|            0|            0|  0.00%|            for base in bases:
   970|         0|            0|            0|  0.00%|                base_dict = base.__dict__
   971|         0|            0|            0|  0.00%|
   972|         0|            0|            0|  0.00%|                annotations.update(base_dict.get('__annotations__', {}))
   973|         0|            0|            0|  0.00%|                required_keys.update(base_dict.get('__required_keys__', ()))
   974|         0|            0|            0|  0.00%|                optional_keys.update(base_dict.get('__optional_keys__', ()))
   975|         0|            0|            0|  0.00%|                readonly_keys.update(base_dict.get('__readonly_keys__', ()))
   976|         0|            0|            0|  0.00%|                mutable_keys.update(base_dict.get('__mutable_keys__', ()))
   977|         0|            0|            0|  0.00%|                base_extra_items_type = base_dict.get('__extra_items__', None)
   978|         0|            0|            0|  0.00%|                if base_extra_items_type is not None:
   979|         0|            0|            0|  0.00%|                    extra_items_type = base_extra_items_type
   980|         0|            0|            0|  0.00%|
   981|         0|            0|            0|  0.00%|            if closed and extra_items_type is None:
   982|         0|            0|            0|  0.00%|                extra_items_type = Never
   983|         0|            0|            0|  0.00%|            if closed and "__extra_items__" in own_annotations:
   984|         0|            0|            0|  0.00%|                annotation_type = own_annotations.pop("__extra_items__")
   985|         0|            0|            0|  0.00%|                qualifiers = set(_get_typeddict_qualifiers(annotation_type))
   986|         0|            0|            0|  0.00%|                if Required in qualifiers:
   987|         0|            0|            0|  0.00%|                    raise TypeError(
   988|         0|            0|            0|  0.00%|                        "Special key __extra_items__ does not support "
   989|         0|            0|            0|  0.00%|                        "Required"
   990|         0|            0|            0|  0.00%|                    )
   991|         0|            0|            0|  0.00%|                if NotRequired in qualifiers:
   992|         0|            0|            0|  0.00%|                    raise TypeError(
   993|         0|            0|            0|  0.00%|                        "Special key __extra_items__ does not support "
   994|         0|            0|            0|  0.00%|                        "NotRequired"
   995|         0|            0|            0|  0.00%|                    )
   996|         0|            0|            0|  0.00%|                extra_items_type = annotation_type
   997|         0|            0|            0|  0.00%|
   998|         0|            0|            0|  0.00%|            annotations.update(own_annotations)
   999|         0|            0|            0|  0.00%|            for annotation_key, annotation_type in own_annotations.items():
  1000|         0|            0|            0|  0.00%|                qualifiers = set(_get_typeddict_qualifiers(annotation_type))
  1001|         0|            0|            0|  0.00%|
  1002|         0|            0|            0|  0.00%|                if Required in qualifiers:
  1003|         0|            0|            0|  0.00%|                    required_keys.add(annotation_key)
  1004|         0|            0|            0|  0.00%|                elif NotRequired in qualifiers:
  1005|         0|            0|            0|  0.00%|                    optional_keys.add(annotation_key)
  1006|         0|            0|            0|  0.00%|                elif total:
  1007|         0|            0|            0|  0.00%|                    required_keys.add(annotation_key)
  1008|         0|            0|            0|  0.00%|                else:
  1009|         0|            0|            0|  0.00%|                    optional_keys.add(annotation_key)
  1010|         0|            0|            0|  0.00%|                if ReadOnly in qualifiers:
  1011|         0|            0|            0|  0.00%|                    mutable_keys.discard(annotation_key)
  1012|         0|            0|            0|  0.00%|                    readonly_keys.add(annotation_key)
  1013|         0|            0|            0|  0.00%|                else:
  1014|         0|            0|            0|  0.00%|                    mutable_keys.add(annotation_key)
  1015|         0|            0|            0|  0.00%|                    readonly_keys.discard(annotation_key)
  1016|         0|            0|            0|  0.00%|
  1017|         0|            0|            0|  0.00%|            tp_dict.__annotations__ = annotations
  1018|         0|            0|            0|  0.00%|            tp_dict.__required_keys__ = frozenset(required_keys)
  1019|         0|            0|            0|  0.00%|            tp_dict.__optional_keys__ = frozenset(optional_keys)
  1020|         0|            0|            0|  0.00%|            tp_dict.__readonly_keys__ = frozenset(readonly_keys)
  1021|         0|            0|            0|  0.00%|            tp_dict.__mutable_keys__ = frozenset(mutable_keys)
  1022|         0|            0|            0|  0.00%|            if not hasattr(tp_dict, '__total__'):
  1023|         0|            0|            0|  0.00%|                tp_dict.__total__ = total
  1024|         0|            0|            0|  0.00%|            tp_dict.__closed__ = closed
  1025|         0|            0|            0|  0.00%|            tp_dict.__extra_items__ = extra_items_type
  1026|         0|            0|            0|  0.00%|            return tp_dict
  1027|         0|            0|            0|  0.00%|
  1028|         0|            0|            0|  0.00%|        __call__ = dict  # static method
  1029|         0|            0|            0|  0.00%|
  1030|         0|            0|            0|  0.00%|        def __subclasscheck__(cls, other):
  1031|         0|            0|            0|  0.00%|            # Typed dicts are only for static structural subtyping.
  1032|         0|            0|            0|  0.00%|            raise TypeError('TypedDict does not support instance and class checks')
  1033|         0|            0|            0|  0.00%|
  1034|         0|            0|            0|  0.00%|        __instancecheck__ = __subclasscheck__
  1035|         0|            0|            0|  0.00%|
  1036|         0|            0|            0|  0.00%|    _TypedDict = type.__new__(_TypedDictMeta, 'TypedDict', (), {})
  1037|         0|            0|            0|  0.00%|
  1038|         0|            0|            0|  0.00%|    @_ensure_subclassable(lambda bases: (_TypedDict,))
  1039|         0|            0|            0|  0.00%|    def TypedDict(typename, fields=_marker, /, *, total=True, closed=False, **kwargs):
  1040|         0|            0|            0|  0.00%|        """A simple typed namespace. At runtime it is equivalent to a plain dict.
  1041|         0|            0|            0|  0.00%|
  1042|         0|            0|            0|  0.00%|        TypedDict creates a dictionary type such that a type checker will expect all
  1043|         0|            0|            0|  0.00%|        instances to have a certain set of keys, where each key is
  1044|         0|            0|            0|  0.00%|        associated with a value of a consistent type. This expectation
  1045|         0|            0|            0|  0.00%|        is not checked at runtime.
  1046|         0|            0|            0|  0.00%|
  1047|         0|            0|            0|  0.00%|        Usage::
  1048|         0|            0|            0|  0.00%|
  1049|         0|            0|            0|  0.00%|            class Point2D(TypedDict):
  1050|         0|            0|            0|  0.00%|                x: int
  1051|         0|            0|            0|  0.00%|                y: int
  1052|         0|            0|            0|  0.00%|                label: str
  1053|         0|            0|            0|  0.00%|
  1054|         0|            0|            0|  0.00%|            a: Point2D = {'x': 1, 'y': 2, 'label': 'good'}  # OK
  1055|         0|            0|            0|  0.00%|            b: Point2D = {'z': 3, 'label': 'bad'}           # Fails type check
  1056|         0|            0|            0|  0.00%|
  1057|         0|            0|            0|  0.00%|            assert Point2D(x=1, y=2, label='first') == dict(x=1, y=2, label='first')
  1058|         0|            0|            0|  0.00%|
  1059|         0|            0|            0|  0.00%|        The type info can be accessed via the Point2D.__annotations__ dict, and
  1060|         0|            0|            0|  0.00%|        the Point2D.__required_keys__ and Point2D.__optional_keys__ frozensets.
  1061|         0|            0|            0|  0.00%|        TypedDict supports an additional equivalent form::
  1062|         0|            0|            0|  0.00%|
  1063|         0|            0|            0|  0.00%|            Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': str})
  1064|         0|            0|            0|  0.00%|
  1065|         0|            0|            0|  0.00%|        By default, all keys must be present in a TypedDict. It is possible
  1066|         0|            0|            0|  0.00%|        to override this by specifying totality::
  1067|         0|            0|            0|  0.00%|
  1068|         0|            0|            0|  0.00%|            class Point2D(TypedDict, total=False):
  1069|         0|            0|            0|  0.00%|                x: int
  1070|         0|            0|            0|  0.00%|                y: int
  1071|         0|            0|            0|  0.00%|
  1072|         0|            0|            0|  0.00%|        This means that a Point2D TypedDict can have any of the keys omitted. A type
  1073|         0|            0|            0|  0.00%|        checker is only expected to support a literal False or True as the value of
  1074|         0|            0|            0|  0.00%|        the total argument. True is the default, and makes all items defined in the
  1075|         0|            0|            0|  0.00%|        class body be required.
  1076|         0|            0|            0|  0.00%|
  1077|         0|            0|            0|  0.00%|        The Required and NotRequired special forms can also be used to mark
  1078|         0|            0|            0|  0.00%|        individual keys as being required or not required::
  1079|         0|            0|            0|  0.00%|
  1080|         0|            0|            0|  0.00%|            class Point2D(TypedDict):
  1081|         0|            0|            0|  0.00%|                x: int  # the "x" key must always be present (Required is the default)
  1082|         0|            0|            0|  0.00%|                y: NotRequired[int]  # the "y" key can be omitted
  1083|         0|            0|            0|  0.00%|
  1084|         0|            0|            0|  0.00%|        See PEP 655 for more details on Required and NotRequired.
  1085|         0|            0|            0|  0.00%|        """
  1086|         0|            0|            0|  0.00%|        if fields is _marker or fields is None:
  1087|         0|            0|            0|  0.00%|            if fields is _marker:
  1088|         0|            0|            0|  0.00%|                deprecated_thing = "Failing to pass a value for the 'fields' parameter"
  1089|         0|            0|            0|  0.00%|            else:
  1090|         0|            0|            0|  0.00%|                deprecated_thing = "Passing `None` as the 'fields' parameter"
  1091|         0|            0|            0|  0.00%|
  1092|         0|            0|            0|  0.00%|            example = f"`{typename} = TypedDict({typename!r}, {{}})`"
  1093|         0|            0|            0|  0.00%|            deprecation_msg = (
  1094|         0|            0|            0|  0.00%|                f"{deprecated_thing} is deprecated and will be disallowed in "
  1095|         0|            0|            0|  0.00%|                "Python 3.15. To create a TypedDict class with 0 fields "
  1096|         0|            0|            0|  0.00%|                "using the functional syntax, pass an empty dictionary, e.g. "
  1097|         0|            0|            0|  0.00%|            ) + example + "."
  1098|         0|            0|            0|  0.00%|            warnings.warn(deprecation_msg, DeprecationWarning, stacklevel=2)
  1099|         0|            0|            0|  0.00%|            if closed is not False and closed is not True:
  1100|         0|            0|            0|  0.00%|                kwargs["closed"] = closed
  1101|         0|            0|            0|  0.00%|                closed = False
  1102|         0|            0|            0|  0.00%|            fields = kwargs
  1103|         0|            0|            0|  0.00%|        elif kwargs:
  1104|         0|            0|            0|  0.00%|            raise TypeError("TypedDict takes either a dict or keyword arguments,"
  1105|         0|            0|            0|  0.00%|                            " but not both")
  1106|         0|            0|            0|  0.00%|        if kwargs:
  1107|         0|            0|            0|  0.00%|            if sys.version_info >= (3, 13):
  1108|         0|            0|            0|  0.00%|                raise TypeError("TypedDict takes no keyword arguments")
  1109|         0|            0|            0|  0.00%|            warnings.warn(
  1110|         0|            0|            0|  0.00%|                "The kwargs-based syntax for TypedDict definitions is deprecated "
  1111|         0|            0|            0|  0.00%|                "in Python 3.11, will be removed in Python 3.13, and may not be "
  1112|         0|            0|            0|  0.00%|                "understood by third-party type checkers.",
  1113|         0|            0|            0|  0.00%|                DeprecationWarning,
  1114|         0|            0|            0|  0.00%|                stacklevel=2,
  1115|         0|            0|            0|  0.00%|            )
  1116|         0|            0|            0|  0.00%|
  1117|         0|            0|            0|  0.00%|        ns = {'__annotations__': dict(fields)}
  1118|         0|            0|            0|  0.00%|        module = _caller()
  1119|         0|            0|            0|  0.00%|        if module is not None:
  1120|         0|            0|            0|  0.00%|            # Setting correct module is necessary to make typed dict classes pickleable.
  1121|         0|            0|            0|  0.00%|            ns['__module__'] = module
  1122|         0|            0|            0|  0.00%|
  1123|         0|            0|            0|  0.00%|        td = _TypedDictMeta(typename, (), ns, total=total, closed=closed)
  1124|         0|            0|            0|  0.00%|        td.__orig_bases__ = (TypedDict,)
  1125|         0|            0|            0|  0.00%|        return td
  1126|         0|            0|            0|  0.00%|
  1127|         0|            0|            0|  0.00%|    if hasattr(typing, "_TypedDictMeta"):
  1128|         0|            0|            0|  0.00%|        _TYPEDDICT_TYPES = (typing._TypedDictMeta, _TypedDictMeta)
  1129|         0|            0|            0|  0.00%|    else:
  1130|         0|            0|            0|  0.00%|        _TYPEDDICT_TYPES = (_TypedDictMeta,)
  1131|         0|            0|            0|  0.00%|
  1132|         2|  4.05312e-06|  2.02656e-06|  0.00%|    def is_typeddict(tp):
  1133|         0|            0|            0|  0.00%|        """Check if an annotation is a TypedDict class
  1134|         0|            0|            0|  0.00%|
  1135|         0|            0|            0|  0.00%|        For example::
  1136|         0|            0|            0|  0.00%|            class Film(TypedDict):
  1137|         0|            0|            0|  0.00%|                title: str
  1138|         0|            0|            0|  0.00%|                year: int
  1139|         0|            0|            0|  0.00%|
  1140|         0|            0|            0|  0.00%|            is_typeddict(Film)  # => True
  1141|         0|            0|            0|  0.00%|            is_typeddict(Union[list, str])  # => False
  1142|         0|            0|            0|  0.00%|        """
  1143|         0|            0|            0|  0.00%|        # On 3.8, this would otherwise return True
  1144|         2|  5.48363e-06|  2.74181e-06|  0.01%|        if hasattr(typing, "TypedDict") and tp is typing.TypedDict:
  1145|         0|            0|            0|  0.00%|            return False
  1146|         2|  4.05312e-06|  2.02656e-06|  0.00%|        return isinstance(tp, _TYPEDDICT_TYPES)
  1147|         0|            0|            0|  0.00%|
  1148|         0|            0|            0|  0.00%|
  1149|         0|            0|            0|  0.00%|if hasattr(typing, "assert_type"):
  1150|         0|            0|            0|  0.00%|    assert_type = typing.assert_type
  1151|         0|            0|            0|  0.00%|
  1152|         0|            0|            0|  0.00%|else:
  1153|         0|            0|            0|  0.00%|    def assert_type(val, typ, /):
  1154|         0|            0|            0|  0.00%|        """Assert (to the type checker) that the value is of the given type.
  1155|         0|            0|            0|  0.00%|
  1156|         0|            0|            0|  0.00%|        When the type checker encounters a call to assert_type(), it
  1157|         0|            0|            0|  0.00%|        emits an error if the value is not of the specified type::
  1158|         0|            0|            0|  0.00%|
  1159|         0|            0|            0|  0.00%|            def greet(name: str) -> None:
  1160|         0|            0|            0|  0.00%|                assert_type(name, str)  # ok
  1161|         0|            0|            0|  0.00%|                assert_type(name, int)  # type checker error
  1162|         0|            0|            0|  0.00%|
  1163|         0|            0|            0|  0.00%|        At runtime this returns the first argument unchanged and otherwise
  1164|         0|            0|            0|  0.00%|        does nothing.
  1165|         0|            0|            0|  0.00%|        """
  1166|         0|            0|            0|  0.00%|        return val
  1167|         0|            0|            0|  0.00%|
  1168|         0|            0|            0|  0.00%|
  1169|         0|            0|            0|  0.00%|if hasattr(typing, "ReadOnly"):  # 3.13+
  1170|         0|            0|            0|  0.00%|    get_type_hints = typing.get_type_hints
  1171|         0|            0|            0|  0.00%|else:  # <=3.13
  1172|         0|            0|            0|  0.00%|    # replaces _strip_annotations()
  1173|         0|            0|            0|  0.00%|    def _strip_extras(t):
  1174|         0|            0|            0|  0.00%|        """Strips Annotated, Required and NotRequired from a given type."""
  1175|         0|            0|            0|  0.00%|        if isinstance(t, _AnnotatedAlias):
  1176|         0|            0|            0|  0.00%|            return _strip_extras(t.__origin__)
  1177|         0|            0|            0|  0.00%|        if hasattr(t, "__origin__") and t.__origin__ in (Required, NotRequired, ReadOnly):
  1178|         0|            0|            0|  0.00%|            return _strip_extras(t.__args__[0])
  1179|         0|            0|            0|  0.00%|        if isinstance(t, typing._GenericAlias):
  1180|         0|            0|            0|  0.00%|            stripped_args = tuple(_strip_extras(a) for a in t.__args__)
  1181|         0|            0|            0|  0.00%|            if stripped_args == t.__args__:
  1182|         0|            0|            0|  0.00%|                return t
  1183|         0|            0|            0|  0.00%|            return t.copy_with(stripped_args)
  1184|         0|            0|            0|  0.00%|        if hasattr(_types, "GenericAlias") and isinstance(t, _types.GenericAlias):
  1185|         0|            0|            0|  0.00%|            stripped_args = tuple(_strip_extras(a) for a in t.__args__)
  1186|         0|            0|            0|  0.00%|            if stripped_args == t.__args__:
  1187|         0|            0|            0|  0.00%|                return t
  1188|         0|            0|            0|  0.00%|            return _types.GenericAlias(t.__origin__, stripped_args)
  1189|         0|            0|            0|  0.00%|        if hasattr(_types, "UnionType") and isinstance(t, _types.UnionType):
  1190|         0|            0|            0|  0.00%|            stripped_args = tuple(_strip_extras(a) for a in t.__args__)
  1191|         0|            0|            0|  0.00%|            if stripped_args == t.__args__:
  1192|         0|            0|            0|  0.00%|                return t
  1193|         0|            0|            0|  0.00%|            return functools.reduce(operator.or_, stripped_args)
  1194|         0|            0|            0|  0.00%|
  1195|         0|            0|            0|  0.00%|        return t
  1196|         0|            0|            0|  0.00%|
  1197|         0|            0|            0|  0.00%|    def get_type_hints(obj, globalns=None, localns=None, include_extras=False):
  1198|         0|            0|            0|  0.00%|        """Return type hints for an object.
  1199|         0|            0|            0|  0.00%|
  1200|         0|            0|            0|  0.00%|        This is often the same as obj.__annotations__, but it handles
  1201|         0|            0|            0|  0.00%|        forward references encoded as string literals, adds Optional[t] if a
  1202|         0|            0|            0|  0.00%|        default value equal to None is set and recursively replaces all
  1203|         0|            0|            0|  0.00%|        'Annotated[T, ...]', 'Required[T]' or 'NotRequired[T]' with 'T'
  1204|         0|            0|            0|  0.00%|        (unless 'include_extras=True').
  1205|         0|            0|            0|  0.00%|
  1206|         0|            0|            0|  0.00%|        The argument may be a module, class, method, or function. The annotations
  1207|         0|            0|            0|  0.00%|        are returned as a dictionary. For classes, annotations include also
  1208|         0|            0|            0|  0.00%|        inherited members.
  1209|         0|            0|            0|  0.00%|
  1210|         0|            0|            0|  0.00%|        TypeError is raised if the argument is not of a type that can contain
  1211|         0|            0|            0|  0.00%|        annotations, and an empty dictionary is returned if no annotations are
  1212|         0|            0|            0|  0.00%|        present.
  1213|         0|            0|            0|  0.00%|
  1214|         0|            0|            0|  0.00%|        BEWARE -- the behavior of globalns and localns is counterintuitive
  1215|         0|            0|            0|  0.00%|        (unless you are familiar with how eval() and exec() work).  The
  1216|         0|            0|            0|  0.00%|        search order is locals first, then globals.
  1217|         0|            0|            0|  0.00%|
  1218|         0|            0|            0|  0.00%|        - If no dict arguments are passed, an attempt is made to use the
  1219|         0|            0|            0|  0.00%|          globals from obj (or the respective module's globals for classes),
  1220|         0|            0|            0|  0.00%|          and these are also used as the locals.  If the object does not appear
  1221|         0|            0|            0|  0.00%|          to have globals, an empty dictionary is used.
  1222|         0|            0|            0|  0.00%|
  1223|         0|            0|            0|  0.00%|        - If one dict argument is passed, it is used for both globals and
  1224|         0|            0|            0|  0.00%|          locals.
  1225|         0|            0|            0|  0.00%|
  1226|         0|            0|            0|  0.00%|        - If two dict arguments are passed, they specify globals and
  1227|         0|            0|            0|  0.00%|          locals, respectively.
  1228|         0|            0|            0|  0.00%|        """
  1229|         0|            0|            0|  0.00%|        if hasattr(typing, "Annotated"):  # 3.9+
  1230|         0|            0|            0|  0.00%|            hint = typing.get_type_hints(
  1231|         0|            0|            0|  0.00%|                obj, globalns=globalns, localns=localns, include_extras=True
  1232|         0|            0|            0|  0.00%|            )
  1233|         0|            0|            0|  0.00%|        else:  # 3.8
  1234|         0|            0|            0|  0.00%|            hint = typing.get_type_hints(obj, globalns=globalns, localns=localns)
  1235|         0|            0|            0|  0.00%|        if include_extras:
  1236|         0|            0|            0|  0.00%|            return hint
  1237|         0|            0|            0|  0.00%|        return {k: _strip_extras(t) for k, t in hint.items()}
  1238|         0|            0|            0|  0.00%|
  1239|         0|            0|            0|  0.00%|
  1240|         0|            0|            0|  0.00%|# Python 3.9+ has PEP 593 (Annotated)
  1241|         0|            0|            0|  0.00%|if hasattr(typing, 'Annotated'):
  1242|         0|            0|            0|  0.00%|    Annotated = typing.Annotated
  1243|         0|            0|            0|  0.00%|    # Not exported and not a public API, but needed for get_origin() and get_args()
  1244|         0|            0|            0|  0.00%|    # to work.
  1245|         0|            0|            0|  0.00%|    _AnnotatedAlias = typing._AnnotatedAlias
  1246|         0|            0|            0|  0.00%|# 3.8
  1247|         0|            0|            0|  0.00%|else:
  1248|         0|            0|            0|  0.00%|    class _AnnotatedAlias(typing._GenericAlias, _root=True):
  1249|         0|            0|            0|  0.00%|        """Runtime representation of an annotated type.
  1250|         0|            0|            0|  0.00%|
  1251|         0|            0|            0|  0.00%|        At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
  1252|         0|            0|            0|  0.00%|        with extra annotations. The alias behaves like a normal typing alias,
  1253|         0|            0|            0|  0.00%|        instantiating is the same as instantiating the underlying type, binding
  1254|         0|            0|            0|  0.00%|        it to types is also the same.
  1255|         0|            0|            0|  0.00%|        """
  1256|         0|            0|            0|  0.00%|        def __init__(self, origin, metadata):
  1257|         0|            0|            0|  0.00%|            if isinstance(origin, _AnnotatedAlias):
  1258|         0|            0|            0|  0.00%|                metadata = origin.__metadata__ + metadata
  1259|         0|            0|            0|  0.00%|                origin = origin.__origin__
  1260|         0|            0|            0|  0.00%|            super().__init__(origin, origin)
  1261|         0|            0|            0|  0.00%|            self.__metadata__ = metadata
  1262|         0|            0|            0|  0.00%|
  1263|         0|            0|            0|  0.00%|        def copy_with(self, params):
  1264|         0|            0|            0|  0.00%|            assert len(params) == 1
  1265|         0|            0|            0|  0.00%|            new_type = params[0]
  1266|         0|            0|            0|  0.00%|            return _AnnotatedAlias(new_type, self.__metadata__)
  1267|         0|            0|            0|  0.00%|
  1268|         0|            0|            0|  0.00%|        def __repr__(self):
  1269|         0|            0|            0|  0.00%|            return (f"typing_extensions.Annotated[{typing._type_repr(self.__origin__)}, "
  1270|         0|            0|            0|  0.00%|                    f"{', '.join(repr(a) for a in self.__metadata__)}]")
  1271|         0|            0|            0|  0.00%|
  1272|         0|            0|            0|  0.00%|        def __reduce__(self):
  1273|         0|            0|            0|  0.00%|            return operator.getitem, (
  1274|         0|            0|            0|  0.00%|                Annotated, (self.__origin__, *self.__metadata__)
  1275|         0|            0|            0|  0.00%|            )
  1276|         0|            0|            0|  0.00%|
  1277|         0|            0|            0|  0.00%|        def __eq__(self, other):
  1278|         0|            0|            0|  0.00%|            if not isinstance(other, _AnnotatedAlias):
  1279|         0|            0|            0|  0.00%|                return NotImplemented
  1280|         0|            0|            0|  0.00%|            if self.__origin__ != other.__origin__:
  1281|         0|            0|            0|  0.00%|                return False
  1282|         0|            0|            0|  0.00%|            return self.__metadata__ == other.__metadata__
  1283|         0|            0|            0|  0.00%|
  1284|         0|            0|            0|  0.00%|        def __hash__(self):
  1285|         0|            0|            0|  0.00%|            return hash((self.__origin__, self.__metadata__))
  1286|         0|            0|            0|  0.00%|
  1287|         0|            0|            0|  0.00%|    class Annotated:
  1288|         0|            0|            0|  0.00%|        """Add context specific metadata to a type.
  1289|         0|            0|            0|  0.00%|
  1290|         0|            0|            0|  0.00%|        Example: Annotated[int, runtime_check.Unsigned] indicates to the
  1291|         0|            0|            0|  0.00%|        hypothetical runtime_check module that this type is an unsigned int.
  1292|         0|            0|            0|  0.00%|        Every other consumer of this type can ignore this metadata and treat
  1293|         0|            0|            0|  0.00%|        this type as int.
  1294|         0|            0|            0|  0.00%|
  1295|         0|            0|            0|  0.00%|        The first argument to Annotated must be a valid type (and will be in
  1296|         0|            0|            0|  0.00%|        the __origin__ field), the remaining arguments are kept as a tuple in
  1297|         0|            0|            0|  0.00%|        the __extra__ field.
  1298|         0|            0|            0|  0.00%|
  1299|         0|            0|            0|  0.00%|        Details:
  1300|         0|            0|            0|  0.00%|
  1301|         0|            0|            0|  0.00%|        - It's an error to call `Annotated` with less than two arguments.
  1302|         0|            0|            0|  0.00%|        - Nested Annotated are flattened::
  1303|         0|            0|            0|  0.00%|
  1304|         0|            0|            0|  0.00%|            Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3]
  1305|         0|            0|            0|  0.00%|
  1306|         0|            0|            0|  0.00%|        - Instantiating an annotated type is equivalent to instantiating the
  1307|         0|            0|            0|  0.00%|        underlying type::
  1308|         0|            0|            0|  0.00%|
  1309|         0|            0|            0|  0.00%|            Annotated[C, Ann1](5) == C(5)
  1310|         0|            0|            0|  0.00%|
  1311|         0|            0|            0|  0.00%|        - Annotated can be used as a generic type alias::
  1312|         0|            0|            0|  0.00%|
  1313|         0|            0|            0|  0.00%|            Optimized = Annotated[T, runtime.Optimize()]
  1314|         0|            0|            0|  0.00%|            Optimized[int] == Annotated[int, runtime.Optimize()]
  1315|         0|            0|            0|  0.00%|
  1316|         0|            0|            0|  0.00%|            OptimizedList = Annotated[List[T], runtime.Optimize()]
  1317|         0|            0|            0|  0.00%|            OptimizedList[int] == Annotated[List[int], runtime.Optimize()]
  1318|         0|            0|            0|  0.00%|        """
  1319|         0|            0|            0|  0.00%|
  1320|         0|            0|            0|  0.00%|        __slots__ = ()
  1321|         0|            0|            0|  0.00%|
  1322|         0|            0|            0|  0.00%|        def __new__(cls, *args, **kwargs):
  1323|         0|            0|            0|  0.00%|            raise TypeError("Type Annotated cannot be instantiated.")
  1324|         0|            0|            0|  0.00%|
  1325|         0|            0|            0|  0.00%|        @typing._tp_cache
  1326|         0|            0|            0|  0.00%|        def __class_getitem__(cls, params):
  1327|         0|            0|            0|  0.00%|            if not isinstance(params, tuple) or len(params) < 2:
  1328|         0|            0|            0|  0.00%|                raise TypeError("Annotated[...] should be used "
  1329|         0|            0|            0|  0.00%|                                "with at least two arguments (a type and an "
  1330|         0|            0|            0|  0.00%|                                "annotation).")
  1331|         0|            0|            0|  0.00%|            allowed_special_forms = (ClassVar, Final)
  1332|         0|            0|            0|  0.00%|            if get_origin(params[0]) in allowed_special_forms:
  1333|         0|            0|            0|  0.00%|                origin = params[0]
  1334|         0|            0|            0|  0.00%|            else:
  1335|         0|            0|            0|  0.00%|                msg = "Annotated[t, ...]: t must be a type."
  1336|         0|            0|            0|  0.00%|                origin = typing._type_check(params[0], msg)
  1337|         0|            0|            0|  0.00%|            metadata = tuple(params[1:])
  1338|         0|            0|            0|  0.00%|            return _AnnotatedAlias(origin, metadata)
  1339|         0|            0|            0|  0.00%|
  1340|         0|            0|            0|  0.00%|        def __init_subclass__(cls, *args, **kwargs):
  1341|         0|            0|            0|  0.00%|            raise TypeError(
  1342|         0|            0|            0|  0.00%|                f"Cannot subclass {cls.__module__}.Annotated"
  1343|         0|            0|            0|  0.00%|            )
  1344|         0|            0|            0|  0.00%|
  1345|         0|            0|            0|  0.00%|# Python 3.8 has get_origin() and get_args() but those implementations aren't
  1346|         0|            0|            0|  0.00%|# Annotated-aware, so we can't use those. Python 3.9's versions don't support
  1347|         0|            0|            0|  0.00%|# ParamSpecArgs and ParamSpecKwargs, so only Python 3.10's versions will do.
  1348|         0|            0|            0|  0.00%|if sys.version_info[:2] >= (3, 10):
  1349|         0|            0|            0|  0.00%|    get_origin = typing.get_origin
  1350|         0|            0|            0|  0.00%|    get_args = typing.get_args
  1351|         0|            0|            0|  0.00%|# 3.8-3.9
  1352|         0|            0|            0|  0.00%|else:
  1353|         0|            0|            0|  0.00%|    try:
  1354|         0|            0|            0|  0.00%|        # 3.9+
  1355|         0|            0|            0|  0.00%|        from typing import _BaseGenericAlias
  1356|         0|            0|            0|  0.00%|    except ImportError:
  1357|         0|            0|            0|  0.00%|        _BaseGenericAlias = typing._GenericAlias
  1358|         0|            0|            0|  0.00%|    try:
  1359|         0|            0|            0|  0.00%|        # 3.9+
  1360|         0|            0|            0|  0.00%|        from typing import GenericAlias as _typing_GenericAlias
  1361|         0|            0|            0|  0.00%|    except ImportError:
  1362|         0|            0|            0|  0.00%|        _typing_GenericAlias = typing._GenericAlias
  1363|         0|            0|            0|  0.00%|
  1364|         0|            0|            0|  0.00%|    def get_origin(tp):
  1365|         0|            0|            0|  0.00%|        """Get the unsubscripted version of a type.
  1366|         0|            0|            0|  0.00%|
  1367|         0|            0|            0|  0.00%|        This supports generic types, Callable, Tuple, Union, Literal, Final, ClassVar
  1368|         0|            0|            0|  0.00%|        and Annotated. Return None for unsupported types. Examples::
  1369|         0|            0|            0|  0.00%|
  1370|         0|            0|            0|  0.00%|            get_origin(Literal[42]) is Literal
  1371|         0|            0|            0|  0.00%|            get_origin(int) is None
  1372|         0|            0|            0|  0.00%|            get_origin(ClassVar[int]) is ClassVar
  1373|         0|            0|            0|  0.00%|            get_origin(Generic) is Generic
  1374|         0|            0|            0|  0.00%|            get_origin(Generic[T]) is Generic
  1375|         0|            0|            0|  0.00%|            get_origin(Union[T, int]) is Union
  1376|         0|            0|            0|  0.00%|            get_origin(List[Tuple[T, T]][int]) == list
  1377|         0|            0|            0|  0.00%|            get_origin(P.args) is P
  1378|         0|            0|            0|  0.00%|        """
  1379|         0|            0|            0|  0.00%|        if isinstance(tp, _AnnotatedAlias):
  1380|         0|            0|            0|  0.00%|            return Annotated
  1381|         0|            0|            0|  0.00%|        if isinstance(tp, (typing._GenericAlias, _typing_GenericAlias, _BaseGenericAlias,
  1382|         0|            0|            0|  0.00%|                           ParamSpecArgs, ParamSpecKwargs)):
  1383|         0|            0|            0|  0.00%|            return tp.__origin__
  1384|         0|            0|            0|  0.00%|        if tp is typing.Generic:
  1385|         0|            0|            0|  0.00%|            return typing.Generic
  1386|         0|            0|            0|  0.00%|        return None
  1387|         0|            0|            0|  0.00%|
  1388|         0|            0|            0|  0.00%|    def get_args(tp):
  1389|         0|            0|            0|  0.00%|        """Get type arguments with all substitutions performed.
  1390|         0|            0|            0|  0.00%|
  1391|         0|            0|            0|  0.00%|        For unions, basic simplifications used by Union constructor are performed.
  1392|         0|            0|            0|  0.00%|        Examples::
  1393|         0|            0|            0|  0.00%|            get_args(Dict[str, int]) == (str, int)
  1394|         0|            0|            0|  0.00%|            get_args(int) == ()
  1395|         0|            0|            0|  0.00%|            get_args(Union[int, Union[T, int], str][int]) == (int, str)
  1396|         0|            0|            0|  0.00%|            get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int])
  1397|         0|            0|            0|  0.00%|            get_args(Callable[[], T][int]) == ([], int)
  1398|         0|            0|            0|  0.00%|        """
  1399|         0|            0|            0|  0.00%|        if isinstance(tp, _AnnotatedAlias):
  1400|         0|            0|            0|  0.00%|            return (tp.__origin__, *tp.__metadata__)
  1401|         0|            0|            0|  0.00%|        if isinstance(tp, (typing._GenericAlias, _typing_GenericAlias)):
  1402|         0|            0|            0|  0.00%|            if getattr(tp, "_special", False):
  1403|         0|            0|            0|  0.00%|                return ()
  1404|         0|            0|            0|  0.00%|            res = tp.__args__
  1405|         0|            0|            0|  0.00%|            if get_origin(tp) is collections.abc.Callable and res[0] is not Ellipsis:
  1406|         0|            0|            0|  0.00%|                res = (list(res[:-1]), res[-1])
  1407|         0|            0|            0|  0.00%|            return res
  1408|         0|            0|            0|  0.00%|        return ()
  1409|         0|            0|            0|  0.00%|
  1410|         0|            0|            0|  0.00%|
  1411|         0|            0|            0|  0.00%|# 3.10+
  1412|         0|            0|            0|  0.00%|if hasattr(typing, 'TypeAlias'):
  1413|         0|            0|            0|  0.00%|    TypeAlias = typing.TypeAlias
  1414|         0|            0|            0|  0.00%|# 3.9
  1415|         0|            0|            0|  0.00%|elif sys.version_info[:2] >= (3, 9):
  1416|         0|            0|            0|  0.00%|    @_ExtensionsSpecialForm
  1417|         0|            0|            0|  0.00%|    def TypeAlias(self, parameters):
  1418|         0|            0|            0|  0.00%|        """Special marker indicating that an assignment should
  1419|         0|            0|            0|  0.00%|        be recognized as a proper type alias definition by type
  1420|         0|            0|            0|  0.00%|        checkers.
  1421|         0|            0|            0|  0.00%|
  1422|         0|            0|            0|  0.00%|        For example::
  1423|         0|            0|            0|  0.00%|
  1424|         0|            0|            0|  0.00%|            Predicate: TypeAlias = Callable[..., bool]
  1425|         0|            0|            0|  0.00%|
  1426|         0|            0|            0|  0.00%|        It's invalid when used anywhere except as in the example above.
  1427|         0|            0|            0|  0.00%|        """
  1428|         0|            0|            0|  0.00%|        raise TypeError(f"{self} is not subscriptable")
  1429|         0|            0|            0|  0.00%|# 3.8
  1430|         0|            0|            0|  0.00%|else:
  1431|         0|            0|            0|  0.00%|    TypeAlias = _ExtensionsSpecialForm(
  1432|         0|            0|            0|  0.00%|        'TypeAlias',
  1433|         0|            0|            0|  0.00%|        doc="""Special marker indicating that an assignment should
  1434|         0|            0|            0|  0.00%|        be recognized as a proper type alias definition by type
  1435|         0|            0|            0|  0.00%|        checkers.
  1436|         0|            0|            0|  0.00%|
  1437|         0|            0|            0|  0.00%|        For example::
  1438|         0|            0|            0|  0.00%|
  1439|         0|            0|            0|  0.00%|            Predicate: TypeAlias = Callable[..., bool]
  1440|         0|            0|            0|  0.00%|
  1441|         0|            0|            0|  0.00%|        It's invalid when used anywhere except as in the example
  1442|         0|            0|            0|  0.00%|        above."""
  1443|         0|            0|            0|  0.00%|    )
  1444|         0|            0|            0|  0.00%|
  1445|         0|            0|            0|  0.00%|
  1446|         0|            0|            0|  0.00%|if hasattr(typing, "NoDefault"):
  1447|         0|            0|            0|  0.00%|    NoDefault = typing.NoDefault
  1448|         0|            0|            0|  0.00%|else:
  1449|         0|            0|            0|  0.00%|    class NoDefaultTypeMeta(type):
  1450|         0|            0|            0|  0.00%|        def __setattr__(cls, attr, value):
  1451|         0|            0|            0|  0.00%|            # TypeError is consistent with the behavior of NoneType
  1452|         0|            0|            0|  0.00%|            raise TypeError(
  1453|         0|            0|            0|  0.00%|                f"cannot set {attr!r} attribute of immutable type {cls.__name__!r}"
  1454|         0|            0|            0|  0.00%|            )
  1455|         0|            0|            0|  0.00%|
  1456|         0|            0|            0|  0.00%|    class NoDefaultType(metaclass=NoDefaultTypeMeta):
  1457|         0|            0|            0|  0.00%|        """The type of the NoDefault singleton."""
  1458|         0|            0|            0|  0.00%|
  1459|         0|            0|            0|  0.00%|        __slots__ = ()
  1460|         0|            0|            0|  0.00%|
  1461|         0|            0|            0|  0.00%|        def __new__(cls):
  1462|         0|            0|            0|  0.00%|            return globals().get("NoDefault") or object.__new__(cls)
  1463|         0|            0|            0|  0.00%|
  1464|         0|            0|            0|  0.00%|        def __repr__(self):
  1465|         0|            0|            0|  0.00%|            return "typing_extensions.NoDefault"
  1466|         0|            0|            0|  0.00%|
  1467|         0|            0|            0|  0.00%|        def __reduce__(self):
  1468|         0|            0|            0|  0.00%|            return "NoDefault"
  1469|         0|            0|            0|  0.00%|
  1470|         0|            0|            0|  0.00%|    NoDefault = NoDefaultType()
  1471|         0|            0|            0|  0.00%|    del NoDefaultType, NoDefaultTypeMeta
  1472|         0|            0|            0|  0.00%|
  1473|         0|            0|            0|  0.00%|
  1474|         0|            0|            0|  0.00%|def _set_default(type_param, default):
  1475|         0|            0|            0|  0.00%|    type_param.has_default = lambda: default is not NoDefault
  1476|         0|            0|            0|  0.00%|    type_param.__default__ = default
  1477|         0|            0|            0|  0.00%|
  1478|         0|            0|            0|  0.00%|
  1479|         0|            0|            0|  0.00%|def _set_module(typevarlike):
  1480|         0|            0|            0|  0.00%|    # for pickling:
  1481|         0|            0|            0|  0.00%|    def_mod = _caller(depth=3)
  1482|         0|            0|            0|  0.00%|    if def_mod != 'typing_extensions':
  1483|         0|            0|            0|  0.00%|        typevarlike.__module__ = def_mod
  1484|         0|            0|            0|  0.00%|
  1485|         0|            0|            0|  0.00%|
  1486|         0|            0|            0|  0.00%|class _DefaultMixin:
  1487|         0|            0|            0|  0.00%|    """Mixin for TypeVarLike defaults."""
  1488|         0|            0|            0|  0.00%|
  1489|         0|            0|            0|  0.00%|    __slots__ = ()
  1490|         0|            0|            0|  0.00%|    __init__ = _set_default
  1491|         0|            0|            0|  0.00%|
  1492|         0|            0|            0|  0.00%|
  1493|         0|            0|            0|  0.00%|# Classes using this metaclass must provide a _backported_typevarlike ClassVar
  1494|         0|            0|            0|  0.00%|class _TypeVarLikeMeta(type):
  1495|         0|            0|            0|  0.00%|    def __instancecheck__(cls, __instance: Any) -> bool:
  1496|         0|            0|            0|  0.00%|        return isinstance(__instance, cls._backported_typevarlike)
  1497|         0|            0|            0|  0.00%|
  1498|         0|            0|            0|  0.00%|
  1499|         0|            0|            0|  0.00%|if _PEP_696_IMPLEMENTED:
  1500|         0|            0|            0|  0.00%|    from typing import TypeVar
  1501|         0|            0|            0|  0.00%|else:
  1502|         0|            0|            0|  0.00%|    # Add default and infer_variance parameters from PEP 696 and 695
  1503|         0|            0|            0|  0.00%|    class TypeVar(metaclass=_TypeVarLikeMeta):
  1504|         0|            0|            0|  0.00%|        """Type variable."""
  1505|         0|            0|            0|  0.00%|
  1506|         0|            0|            0|  0.00%|        _backported_typevarlike = typing.TypeVar
  1507|         0|            0|            0|  0.00%|
  1508|         0|            0|            0|  0.00%|        def __new__(cls, name, *constraints, bound=None,
  1509|         0|            0|            0|  0.00%|                    covariant=False, contravariant=False,
  1510|         0|            0|            0|  0.00%|                    default=NoDefault, infer_variance=False):
  1511|         0|            0|            0|  0.00%|            if hasattr(typing, "TypeAliasType"):
  1512|         0|            0|            0|  0.00%|                # PEP 695 implemented (3.12+), can pass infer_variance to typing.TypeVar
  1513|         0|            0|            0|  0.00%|                typevar = typing.TypeVar(name, *constraints, bound=bound,
  1514|         0|            0|            0|  0.00%|                                         covariant=covariant, contravariant=contravariant,
  1515|         0|            0|            0|  0.00%|                                         infer_variance=infer_variance)
  1516|         0|            0|            0|  0.00%|            else:
  1517|         0|            0|            0|  0.00%|                typevar = typing.TypeVar(name, *constraints, bound=bound,
  1518|         0|            0|            0|  0.00%|                                         covariant=covariant, contravariant=contravariant)
  1519|         0|            0|            0|  0.00%|                if infer_variance and (covariant or contravariant):
  1520|         0|            0|            0|  0.00%|                    raise ValueError("Variance cannot be specified with infer_variance.")
  1521|         0|            0|            0|  0.00%|                typevar.__infer_variance__ = infer_variance
  1522|         0|            0|            0|  0.00%|
  1523|         0|            0|            0|  0.00%|            _set_default(typevar, default)
  1524|         0|            0|            0|  0.00%|            _set_module(typevar)
  1525|         0|            0|            0|  0.00%|
  1526|         0|            0|            0|  0.00%|            def _tvar_prepare_subst(alias, args):
  1527|         0|            0|            0|  0.00%|                if (
  1528|         0|            0|            0|  0.00%|                    typevar.has_default()
  1529|         0|            0|            0|  0.00%|                    and alias.__parameters__.index(typevar) == len(args)
  1530|         0|            0|            0|  0.00%|                ):
  1531|         0|            0|            0|  0.00%|                    args += (typevar.__default__,)
  1532|         0|            0|            0|  0.00%|                return args
  1533|         0|            0|            0|  0.00%|
  1534|         0|            0|            0|  0.00%|            typevar.__typing_prepare_subst__ = _tvar_prepare_subst
  1535|         0|            0|            0|  0.00%|            return typevar
  1536|         0|            0|            0|  0.00%|
  1537|         0|            0|            0|  0.00%|        def __init_subclass__(cls) -> None:
  1538|         0|            0|            0|  0.00%|            raise TypeError(f"type '{__name__}.TypeVar' is not an acceptable base type")
  1539|         0|            0|            0|  0.00%|
  1540|         0|            0|            0|  0.00%|
  1541|         0|            0|            0|  0.00%|# Python 3.10+ has PEP 612
  1542|         0|            0|            0|  0.00%|if hasattr(typing, 'ParamSpecArgs'):
  1543|         0|            0|            0|  0.00%|    ParamSpecArgs = typing.ParamSpecArgs
  1544|         0|            0|            0|  0.00%|    ParamSpecKwargs = typing.ParamSpecKwargs
  1545|         0|            0|            0|  0.00%|# 3.8-3.9
  1546|         0|            0|            0|  0.00%|else:
  1547|         0|            0|            0|  0.00%|    class _Immutable:
  1548|         0|            0|            0|  0.00%|        """Mixin to indicate that object should not be copied."""
  1549|         0|            0|            0|  0.00%|        __slots__ = ()
  1550|         0|            0|            0|  0.00%|
  1551|         0|            0|            0|  0.00%|        def __copy__(self):
  1552|         0|            0|            0|  0.00%|            return self
  1553|         0|            0|            0|  0.00%|
  1554|         0|            0|            0|  0.00%|        def __deepcopy__(self, memo):
  1555|         0|            0|            0|  0.00%|            return self
  1556|         0|            0|            0|  0.00%|
  1557|         0|            0|            0|  0.00%|    class ParamSpecArgs(_Immutable):
  1558|         0|            0|            0|  0.00%|        """The args for a ParamSpec object.
  1559|         0|            0|            0|  0.00%|
  1560|         0|            0|            0|  0.00%|        Given a ParamSpec object P, P.args is an instance of ParamSpecArgs.
  1561|         0|            0|            0|  0.00%|
  1562|         0|            0|            0|  0.00%|        ParamSpecArgs objects have a reference back to their ParamSpec:
  1563|         0|            0|            0|  0.00%|
  1564|         0|            0|            0|  0.00%|        P.args.__origin__ is P
  1565|         0|            0|            0|  0.00%|
  1566|         0|            0|            0|  0.00%|        This type is meant for runtime introspection and has no special meaning to
  1567|         0|            0|            0|  0.00%|        static type checkers.
  1568|         0|            0|            0|  0.00%|        """
  1569|         0|            0|            0|  0.00%|        def __init__(self, origin):
  1570|         0|            0|            0|  0.00%|            self.__origin__ = origin
  1571|         0|            0|            0|  0.00%|
  1572|         0|            0|            0|  0.00%|        def __repr__(self):
  1573|         0|            0|            0|  0.00%|            return f"{self.__origin__.__name__}.args"
  1574|         0|            0|            0|  0.00%|
  1575|         0|            0|            0|  0.00%|        def __eq__(self, other):
  1576|         0|            0|            0|  0.00%|            if not isinstance(other, ParamSpecArgs):
  1577|         0|            0|            0|  0.00%|                return NotImplemented
  1578|         0|            0|            0|  0.00%|            return self.__origin__ == other.__origin__
  1579|         0|            0|            0|  0.00%|
  1580|         0|            0|            0|  0.00%|    class ParamSpecKwargs(_Immutable):
  1581|         0|            0|            0|  0.00%|        """The kwargs for a ParamSpec object.
  1582|         0|            0|            0|  0.00%|
  1583|         0|            0|            0|  0.00%|        Given a ParamSpec object P, P.kwargs is an instance of ParamSpecKwargs.
  1584|         0|            0|            0|  0.00%|
  1585|         0|            0|            0|  0.00%|        ParamSpecKwargs objects have a reference back to their ParamSpec:
  1586|         0|            0|            0|  0.00%|
  1587|         0|            0|            0|  0.00%|        P.kwargs.__origin__ is P
  1588|         0|            0|            0|  0.00%|
  1589|         0|            0|            0|  0.00%|        This type is meant for runtime introspection and has no special meaning to
  1590|         0|            0|            0|  0.00%|        static type checkers.
  1591|         0|            0|            0|  0.00%|        """
  1592|         0|            0|            0|  0.00%|        def __init__(self, origin):
  1593|         0|            0|            0|  0.00%|            self.__origin__ = origin
  1594|         0|            0|            0|  0.00%|
  1595|         0|            0|            0|  0.00%|        def __repr__(self):
  1596|         0|            0|            0|  0.00%|            return f"{self.__origin__.__name__}.kwargs"
  1597|         0|            0|            0|  0.00%|
  1598|         0|            0|            0|  0.00%|        def __eq__(self, other):
  1599|         0|            0|            0|  0.00%|            if not isinstance(other, ParamSpecKwargs):
  1600|         0|            0|            0|  0.00%|                return NotImplemented
  1601|         0|            0|            0|  0.00%|            return self.__origin__ == other.__origin__
  1602|         0|            0|            0|  0.00%|
  1603|         0|            0|            0|  0.00%|
  1604|         0|            0|            0|  0.00%|if _PEP_696_IMPLEMENTED:
  1605|         0|            0|            0|  0.00%|    from typing import ParamSpec
  1606|         0|            0|            0|  0.00%|
  1607|         0|            0|            0|  0.00%|# 3.10+
  1608|         0|            0|            0|  0.00%|elif hasattr(typing, 'ParamSpec'):
  1609|         0|            0|            0|  0.00%|
  1610|         0|            0|            0|  0.00%|    # Add default parameter - PEP 696
  1611|         0|            0|            0|  0.00%|    class ParamSpec(metaclass=_TypeVarLikeMeta):
  1612|         0|            0|            0|  0.00%|        """Parameter specification."""
  1613|         0|            0|            0|  0.00%|
  1614|         0|            0|            0|  0.00%|        _backported_typevarlike = typing.ParamSpec
  1615|         0|            0|            0|  0.00%|
  1616|         0|            0|            0|  0.00%|        def __new__(cls, name, *, bound=None,
  1617|         0|            0|            0|  0.00%|                    covariant=False, contravariant=False,
  1618|         0|            0|            0|  0.00%|                    infer_variance=False, default=NoDefault):
  1619|         0|            0|            0|  0.00%|            if hasattr(typing, "TypeAliasType"):
  1620|         0|            0|            0|  0.00%|                # PEP 695 implemented, can pass infer_variance to typing.TypeVar
  1621|         0|            0|            0|  0.00%|                paramspec = typing.ParamSpec(name, bound=bound,
  1622|         0|            0|            0|  0.00%|                                             covariant=covariant,
  1623|         0|            0|            0|  0.00%|                                             contravariant=contravariant,
  1624|         0|            0|            0|  0.00%|                                             infer_variance=infer_variance)
  1625|         0|            0|            0|  0.00%|            else:
  1626|         0|            0|            0|  0.00%|                paramspec = typing.ParamSpec(name, bound=bound,
  1627|         0|            0|            0|  0.00%|                                             covariant=covariant,
  1628|         0|            0|            0|  0.00%|                                             contravariant=contravariant)
  1629|         0|            0|            0|  0.00%|                paramspec.__infer_variance__ = infer_variance
  1630|         0|            0|            0|  0.00%|
  1631|         0|            0|            0|  0.00%|            _set_default(paramspec, default)
  1632|         0|            0|            0|  0.00%|            _set_module(paramspec)
  1633|         0|            0|            0|  0.00%|
  1634|         0|            0|            0|  0.00%|            def _paramspec_prepare_subst(alias, args):
  1635|         0|            0|            0|  0.00%|                params = alias.__parameters__
  1636|         0|            0|            0|  0.00%|                i = params.index(paramspec)
  1637|         0|            0|            0|  0.00%|                if i == len(args) and paramspec.has_default():
  1638|         0|            0|            0|  0.00%|                    args = [*args, paramspec.__default__]
  1639|         0|            0|            0|  0.00%|                if i >= len(args):
  1640|         0|            0|            0|  0.00%|                    raise TypeError(f"Too few arguments for {alias}")
  1641|         0|            0|            0|  0.00%|                # Special case where Z[[int, str, bool]] == Z[int, str, bool] in PEP 612.
  1642|         0|            0|            0|  0.00%|                if len(params) == 1 and not typing._is_param_expr(args[0]):
  1643|         0|            0|            0|  0.00%|                    assert i == 0
  1644|         0|            0|            0|  0.00%|                    args = (args,)
  1645|         0|            0|            0|  0.00%|                # Convert lists to tuples to help other libraries cache the results.
  1646|         0|            0|            0|  0.00%|                elif isinstance(args[i], list):
  1647|         0|            0|            0|  0.00%|                    args = (*args[:i], tuple(args[i]), *args[i + 1:])
  1648|         0|            0|            0|  0.00%|                return args
  1649|         0|            0|            0|  0.00%|
  1650|         0|            0|            0|  0.00%|            paramspec.__typing_prepare_subst__ = _paramspec_prepare_subst
  1651|         0|            0|            0|  0.00%|            return paramspec
  1652|         0|            0|            0|  0.00%|
  1653|         0|            0|            0|  0.00%|        def __init_subclass__(cls) -> None:
  1654|         0|            0|            0|  0.00%|            raise TypeError(f"type '{__name__}.ParamSpec' is not an acceptable base type")
  1655|         0|            0|            0|  0.00%|
  1656|         0|            0|            0|  0.00%|# 3.8-3.9
  1657|         0|            0|            0|  0.00%|else:
  1658|         0|            0|            0|  0.00%|
  1659|         0|            0|            0|  0.00%|    # Inherits from list as a workaround for Callable checks in Python < 3.9.2.
  1660|         0|            0|            0|  0.00%|    class ParamSpec(list, _DefaultMixin):
  1661|         0|            0|            0|  0.00%|        """Parameter specification variable.
  1662|         0|            0|            0|  0.00%|
  1663|         0|            0|            0|  0.00%|        Usage::
  1664|         0|            0|            0|  0.00%|
  1665|         0|            0|            0|  0.00%|           P = ParamSpec('P')
  1666|         0|            0|            0|  0.00%|
  1667|         0|            0|            0|  0.00%|        Parameter specification variables exist primarily for the benefit of static
  1668|         0|            0|            0|  0.00%|        type checkers.  They are used to forward the parameter types of one
  1669|         0|            0|            0|  0.00%|        callable to another callable, a pattern commonly found in higher order
  1670|         0|            0|            0|  0.00%|        functions and decorators.  They are only valid when used in ``Concatenate``,
  1671|         0|            0|            0|  0.00%|        or s the first argument to ``Callable``. In Python 3.10 and higher,
  1672|         0|            0|            0|  0.00%|        they are also supported in user-defined Generics at runtime.
  1673|         0|            0|            0|  0.00%|        See class Generic for more information on generic types.  An
  1674|         0|            0|            0|  0.00%|        example for annotating a decorator::
  1675|         0|            0|            0|  0.00%|
  1676|         0|            0|            0|  0.00%|           T = TypeVar('T')
  1677|         0|            0|            0|  0.00%|           P = ParamSpec('P')
  1678|         0|            0|            0|  0.00%|
  1679|         0|            0|            0|  0.00%|           def add_logging(f: Callable[P, T]) -> Callable[P, T]:
  1680|         0|            0|            0|  0.00%|               '''A type-safe decorator to add logging to a function.'''
  1681|         0|            0|            0|  0.00%|               def inner(*args: P.args, **kwargs: P.kwargs) -> T:
  1682|         0|            0|            0|  0.00%|                   logging.info(f'{f.__name__} was called')
  1683|         0|            0|            0|  0.00%|                   return f(*args, **kwargs)
  1684|         0|            0|            0|  0.00%|               return inner
  1685|         0|            0|            0|  0.00%|
  1686|         0|            0|            0|  0.00%|           @add_logging
  1687|         0|            0|            0|  0.00%|           def add_two(x: float, y: float) -> float:
  1688|         0|            0|            0|  0.00%|               '''Add two numbers together.'''
  1689|         0|            0|            0|  0.00%|               return x + y
  1690|         0|            0|            0|  0.00%|
  1691|         0|            0|            0|  0.00%|        Parameter specification variables defined with covariant=True or
  1692|         0|            0|            0|  0.00%|        contravariant=True can be used to declare covariant or contravariant
  1693|         0|            0|            0|  0.00%|        generic types.  These keyword arguments are valid, but their actual semantics
  1694|         0|            0|            0|  0.00%|        are yet to be decided.  See PEP 612 for details.
  1695|         0|            0|            0|  0.00%|
  1696|         0|            0|            0|  0.00%|        Parameter specification variables can be introspected. e.g.:
  1697|         0|            0|            0|  0.00%|
  1698|         0|            0|            0|  0.00%|           P.__name__ == 'T'
  1699|         0|            0|            0|  0.00%|           P.__bound__ == None
  1700|         0|            0|            0|  0.00%|           P.__covariant__ == False
  1701|         0|            0|            0|  0.00%|           P.__contravariant__ == False
  1702|         0|            0|            0|  0.00%|
  1703|         0|            0|            0|  0.00%|        Note that only parameter specification variables defined in global scope can
  1704|         0|            0|            0|  0.00%|        be pickled.
  1705|         0|            0|            0|  0.00%|        """
  1706|         0|            0|            0|  0.00%|
  1707|         0|            0|            0|  0.00%|        # Trick Generic __parameters__.
  1708|         0|            0|            0|  0.00%|        __class__ = typing.TypeVar
  1709|         0|            0|            0|  0.00%|
  1710|         0|            0|            0|  0.00%|        @property
  1711|         0|            0|            0|  0.00%|        def args(self):
  1712|         0|            0|            0|  0.00%|            return ParamSpecArgs(self)
  1713|         0|            0|            0|  0.00%|
  1714|         0|            0|            0|  0.00%|        @property
  1715|         0|            0|            0|  0.00%|        def kwargs(self):
  1716|         0|            0|            0|  0.00%|            return ParamSpecKwargs(self)
  1717|         0|            0|            0|  0.00%|
  1718|         0|            0|            0|  0.00%|        def __init__(self, name, *, bound=None, covariant=False, contravariant=False,
  1719|         0|            0|            0|  0.00%|                     infer_variance=False, default=NoDefault):
  1720|         0|            0|            0|  0.00%|            list.__init__(self, [self])
  1721|         0|            0|            0|  0.00%|            self.__name__ = name
  1722|         0|            0|            0|  0.00%|            self.__covariant__ = bool(covariant)
  1723|         0|            0|            0|  0.00%|            self.__contravariant__ = bool(contravariant)
  1724|         0|            0|            0|  0.00%|            self.__infer_variance__ = bool(infer_variance)
  1725|         0|            0|            0|  0.00%|            if bound:
  1726|         0|            0|            0|  0.00%|                self.__bound__ = typing._type_check(bound, 'Bound must be a type.')
  1727|         0|            0|            0|  0.00%|            else:
  1728|         0|            0|            0|  0.00%|                self.__bound__ = None
  1729|         0|            0|            0|  0.00%|            _DefaultMixin.__init__(self, default)
  1730|         0|            0|            0|  0.00%|
  1731|         0|            0|            0|  0.00%|            # for pickling:
  1732|         0|            0|            0|  0.00%|            def_mod = _caller()
  1733|         0|            0|            0|  0.00%|            if def_mod != 'typing_extensions':
  1734|         0|            0|            0|  0.00%|                self.__module__ = def_mod
  1735|         0|            0|            0|  0.00%|
  1736|         0|            0|            0|  0.00%|        def __repr__(self):
  1737|         0|            0|            0|  0.00%|            if self.__infer_variance__:
  1738|         0|            0|            0|  0.00%|                prefix = ''
  1739|         0|            0|            0|  0.00%|            elif self.__covariant__:
  1740|         0|            0|            0|  0.00%|                prefix = '+'
  1741|         0|            0|            0|  0.00%|            elif self.__contravariant__:
  1742|         0|            0|            0|  0.00%|                prefix = '-'
  1743|         0|            0|            0|  0.00%|            else:
  1744|         0|            0|            0|  0.00%|                prefix = '~'
  1745|         0|            0|            0|  0.00%|            return prefix + self.__name__
  1746|         0|            0|            0|  0.00%|
  1747|         0|            0|            0|  0.00%|        def __hash__(self):
  1748|         0|            0|            0|  0.00%|            return object.__hash__(self)
  1749|         0|            0|            0|  0.00%|
  1750|         0|            0|            0|  0.00%|        def __eq__(self, other):
  1751|         0|            0|            0|  0.00%|            return self is other
  1752|         0|            0|            0|  0.00%|
  1753|         0|            0|            0|  0.00%|        def __reduce__(self):
  1754|         0|            0|            0|  0.00%|            return self.__name__
  1755|         0|            0|            0|  0.00%|
  1756|         0|            0|            0|  0.00%|        # Hack to get typing._type_check to pass.
  1757|         0|            0|            0|  0.00%|        def __call__(self, *args, **kwargs):
  1758|         0|            0|            0|  0.00%|            pass
  1759|         0|            0|            0|  0.00%|
  1760|         0|            0|            0|  0.00%|
  1761|         0|            0|            0|  0.00%|# 3.8-3.9
  1762|         0|            0|            0|  0.00%|if not hasattr(typing, 'Concatenate'):
  1763|         0|            0|            0|  0.00%|    # Inherits from list as a workaround for Callable checks in Python < 3.9.2.
  1764|         0|            0|            0|  0.00%|    class _ConcatenateGenericAlias(list):
  1765|         0|            0|            0|  0.00%|
  1766|         0|            0|            0|  0.00%|        # Trick Generic into looking into this for __parameters__.
  1767|         0|            0|            0|  0.00%|        __class__ = typing._GenericAlias
  1768|         0|            0|            0|  0.00%|
  1769|         0|            0|            0|  0.00%|        # Flag in 3.8.
  1770|         0|            0|            0|  0.00%|        _special = False
  1771|         0|            0|            0|  0.00%|
  1772|         0|            0|            0|  0.00%|        def __init__(self, origin, args):
  1773|         0|            0|            0|  0.00%|            super().__init__(args)
  1774|         0|            0|            0|  0.00%|            self.__origin__ = origin
  1775|         0|            0|            0|  0.00%|            self.__args__ = args
  1776|         0|            0|            0|  0.00%|
  1777|         0|            0|            0|  0.00%|        def __repr__(self):
  1778|         0|            0|            0|  0.00%|            _type_repr = typing._type_repr
  1779|         0|            0|            0|  0.00%|            return (f'{_type_repr(self.__origin__)}'
  1780|         0|            0|            0|  0.00%|                    f'[{", ".join(_type_repr(arg) for arg in self.__args__)}]')
  1781|         0|            0|            0|  0.00%|
  1782|         0|            0|            0|  0.00%|        def __hash__(self):
  1783|         0|            0|            0|  0.00%|            return hash((self.__origin__, self.__args__))
  1784|         0|            0|            0|  0.00%|
  1785|         0|            0|            0|  0.00%|        # Hack to get typing._type_check to pass in Generic.
  1786|         0|            0|            0|  0.00%|        def __call__(self, *args, **kwargs):
  1787|         0|            0|            0|  0.00%|            pass
  1788|         0|            0|            0|  0.00%|
  1789|         0|            0|            0|  0.00%|        @property
  1790|         0|            0|            0|  0.00%|        def __parameters__(self):
  1791|         0|            0|            0|  0.00%|            return tuple(
  1792|         0|            0|            0|  0.00%|                tp for tp in self.__args__ if isinstance(tp, (typing.TypeVar, ParamSpec))
  1793|         0|            0|            0|  0.00%|            )
  1794|         0|            0|            0|  0.00%|
  1795|         0|            0|            0|  0.00%|
  1796|         0|            0|            0|  0.00%|# 3.8-3.9
  1797|         0|            0|            0|  0.00%|@typing._tp_cache
  1798|         0|            0|            0|  0.00%|def _concatenate_getitem(self, parameters):
  1799|         0|            0|            0|  0.00%|    if parameters == ():
  1800|         0|            0|            0|  0.00%|        raise TypeError("Cannot take a Concatenate of no types.")
  1801|         0|            0|            0|  0.00%|    if not isinstance(parameters, tuple):
  1802|         0|            0|            0|  0.00%|        parameters = (parameters,)
  1803|         0|            0|            0|  0.00%|    if not isinstance(parameters[-1], ParamSpec):
  1804|         0|            0|            0|  0.00%|        raise TypeError("The last parameter to Concatenate should be a "
  1805|         0|            0|            0|  0.00%|                        "ParamSpec variable.")
  1806|         0|            0|            0|  0.00%|    msg = "Concatenate[arg, ...]: each arg must be a type."
  1807|         0|            0|            0|  0.00%|    parameters = tuple(typing._type_check(p, msg) for p in parameters)
  1808|         0|            0|            0|  0.00%|    return _ConcatenateGenericAlias(self, parameters)
  1809|         0|            0|            0|  0.00%|
  1810|         0|            0|            0|  0.00%|
  1811|         0|            0|            0|  0.00%|# 3.10+
  1812|         0|            0|            0|  0.00%|if hasattr(typing, 'Concatenate'):
  1813|         0|            0|            0|  0.00%|    Concatenate = typing.Concatenate
  1814|         0|            0|            0|  0.00%|    _ConcatenateGenericAlias = typing._ConcatenateGenericAlias
  1815|         0|            0|            0|  0.00%|# 3.9
  1816|         0|            0|            0|  0.00%|elif sys.version_info[:2] >= (3, 9):
  1817|         0|            0|            0|  0.00%|    @_ExtensionsSpecialForm
  1818|         0|            0|            0|  0.00%|    def Concatenate(self, parameters):
  1819|         0|            0|            0|  0.00%|        """Used in conjunction with ``ParamSpec`` and ``Callable`` to represent a
  1820|         0|            0|            0|  0.00%|        higher order function which adds, removes or transforms parameters of a
  1821|         0|            0|            0|  0.00%|        callable.
  1822|         0|            0|            0|  0.00%|
  1823|         0|            0|            0|  0.00%|        For example::
  1824|         0|            0|            0|  0.00%|
  1825|         0|            0|            0|  0.00%|           Callable[Concatenate[int, P], int]
  1826|         0|            0|            0|  0.00%|
  1827|         0|            0|            0|  0.00%|        See PEP 612 for detailed information.
  1828|         0|            0|            0|  0.00%|        """
  1829|         0|            0|            0|  0.00%|        return _concatenate_getitem(self, parameters)
  1830|         0|            0|            0|  0.00%|# 3.8
  1831|         0|            0|            0|  0.00%|else:
  1832|         0|            0|            0|  0.00%|    class _ConcatenateForm(_ExtensionsSpecialForm, _root=True):
  1833|         0|            0|            0|  0.00%|        def __getitem__(self, parameters):
  1834|         0|            0|            0|  0.00%|            return _concatenate_getitem(self, parameters)
  1835|         0|            0|            0|  0.00%|
  1836|         0|            0|            0|  0.00%|    Concatenate = _ConcatenateForm(
  1837|         0|            0|            0|  0.00%|        'Concatenate',
  1838|         0|            0|            0|  0.00%|        doc="""Used in conjunction with ``ParamSpec`` and ``Callable`` to represent a
  1839|         0|            0|            0|  0.00%|        higher order function which adds, removes or transforms parameters of a
  1840|         0|            0|            0|  0.00%|        callable.
  1841|         0|            0|            0|  0.00%|
  1842|         0|            0|            0|  0.00%|        For example::
  1843|         0|            0|            0|  0.00%|
  1844|         0|            0|            0|  0.00%|           Callable[Concatenate[int, P], int]
  1845|         0|            0|            0|  0.00%|
  1846|         0|            0|            0|  0.00%|        See PEP 612 for detailed information.
  1847|         0|            0|            0|  0.00%|        """)
  1848|         0|            0|            0|  0.00%|
  1849|         0|            0|            0|  0.00%|# 3.10+
  1850|         0|            0|            0|  0.00%|if hasattr(typing, 'TypeGuard'):
  1851|         0|            0|            0|  0.00%|    TypeGuard = typing.TypeGuard
  1852|         0|            0|            0|  0.00%|# 3.9
  1853|         0|            0|            0|  0.00%|elif sys.version_info[:2] >= (3, 9):
  1854|         0|            0|            0|  0.00%|    @_ExtensionsSpecialForm
  1855|         0|            0|            0|  0.00%|    def TypeGuard(self, parameters):
  1856|         0|            0|            0|  0.00%|        """Special typing form used to annotate the return type of a user-defined
  1857|         0|            0|            0|  0.00%|        type guard function.  ``TypeGuard`` only accepts a single type argument.
  1858|         0|            0|            0|  0.00%|        At runtime, functions marked this way should return a boolean.
  1859|         0|            0|            0|  0.00%|
  1860|         0|            0|            0|  0.00%|        ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static
  1861|         0|            0|            0|  0.00%|        type checkers to determine a more precise type of an expression within a
  1862|         0|            0|            0|  0.00%|        program's code flow.  Usually type narrowing is done by analyzing
  1863|         0|            0|            0|  0.00%|        conditional code flow and applying the narrowing to a block of code.  The
  1864|         0|            0|            0|  0.00%|        conditional expression here is sometimes referred to as a "type guard".
  1865|         0|            0|            0|  0.00%|
  1866|         0|            0|            0|  0.00%|        Sometimes it would be convenient to use a user-defined boolean function
  1867|         0|            0|            0|  0.00%|        as a type guard.  Such a function should use ``TypeGuard[...]`` as its
  1868|         0|            0|            0|  0.00%|        return type to alert static type checkers to this intention.
  1869|         0|            0|            0|  0.00%|
  1870|         0|            0|            0|  0.00%|        Using  ``-> TypeGuard`` tells the static type checker that for a given
  1871|         0|            0|            0|  0.00%|        function:
  1872|         0|            0|            0|  0.00%|
  1873|         0|            0|            0|  0.00%|        1. The return value is a boolean.
  1874|         0|            0|            0|  0.00%|        2. If the return value is ``True``, the type of its argument
  1875|         0|            0|            0|  0.00%|        is the type inside ``TypeGuard``.
  1876|         0|            0|            0|  0.00%|
  1877|         0|            0|            0|  0.00%|        For example::
  1878|         0|            0|            0|  0.00%|
  1879|         0|            0|            0|  0.00%|            def is_str(val: Union[str, float]):
  1880|         0|            0|            0|  0.00%|                # "isinstance" type guard
  1881|         0|            0|            0|  0.00%|                if isinstance(val, str):
  1882|         0|            0|            0|  0.00%|                    # Type of ``val`` is narrowed to ``str``
  1883|         0|            0|            0|  0.00%|                    ...
  1884|         0|            0|            0|  0.00%|                else:
  1885|         0|            0|            0|  0.00%|                    # Else, type of ``val`` is narrowed to ``float``.
  1886|         0|            0|            0|  0.00%|                    ...
  1887|         0|            0|            0|  0.00%|
  1888|         0|            0|            0|  0.00%|        Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower
  1889|         0|            0|            0|  0.00%|        form of ``TypeA`` (it can even be a wider form) and this may lead to
  1890|         0|            0|            0|  0.00%|        type-unsafe results.  The main reason is to allow for things like
  1891|         0|            0|            0|  0.00%|        narrowing ``List[object]`` to ``List[str]`` even though the latter is not
  1892|         0|            0|            0|  0.00%|        a subtype of the former, since ``List`` is invariant.  The responsibility of
  1893|         0|            0|            0|  0.00%|        writing type-safe type guards is left to the user.
  1894|         0|            0|            0|  0.00%|
  1895|         0|            0|            0|  0.00%|        ``TypeGuard`` also works with type variables.  For more information, see
  1896|         0|            0|            0|  0.00%|        PEP 647 (User-Defined Type Guards).
  1897|         0|            0|            0|  0.00%|        """
  1898|         0|            0|            0|  0.00%|        item = typing._type_check(parameters, f'{self} accepts only a single type.')
  1899|         0|            0|            0|  0.00%|        return typing._GenericAlias(self, (item,))
  1900|         0|            0|            0|  0.00%|# 3.8
  1901|         0|            0|            0|  0.00%|else:
  1902|         0|            0|            0|  0.00%|    class _TypeGuardForm(_ExtensionsSpecialForm, _root=True):
  1903|         0|            0|            0|  0.00%|        def __getitem__(self, parameters):
  1904|         0|            0|            0|  0.00%|            item = typing._type_check(parameters,
  1905|         0|            0|            0|  0.00%|                                      f'{self._name} accepts only a single type')
  1906|         0|            0|            0|  0.00%|            return typing._GenericAlias(self, (item,))
  1907|         0|            0|            0|  0.00%|
  1908|         0|            0|            0|  0.00%|    TypeGuard = _TypeGuardForm(
  1909|         0|            0|            0|  0.00%|        'TypeGuard',
  1910|         0|            0|            0|  0.00%|        doc="""Special typing form used to annotate the return type of a user-defined
  1911|         0|            0|            0|  0.00%|        type guard function.  ``TypeGuard`` only accepts a single type argument.
  1912|         0|            0|            0|  0.00%|        At runtime, functions marked this way should return a boolean.
  1913|         0|            0|            0|  0.00%|
  1914|         0|            0|            0|  0.00%|        ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static
  1915|         0|            0|            0|  0.00%|        type checkers to determine a more precise type of an expression within a
  1916|         0|            0|            0|  0.00%|        program's code flow.  Usually type narrowing is done by analyzing
  1917|         0|            0|            0|  0.00%|        conditional code flow and applying the narrowing to a block of code.  The
  1918|         0|            0|            0|  0.00%|        conditional expression here is sometimes referred to as a "type guard".
  1919|         0|            0|            0|  0.00%|
  1920|         0|            0|            0|  0.00%|        Sometimes it would be convenient to use a user-defined boolean function
  1921|         0|            0|            0|  0.00%|        as a type guard.  Such a function should use ``TypeGuard[...]`` as its
  1922|         0|            0|            0|  0.00%|        return type to alert static type checkers to this intention.
  1923|         0|            0|            0|  0.00%|
  1924|         0|            0|            0|  0.00%|        Using  ``-> TypeGuard`` tells the static type checker that for a given
  1925|         0|            0|            0|  0.00%|        function:
  1926|         0|            0|            0|  0.00%|
  1927|         0|            0|            0|  0.00%|        1. The return value is a boolean.
  1928|         0|            0|            0|  0.00%|        2. If the return value is ``True``, the type of its argument
  1929|         0|            0|            0|  0.00%|        is the type inside ``TypeGuard``.
  1930|         0|            0|            0|  0.00%|
  1931|         0|            0|            0|  0.00%|        For example::
  1932|         0|            0|            0|  0.00%|
  1933|         0|            0|            0|  0.00%|            def is_str(val: Union[str, float]):
  1934|         0|            0|            0|  0.00%|                # "isinstance" type guard
  1935|         0|            0|            0|  0.00%|                if isinstance(val, str):
  1936|         0|            0|            0|  0.00%|                    # Type of ``val`` is narrowed to ``str``
  1937|         0|            0|            0|  0.00%|                    ...
  1938|         0|            0|            0|  0.00%|                else:
  1939|         0|            0|            0|  0.00%|                    # Else, type of ``val`` is narrowed to ``float``.
  1940|         0|            0|            0|  0.00%|                    ...
  1941|         0|            0|            0|  0.00%|
  1942|         0|            0|            0|  0.00%|        Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower
  1943|         0|            0|            0|  0.00%|        form of ``TypeA`` (it can even be a wider form) and this may lead to
  1944|         0|            0|            0|  0.00%|        type-unsafe results.  The main reason is to allow for things like
  1945|         0|            0|            0|  0.00%|        narrowing ``List[object]`` to ``List[str]`` even though the latter is not
  1946|         0|            0|            0|  0.00%|        a subtype of the former, since ``List`` is invariant.  The responsibility of
  1947|         0|            0|            0|  0.00%|        writing type-safe type guards is left to the user.
  1948|         0|            0|            0|  0.00%|
  1949|         0|            0|            0|  0.00%|        ``TypeGuard`` also works with type variables.  For more information, see
  1950|         0|            0|            0|  0.00%|        PEP 647 (User-Defined Type Guards).
  1951|         0|            0|            0|  0.00%|        """)
  1952|         0|            0|            0|  0.00%|
  1953|         0|            0|            0|  0.00%|# 3.13+
  1954|         0|            0|            0|  0.00%|if hasattr(typing, 'TypeIs'):
  1955|         0|            0|            0|  0.00%|    TypeIs = typing.TypeIs
  1956|         0|            0|            0|  0.00%|# 3.9
  1957|         0|            0|            0|  0.00%|elif sys.version_info[:2] >= (3, 9):
  1958|         0|            0|            0|  0.00%|    @_ExtensionsSpecialForm
  1959|         0|            0|            0|  0.00%|    def TypeIs(self, parameters):
  1960|         0|            0|            0|  0.00%|        """Special typing form used to annotate the return type of a user-defined
  1961|         0|            0|            0|  0.00%|        type narrower function.  ``TypeIs`` only accepts a single type argument.
  1962|         0|            0|            0|  0.00%|        At runtime, functions marked this way should return a boolean.
  1963|         0|            0|            0|  0.00%|
  1964|         0|            0|            0|  0.00%|        ``TypeIs`` aims to benefit *type narrowing* -- a technique used by static
  1965|         0|            0|            0|  0.00%|        type checkers to determine a more precise type of an expression within a
  1966|         0|            0|            0|  0.00%|        program's code flow.  Usually type narrowing is done by analyzing
  1967|         0|            0|            0|  0.00%|        conditional code flow and applying the narrowing to a block of code.  The
  1968|         0|            0|            0|  0.00%|        conditional expression here is sometimes referred to as a "type guard".
  1969|         0|            0|            0|  0.00%|
  1970|         0|            0|            0|  0.00%|        Sometimes it would be convenient to use a user-defined boolean function
  1971|         0|            0|            0|  0.00%|        as a type guard.  Such a function should use ``TypeIs[...]`` as its
  1972|         0|            0|            0|  0.00%|        return type to alert static type checkers to this intention.
  1973|         0|            0|            0|  0.00%|
  1974|         0|            0|            0|  0.00%|        Using  ``-> TypeIs`` tells the static type checker that for a given
  1975|         0|            0|            0|  0.00%|        function:
  1976|         0|            0|            0|  0.00%|
  1977|         0|            0|            0|  0.00%|        1. The return value is a boolean.
  1978|         0|            0|            0|  0.00%|        2. If the return value is ``True``, the type of its argument
  1979|         0|            0|            0|  0.00%|        is the intersection of the type inside ``TypeGuard`` and the argument's
  1980|         0|            0|            0|  0.00%|        previously known type.
  1981|         0|            0|            0|  0.00%|
  1982|         0|            0|            0|  0.00%|        For example::
  1983|         0|            0|            0|  0.00%|
  1984|         0|            0|            0|  0.00%|            def is_awaitable(val: object) -> TypeIs[Awaitable[Any]]:
  1985|         0|            0|            0|  0.00%|                return hasattr(val, '__await__')
  1986|         0|            0|            0|  0.00%|
  1987|         0|            0|            0|  0.00%|            def f(val: Union[int, Awaitable[int]]) -> int:
  1988|         0|            0|            0|  0.00%|                if is_awaitable(val):
  1989|         0|            0|            0|  0.00%|                    assert_type(val, Awaitable[int])
  1990|         0|            0|            0|  0.00%|                else:
  1991|         0|            0|            0|  0.00%|                    assert_type(val, int)
  1992|         0|            0|            0|  0.00%|
  1993|         0|            0|            0|  0.00%|        ``TypeIs`` also works with type variables.  For more information, see
  1994|         0|            0|            0|  0.00%|        PEP 742 (Narrowing types with TypeIs).
  1995|         0|            0|            0|  0.00%|        """
  1996|         0|            0|            0|  0.00%|        item = typing._type_check(parameters, f'{self} accepts only a single type.')
  1997|         0|            0|            0|  0.00%|        return typing._GenericAlias(self, (item,))
  1998|         0|            0|            0|  0.00%|# 3.8
  1999|         0|            0|            0|  0.00%|else:
  2000|         0|            0|            0|  0.00%|    class _TypeIsForm(_ExtensionsSpecialForm, _root=True):
  2001|         0|            0|            0|  0.00%|        def __getitem__(self, parameters):
  2002|         0|            0|            0|  0.00%|            item = typing._type_check(parameters,
  2003|         0|            0|            0|  0.00%|                                      f'{self._name} accepts only a single type')
  2004|         0|            0|            0|  0.00%|            return typing._GenericAlias(self, (item,))
  2005|         0|            0|            0|  0.00%|
  2006|         0|            0|            0|  0.00%|    TypeIs = _TypeIsForm(
  2007|         0|            0|            0|  0.00%|        'TypeIs',
  2008|         0|            0|            0|  0.00%|        doc="""Special typing form used to annotate the return type of a user-defined
  2009|         0|            0|            0|  0.00%|        type narrower function.  ``TypeIs`` only accepts a single type argument.
  2010|         0|            0|            0|  0.00%|        At runtime, functions marked this way should return a boolean.
  2011|         0|            0|            0|  0.00%|
  2012|         0|            0|            0|  0.00%|        ``TypeIs`` aims to benefit *type narrowing* -- a technique used by static
  2013|         0|            0|            0|  0.00%|        type checkers to determine a more precise type of an expression within a
  2014|         0|            0|            0|  0.00%|        program's code flow.  Usually type narrowing is done by analyzing
  2015|         0|            0|            0|  0.00%|        conditional code flow and applying the narrowing to a block of code.  The
  2016|         0|            0|            0|  0.00%|        conditional expression here is sometimes referred to as a "type guard".
  2017|         0|            0|            0|  0.00%|
  2018|         0|            0|            0|  0.00%|        Sometimes it would be convenient to use a user-defined boolean function
  2019|         0|            0|            0|  0.00%|        as a type guard.  Such a function should use ``TypeIs[...]`` as its
  2020|         0|            0|            0|  0.00%|        return type to alert static type checkers to this intention.
  2021|         0|            0|            0|  0.00%|
  2022|         0|            0|            0|  0.00%|        Using  ``-> TypeIs`` tells the static type checker that for a given
  2023|         0|            0|            0|  0.00%|        function:
  2024|         0|            0|            0|  0.00%|
  2025|         0|            0|            0|  0.00%|        1. The return value is a boolean.
  2026|         0|            0|            0|  0.00%|        2. If the return value is ``True``, the type of its argument
  2027|         0|            0|            0|  0.00%|        is the intersection of the type inside ``TypeGuard`` and the argument's
  2028|         0|            0|            0|  0.00%|        previously known type.
  2029|         0|            0|            0|  0.00%|
  2030|         0|            0|            0|  0.00%|        For example::
  2031|         0|            0|            0|  0.00%|
  2032|         0|            0|            0|  0.00%|            def is_awaitable(val: object) -> TypeIs[Awaitable[Any]]:
  2033|         0|            0|            0|  0.00%|                return hasattr(val, '__await__')
  2034|         0|            0|            0|  0.00%|
  2035|         0|            0|            0|  0.00%|            def f(val: Union[int, Awaitable[int]]) -> int:
  2036|         0|            0|            0|  0.00%|                if is_awaitable(val):
  2037|         0|            0|            0|  0.00%|                    assert_type(val, Awaitable[int])
  2038|         0|            0|            0|  0.00%|                else:
  2039|         0|            0|            0|  0.00%|                    assert_type(val, int)
  2040|         0|            0|            0|  0.00%|
  2041|         0|            0|            0|  0.00%|        ``TypeIs`` also works with type variables.  For more information, see
  2042|         0|            0|            0|  0.00%|        PEP 742 (Narrowing types with TypeIs).
  2043|         0|            0|            0|  0.00%|        """)
  2044|         0|            0|            0|  0.00%|
  2045|         0|            0|            0|  0.00%|
  2046|         0|            0|            0|  0.00%|# Vendored from cpython typing._SpecialFrom
  2047|         0|            0|            0|  0.00%|class _SpecialForm(typing._Final, _root=True):
  2048|         0|            0|            0|  0.00%|    __slots__ = ('_name', '__doc__', '_getitem')
  2049|         0|            0|            0|  0.00%|
  2050|         0|            0|            0|  0.00%|    def __init__(self, getitem):
  2051|         0|            0|            0|  0.00%|        self._getitem = getitem
  2052|         0|            0|            0|  0.00%|        self._name = getitem.__name__
  2053|         0|            0|            0|  0.00%|        self.__doc__ = getitem.__doc__
  2054|         0|            0|            0|  0.00%|
  2055|         0|            0|            0|  0.00%|    def __getattr__(self, item):
  2056|         0|            0|            0|  0.00%|        if item in {'__name__', '__qualname__'}:
  2057|         0|            0|            0|  0.00%|            return self._name
  2058|         0|            0|            0|  0.00%|
  2059|         0|            0|            0|  0.00%|        raise AttributeError(item)
  2060|         0|            0|            0|  0.00%|
  2061|         0|            0|            0|  0.00%|    def __mro_entries__(self, bases):
  2062|         0|            0|            0|  0.00%|        raise TypeError(f"Cannot subclass {self!r}")
  2063|         0|            0|            0|  0.00%|
  2064|         0|            0|            0|  0.00%|    def __repr__(self):
  2065|         0|            0|            0|  0.00%|        return f'typing_extensions.{self._name}'
  2066|         0|            0|            0|  0.00%|
  2067|         0|            0|            0|  0.00%|    def __reduce__(self):
  2068|         0|            0|            0|  0.00%|        return self._name
  2069|         0|            0|            0|  0.00%|
  2070|         0|            0|            0|  0.00%|    def __call__(self, *args, **kwds):
  2071|         0|            0|            0|  0.00%|        raise TypeError(f"Cannot instantiate {self!r}")
  2072|         0|            0|            0|  0.00%|
  2073|         0|            0|            0|  0.00%|    def __or__(self, other):
  2074|         0|            0|            0|  0.00%|        return typing.Union[self, other]
  2075|         0|            0|            0|  0.00%|
  2076|         0|            0|            0|  0.00%|    def __ror__(self, other):
  2077|         0|            0|            0|  0.00%|        return typing.Union[other, self]
  2078|         0|            0|            0|  0.00%|
  2079|         0|            0|            0|  0.00%|    def __instancecheck__(self, obj):
  2080|         0|            0|            0|  0.00%|        raise TypeError(f"{self} cannot be used with isinstance()")
  2081|         0|            0|            0|  0.00%|
  2082|         0|            0|            0|  0.00%|    def __subclasscheck__(self, cls):
  2083|         0|            0|            0|  0.00%|        raise TypeError(f"{self} cannot be used with issubclass()")
  2084|         0|            0|            0|  0.00%|
  2085|         0|            0|            0|  0.00%|    @typing._tp_cache
  2086|         0|            0|            0|  0.00%|    def __getitem__(self, parameters):
  2087|         0|            0|            0|  0.00%|        return self._getitem(self, parameters)
  2088|         0|            0|            0|  0.00%|
  2089|         0|            0|            0|  0.00%|
  2090|         0|            0|            0|  0.00%|if hasattr(typing, "LiteralString"):  # 3.11+
  2091|         0|            0|            0|  0.00%|    LiteralString = typing.LiteralString
  2092|         0|            0|            0|  0.00%|else:
  2093|         0|            0|            0|  0.00%|    @_SpecialForm
  2094|         0|            0|            0|  0.00%|    def LiteralString(self, params):
  2095|         0|            0|            0|  0.00%|        """Represents an arbitrary literal string.
  2096|         0|            0|            0|  0.00%|
  2097|         0|            0|            0|  0.00%|        Example::
  2098|         0|            0|            0|  0.00%|
  2099|         0|            0|            0|  0.00%|          from typing_extensions import LiteralString
  2100|         0|            0|            0|  0.00%|
  2101|         0|            0|            0|  0.00%|          def query(sql: LiteralString) -> ...:
  2102|         0|            0|            0|  0.00%|              ...
  2103|         0|            0|            0|  0.00%|
  2104|         0|            0|            0|  0.00%|          query("SELECT * FROM table")  # ok
  2105|         0|            0|            0|  0.00%|          query(f"SELECT * FROM {input()}")  # not ok
  2106|         0|            0|            0|  0.00%|
  2107|         0|            0|            0|  0.00%|        See PEP 675 for details.
  2108|         0|            0|            0|  0.00%|
  2109|         0|            0|            0|  0.00%|        """
  2110|         0|            0|            0|  0.00%|        raise TypeError(f"{self} is not subscriptable")
  2111|         0|            0|            0|  0.00%|
  2112|         0|            0|            0|  0.00%|
  2113|         0|            0|            0|  0.00%|if hasattr(typing, "Self"):  # 3.11+
  2114|         0|            0|            0|  0.00%|    Self = typing.Self
  2115|         0|            0|            0|  0.00%|else:
  2116|         0|            0|            0|  0.00%|    @_SpecialForm
  2117|         0|            0|            0|  0.00%|    def Self(self, params):
  2118|         0|            0|            0|  0.00%|        """Used to spell the type of "self" in classes.
  2119|         0|            0|            0|  0.00%|
  2120|         0|            0|            0|  0.00%|        Example::
  2121|         0|            0|            0|  0.00%|
  2122|         0|            0|            0|  0.00%|          from typing import Self
  2123|         0|            0|            0|  0.00%|
  2124|         0|            0|            0|  0.00%|          class ReturnsSelf:
  2125|         0|            0|            0|  0.00%|              def parse(self, data: bytes) -> Self:
  2126|         0|            0|            0|  0.00%|                  ...
  2127|         0|            0|            0|  0.00%|                  return self
  2128|         0|            0|            0|  0.00%|
  2129|         0|            0|            0|  0.00%|        """
  2130|         0|            0|            0|  0.00%|
  2131|         0|            0|            0|  0.00%|        raise TypeError(f"{self} is not subscriptable")
  2132|         0|            0|            0|  0.00%|
  2133|         0|            0|            0|  0.00%|
  2134|         0|            0|            0|  0.00%|if hasattr(typing, "Never"):  # 3.11+
  2135|         0|            0|            0|  0.00%|    Never = typing.Never
  2136|         0|            0|            0|  0.00%|else:
  2137|         0|            0|            0|  0.00%|    @_SpecialForm
  2138|         0|            0|            0|  0.00%|    def Never(self, params):
  2139|         0|            0|            0|  0.00%|        """The bottom type, a type that has no members.
  2140|         0|            0|            0|  0.00%|
  2141|         0|            0|            0|  0.00%|        This can be used to define a function that should never be
  2142|         0|            0|            0|  0.00%|        called, or a function that never returns::
  2143|         0|            0|            0|  0.00%|
  2144|         0|            0|            0|  0.00%|            from typing_extensions import Never
  2145|         0|            0|            0|  0.00%|
  2146|         0|            0|            0|  0.00%|            def never_call_me(arg: Never) -> None:
  2147|         0|            0|            0|  0.00%|                pass
  2148|         0|            0|            0|  0.00%|
  2149|         0|            0|            0|  0.00%|            def int_or_str(arg: int | str) -> None:
  2150|         0|            0|            0|  0.00%|                never_call_me(arg)  # type checker error
  2151|         0|            0|            0|  0.00%|                match arg:
  2152|         0|            0|            0|  0.00%|                    case int():
  2153|         0|            0|            0|  0.00%|                        print("It's an int")
  2154|         0|            0|            0|  0.00%|                    case str():
  2155|         0|            0|            0|  0.00%|                        print("It's a str")
  2156|         0|            0|            0|  0.00%|                    case _:
  2157|         0|            0|            0|  0.00%|                        never_call_me(arg)  # ok, arg is of type Never
  2158|         0|            0|            0|  0.00%|
  2159|         0|            0|            0|  0.00%|        """
  2160|         0|            0|            0|  0.00%|
  2161|         0|            0|            0|  0.00%|        raise TypeError(f"{self} is not subscriptable")
  2162|         0|            0|            0|  0.00%|
  2163|         0|            0|            0|  0.00%|
  2164|         0|            0|            0|  0.00%|if hasattr(typing, 'Required'):  # 3.11+
  2165|         0|            0|            0|  0.00%|    Required = typing.Required
  2166|         0|            0|            0|  0.00%|    NotRequired = typing.NotRequired
  2167|         0|            0|            0|  0.00%|elif sys.version_info[:2] >= (3, 9):  # 3.9-3.10
  2168|         0|            0|            0|  0.00%|    @_ExtensionsSpecialForm
  2169|         0|            0|            0|  0.00%|    def Required(self, parameters):
  2170|         0|            0|            0|  0.00%|        """A special typing construct to mark a key of a total=False TypedDict
  2171|         0|            0|            0|  0.00%|        as required. For example:
  2172|         0|            0|            0|  0.00%|
  2173|         0|            0|            0|  0.00%|            class Movie(TypedDict, total=False):
  2174|         0|            0|            0|  0.00%|                title: Required[str]
  2175|         0|            0|            0|  0.00%|                year: int
  2176|         0|            0|            0|  0.00%|
  2177|         0|            0|            0|  0.00%|            m = Movie(
  2178|         0|            0|            0|  0.00%|                title='The Matrix',  # typechecker error if key is omitted
  2179|         0|            0|            0|  0.00%|                year=1999,
  2180|         0|            0|            0|  0.00%|            )
  2181|         0|            0|            0|  0.00%|
  2182|         0|            0|            0|  0.00%|        There is no runtime checking that a required key is actually provided
  2183|         0|            0|            0|  0.00%|        when instantiating a related TypedDict.
  2184|         0|            0|            0|  0.00%|        """
  2185|         0|            0|            0|  0.00%|        item = typing._type_check(parameters, f'{self._name} accepts only a single type.')
  2186|         0|            0|            0|  0.00%|        return typing._GenericAlias(self, (item,))
  2187|         0|            0|            0|  0.00%|
  2188|         0|            0|            0|  0.00%|    @_ExtensionsSpecialForm
  2189|         0|            0|            0|  0.00%|    def NotRequired(self, parameters):
  2190|         0|            0|            0|  0.00%|        """A special typing construct to mark a key of a TypedDict as
  2191|         0|            0|            0|  0.00%|        potentially missing. For example:
  2192|         0|            0|            0|  0.00%|
  2193|         0|            0|            0|  0.00%|            class Movie(TypedDict):
  2194|         0|            0|            0|  0.00%|                title: str
  2195|         0|            0|            0|  0.00%|                year: NotRequired[int]
  2196|         0|            0|            0|  0.00%|
  2197|         0|            0|            0|  0.00%|            m = Movie(
  2198|         0|            0|            0|  0.00%|                title='The Matrix',  # typechecker error if key is omitted
  2199|         0|            0|            0|  0.00%|                year=1999,
  2200|         0|            0|            0|  0.00%|            )
  2201|         0|            0|            0|  0.00%|        """
  2202|         0|            0|            0|  0.00%|        item = typing._type_check(parameters, f'{self._name} accepts only a single type.')
  2203|         0|            0|            0|  0.00%|        return typing._GenericAlias(self, (item,))
  2204|         0|            0|            0|  0.00%|
  2205|         0|            0|            0|  0.00%|else:  # 3.8
  2206|         0|            0|            0|  0.00%|    class _RequiredForm(_ExtensionsSpecialForm, _root=True):
  2207|         0|            0|            0|  0.00%|        def __getitem__(self, parameters):
  2208|         0|            0|            0|  0.00%|            item = typing._type_check(parameters,
  2209|         0|            0|            0|  0.00%|                                      f'{self._name} accepts only a single type.')
  2210|         0|            0|            0|  0.00%|            return typing._GenericAlias(self, (item,))
  2211|         0|            0|            0|  0.00%|
  2212|         0|            0|            0|  0.00%|    Required = _RequiredForm(
  2213|         0|            0|            0|  0.00%|        'Required',
  2214|         0|            0|            0|  0.00%|        doc="""A special typing construct to mark a key of a total=False TypedDict
  2215|         0|            0|            0|  0.00%|        as required. For example:
  2216|         0|            0|            0|  0.00%|
  2217|         0|            0|            0|  0.00%|            class Movie(TypedDict, total=False):
  2218|         0|            0|            0|  0.00%|                title: Required[str]
  2219|         0|            0|            0|  0.00%|                year: int
  2220|         0|            0|            0|  0.00%|
  2221|         0|            0|            0|  0.00%|            m = Movie(
  2222|         0|            0|            0|  0.00%|                title='The Matrix',  # typechecker error if key is omitted
  2223|         0|            0|            0|  0.00%|                year=1999,
  2224|         0|            0|            0|  0.00%|            )
  2225|         0|            0|            0|  0.00%|
  2226|         0|            0|            0|  0.00%|        There is no runtime checking that a required key is actually provided
  2227|         0|            0|            0|  0.00%|        when instantiating a related TypedDict.
  2228|         0|            0|            0|  0.00%|        """)
  2229|         0|            0|            0|  0.00%|    NotRequired = _RequiredForm(
  2230|         0|            0|            0|  0.00%|        'NotRequired',
  2231|         0|            0|            0|  0.00%|        doc="""A special typing construct to mark a key of a TypedDict as
  2232|         0|            0|            0|  0.00%|        potentially missing. For example:
  2233|         0|            0|            0|  0.00%|
  2234|         0|            0|            0|  0.00%|            class Movie(TypedDict):
  2235|         0|            0|            0|  0.00%|                title: str
  2236|         0|            0|            0|  0.00%|                year: NotRequired[int]
  2237|         0|            0|            0|  0.00%|
  2238|         0|            0|            0|  0.00%|            m = Movie(
  2239|         0|            0|            0|  0.00%|                title='The Matrix',  # typechecker error if key is omitted
  2240|         0|            0|            0|  0.00%|                year=1999,
  2241|         0|            0|            0|  0.00%|            )
  2242|         0|            0|            0|  0.00%|        """)
  2243|         0|            0|            0|  0.00%|
  2244|         0|            0|            0|  0.00%|
  2245|         0|            0|            0|  0.00%|if hasattr(typing, 'ReadOnly'):
  2246|         0|            0|            0|  0.00%|    ReadOnly = typing.ReadOnly
  2247|         0|            0|            0|  0.00%|elif sys.version_info[:2] >= (3, 9):  # 3.9-3.12
  2248|         0|            0|            0|  0.00%|    @_ExtensionsSpecialForm
  2249|         0|            0|            0|  0.00%|    def ReadOnly(self, parameters):
  2250|         0|            0|            0|  0.00%|        """A special typing construct to mark an item of a TypedDict as read-only.
  2251|         0|            0|            0|  0.00%|
  2252|         0|            0|            0|  0.00%|        For example:
  2253|         0|            0|            0|  0.00%|
  2254|         0|            0|            0|  0.00%|            class Movie(TypedDict):
  2255|         0|            0|            0|  0.00%|                title: ReadOnly[str]
  2256|         0|            0|            0|  0.00%|                year: int
  2257|         0|            0|            0|  0.00%|
  2258|         0|            0|            0|  0.00%|            def mutate_movie(m: Movie) -> None:
  2259|         0|            0|            0|  0.00%|                m["year"] = 1992  # allowed
  2260|         0|            0|            0|  0.00%|                m["title"] = "The Matrix"  # typechecker error
  2261|         0|            0|            0|  0.00%|
  2262|         0|            0|            0|  0.00%|        There is no runtime checking for this property.
  2263|         0|            0|            0|  0.00%|        """
  2264|         0|            0|            0|  0.00%|        item = typing._type_check(parameters, f'{self._name} accepts only a single type.')
  2265|         0|            0|            0|  0.00%|        return typing._GenericAlias(self, (item,))
  2266|         0|            0|            0|  0.00%|
  2267|         0|            0|            0|  0.00%|else:  # 3.8
  2268|         0|            0|            0|  0.00%|    class _ReadOnlyForm(_ExtensionsSpecialForm, _root=True):
  2269|         0|            0|            0|  0.00%|        def __getitem__(self, parameters):
  2270|         0|            0|            0|  0.00%|            item = typing._type_check(parameters,
  2271|         0|            0|            0|  0.00%|                                      f'{self._name} accepts only a single type.')
  2272|         0|            0|            0|  0.00%|            return typing._GenericAlias(self, (item,))
  2273|         0|            0|            0|  0.00%|
  2274|         0|            0|            0|  0.00%|    ReadOnly = _ReadOnlyForm(
  2275|         0|            0|            0|  0.00%|        'ReadOnly',
  2276|         0|            0|            0|  0.00%|        doc="""A special typing construct to mark a key of a TypedDict as read-only.
  2277|         0|            0|            0|  0.00%|
  2278|         0|            0|            0|  0.00%|        For example:
  2279|         0|            0|            0|  0.00%|
  2280|         0|            0|            0|  0.00%|            class Movie(TypedDict):
  2281|         0|            0|            0|  0.00%|                title: ReadOnly[str]
  2282|         0|            0|            0|  0.00%|                year: int
  2283|         0|            0|            0|  0.00%|
  2284|         0|            0|            0|  0.00%|            def mutate_movie(m: Movie) -> None:
  2285|         0|            0|            0|  0.00%|                m["year"] = 1992  # allowed
  2286|         0|            0|            0|  0.00%|                m["title"] = "The Matrix"  # typechecker error
  2287|         0|            0|            0|  0.00%|
  2288|         0|            0|            0|  0.00%|        There is no runtime checking for this propery.
  2289|         0|            0|            0|  0.00%|        """)
  2290|         0|            0|            0|  0.00%|
  2291|         0|            0|            0|  0.00%|
  2292|         0|            0|            0|  0.00%|_UNPACK_DOC = """\
  2293|         0|            0|            0|  0.00%|Type unpack operator.
  2294|         0|            0|            0|  0.00%|
  2295|         0|            0|            0|  0.00%|The type unpack operator takes the child types from some container type,
  2296|         0|            0|            0|  0.00%|such as `tuple[int, str]` or a `TypeVarTuple`, and 'pulls them out'. For
  2297|         0|            0|            0|  0.00%|example:
  2298|         0|            0|            0|  0.00%|
  2299|         0|            0|            0|  0.00%|  # For some generic class `Foo`:
  2300|         0|            0|            0|  0.00%|  Foo[Unpack[tuple[int, str]]]  # Equivalent to Foo[int, str]
  2301|         0|            0|            0|  0.00%|
  2302|         0|            0|            0|  0.00%|  Ts = TypeVarTuple('Ts')
  2303|         0|            0|            0|  0.00%|  # Specifies that `Bar` is generic in an arbitrary number of types.
  2304|         0|            0|            0|  0.00%|  # (Think of `Ts` as a tuple of an arbitrary number of individual
  2305|         0|            0|            0|  0.00%|  #  `TypeVar`s, which the `Unpack` is 'pulling out' directly into the
  2306|         0|            0|            0|  0.00%|  #  `Generic[]`.)
  2307|         0|            0|            0|  0.00%|  class Bar(Generic[Unpack[Ts]]): ...
  2308|         0|            0|            0|  0.00%|  Bar[int]  # Valid
  2309|         0|            0|            0|  0.00%|  Bar[int, str]  # Also valid
  2310|         0|            0|            0|  0.00%|
  2311|         0|            0|            0|  0.00%|From Python 3.11, this can also be done using the `*` operator:
  2312|         0|            0|            0|  0.00%|
  2313|         0|            0|            0|  0.00%|    Foo[*tuple[int, str]]
  2314|         0|            0|            0|  0.00%|    class Bar(Generic[*Ts]): ...
  2315|         0|            0|            0|  0.00%|
  2316|         0|            0|            0|  0.00%|The operator can also be used along with a `TypedDict` to annotate
  2317|         0|            0|            0|  0.00%|`**kwargs` in a function signature. For instance:
  2318|         0|            0|            0|  0.00%|
  2319|         0|            0|            0|  0.00%|  class Movie(TypedDict):
  2320|         0|            0|            0|  0.00%|    name: str
  2321|         0|            0|            0|  0.00%|    year: int
  2322|         0|            0|            0|  0.00%|
  2323|         0|            0|            0|  0.00%|  # This function expects two keyword arguments - *name* of type `str` and
  2324|         0|            0|            0|  0.00%|  # *year* of type `int`.
  2325|         0|            0|            0|  0.00%|  def foo(**kwargs: Unpack[Movie]): ...
  2326|         0|            0|            0|  0.00%|
  2327|         0|            0|            0|  0.00%|Note that there is only some runtime checking of this operator. Not
  2328|         0|            0|            0|  0.00%|everything the runtime allows may be accepted by static type checkers.
  2329|         0|            0|            0|  0.00%|
  2330|         0|            0|            0|  0.00%|For more information, see PEP 646 and PEP 692.
  2331|         0|            0|            0|  0.00%|"""
  2332|         0|            0|            0|  0.00%|
  2333|         0|            0|            0|  0.00%|
  2334|         0|            0|            0|  0.00%|if sys.version_info >= (3, 12):  # PEP 692 changed the repr of Unpack[]
  2335|         0|            0|            0|  0.00%|    Unpack = typing.Unpack
  2336|         0|            0|            0|  0.00%|
  2337|         0|            0|            0|  0.00%|    def _is_unpack(obj):
  2338|         0|            0|            0|  0.00%|        return get_origin(obj) is Unpack
  2339|         0|            0|            0|  0.00%|
  2340|         0|            0|            0|  0.00%|elif sys.version_info[:2] >= (3, 9):  # 3.9+
  2341|         0|            0|            0|  0.00%|    class _UnpackSpecialForm(_ExtensionsSpecialForm, _root=True):
  2342|         0|            0|            0|  0.00%|        def __init__(self, getitem):
  2343|         0|            0|            0|  0.00%|            super().__init__(getitem)
  2344|         0|            0|            0|  0.00%|            self.__doc__ = _UNPACK_DOC
  2345|         0|            0|            0|  0.00%|
  2346|         0|            0|            0|  0.00%|    class _UnpackAlias(typing._GenericAlias, _root=True):
  2347|         0|            0|            0|  0.00%|        __class__ = typing.TypeVar
  2348|         0|            0|            0|  0.00%|
  2349|         0|            0|            0|  0.00%|        @property
  2350|         0|            0|            0|  0.00%|        def __typing_unpacked_tuple_args__(self):
  2351|         0|            0|            0|  0.00%|            assert self.__origin__ is Unpack
  2352|         0|            0|            0|  0.00%|            assert len(self.__args__) == 1
  2353|         0|            0|            0|  0.00%|            arg, = self.__args__
  2354|         0|            0|            0|  0.00%|            if isinstance(arg, (typing._GenericAlias, _types.GenericAlias)):
  2355|         0|            0|            0|  0.00%|                if arg.__origin__ is not tuple:
  2356|         0|            0|            0|  0.00%|                    raise TypeError("Unpack[...] must be used with a tuple type")
  2357|         0|            0|            0|  0.00%|                return arg.__args__
  2358|         0|            0|            0|  0.00%|            return None
  2359|         0|            0|            0|  0.00%|
  2360|         0|            0|            0|  0.00%|    @_UnpackSpecialForm
  2361|         0|            0|            0|  0.00%|    def Unpack(self, parameters):
  2362|         0|            0|            0|  0.00%|        item = typing._type_check(parameters, f'{self._name} accepts only a single type.')
  2363|         0|            0|            0|  0.00%|        return _UnpackAlias(self, (item,))
  2364|         0|            0|            0|  0.00%|
  2365|         0|            0|            0|  0.00%|    def _is_unpack(obj):
  2366|         0|            0|            0|  0.00%|        return isinstance(obj, _UnpackAlias)
  2367|         0|            0|            0|  0.00%|
  2368|         0|            0|            0|  0.00%|else:  # 3.8
  2369|         0|            0|            0|  0.00%|    class _UnpackAlias(typing._GenericAlias, _root=True):
  2370|         0|            0|            0|  0.00%|        __class__ = typing.TypeVar
  2371|         0|            0|            0|  0.00%|
  2372|         0|            0|            0|  0.00%|    class _UnpackForm(_ExtensionsSpecialForm, _root=True):
  2373|         0|            0|            0|  0.00%|        def __getitem__(self, parameters):
  2374|         0|            0|            0|  0.00%|            item = typing._type_check(parameters,
  2375|         0|            0|            0|  0.00%|                                      f'{self._name} accepts only a single type.')
  2376|         0|            0|            0|  0.00%|            return _UnpackAlias(self, (item,))
  2377|         0|            0|            0|  0.00%|
  2378|         0|            0|            0|  0.00%|    Unpack = _UnpackForm('Unpack', doc=_UNPACK_DOC)
  2379|         0|            0|            0|  0.00%|
  2380|         0|            0|            0|  0.00%|    def _is_unpack(obj):
  2381|         0|            0|            0|  0.00%|        return isinstance(obj, _UnpackAlias)
  2382|         0|            0|            0|  0.00%|
  2383|         0|            0|            0|  0.00%|
  2384|         0|            0|            0|  0.00%|if _PEP_696_IMPLEMENTED:
  2385|         0|            0|            0|  0.00%|    from typing import TypeVarTuple
  2386|         0|            0|            0|  0.00%|
  2387|         0|            0|            0|  0.00%|elif hasattr(typing, "TypeVarTuple"):  # 3.11+
  2388|         0|            0|            0|  0.00%|
  2389|         0|            0|            0|  0.00%|    def _unpack_args(*args):
  2390|         0|            0|            0|  0.00%|        newargs = []
  2391|         0|            0|            0|  0.00%|        for arg in args:
  2392|         0|            0|            0|  0.00%|            subargs = getattr(arg, '__typing_unpacked_tuple_args__', None)
  2393|         0|            0|            0|  0.00%|            if subargs is not None and not (subargs and subargs[-1] is ...):
  2394|         0|            0|            0|  0.00%|                newargs.extend(subargs)
  2395|         0|            0|            0|  0.00%|            else:
  2396|         0|            0|            0|  0.00%|                newargs.append(arg)
  2397|         0|            0|            0|  0.00%|        return newargs
  2398|         0|            0|            0|  0.00%|
  2399|         0|            0|            0|  0.00%|    # Add default parameter - PEP 696
  2400|         0|            0|            0|  0.00%|    class TypeVarTuple(metaclass=_TypeVarLikeMeta):
  2401|         0|            0|            0|  0.00%|        """Type variable tuple."""
  2402|         0|            0|            0|  0.00%|
  2403|         0|            0|            0|  0.00%|        _backported_typevarlike = typing.TypeVarTuple
  2404|         0|            0|            0|  0.00%|
  2405|         0|            0|            0|  0.00%|        def __new__(cls, name, *, default=NoDefault):
  2406|         0|            0|            0|  0.00%|            tvt = typing.TypeVarTuple(name)
  2407|         0|            0|            0|  0.00%|            _set_default(tvt, default)
  2408|         0|            0|            0|  0.00%|            _set_module(tvt)
  2409|         0|            0|            0|  0.00%|
  2410|         0|            0|            0|  0.00%|            def _typevartuple_prepare_subst(alias, args):
  2411|         0|            0|            0|  0.00%|                params = alias.__parameters__
  2412|         0|            0|            0|  0.00%|                typevartuple_index = params.index(tvt)
  2413|         0|            0|            0|  0.00%|                for param in params[typevartuple_index + 1:]:
  2414|         0|            0|            0|  0.00%|                    if isinstance(param, TypeVarTuple):
  2415|         0|            0|            0|  0.00%|                        raise TypeError(
  2416|         0|            0|            0|  0.00%|                            f"More than one TypeVarTuple parameter in {alias}"
  2417|         0|            0|            0|  0.00%|                        )
  2418|         0|            0|            0|  0.00%|
  2419|         0|            0|            0|  0.00%|                alen = len(args)
  2420|         0|            0|            0|  0.00%|                plen = len(params)
  2421|         0|            0|            0|  0.00%|                left = typevartuple_index
  2422|         0|            0|            0|  0.00%|                right = plen - typevartuple_index - 1
  2423|         0|            0|            0|  0.00%|                var_tuple_index = None
  2424|         0|            0|            0|  0.00%|                fillarg = None
  2425|         0|            0|            0|  0.00%|                for k, arg in enumerate(args):
  2426|         0|            0|            0|  0.00%|                    if not isinstance(arg, type):
  2427|         0|            0|            0|  0.00%|                        subargs = getattr(arg, '__typing_unpacked_tuple_args__', None)
  2428|         0|            0|            0|  0.00%|                        if subargs and len(subargs) == 2 and subargs[-1] is ...:
  2429|         0|            0|            0|  0.00%|                            if var_tuple_index is not None:
  2430|         0|            0|            0|  0.00%|                                raise TypeError(
  2431|         0|            0|            0|  0.00%|                                    "More than one unpacked "
  2432|         0|            0|            0|  0.00%|                                    "arbitrary-length tuple argument"
  2433|         0|            0|            0|  0.00%|                                )
  2434|         0|            0|            0|  0.00%|                            var_tuple_index = k
  2435|         0|            0|            0|  0.00%|                            fillarg = subargs[0]
  2436|         0|            0|            0|  0.00%|                if var_tuple_index is not None:
  2437|         0|            0|            0|  0.00%|                    left = min(left, var_tuple_index)
  2438|         0|            0|            0|  0.00%|                    right = min(right, alen - var_tuple_index - 1)
  2439|         0|            0|            0|  0.00%|                elif left + right > alen:
  2440|         0|            0|            0|  0.00%|                    raise TypeError(f"Too few arguments for {alias};"
  2441|         0|            0|            0|  0.00%|                                    f" actual {alen}, expected at least {plen - 1}")
  2442|         0|            0|            0|  0.00%|                if left == alen - right and tvt.has_default():
  2443|         0|            0|            0|  0.00%|                    replacement = _unpack_args(tvt.__default__)
  2444|         0|            0|            0|  0.00%|                else:
  2445|         0|            0|            0|  0.00%|                    replacement = args[left: alen - right]
  2446|         0|            0|            0|  0.00%|
  2447|         0|            0|            0|  0.00%|                return (
  2448|         0|            0|            0|  0.00%|                    *args[:left],
  2449|         0|            0|            0|  0.00%|                    *([fillarg] * (typevartuple_index - left)),
  2450|         0|            0|            0|  0.00%|                    replacement,
  2451|         0|            0|            0|  0.00%|                    *([fillarg] * (plen - right - left - typevartuple_index - 1)),
  2452|         0|            0|            0|  0.00%|                    *args[alen - right:],
  2453|         0|            0|            0|  0.00%|                )
  2454|         0|            0|            0|  0.00%|
  2455|         0|            0|            0|  0.00%|            tvt.__typing_prepare_subst__ = _typevartuple_prepare_subst
  2456|         0|            0|            0|  0.00%|            return tvt
  2457|         0|            0|            0|  0.00%|
  2458|         0|            0|            0|  0.00%|        def __init_subclass__(self, *args, **kwds):
  2459|         0|            0|            0|  0.00%|            raise TypeError("Cannot subclass special typing classes")
  2460|         0|            0|            0|  0.00%|
  2461|         0|            0|            0|  0.00%|else:  # <=3.10
  2462|         0|            0|            0|  0.00%|    class TypeVarTuple(_DefaultMixin):
  2463|         0|            0|            0|  0.00%|        """Type variable tuple.
  2464|         0|            0|            0|  0.00%|
  2465|         0|            0|            0|  0.00%|        Usage::
  2466|         0|            0|            0|  0.00%|
  2467|         0|            0|            0|  0.00%|            Ts = TypeVarTuple('Ts')
  2468|         0|            0|            0|  0.00%|
  2469|         0|            0|            0|  0.00%|        In the same way that a normal type variable is a stand-in for a single
  2470|         0|            0|            0|  0.00%|        type such as ``int``, a type variable *tuple* is a stand-in for a *tuple*
  2471|         0|            0|            0|  0.00%|        type such as ``Tuple[int, str]``.
  2472|         0|            0|            0|  0.00%|
  2473|         0|            0|            0|  0.00%|        Type variable tuples can be used in ``Generic`` declarations.
  2474|         0|            0|            0|  0.00%|        Consider the following example::
  2475|         0|            0|            0|  0.00%|
  2476|         0|            0|            0|  0.00%|            class Array(Generic[*Ts]): ...
  2477|         0|            0|            0|  0.00%|
  2478|         0|            0|            0|  0.00%|        The ``Ts`` type variable tuple here behaves like ``tuple[T1, T2]``,
  2479|         0|            0|            0|  0.00%|        where ``T1`` and ``T2`` are type variables. To use these type variables
  2480|         0|            0|            0|  0.00%|        as type parameters of ``Array``, we must *unpack* the type variable tuple using
  2481|         0|            0|            0|  0.00%|        the star operator: ``*Ts``. The signature of ``Array`` then behaves
  2482|         0|            0|            0|  0.00%|        as if we had simply written ``class Array(Generic[T1, T2]): ...``.
  2483|         0|            0|            0|  0.00%|        In contrast to ``Generic[T1, T2]``, however, ``Generic[*Shape]`` allows
  2484|         0|            0|            0|  0.00%|        us to parameterise the class with an *arbitrary* number of type parameters.
  2485|         0|            0|            0|  0.00%|
  2486|         0|            0|            0|  0.00%|        Type variable tuples can be used anywhere a normal ``TypeVar`` can.
  2487|         0|            0|            0|  0.00%|        This includes class definitions, as shown above, as well as function
  2488|         0|            0|            0|  0.00%|        signatures and variable annotations::
  2489|         0|            0|            0|  0.00%|
  2490|         0|            0|            0|  0.00%|            class Array(Generic[*Ts]):
  2491|         0|            0|            0|  0.00%|
  2492|         0|            0|            0|  0.00%|                def __init__(self, shape: Tuple[*Ts]):
  2493|         0|            0|            0|  0.00%|                    self._shape: Tuple[*Ts] = shape
  2494|         0|            0|            0|  0.00%|
  2495|         0|            0|            0|  0.00%|                def get_shape(self) -> Tuple[*Ts]:
  2496|         0|            0|            0|  0.00%|                    return self._shape
  2497|         0|            0|            0|  0.00%|
  2498|         0|            0|            0|  0.00%|            shape = (Height(480), Width(640))
  2499|         0|            0|            0|  0.00%|            x: Array[Height, Width] = Array(shape)
  2500|         0|            0|            0|  0.00%|            y = abs(x)  # Inferred type is Array[Height, Width]
  2501|         0|            0|            0|  0.00%|            z = x + x   #        ...    is Array[Height, Width]
  2502|         0|            0|            0|  0.00%|            x.get_shape()  #     ...    is tuple[Height, Width]
  2503|         0|            0|            0|  0.00%|
  2504|         0|            0|            0|  0.00%|        """
  2505|         0|            0|            0|  0.00%|
  2506|         0|            0|            0|  0.00%|        # Trick Generic __parameters__.
  2507|         0|            0|            0|  0.00%|        __class__ = typing.TypeVar
  2508|         0|            0|            0|  0.00%|
  2509|         0|            0|            0|  0.00%|        def __iter__(self):
  2510|         0|            0|            0|  0.00%|            yield self.__unpacked__
  2511|         0|            0|            0|  0.00%|
  2512|         0|            0|            0|  0.00%|        def __init__(self, name, *, default=NoDefault):
  2513|         0|            0|            0|  0.00%|            self.__name__ = name
  2514|         0|            0|            0|  0.00%|            _DefaultMixin.__init__(self, default)
  2515|         0|            0|            0|  0.00%|
  2516|         0|            0|            0|  0.00%|            # for pickling:
  2517|         0|            0|            0|  0.00%|            def_mod = _caller()
  2518|         0|            0|            0|  0.00%|            if def_mod != 'typing_extensions':
  2519|         0|            0|            0|  0.00%|                self.__module__ = def_mod
  2520|         0|            0|            0|  0.00%|
  2521|         0|            0|            0|  0.00%|            self.__unpacked__ = Unpack[self]
  2522|         0|            0|            0|  0.00%|
  2523|         0|            0|            0|  0.00%|        def __repr__(self):
  2524|         0|            0|            0|  0.00%|            return self.__name__
  2525|         0|            0|            0|  0.00%|
  2526|         0|            0|            0|  0.00%|        def __hash__(self):
  2527|         0|            0|            0|  0.00%|            return object.__hash__(self)
  2528|         0|            0|            0|  0.00%|
  2529|         0|            0|            0|  0.00%|        def __eq__(self, other):
  2530|         0|            0|            0|  0.00%|            return self is other
  2531|         0|            0|            0|  0.00%|
  2532|         0|            0|            0|  0.00%|        def __reduce__(self):
  2533|         0|            0|            0|  0.00%|            return self.__name__
  2534|         0|            0|            0|  0.00%|
  2535|         0|            0|            0|  0.00%|        def __init_subclass__(self, *args, **kwds):
  2536|         0|            0|            0|  0.00%|            if '_root' not in kwds:
  2537|         0|            0|            0|  0.00%|                raise TypeError("Cannot subclass special typing classes")
  2538|         0|            0|            0|  0.00%|
  2539|         0|            0|            0|  0.00%|
  2540|         0|            0|            0|  0.00%|if hasattr(typing, "reveal_type"):  # 3.11+
  2541|         0|            0|            0|  0.00%|    reveal_type = typing.reveal_type
  2542|         0|            0|            0|  0.00%|else:  # <=3.10
  2543|         0|            0|            0|  0.00%|    def reveal_type(obj: T, /) -> T:
  2544|         0|            0|            0|  0.00%|        """Reveal the inferred type of a variable.
  2545|         0|            0|            0|  0.00%|
  2546|         0|            0|            0|  0.00%|        When a static type checker encounters a call to ``reveal_type()``,
  2547|         0|            0|            0|  0.00%|        it will emit the inferred type of the argument::
  2548|         0|            0|            0|  0.00%|
  2549|         0|            0|            0|  0.00%|            x: int = 1
  2550|         0|            0|            0|  0.00%|            reveal_type(x)
  2551|         0|            0|            0|  0.00%|
  2552|         0|            0|            0|  0.00%|        Running a static type checker (e.g., ``mypy``) on this example
  2553|         0|            0|            0|  0.00%|        will produce output similar to 'Revealed type is "builtins.int"'.
  2554|         0|            0|            0|  0.00%|
  2555|         0|            0|            0|  0.00%|        At runtime, the function prints the runtime type of the
  2556|         0|            0|            0|  0.00%|        argument and returns it unchanged.
  2557|         0|            0|            0|  0.00%|
  2558|         0|            0|            0|  0.00%|        """
  2559|         0|            0|            0|  0.00%|        print(f"Runtime type is {type(obj).__name__!r}", file=sys.stderr)
  2560|         0|            0|            0|  0.00%|        return obj
  2561|         0|            0|            0|  0.00%|
  2562|         0|            0|            0|  0.00%|
  2563|         0|            0|            0|  0.00%|if hasattr(typing, "_ASSERT_NEVER_REPR_MAX_LENGTH"):  # 3.11+
  2564|         0|            0|            0|  0.00%|    _ASSERT_NEVER_REPR_MAX_LENGTH = typing._ASSERT_NEVER_REPR_MAX_LENGTH
  2565|         0|            0|            0|  0.00%|else:  # <=3.10
  2566|         0|            0|            0|  0.00%|    _ASSERT_NEVER_REPR_MAX_LENGTH = 100
  2567|         0|            0|            0|  0.00%|
  2568|         0|            0|            0|  0.00%|
  2569|         0|            0|            0|  0.00%|if hasattr(typing, "assert_never"):  # 3.11+
  2570|         0|            0|            0|  0.00%|    assert_never = typing.assert_never
  2571|         0|            0|            0|  0.00%|else:  # <=3.10
  2572|         0|            0|            0|  0.00%|    def assert_never(arg: Never, /) -> Never:
  2573|         0|            0|            0|  0.00%|        """Assert to the type checker that a line of code is unreachable.
  2574|         0|            0|            0|  0.00%|
  2575|         0|            0|            0|  0.00%|        Example::
  2576|         0|            0|            0|  0.00%|
  2577|         0|            0|            0|  0.00%|            def int_or_str(arg: int | str) -> None:
  2578|         0|            0|            0|  0.00%|                match arg:
  2579|         0|            0|            0|  0.00%|                    case int():
  2580|         0|            0|            0|  0.00%|                        print("It's an int")
  2581|         0|            0|            0|  0.00%|                    case str():
  2582|         0|            0|            0|  0.00%|                        print("It's a str")
  2583|         0|            0|            0|  0.00%|                    case _:
  2584|         0|            0|            0|  0.00%|                        assert_never(arg)
  2585|         0|            0|            0|  0.00%|
  2586|         0|            0|            0|  0.00%|        If a type checker finds that a call to assert_never() is
  2587|         0|            0|            0|  0.00%|        reachable, it will emit an error.
  2588|         0|            0|            0|  0.00%|
  2589|         0|            0|            0|  0.00%|        At runtime, this throws an exception when called.
  2590|         0|            0|            0|  0.00%|
  2591|         0|            0|            0|  0.00%|        """
  2592|         0|            0|            0|  0.00%|        value = repr(arg)
  2593|         0|            0|            0|  0.00%|        if len(value) > _ASSERT_NEVER_REPR_MAX_LENGTH:
  2594|         0|            0|            0|  0.00%|            value = value[:_ASSERT_NEVER_REPR_MAX_LENGTH] + '...'
  2595|         0|            0|            0|  0.00%|        raise AssertionError(f"Expected code to be unreachable, but got: {value}")
  2596|         0|            0|            0|  0.00%|
  2597|         0|            0|            0|  0.00%|
  2598|         0|            0|            0|  0.00%|if sys.version_info >= (3, 12):  # 3.12+
  2599|         0|            0|            0|  0.00%|    # dataclass_transform exists in 3.11 but lacks the frozen_default parameter
  2600|         0|            0|            0|  0.00%|    dataclass_transform = typing.dataclass_transform
  2601|         0|            0|            0|  0.00%|else:  # <=3.11
  2602|         0|            0|            0|  0.00%|    def dataclass_transform(
  2603|         0|            0|            0|  0.00%|        *,
  2604|         0|            0|            0|  0.00%|        eq_default: bool = True,
  2605|         0|            0|            0|  0.00%|        order_default: bool = False,
  2606|         0|            0|            0|  0.00%|        kw_only_default: bool = False,
  2607|         0|            0|            0|  0.00%|        frozen_default: bool = False,
  2608|         0|            0|            0|  0.00%|        field_specifiers: typing.Tuple[
  2609|         0|            0|            0|  0.00%|            typing.Union[typing.Type[typing.Any], typing.Callable[..., typing.Any]],
  2610|         0|            0|            0|  0.00%|            ...
  2611|         0|            0|            0|  0.00%|        ] = (),
  2612|         0|            0|            0|  0.00%|        **kwargs: typing.Any,
  2613|         0|            0|            0|  0.00%|    ) -> typing.Callable[[T], T]:
  2614|         0|            0|            0|  0.00%|        """Decorator that marks a function, class, or metaclass as providing
  2615|         0|            0|            0|  0.00%|        dataclass-like behavior.
  2616|         0|            0|            0|  0.00%|
  2617|         0|            0|            0|  0.00%|        Example:
  2618|         0|            0|            0|  0.00%|
  2619|         0|            0|            0|  0.00%|            from typing_extensions import dataclass_transform
  2620|         0|            0|            0|  0.00%|
  2621|         0|            0|            0|  0.00%|            _T = TypeVar("_T")
  2622|         0|            0|            0|  0.00%|
  2623|         0|            0|            0|  0.00%|            # Used on a decorator function
  2624|         0|            0|            0|  0.00%|            @dataclass_transform()
  2625|         0|            0|            0|  0.00%|            def create_model(cls: type[_T]) -> type[_T]:
  2626|         0|            0|            0|  0.00%|                ...
  2627|         0|            0|            0|  0.00%|                return cls
  2628|         0|            0|            0|  0.00%|
  2629|         0|            0|            0|  0.00%|            @create_model
  2630|         0|            0|            0|  0.00%|            class CustomerModel:
  2631|         0|            0|            0|  0.00%|                id: int
  2632|         0|            0|            0|  0.00%|                name: str
  2633|         0|            0|            0|  0.00%|
  2634|         0|            0|            0|  0.00%|            # Used on a base class
  2635|         0|            0|            0|  0.00%|            @dataclass_transform()
  2636|         0|            0|            0|  0.00%|            class ModelBase: ...
  2637|         0|            0|            0|  0.00%|
  2638|         0|            0|            0|  0.00%|            class CustomerModel(ModelBase):
  2639|         0|            0|            0|  0.00%|                id: int
  2640|         0|            0|            0|  0.00%|                name: str
  2641|         0|            0|            0|  0.00%|
  2642|         0|            0|            0|  0.00%|            # Used on a metaclass
  2643|         0|            0|            0|  0.00%|            @dataclass_transform()
  2644|         0|            0|            0|  0.00%|            class ModelMeta(type): ...
  2645|         0|            0|            0|  0.00%|
  2646|         0|            0|            0|  0.00%|            class ModelBase(metaclass=ModelMeta): ...
  2647|         0|            0|            0|  0.00%|
  2648|         0|            0|            0|  0.00%|            class CustomerModel(ModelBase):
  2649|         0|            0|            0|  0.00%|                id: int
  2650|         0|            0|            0|  0.00%|                name: str
  2651|         0|            0|            0|  0.00%|
  2652|         0|            0|            0|  0.00%|        Each of the ``CustomerModel`` classes defined in this example will now
  2653|         0|            0|            0|  0.00%|        behave similarly to a dataclass created with the ``@dataclasses.dataclass``
  2654|         0|            0|            0|  0.00%|        decorator. For example, the type checker will synthesize an ``__init__``
  2655|         0|            0|            0|  0.00%|        method.
  2656|         0|            0|            0|  0.00%|
  2657|         0|            0|            0|  0.00%|        The arguments to this decorator can be used to customize this behavior:
  2658|         0|            0|            0|  0.00%|        - ``eq_default`` indicates whether the ``eq`` parameter is assumed to be
  2659|         0|            0|            0|  0.00%|          True or False if it is omitted by the caller.
  2660|         0|            0|            0|  0.00%|        - ``order_default`` indicates whether the ``order`` parameter is
  2661|         0|            0|            0|  0.00%|          assumed to be True or False if it is omitted by the caller.
  2662|         0|            0|            0|  0.00%|        - ``kw_only_default`` indicates whether the ``kw_only`` parameter is
  2663|         0|            0|            0|  0.00%|          assumed to be True or False if it is omitted by the caller.
  2664|         0|            0|            0|  0.00%|        - ``frozen_default`` indicates whether the ``frozen`` parameter is
  2665|         0|            0|            0|  0.00%|          assumed to be True or False if it is omitted by the caller.
  2666|         0|            0|            0|  0.00%|        - ``field_specifiers`` specifies a static list of supported classes
  2667|         0|            0|            0|  0.00%|          or functions that describe fields, similar to ``dataclasses.field()``.
  2668|         0|            0|            0|  0.00%|
  2669|         0|            0|            0|  0.00%|        At runtime, this decorator records its arguments in the
  2670|         0|            0|            0|  0.00%|        ``__dataclass_transform__`` attribute on the decorated object.
  2671|         0|            0|            0|  0.00%|
  2672|         0|            0|            0|  0.00%|        See PEP 681 for details.
  2673|         0|            0|            0|  0.00%|
  2674|         0|            0|            0|  0.00%|        """
  2675|         0|            0|            0|  0.00%|        def decorator(cls_or_fn):
  2676|         0|            0|            0|  0.00%|            cls_or_fn.__dataclass_transform__ = {
  2677|         0|            0|            0|  0.00%|                "eq_default": eq_default,
  2678|         0|            0|            0|  0.00%|                "order_default": order_default,
  2679|         0|            0|            0|  0.00%|                "kw_only_default": kw_only_default,
  2680|         0|            0|            0|  0.00%|                "frozen_default": frozen_default,
  2681|         0|            0|            0|  0.00%|                "field_specifiers": field_specifiers,
  2682|         0|            0|            0|  0.00%|                "kwargs": kwargs,
  2683|         0|            0|            0|  0.00%|            }
  2684|         0|            0|            0|  0.00%|            return cls_or_fn
  2685|         0|            0|            0|  0.00%|        return decorator
  2686|         0|            0|            0|  0.00%|
  2687|         0|            0|            0|  0.00%|
  2688|         0|            0|            0|  0.00%|if hasattr(typing, "override"):  # 3.12+
  2689|         0|            0|            0|  0.00%|    override = typing.override
  2690|         0|            0|            0|  0.00%|else:  # <=3.11
  2691|         0|            0|            0|  0.00%|    _F = typing.TypeVar("_F", bound=typing.Callable[..., typing.Any])
  2692|         0|            0|            0|  0.00%|
  2693|         0|            0|            0|  0.00%|    def override(arg: _F, /) -> _F:
  2694|         0|            0|            0|  0.00%|        """Indicate that a method is intended to override a method in a base class.
  2695|         0|            0|            0|  0.00%|
  2696|         0|            0|            0|  0.00%|        Usage:
  2697|         0|            0|            0|  0.00%|
  2698|         0|            0|            0|  0.00%|            class Base:
  2699|         0|            0|            0|  0.00%|                def method(self) -> None:
  2700|         0|            0|            0|  0.00%|                    pass
  2701|         0|            0|            0|  0.00%|
  2702|         0|            0|            0|  0.00%|            class Child(Base):
  2703|         0|            0|            0|  0.00%|                @override
  2704|         0|            0|            0|  0.00%|                def method(self) -> None:
  2705|         0|            0|            0|  0.00%|                    super().method()
  2706|         0|            0|            0|  0.00%|
  2707|         0|            0|            0|  0.00%|        When this decorator is applied to a method, the type checker will
  2708|         0|            0|            0|  0.00%|        validate that it overrides a method with the same name on a base class.
  2709|         0|            0|            0|  0.00%|        This helps prevent bugs that may occur when a base class is changed
  2710|         0|            0|            0|  0.00%|        without an equivalent change to a child class.
  2711|         0|            0|            0|  0.00%|
  2712|         0|            0|            0|  0.00%|        There is no runtime checking of these properties. The decorator
  2713|         0|            0|            0|  0.00%|        sets the ``__override__`` attribute to ``True`` on the decorated object
  2714|         0|            0|            0|  0.00%|        to allow runtime introspection.
  2715|         0|            0|            0|  0.00%|
  2716|         0|            0|            0|  0.00%|        See PEP 698 for details.
  2717|         0|            0|            0|  0.00%|
  2718|         0|            0|            0|  0.00%|        """
  2719|         0|            0|            0|  0.00%|        try:
  2720|         0|            0|            0|  0.00%|            arg.__override__ = True
  2721|         0|            0|            0|  0.00%|        except (AttributeError, TypeError):
  2722|         0|            0|            0|  0.00%|            # Skip the attribute silently if it is not writable.
  2723|         0|            0|            0|  0.00%|            # AttributeError happens if the object has __slots__ or a
  2724|         0|            0|            0|  0.00%|            # read-only property, TypeError if it's a builtin class.
  2725|         0|            0|            0|  0.00%|            pass
  2726|         0|            0|            0|  0.00%|        return arg
  2727|         0|            0|            0|  0.00%|
  2728|         0|            0|            0|  0.00%|
  2729|         0|            0|            0|  0.00%|if hasattr(warnings, "deprecated"):
  2730|         0|            0|            0|  0.00%|    deprecated = warnings.deprecated
  2731|         0|            0|            0|  0.00%|else:
  2732|         0|            0|            0|  0.00%|    _T = typing.TypeVar("_T")
  2733|         0|            0|            0|  0.00%|
  2734|         0|            0|            0|  0.00%|    class deprecated:
  2735|         0|            0|            0|  0.00%|        """Indicate that a class, function or overload is deprecated.
  2736|         0|            0|            0|  0.00%|
  2737|         0|            0|            0|  0.00%|        When this decorator is applied to an object, the type checker
  2738|         0|            0|            0|  0.00%|        will generate a diagnostic on usage of the deprecated object.
  2739|         0|            0|            0|  0.00%|
  2740|         0|            0|            0|  0.00%|        Usage:
  2741|         0|            0|            0|  0.00%|
  2742|         0|            0|            0|  0.00%|            @deprecated("Use B instead")
  2743|         0|            0|            0|  0.00%|            class A:
  2744|         0|            0|            0|  0.00%|                pass
  2745|         0|            0|            0|  0.00%|
  2746|         0|            0|            0|  0.00%|            @deprecated("Use g instead")
  2747|         0|            0|            0|  0.00%|            def f():
  2748|         0|            0|            0|  0.00%|                pass
  2749|         0|            0|            0|  0.00%|
  2750|         0|            0|            0|  0.00%|            @overload
  2751|         0|            0|            0|  0.00%|            @deprecated("int support is deprecated")
  2752|         0|            0|            0|  0.00%|            def g(x: int) -> int: ...
  2753|         0|            0|            0|  0.00%|            @overload
  2754|         0|            0|            0|  0.00%|            def g(x: str) -> int: ...
  2755|         0|            0|            0|  0.00%|
  2756|         0|            0|            0|  0.00%|        The warning specified by *category* will be emitted at runtime
  2757|         0|            0|            0|  0.00%|        on use of deprecated objects. For functions, that happens on calls;
  2758|         0|            0|            0|  0.00%|        for classes, on instantiation and on creation of subclasses.
  2759|         0|            0|            0|  0.00%|        If the *category* is ``None``, no warning is emitted at runtime.
  2760|         0|            0|            0|  0.00%|        The *stacklevel* determines where the
  2761|         0|            0|            0|  0.00%|        warning is emitted. If it is ``1`` (the default), the warning
  2762|         0|            0|            0|  0.00%|        is emitted at the direct caller of the deprecated object; if it
  2763|         0|            0|            0|  0.00%|        is higher, it is emitted further up the stack.
  2764|         0|            0|            0|  0.00%|        Static type checker behavior is not affected by the *category*
  2765|         0|            0|            0|  0.00%|        and *stacklevel* arguments.
  2766|         0|            0|            0|  0.00%|
  2767|         0|            0|            0|  0.00%|        The deprecation message passed to the decorator is saved in the
  2768|         0|            0|            0|  0.00%|        ``__deprecated__`` attribute on the decorated object.
  2769|         0|            0|            0|  0.00%|        If applied to an overload, the decorator
  2770|         0|            0|            0|  0.00%|        must be after the ``@overload`` decorator for the attribute to
  2771|         0|            0|            0|  0.00%|        exist on the overload as returned by ``get_overloads()``.
  2772|         0|            0|            0|  0.00%|
  2773|         0|            0|            0|  0.00%|        See PEP 702 for details.
  2774|         0|            0|            0|  0.00%|
  2775|         0|            0|            0|  0.00%|        """
  2776|         0|            0|            0|  0.00%|        def __init__(
  2777|         0|            0|            0|  0.00%|            self,
  2778|         0|            0|            0|  0.00%|            message: str,
  2779|         0|            0|            0|  0.00%|            /,
  2780|         0|            0|            0|  0.00%|            *,
  2781|         0|            0|            0|  0.00%|            category: typing.Optional[typing.Type[Warning]] = DeprecationWarning,
  2782|         0|            0|            0|  0.00%|            stacklevel: int = 1,
  2783|         0|            0|            0|  0.00%|        ) -> None:
  2784|         0|            0|            0|  0.00%|            if not isinstance(message, str):
  2785|         0|            0|            0|  0.00%|                raise TypeError(
  2786|         0|            0|            0|  0.00%|                    "Expected an object of type str for 'message', not "
  2787|         0|            0|            0|  0.00%|                    f"{type(message).__name__!r}"
  2788|         0|            0|            0|  0.00%|                )
  2789|         0|            0|            0|  0.00%|            self.message = message
  2790|         0|            0|            0|  0.00%|            self.category = category
  2791|         0|            0|            0|  0.00%|            self.stacklevel = stacklevel
  2792|         0|            0|            0|  0.00%|
  2793|         0|            0|            0|  0.00%|        def __call__(self, arg: _T, /) -> _T:
  2794|         0|            0|            0|  0.00%|            # Make sure the inner functions created below don't
  2795|         0|            0|            0|  0.00%|            # retain a reference to self.
  2796|         0|            0|            0|  0.00%|            msg = self.message
  2797|         0|            0|            0|  0.00%|            category = self.category
  2798|         0|            0|            0|  0.00%|            stacklevel = self.stacklevel
  2799|         0|            0|            0|  0.00%|            if category is None:
  2800|         0|            0|            0|  0.00%|                arg.__deprecated__ = msg
  2801|         0|            0|            0|  0.00%|                return arg
  2802|         0|            0|            0|  0.00%|            elif isinstance(arg, type):
  2803|         0|            0|            0|  0.00%|                import functools
  2804|         0|            0|            0|  0.00%|                from types import MethodType
  2805|         0|            0|            0|  0.00%|
  2806|         0|            0|            0|  0.00%|                original_new = arg.__new__
  2807|         0|            0|            0|  0.00%|
  2808|         0|            0|            0|  0.00%|                @functools.wraps(original_new)
  2809|         0|            0|            0|  0.00%|                def __new__(cls, *args, **kwargs):
  2810|         0|            0|            0|  0.00%|                    if cls is arg:
  2811|         0|            0|            0|  0.00%|                        warnings.warn(msg, category=category, stacklevel=stacklevel + 1)
  2812|         0|            0|            0|  0.00%|                    if original_new is not object.__new__:
  2813|         0|            0|            0|  0.00%|                        return original_new(cls, *args, **kwargs)
  2814|         0|            0|            0|  0.00%|                    # Mirrors a similar check in object.__new__.
  2815|         0|            0|            0|  0.00%|                    elif cls.__init__ is object.__init__ and (args or kwargs):
  2816|         0|            0|            0|  0.00%|                        raise TypeError(f"{cls.__name__}() takes no arguments")
  2817|         0|            0|            0|  0.00%|                    else:
  2818|         0|            0|            0|  0.00%|                        return original_new(cls)
  2819|         0|            0|            0|  0.00%|
  2820|         0|            0|            0|  0.00%|                arg.__new__ = staticmethod(__new__)
  2821|         0|            0|            0|  0.00%|
  2822|         0|            0|            0|  0.00%|                original_init_subclass = arg.__init_subclass__
  2823|         0|            0|            0|  0.00%|                # We need slightly different behavior if __init_subclass__
  2824|         0|            0|            0|  0.00%|                # is a bound method (likely if it was implemented in Python)
  2825|         0|            0|            0|  0.00%|                if isinstance(original_init_subclass, MethodType):
  2826|         0|            0|            0|  0.00%|                    original_init_subclass = original_init_subclass.__func__
  2827|         0|            0|            0|  0.00%|
  2828|         0|            0|            0|  0.00%|                    @functools.wraps(original_init_subclass)
  2829|         0|            0|            0|  0.00%|                    def __init_subclass__(*args, **kwargs):
  2830|         0|            0|            0|  0.00%|                        warnings.warn(msg, category=category, stacklevel=stacklevel + 1)
  2831|         0|            0|            0|  0.00%|                        return original_init_subclass(*args, **kwargs)
  2832|         0|            0|            0|  0.00%|
  2833|         0|            0|            0|  0.00%|                    arg.__init_subclass__ = classmethod(__init_subclass__)
  2834|         0|            0|            0|  0.00%|                # Or otherwise, which likely means it's a builtin such as
  2835|         0|            0|            0|  0.00%|                # object's implementation of __init_subclass__.
  2836|         0|            0|            0|  0.00%|                else:
  2837|         0|            0|            0|  0.00%|                    @functools.wraps(original_init_subclass)
  2838|         0|            0|            0|  0.00%|                    def __init_subclass__(*args, **kwargs):
  2839|         0|            0|            0|  0.00%|                        warnings.warn(msg, category=category, stacklevel=stacklevel + 1)
  2840|         0|            0|            0|  0.00%|                        return original_init_subclass(*args, **kwargs)
  2841|         0|            0|            0|  0.00%|
  2842|         0|            0|            0|  0.00%|                    arg.__init_subclass__ = __init_subclass__
  2843|         0|            0|            0|  0.00%|
  2844|         0|            0|            0|  0.00%|                arg.__deprecated__ = __new__.__deprecated__ = msg
  2845|         0|            0|            0|  0.00%|                __init_subclass__.__deprecated__ = msg
  2846|         0|            0|            0|  0.00%|                return arg
  2847|         0|            0|            0|  0.00%|            elif callable(arg):
  2848|         0|            0|            0|  0.00%|                import functools
  2849|         0|            0|            0|  0.00%|
  2850|         0|            0|            0|  0.00%|                @functools.wraps(arg)
  2851|         0|            0|            0|  0.00%|                def wrapper(*args, **kwargs):
  2852|         0|            0|            0|  0.00%|                    warnings.warn(msg, category=category, stacklevel=stacklevel + 1)
  2853|         0|            0|            0|  0.00%|                    return arg(*args, **kwargs)
  2854|         0|            0|            0|  0.00%|
  2855|         0|            0|            0|  0.00%|                arg.__deprecated__ = wrapper.__deprecated__ = msg
  2856|         0|            0|            0|  0.00%|                return wrapper
  2857|         0|            0|            0|  0.00%|            else:
  2858|         0|            0|            0|  0.00%|                raise TypeError(
  2859|         0|            0|            0|  0.00%|                    "@deprecated decorator with non-None category must be applied to "
  2860|         0|            0|            0|  0.00%|                    f"a class or callable, not {arg!r}"
  2861|         0|            0|            0|  0.00%|                )
  2862|         0|            0|            0|  0.00%|
  2863|         0|            0|            0|  0.00%|
  2864|         0|            0|            0|  0.00%|# We have to do some monkey patching to deal with the dual nature of
  2865|         0|            0|            0|  0.00%|# Unpack/TypeVarTuple:
  2866|         0|            0|            0|  0.00%|# - We want Unpack to be a kind of TypeVar so it gets accepted in
  2867|         0|            0|            0|  0.00%|#   Generic[Unpack[Ts]]
  2868|         0|            0|            0|  0.00%|# - We want it to *not* be treated as a TypeVar for the purposes of
  2869|         0|            0|            0|  0.00%|#   counting generic parameters, so that when we subscript a generic,
  2870|         0|            0|            0|  0.00%|#   the runtime doesn't try to substitute the Unpack with the subscripted type.
  2871|         0|            0|            0|  0.00%|if not hasattr(typing, "TypeVarTuple"):
  2872|         0|            0|            0|  0.00%|    def _check_generic(cls, parameters, elen=_marker):
  2873|         0|            0|            0|  0.00%|        """Check correct count for parameters of a generic cls (internal helper).
  2874|         0|            0|            0|  0.00%|
  2875|         0|            0|            0|  0.00%|        This gives a nice error message in case of count mismatch.
  2876|         0|            0|            0|  0.00%|        """
  2877|         0|            0|            0|  0.00%|        if not elen:
  2878|         0|            0|            0|  0.00%|            raise TypeError(f"{cls} is not a generic class")
  2879|         0|            0|            0|  0.00%|        if elen is _marker:
  2880|         0|            0|            0|  0.00%|            if not hasattr(cls, "__parameters__") or not cls.__parameters__:
  2881|         0|            0|            0|  0.00%|                raise TypeError(f"{cls} is not a generic class")
  2882|         0|            0|            0|  0.00%|            elen = len(cls.__parameters__)
  2883|         0|            0|            0|  0.00%|        alen = len(parameters)
  2884|         0|            0|            0|  0.00%|        if alen != elen:
  2885|         0|            0|            0|  0.00%|            expect_val = elen
  2886|         0|            0|            0|  0.00%|            if hasattr(cls, "__parameters__"):
  2887|         0|            0|            0|  0.00%|                parameters = [p for p in cls.__parameters__ if not _is_unpack(p)]
  2888|         0|            0|            0|  0.00%|                num_tv_tuples = sum(isinstance(p, TypeVarTuple) for p in parameters)
  2889|         0|            0|            0|  0.00%|                if (num_tv_tuples > 0) and (alen >= elen - num_tv_tuples):
  2890|         0|            0|            0|  0.00%|                    return
  2891|         0|            0|            0|  0.00%|
  2892|         0|            0|            0|  0.00%|                # deal with TypeVarLike defaults
  2893|         0|            0|            0|  0.00%|                # required TypeVarLikes cannot appear after a defaulted one.
  2894|         0|            0|            0|  0.00%|                if alen < elen:
  2895|         0|            0|            0|  0.00%|                    # since we validate TypeVarLike default in _collect_type_vars
  2896|         0|            0|            0|  0.00%|                    # or _collect_parameters we can safely check parameters[alen]
  2897|         0|            0|            0|  0.00%|                    if (
  2898|         0|            0|            0|  0.00%|                        getattr(parameters[alen], '__default__', NoDefault)
  2899|         0|            0|            0|  0.00%|                        is not NoDefault
  2900|         0|            0|            0|  0.00%|                    ):
  2901|         0|            0|            0|  0.00%|                        return
  2902|         0|            0|            0|  0.00%|
  2903|         0|            0|            0|  0.00%|                    num_default_tv = sum(getattr(p, '__default__', NoDefault)
  2904|         0|            0|            0|  0.00%|                                         is not NoDefault for p in parameters)
  2905|         0|            0|            0|  0.00%|
  2906|         0|            0|            0|  0.00%|                    elen -= num_default_tv
  2907|         0|            0|            0|  0.00%|
  2908|         0|            0|            0|  0.00%|                    expect_val = f"at least {elen}"
  2909|         0|            0|            0|  0.00%|
  2910|         0|            0|            0|  0.00%|            things = "arguments" if sys.version_info >= (3, 10) else "parameters"
  2911|         0|            0|            0|  0.00%|            raise TypeError(f"Too {'many' if alen > elen else 'few'} {things}"
  2912|         0|            0|            0|  0.00%|                            f" for {cls}; actual {alen}, expected {expect_val}")
  2913|         0|            0|            0|  0.00%|else:
  2914|         0|            0|            0|  0.00%|    # Python 3.11+
  2915|         0|            0|            0|  0.00%|
  2916|         0|            0|            0|  0.00%|    def _check_generic(cls, parameters, elen):
  2917|         0|            0|            0|  0.00%|        """Check correct count for parameters of a generic cls (internal helper).
  2918|         0|            0|            0|  0.00%|
  2919|         0|            0|            0|  0.00%|        This gives a nice error message in case of count mismatch.
  2920|         0|            0|            0|  0.00%|        """
  2921|         0|            0|            0|  0.00%|        if not elen:
  2922|         0|            0|            0|  0.00%|            raise TypeError(f"{cls} is not a generic class")
  2923|         0|            0|            0|  0.00%|        alen = len(parameters)
  2924|         0|            0|            0|  0.00%|        if alen != elen:
  2925|         0|            0|            0|  0.00%|            expect_val = elen
  2926|         0|            0|            0|  0.00%|            if hasattr(cls, "__parameters__"):
  2927|         0|            0|            0|  0.00%|                parameters = [p for p in cls.__parameters__ if not _is_unpack(p)]
  2928|         0|            0|            0|  0.00%|
  2929|         0|            0|            0|  0.00%|                # deal with TypeVarLike defaults
  2930|         0|            0|            0|  0.00%|                # required TypeVarLikes cannot appear after a defaulted one.
  2931|         0|            0|            0|  0.00%|                if alen < elen:
  2932|         0|            0|            0|  0.00%|                    # since we validate TypeVarLike default in _collect_type_vars
  2933|         0|            0|            0|  0.00%|                    # or _collect_parameters we can safely check parameters[alen]
  2934|         0|            0|            0|  0.00%|                    if (
  2935|         0|            0|            0|  0.00%|                        getattr(parameters[alen], '__default__', NoDefault)
  2936|         0|            0|            0|  0.00%|                        is not NoDefault
  2937|         0|            0|            0|  0.00%|                    ):
  2938|         0|            0|            0|  0.00%|                        return
  2939|         0|            0|            0|  0.00%|
  2940|         0|            0|            0|  0.00%|                    num_default_tv = sum(getattr(p, '__default__', NoDefault)
  2941|         0|            0|            0|  0.00%|                                         is not NoDefault for p in parameters)
  2942|         0|            0|            0|  0.00%|
  2943|         0|            0|            0|  0.00%|                    elen -= num_default_tv
  2944|         0|            0|            0|  0.00%|
  2945|         0|            0|            0|  0.00%|                    expect_val = f"at least {elen}"
  2946|         0|            0|            0|  0.00%|
  2947|         0|            0|            0|  0.00%|            raise TypeError(f"Too {'many' if alen > elen else 'few'} arguments"
  2948|         0|            0|            0|  0.00%|                            f" for {cls}; actual {alen}, expected {expect_val}")
  2949|         0|            0|            0|  0.00%|
  2950|         0|            0|            0|  0.00%|if not _PEP_696_IMPLEMENTED:
  2951|         0|            0|            0|  0.00%|    typing._check_generic = _check_generic
  2952|         0|            0|            0|  0.00%|
  2953|         0|            0|            0|  0.00%|
  2954|         2|  9.05991e-06|  4.52995e-06|  0.01%|def _has_generic_or_protocol_as_origin() -> bool:
  2955|         2|  5.24521e-06|   2.6226e-06|  0.01%|    try:
  2956|         2|  5.24521e-06|   2.6226e-06|  0.01%|        frame = sys._getframe(2)
  2957|         0|            0|            0|  0.00%|    # - Catch AttributeError: not all Python implementations have sys._getframe()
  2958|         0|            0|            0|  0.00%|    # - Catch ValueError: maybe we're called from an unexpected module
  2959|         0|            0|            0|  0.00%|    #   and the call stack isn't deep enough
  2960|         0|            0|            0|  0.00%|    except (AttributeError, ValueError):
  2961|         0|            0|            0|  0.00%|        return False  # err on the side of leniency
  2962|         0|            0|            0|  0.00%|    else:
  2963|         0|            0|            0|  0.00%|        # If we somehow get invoked from outside typing.py,
  2964|         0|            0|            0|  0.00%|        # also err on the side of leniency
  2965|         2|  3.57628e-06|  1.78814e-06|  0.00%|        if frame.f_globals.get("__name__") != "typing":
  2966|         0|            0|            0|  0.00%|            return False
  2967|         2|  6.19888e-06|  3.09944e-06|  0.01%|        origin = frame.f_locals.get("origin")
  2968|         0|            0|            0|  0.00%|        # Cannot use "in" because origin may be an object with a buggy __eq__ that
  2969|         0|            0|            0|  0.00%|        # throws an error.
  2970|         2|  6.19888e-06|  3.09944e-06|  0.01%|        return origin is typing.Generic or origin is Protocol or origin is typing.Protocol
  2971|         0|            0|            0|  0.00%|
  2972|         0|            0|            0|  0.00%|
  2973|         0|            0|            0|  0.00%|_TYPEVARTUPLE_TYPES = {TypeVarTuple, getattr(typing, "TypeVarTuple", None)}
  2974|         0|            0|            0|  0.00%|
  2975|         0|            0|            0|  0.00%|
  2976|         0|            0|            0|  0.00%|def _is_unpacked_typevartuple(x) -> bool:
  2977|         0|            0|            0|  0.00%|    if get_origin(x) is not Unpack:
  2978|         0|            0|            0|  0.00%|        return False
  2979|         0|            0|            0|  0.00%|    args = get_args(x)
  2980|         0|            0|            0|  0.00%|    return (
  2981|         0|            0|            0|  0.00%|        bool(args)
  2982|         0|            0|            0|  0.00%|        and len(args) == 1
  2983|         0|            0|            0|  0.00%|        and type(args[0]) in _TYPEVARTUPLE_TYPES
  2984|         0|            0|            0|  0.00%|    )
  2985|         0|            0|            0|  0.00%|
  2986|         0|            0|            0|  0.00%|
  2987|         0|            0|            0|  0.00%|# Python 3.11+ _collect_type_vars was renamed to _collect_parameters
  2988|         0|            0|            0|  0.00%|if hasattr(typing, '_collect_type_vars'):
  2989|         0|            0|            0|  0.00%|    def _collect_type_vars(types, typevar_types=None):
  2990|         0|            0|            0|  0.00%|        """Collect all type variable contained in types in order of
  2991|         0|            0|            0|  0.00%|        first appearance (lexicographic order). For example::
  2992|         0|            0|            0|  0.00%|
  2993|         0|            0|            0|  0.00%|            _collect_type_vars((T, List[S, T])) == (T, S)
  2994|         0|            0|            0|  0.00%|        """
  2995|         0|            0|            0|  0.00%|        if typevar_types is None:
  2996|         0|            0|            0|  0.00%|            typevar_types = typing.TypeVar
  2997|         0|            0|            0|  0.00%|        tvars = []
  2998|         0|            0|            0|  0.00%|
  2999|         0|            0|            0|  0.00%|        # A required TypeVarLike cannot appear after a TypeVarLike with a default
  3000|         0|            0|            0|  0.00%|        # if it was a direct call to `Generic[]` or `Protocol[]`
  3001|         0|            0|            0|  0.00%|        enforce_default_ordering = _has_generic_or_protocol_as_origin()
  3002|         0|            0|            0|  0.00%|        default_encountered = False
  3003|         0|            0|            0|  0.00%|
  3004|         0|            0|            0|  0.00%|        # Also, a TypeVarLike with a default cannot appear after a TypeVarTuple
  3005|         0|            0|            0|  0.00%|        type_var_tuple_encountered = False
  3006|         0|            0|            0|  0.00%|
  3007|         0|            0|            0|  0.00%|        for t in types:
  3008|         0|            0|            0|  0.00%|            if _is_unpacked_typevartuple(t):
  3009|         0|            0|            0|  0.00%|                type_var_tuple_encountered = True
  3010|         0|            0|            0|  0.00%|            elif isinstance(t, typevar_types) and t not in tvars:
  3011|         0|            0|            0|  0.00%|                if enforce_default_ordering:
  3012|         0|            0|            0|  0.00%|                    has_default = getattr(t, '__default__', NoDefault) is not NoDefault
  3013|         0|            0|            0|  0.00%|                    if has_default:
  3014|         0|            0|            0|  0.00%|                        if type_var_tuple_encountered:
  3015|         0|            0|            0|  0.00%|                            raise TypeError('Type parameter with a default'
  3016|         0|            0|            0|  0.00%|                                            ' follows TypeVarTuple')
  3017|         0|            0|            0|  0.00%|                        default_encountered = True
  3018|         0|            0|            0|  0.00%|                    elif default_encountered:
  3019|         0|            0|            0|  0.00%|                        raise TypeError(f'Type parameter {t!r} without a default'
  3020|         0|            0|            0|  0.00%|                                        ' follows type parameter with a default')
  3021|         0|            0|            0|  0.00%|
  3022|         0|            0|            0|  0.00%|                tvars.append(t)
  3023|         0|            0|            0|  0.00%|            if _should_collect_from_parameters(t):
  3024|         0|            0|            0|  0.00%|                tvars.extend([t for t in t.__parameters__ if t not in tvars])
  3025|         0|            0|            0|  0.00%|        return tuple(tvars)
  3026|         0|            0|            0|  0.00%|
  3027|         0|            0|            0|  0.00%|    typing._collect_type_vars = _collect_type_vars
  3028|         0|            0|            0|  0.00%|else:
  3029|         2|  8.34465e-06|  4.17233e-06|  0.01%|    def _collect_parameters(args):
  3030|         0|            0|            0|  0.00%|        """Collect all type variables and parameter specifications in args
  3031|         0|            0|            0|  0.00%|        in order of first appearance (lexicographic order).
  3032|         0|            0|            0|  0.00%|
  3033|         0|            0|            0|  0.00%|        For example::
  3034|         0|            0|            0|  0.00%|
  3035|         0|            0|            0|  0.00%|            assert _collect_parameters((T, Callable[P, T])) == (T, P)
  3036|         0|            0|            0|  0.00%|        """
  3037|         2|  8.10623e-06|  4.05312e-06|  0.01%|        parameters = []
  3038|         0|            0|            0|  0.00%|
  3039|         0|            0|            0|  0.00%|        # A required TypeVarLike cannot appear after a TypeVarLike with default
  3040|         0|            0|            0|  0.00%|        # if it was a direct call to `Generic[]` or `Protocol[]`
  3041|         2|  2.76566e-05|  1.38283e-05|  0.03%|        enforce_default_ordering = _has_generic_or_protocol_as_origin()
(call)|         2|  3.55244e-05|  1.77622e-05|  0.04%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/typing_extensions.py:2954 _has_generic_or_protocol_as_origin
  3042|         2|  4.52995e-06|  2.26498e-06|  0.00%|        default_encountered = False
  3043|         0|            0|            0|  0.00%|
  3044|         0|            0|            0|  0.00%|        # Also, a TypeVarLike with a default cannot appear after a TypeVarTuple
  3045|         2|  5.00679e-06|   2.5034e-06|  0.01%|        type_var_tuple_encountered = False
  3046|         0|            0|            0|  0.00%|
  3047|         4|  1.16825e-05|  2.92063e-06|  0.01%|        for t in args:
  3048|         2|  5.24521e-06|   2.6226e-06|  0.01%|            if isinstance(t, type):
  3049|         0|            0|            0|  0.00%|                # We don't want __parameters__ descriptor of a bare Python class.
  3050|         2|  4.52995e-06|  2.26498e-06|  0.00%|                pass
  3051|         0|            0|            0|  0.00%|            elif isinstance(t, tuple):
  3052|         0|            0|            0|  0.00%|                # `t` might be a tuple, when `ParamSpec` is substituted with
  3053|         0|            0|            0|  0.00%|                # `[T, int]`, or `[int, *Ts]`, etc.
  3054|         0|            0|            0|  0.00%|                for x in t:
  3055|         0|            0|            0|  0.00%|                    for collected in _collect_parameters([x]):
  3056|         0|            0|            0|  0.00%|                        if collected not in parameters:
  3057|         0|            0|            0|  0.00%|                            parameters.append(collected)
  3058|         0|            0|            0|  0.00%|            elif hasattr(t, '__typing_subst__'):
  3059|         0|            0|            0|  0.00%|                if t not in parameters:
  3060|         0|            0|            0|  0.00%|                    if enforce_default_ordering:
  3061|         0|            0|            0|  0.00%|                        has_default = (
  3062|         0|            0|            0|  0.00%|                            getattr(t, '__default__', NoDefault) is not NoDefault
  3063|         0|            0|            0|  0.00%|                        )
  3064|         0|            0|            0|  0.00%|
  3065|         0|            0|            0|  0.00%|                        if type_var_tuple_encountered and has_default:
  3066|         0|            0|            0|  0.00%|                            raise TypeError('Type parameter with a default'
  3067|         0|            0|            0|  0.00%|                                            ' follows TypeVarTuple')
  3068|         0|            0|            0|  0.00%|
  3069|         0|            0|            0|  0.00%|                        if has_default:
  3070|         0|            0|            0|  0.00%|                            default_encountered = True
  3071|         0|            0|            0|  0.00%|                        elif default_encountered:
  3072|         0|            0|            0|  0.00%|                            raise TypeError(f'Type parameter {t!r} without a default'
  3073|         0|            0|            0|  0.00%|                                            ' follows type parameter with a default')
  3074|         0|            0|            0|  0.00%|
  3075|         0|            0|            0|  0.00%|                    parameters.append(t)
  3076|         0|            0|            0|  0.00%|            else:
  3077|         0|            0|            0|  0.00%|                if _is_unpacked_typevartuple(t):
  3078|         0|            0|            0|  0.00%|                    type_var_tuple_encountered = True
  3079|         0|            0|            0|  0.00%|                for x in getattr(t, '__parameters__', ()):
  3080|         0|            0|            0|  0.00%|                    if x not in parameters:
  3081|         0|            0|            0|  0.00%|                        parameters.append(x)
  3082|         0|            0|            0|  0.00%|
  3083|         2|  3.57628e-06|  1.78814e-06|  0.00%|        return tuple(parameters)
  3084|         0|            0|            0|  0.00%|
  3085|         0|            0|            0|  0.00%|    if not _PEP_696_IMPLEMENTED:
  3086|         0|            0|            0|  0.00%|        typing._collect_parameters = _collect_parameters
  3087|         0|            0|            0|  0.00%|
  3088|         0|            0|            0|  0.00%|# Backport typing.NamedTuple as it exists in Python 3.13.
  3089|         0|            0|            0|  0.00%|# In 3.11, the ability to define generic `NamedTuple`s was supported.
  3090|         0|            0|            0|  0.00%|# This was explicitly disallowed in 3.9-3.10, and only half-worked in <=3.8.
  3091|         0|            0|            0|  0.00%|# On 3.12, we added __orig_bases__ to call-based NamedTuples
  3092|         0|            0|            0|  0.00%|# On 3.13, we deprecated kwargs-based NamedTuples
  3093|         0|            0|            0|  0.00%|if sys.version_info >= (3, 13):
  3094|         0|            0|            0|  0.00%|    NamedTuple = typing.NamedTuple
  3095|         0|            0|            0|  0.00%|else:
  3096|         0|            0|            0|  0.00%|    def _make_nmtuple(name, types, module, defaults=()):
  3097|         0|            0|            0|  0.00%|        fields = [n for n, t in types]
  3098|         0|            0|            0|  0.00%|        annotations = {n: typing._type_check(t, f"field {n} annotation must be a type")
  3099|         0|            0|            0|  0.00%|                       for n, t in types}
  3100|         0|            0|            0|  0.00%|        nm_tpl = collections.namedtuple(name, fields,
  3101|         0|            0|            0|  0.00%|                                        defaults=defaults, module=module)
  3102|         0|            0|            0|  0.00%|        nm_tpl.__annotations__ = nm_tpl.__new__.__annotations__ = annotations
  3103|         0|            0|            0|  0.00%|        # The `_field_types` attribute was removed in 3.9;
  3104|         0|            0|            0|  0.00%|        # in earlier versions, it is the same as the `__annotations__` attribute
  3105|         0|            0|            0|  0.00%|        if sys.version_info < (3, 9):
  3106|         0|            0|            0|  0.00%|            nm_tpl._field_types = annotations
  3107|         0|            0|            0|  0.00%|        return nm_tpl
  3108|         0|            0|            0|  0.00%|
  3109|         0|            0|            0|  0.00%|    _prohibited_namedtuple_fields = typing._prohibited
  3110|         0|            0|            0|  0.00%|    _special_namedtuple_fields = frozenset({'__module__', '__name__', '__annotations__'})
  3111|         0|            0|            0|  0.00%|
  3112|         0|            0|            0|  0.00%|    class _NamedTupleMeta(type):
  3113|         0|            0|            0|  0.00%|        def __new__(cls, typename, bases, ns):
  3114|         0|            0|            0|  0.00%|            assert _NamedTuple in bases
  3115|         0|            0|            0|  0.00%|            for base in bases:
  3116|         0|            0|            0|  0.00%|                if base is not _NamedTuple and base is not typing.Generic:
  3117|         0|            0|            0|  0.00%|                    raise TypeError(
  3118|         0|            0|            0|  0.00%|                        'can only inherit from a NamedTuple type and Generic')
  3119|         0|            0|            0|  0.00%|            bases = tuple(tuple if base is _NamedTuple else base for base in bases)
  3120|         0|            0|            0|  0.00%|            if "__annotations__" in ns:
  3121|         0|            0|            0|  0.00%|                types = ns["__annotations__"]
  3122|         0|            0|            0|  0.00%|            elif "__annotate__" in ns:
  3123|         0|            0|            0|  0.00%|                # TODO: Use inspect.VALUE here, and make the annotations lazily evaluated
  3124|         0|            0|            0|  0.00%|                types = ns["__annotate__"](1)
  3125|         0|            0|            0|  0.00%|            else:
  3126|         0|            0|            0|  0.00%|                types = {}
  3127|         0|            0|            0|  0.00%|            default_names = []
  3128|         0|            0|            0|  0.00%|            for field_name in types:
  3129|         0|            0|            0|  0.00%|                if field_name in ns:
  3130|         0|            0|            0|  0.00%|                    default_names.append(field_name)
  3131|         0|            0|            0|  0.00%|                elif default_names:
  3132|         0|            0|            0|  0.00%|                    raise TypeError(f"Non-default namedtuple field {field_name} "
  3133|         0|            0|            0|  0.00%|                                    f"cannot follow default field"
  3134|         0|            0|            0|  0.00%|                                    f"{'s' if len(default_names) > 1 else ''} "
  3135|         0|            0|            0|  0.00%|                                    f"{', '.join(default_names)}")
  3136|         0|            0|            0|  0.00%|            nm_tpl = _make_nmtuple(
  3137|         0|            0|            0|  0.00%|                typename, types.items(),
  3138|         0|            0|            0|  0.00%|                defaults=[ns[n] for n in default_names],
  3139|         0|            0|            0|  0.00%|                module=ns['__module__']
  3140|         0|            0|            0|  0.00%|            )
  3141|         0|            0|            0|  0.00%|            nm_tpl.__bases__ = bases
  3142|         0|            0|            0|  0.00%|            if typing.Generic in bases:
  3143|         0|            0|            0|  0.00%|                if hasattr(typing, '_generic_class_getitem'):  # 3.12+
  3144|         0|            0|            0|  0.00%|                    nm_tpl.__class_getitem__ = classmethod(typing._generic_class_getitem)
  3145|         0|            0|            0|  0.00%|                else:
  3146|         0|            0|            0|  0.00%|                    class_getitem = typing.Generic.__class_getitem__.__func__
  3147|         0|            0|            0|  0.00%|                    nm_tpl.__class_getitem__ = classmethod(class_getitem)
  3148|         0|            0|            0|  0.00%|            # update from user namespace without overriding special namedtuple attributes
  3149|         0|            0|            0|  0.00%|            for key, val in ns.items():
  3150|         0|            0|            0|  0.00%|                if key in _prohibited_namedtuple_fields:
  3151|         0|            0|            0|  0.00%|                    raise AttributeError("Cannot overwrite NamedTuple attribute " + key)
  3152|         0|            0|            0|  0.00%|                elif key not in _special_namedtuple_fields:
  3153|         0|            0|            0|  0.00%|                    if key not in nm_tpl._fields:
  3154|         0|            0|            0|  0.00%|                        setattr(nm_tpl, key, ns[key])
  3155|         0|            0|            0|  0.00%|                    try:
  3156|         0|            0|            0|  0.00%|                        set_name = type(val).__set_name__
  3157|         0|            0|            0|  0.00%|                    except AttributeError:
  3158|         0|            0|            0|  0.00%|                        pass
  3159|         0|            0|            0|  0.00%|                    else:
  3160|         0|            0|            0|  0.00%|                        try:
  3161|         0|            0|            0|  0.00%|                            set_name(val, nm_tpl, key)
  3162|         0|            0|            0|  0.00%|                        except BaseException as e:
  3163|         0|            0|            0|  0.00%|                            msg = (
  3164|         0|            0|            0|  0.00%|                                f"Error calling __set_name__ on {type(val).__name__!r} "
  3165|         0|            0|            0|  0.00%|                                f"instance {key!r} in {typename!r}"
  3166|         0|            0|            0|  0.00%|                            )
  3167|         0|            0|            0|  0.00%|                            # BaseException.add_note() existed on py311,
  3168|         0|            0|            0|  0.00%|                            # but the __set_name__ machinery didn't start
  3169|         0|            0|            0|  0.00%|                            # using add_note() until py312.
  3170|         0|            0|            0|  0.00%|                            # Making sure exceptions are raised in the same way
  3171|         0|            0|            0|  0.00%|                            # as in "normal" classes seems most important here.
  3172|         0|            0|            0|  0.00%|                            if sys.version_info >= (3, 12):
  3173|         0|            0|            0|  0.00%|                                e.add_note(msg)
  3174|         0|            0|            0|  0.00%|                                raise
  3175|         0|            0|            0|  0.00%|                            else:
  3176|         0|            0|            0|  0.00%|                                raise RuntimeError(msg) from e
  3177|         0|            0|            0|  0.00%|
  3178|         0|            0|            0|  0.00%|            if typing.Generic in bases:
  3179|         0|            0|            0|  0.00%|                nm_tpl.__init_subclass__()
  3180|         0|            0|            0|  0.00%|            return nm_tpl
  3181|         0|            0|            0|  0.00%|
  3182|         0|            0|            0|  0.00%|    _NamedTuple = type.__new__(_NamedTupleMeta, 'NamedTuple', (), {})
  3183|         0|            0|            0|  0.00%|
  3184|         0|            0|            0|  0.00%|    def _namedtuple_mro_entries(bases):
  3185|         0|            0|            0|  0.00%|        assert NamedTuple in bases
  3186|         0|            0|            0|  0.00%|        return (_NamedTuple,)
  3187|         0|            0|            0|  0.00%|
  3188|         0|            0|            0|  0.00%|    @_ensure_subclassable(_namedtuple_mro_entries)
  3189|         0|            0|            0|  0.00%|    def NamedTuple(typename, fields=_marker, /, **kwargs):
  3190|         0|            0|            0|  0.00%|        """Typed version of namedtuple.
  3191|         0|            0|            0|  0.00%|
  3192|         0|            0|            0|  0.00%|        Usage::
  3193|         0|            0|            0|  0.00%|
  3194|         0|            0|            0|  0.00%|            class Employee(NamedTuple):
  3195|         0|            0|            0|  0.00%|                name: str
  3196|         0|            0|            0|  0.00%|                id: int
  3197|         0|            0|            0|  0.00%|
  3198|         0|            0|            0|  0.00%|        This is equivalent to::
  3199|         0|            0|            0|  0.00%|
  3200|         0|            0|            0|  0.00%|            Employee = collections.namedtuple('Employee', ['name', 'id'])
  3201|         0|            0|            0|  0.00%|
  3202|         0|            0|            0|  0.00%|        The resulting class has an extra __annotations__ attribute, giving a
  3203|         0|            0|            0|  0.00%|        dict that maps field names to types.  (The field names are also in
  3204|         0|            0|            0|  0.00%|        the _fields attribute, which is part of the namedtuple API.)
  3205|         0|            0|            0|  0.00%|        An alternative equivalent functional syntax is also accepted::
  3206|         0|            0|            0|  0.00%|
  3207|         0|            0|            0|  0.00%|            Employee = NamedTuple('Employee', [('name', str), ('id', int)])
  3208|         0|            0|            0|  0.00%|        """
  3209|         0|            0|            0|  0.00%|        if fields is _marker:
  3210|         0|            0|            0|  0.00%|            if kwargs:
  3211|         0|            0|            0|  0.00%|                deprecated_thing = "Creating NamedTuple classes using keyword arguments"
  3212|         0|            0|            0|  0.00%|                deprecation_msg = (
  3213|         0|            0|            0|  0.00%|                    "{name} is deprecated and will be disallowed in Python {remove}. "
  3214|         0|            0|            0|  0.00%|                    "Use the class-based or functional syntax instead."
  3215|         0|            0|            0|  0.00%|                )
  3216|         0|            0|            0|  0.00%|            else:
  3217|         0|            0|            0|  0.00%|                deprecated_thing = "Failing to pass a value for the 'fields' parameter"
  3218|         0|            0|            0|  0.00%|                example = f"`{typename} = NamedTuple({typename!r}, [])`"
  3219|         0|            0|            0|  0.00%|                deprecation_msg = (
  3220|         0|            0|            0|  0.00%|                    "{name} is deprecated and will be disallowed in Python {remove}. "
  3221|         0|            0|            0|  0.00%|                    "To create a NamedTuple class with 0 fields "
  3222|         0|            0|            0|  0.00%|                    "using the functional syntax, "
  3223|         0|            0|            0|  0.00%|                    "pass an empty list, e.g. "
  3224|         0|            0|            0|  0.00%|                ) + example + "."
  3225|         0|            0|            0|  0.00%|        elif fields is None:
  3226|         0|            0|            0|  0.00%|            if kwargs:
  3227|         0|            0|            0|  0.00%|                raise TypeError(
  3228|         0|            0|            0|  0.00%|                    "Cannot pass `None` as the 'fields' parameter "
  3229|         0|            0|            0|  0.00%|                    "and also specify fields using keyword arguments"
  3230|         0|            0|            0|  0.00%|                )
  3231|         0|            0|            0|  0.00%|            else:
  3232|         0|            0|            0|  0.00%|                deprecated_thing = "Passing `None` as the 'fields' parameter"
  3233|         0|            0|            0|  0.00%|                example = f"`{typename} = NamedTuple({typename!r}, [])`"
  3234|         0|            0|            0|  0.00%|                deprecation_msg = (
  3235|         0|            0|            0|  0.00%|                    "{name} is deprecated and will be disallowed in Python {remove}. "
  3236|         0|            0|            0|  0.00%|                    "To create a NamedTuple class with 0 fields "
  3237|         0|            0|            0|  0.00%|                    "using the functional syntax, "
  3238|         0|            0|            0|  0.00%|                    "pass an empty list, e.g. "
  3239|         0|            0|            0|  0.00%|                ) + example + "."
  3240|         0|            0|            0|  0.00%|        elif kwargs:
  3241|         0|            0|            0|  0.00%|            raise TypeError("Either list of fields or keywords"
  3242|         0|            0|            0|  0.00%|                            " can be provided to NamedTuple, not both")
  3243|         0|            0|            0|  0.00%|        if fields is _marker or fields is None:
  3244|         0|            0|            0|  0.00%|            warnings.warn(
  3245|         0|            0|            0|  0.00%|                deprecation_msg.format(name=deprecated_thing, remove="3.15"),
  3246|         0|            0|            0|  0.00%|                DeprecationWarning,
  3247|         0|            0|            0|  0.00%|                stacklevel=2,
  3248|         0|            0|            0|  0.00%|            )
  3249|         0|            0|            0|  0.00%|            fields = kwargs.items()
  3250|         0|            0|            0|  0.00%|        nt = _make_nmtuple(typename, fields, module=_caller())
  3251|         0|            0|            0|  0.00%|        nt.__orig_bases__ = (NamedTuple,)
  3252|         0|            0|            0|  0.00%|        return nt
  3253|         0|            0|            0|  0.00%|
  3254|         0|            0|            0|  0.00%|
  3255|         0|            0|            0|  0.00%|if hasattr(collections.abc, "Buffer"):
  3256|         0|            0|            0|  0.00%|    Buffer = collections.abc.Buffer
  3257|         0|            0|            0|  0.00%|else:
  3258|         0|            0|            0|  0.00%|    class Buffer(abc.ABC):  # noqa: B024
  3259|         0|            0|            0|  0.00%|        """Base class for classes that implement the buffer protocol.
  3260|         0|            0|            0|  0.00%|
  3261|         0|            0|            0|  0.00%|        The buffer protocol allows Python objects to expose a low-level
  3262|         0|            0|            0|  0.00%|        memory buffer interface. Before Python 3.12, it is not possible
  3263|         0|            0|            0|  0.00%|        to implement the buffer protocol in pure Python code, or even
  3264|         0|            0|            0|  0.00%|        to check whether a class implements the buffer protocol. In
  3265|         0|            0|            0|  0.00%|        Python 3.12 and higher, the ``__buffer__`` method allows access
  3266|         0|            0|            0|  0.00%|        to the buffer protocol from Python code, and the
  3267|         0|            0|            0|  0.00%|        ``collections.abc.Buffer`` ABC allows checking whether a class
  3268|         0|            0|            0|  0.00%|        implements the buffer protocol.
  3269|         0|            0|            0|  0.00%|
  3270|         0|            0|            0|  0.00%|        To indicate support for the buffer protocol in earlier versions,
  3271|         0|            0|            0|  0.00%|        inherit from this ABC, either in a stub file or at runtime,
  3272|         0|            0|            0|  0.00%|        or use ABC registration. This ABC provides no methods, because
  3273|         0|            0|            0|  0.00%|        there is no Python-accessible methods shared by pre-3.12 buffer
  3274|         0|            0|            0|  0.00%|        classes. It is useful primarily for static checks.
  3275|         0|            0|            0|  0.00%|
  3276|         0|            0|            0|  0.00%|        """
  3277|         0|            0|            0|  0.00%|
  3278|         0|            0|            0|  0.00%|    # As a courtesy, register the most common stdlib buffer classes.
  3279|         0|            0|            0|  0.00%|    Buffer.register(memoryview)
  3280|         0|            0|            0|  0.00%|    Buffer.register(bytearray)
  3281|         0|            0|            0|  0.00%|    Buffer.register(bytes)
  3282|         0|            0|            0|  0.00%|
  3283|         0|            0|            0|  0.00%|
  3284|         0|            0|            0|  0.00%|# Backport of types.get_original_bases, available on 3.12+ in CPython
  3285|         0|            0|            0|  0.00%|if hasattr(_types, "get_original_bases"):
  3286|         0|            0|            0|  0.00%|    get_original_bases = _types.get_original_bases
  3287|         0|            0|            0|  0.00%|else:
  3288|         0|            0|            0|  0.00%|    def get_original_bases(cls, /):
  3289|         0|            0|            0|  0.00%|        """Return the class's "original" bases prior to modification by `__mro_entries__`.
  3290|         0|            0|            0|  0.00%|
  3291|         0|            0|            0|  0.00%|        Examples::
  3292|         0|            0|            0|  0.00%|
  3293|         0|            0|            0|  0.00%|            from typing import TypeVar, Generic
  3294|         0|            0|            0|  0.00%|            from typing_extensions import NamedTuple, TypedDict
  3295|         0|            0|            0|  0.00%|
  3296|         0|            0|            0|  0.00%|            T = TypeVar("T")
  3297|         0|            0|            0|  0.00%|            class Foo(Generic[T]): ...
  3298|         0|            0|            0|  0.00%|            class Bar(Foo[int], float): ...
  3299|         0|            0|            0|  0.00%|            class Baz(list[str]): ...
  3300|         0|            0|            0|  0.00%|            Eggs = NamedTuple("Eggs", [("a", int), ("b", str)])
  3301|         0|            0|            0|  0.00%|            Spam = TypedDict("Spam", {"a": int, "b": str})
  3302|         0|            0|            0|  0.00%|
  3303|         0|            0|            0|  0.00%|            assert get_original_bases(Bar) == (Foo[int], float)
  3304|         0|            0|            0|  0.00%|            assert get_original_bases(Baz) == (list[str],)
  3305|         0|            0|            0|  0.00%|            assert get_original_bases(Eggs) == (NamedTuple,)
  3306|         0|            0|            0|  0.00%|            assert get_original_bases(Spam) == (TypedDict,)
  3307|         0|            0|            0|  0.00%|            assert get_original_bases(int) == (object,)
  3308|         0|            0|            0|  0.00%|        """
  3309|         0|            0|            0|  0.00%|        try:
  3310|         0|            0|            0|  0.00%|            return cls.__dict__.get("__orig_bases__", cls.__bases__)
  3311|         0|            0|            0|  0.00%|        except AttributeError:
  3312|         0|            0|            0|  0.00%|            raise TypeError(
  3313|         0|            0|            0|  0.00%|                f'Expected an instance of type, not {type(cls).__name__!r}'
  3314|         0|            0|            0|  0.00%|            ) from None
  3315|         0|            0|            0|  0.00%|
  3316|         0|            0|            0|  0.00%|
  3317|         0|            0|            0|  0.00%|# NewType is a class on Python 3.10+, making it pickleable
  3318|         0|            0|            0|  0.00%|# The error message for subclassing instances of NewType was improved on 3.11+
  3319|         0|            0|            0|  0.00%|if sys.version_info >= (3, 11):
  3320|         0|            0|            0|  0.00%|    NewType = typing.NewType
  3321|         0|            0|            0|  0.00%|else:
  3322|         0|            0|            0|  0.00%|    class NewType:
  3323|         0|            0|            0|  0.00%|        """NewType creates simple unique types with almost zero
  3324|         0|            0|            0|  0.00%|        runtime overhead. NewType(name, tp) is considered a subtype of tp
  3325|         0|            0|            0|  0.00%|        by static type checkers. At runtime, NewType(name, tp) returns
  3326|         0|            0|            0|  0.00%|        a dummy callable that simply returns its argument. Usage::
  3327|         0|            0|            0|  0.00%|            UserId = NewType('UserId', int)
  3328|         0|            0|            0|  0.00%|            def name_by_id(user_id: UserId) -> str:
  3329|         0|            0|            0|  0.00%|                ...
  3330|         0|            0|            0|  0.00%|            UserId('user')          # Fails type check
  3331|         0|            0|            0|  0.00%|            name_by_id(42)          # Fails type check
  3332|         0|            0|            0|  0.00%|            name_by_id(UserId(42))  # OK
  3333|         0|            0|            0|  0.00%|            num = UserId(5) + 1     # type: int
  3334|         0|            0|            0|  0.00%|        """
  3335|         0|            0|            0|  0.00%|
  3336|         0|            0|            0|  0.00%|        def __call__(self, obj, /):
  3337|         0|            0|            0|  0.00%|            return obj
  3338|         0|            0|            0|  0.00%|
  3339|         0|            0|            0|  0.00%|        def __init__(self, name, tp):
  3340|         0|            0|            0|  0.00%|            self.__qualname__ = name
  3341|         0|            0|            0|  0.00%|            if '.' in name:
  3342|         0|            0|            0|  0.00%|                name = name.rpartition('.')[-1]
  3343|         0|            0|            0|  0.00%|            self.__name__ = name
  3344|         0|            0|            0|  0.00%|            self.__supertype__ = tp
  3345|         0|            0|            0|  0.00%|            def_mod = _caller()
  3346|         0|            0|            0|  0.00%|            if def_mod != 'typing_extensions':
  3347|         0|            0|            0|  0.00%|                self.__module__ = def_mod
  3348|         0|            0|            0|  0.00%|
  3349|         0|            0|            0|  0.00%|        def __mro_entries__(self, bases):
  3350|         0|            0|            0|  0.00%|            # We defined __mro_entries__ to get a better error message
  3351|         0|            0|            0|  0.00%|            # if a user attempts to subclass a NewType instance. bpo-46170
  3352|         0|            0|            0|  0.00%|            supercls_name = self.__name__
  3353|         0|            0|            0|  0.00%|
  3354|         0|            0|            0|  0.00%|            class Dummy:
  3355|         0|            0|            0|  0.00%|                def __init_subclass__(cls):
  3356|         0|            0|            0|  0.00%|                    subcls_name = cls.__name__
  3357|         0|            0|            0|  0.00%|                    raise TypeError(
  3358|         0|            0|            0|  0.00%|                        f"Cannot subclass an instance of NewType. "
  3359|         0|            0|            0|  0.00%|                        f"Perhaps you were looking for: "
  3360|         0|            0|            0|  0.00%|                        f"`{subcls_name} = NewType({subcls_name!r}, {supercls_name})`"
  3361|         0|            0|            0|  0.00%|                    )
  3362|         0|            0|            0|  0.00%|
  3363|         0|            0|            0|  0.00%|            return (Dummy,)
  3364|         0|            0|            0|  0.00%|
  3365|         0|            0|            0|  0.00%|        def __repr__(self):
  3366|         0|            0|            0|  0.00%|            return f'{self.__module__}.{self.__qualname__}'
  3367|         0|            0|            0|  0.00%|
  3368|         0|            0|            0|  0.00%|        def __reduce__(self):
  3369|         0|            0|            0|  0.00%|            return self.__qualname__
  3370|         0|            0|            0|  0.00%|
  3371|         0|            0|            0|  0.00%|        if sys.version_info >= (3, 10):
  3372|         0|            0|            0|  0.00%|            # PEP 604 methods
  3373|         0|            0|            0|  0.00%|            # It doesn't make sense to have these methods on Python <3.10
  3374|         0|            0|            0|  0.00%|
  3375|         0|            0|            0|  0.00%|            def __or__(self, other):
  3376|         0|            0|            0|  0.00%|                return typing.Union[self, other]
  3377|         0|            0|            0|  0.00%|
  3378|         0|            0|            0|  0.00%|            def __ror__(self, other):
  3379|         0|            0|            0|  0.00%|                return typing.Union[other, self]
  3380|         0|            0|            0|  0.00%|
  3381|         0|            0|            0|  0.00%|
  3382|         0|            0|            0|  0.00%|if hasattr(typing, "TypeAliasType"):
  3383|         0|            0|            0|  0.00%|    TypeAliasType = typing.TypeAliasType
  3384|         0|            0|            0|  0.00%|else:
  3385|         0|            0|            0|  0.00%|    def _is_unionable(obj):
  3386|         0|            0|            0|  0.00%|        """Corresponds to is_unionable() in unionobject.c in CPython."""
  3387|         0|            0|            0|  0.00%|        return obj is None or isinstance(obj, (
  3388|         0|            0|            0|  0.00%|            type,
  3389|         0|            0|            0|  0.00%|            _types.GenericAlias,
  3390|         0|            0|            0|  0.00%|            _types.UnionType,
  3391|         0|            0|            0|  0.00%|            TypeAliasType,
  3392|         0|            0|            0|  0.00%|        ))
  3393|         0|            0|            0|  0.00%|
  3394|         0|            0|            0|  0.00%|    class TypeAliasType:
  3395|         0|            0|            0|  0.00%|        """Create named, parameterized type aliases.
  3396|         0|            0|            0|  0.00%|
  3397|         0|            0|            0|  0.00%|        This provides a backport of the new `type` statement in Python 3.12:
  3398|         0|            0|            0|  0.00%|
  3399|         0|            0|            0|  0.00%|            type ListOrSet[T] = list[T] | set[T]
  3400|         0|            0|            0|  0.00%|
  3401|         0|            0|            0|  0.00%|        is equivalent to:
  3402|         0|            0|            0|  0.00%|
  3403|         0|            0|            0|  0.00%|            T = TypeVar("T")
  3404|         0|            0|            0|  0.00%|            ListOrSet = TypeAliasType("ListOrSet", list[T] | set[T], type_params=(T,))
  3405|         0|            0|            0|  0.00%|
  3406|         0|            0|            0|  0.00%|        The name ListOrSet can then be used as an alias for the type it refers to.
  3407|         0|            0|            0|  0.00%|
  3408|         0|            0|            0|  0.00%|        The type_params argument should contain all the type parameters used
  3409|         0|            0|            0|  0.00%|        in the value of the type alias. If the alias is not generic, this
  3410|         0|            0|            0|  0.00%|        argument is omitted.
  3411|         0|            0|            0|  0.00%|
  3412|         0|            0|            0|  0.00%|        Static type checkers should only support type aliases declared using
  3413|         0|            0|            0|  0.00%|        TypeAliasType that follow these rules:
  3414|         0|            0|            0|  0.00%|
  3415|         0|            0|            0|  0.00%|        - The first argument (the name) must be a string literal.
  3416|         0|            0|            0|  0.00%|        - The TypeAliasType instance must be immediately assigned to a variable
  3417|         0|            0|            0|  0.00%|          of the same name. (For example, 'X = TypeAliasType("Y", int)' is invalid,
  3418|         0|            0|            0|  0.00%|          as is 'X, Y = TypeAliasType("X", int), TypeAliasType("Y", int)').
  3419|         0|            0|            0|  0.00%|
  3420|         0|            0|            0|  0.00%|        """
  3421|         0|            0|            0|  0.00%|
  3422|         0|            0|            0|  0.00%|        def __init__(self, name: str, value, *, type_params=()):
  3423|         0|            0|            0|  0.00%|            if not isinstance(name, str):
  3424|         0|            0|            0|  0.00%|                raise TypeError("TypeAliasType name must be a string")
  3425|         0|            0|            0|  0.00%|            self.__value__ = value
  3426|         0|            0|            0|  0.00%|            self.__type_params__ = type_params
  3427|         0|            0|            0|  0.00%|
  3428|         0|            0|            0|  0.00%|            parameters = []
  3429|         0|            0|            0|  0.00%|            for type_param in type_params:
  3430|         0|            0|            0|  0.00%|                if isinstance(type_param, TypeVarTuple):
  3431|         0|            0|            0|  0.00%|                    parameters.extend(type_param)
  3432|         0|            0|            0|  0.00%|                else:
  3433|         0|            0|            0|  0.00%|                    parameters.append(type_param)
  3434|         0|            0|            0|  0.00%|            self.__parameters__ = tuple(parameters)
  3435|         0|            0|            0|  0.00%|            def_mod = _caller()
  3436|         0|            0|            0|  0.00%|            if def_mod != 'typing_extensions':
  3437|         0|            0|            0|  0.00%|                self.__module__ = def_mod
  3438|         0|            0|            0|  0.00%|            # Setting this attribute closes the TypeAliasType from further modification
  3439|         0|            0|            0|  0.00%|            self.__name__ = name
  3440|         0|            0|            0|  0.00%|
  3441|         0|            0|            0|  0.00%|        def __setattr__(self, name: str, value: object, /) -> None:
  3442|         0|            0|            0|  0.00%|            if hasattr(self, "__name__"):
  3443|         0|            0|            0|  0.00%|                self._raise_attribute_error(name)
  3444|         0|            0|            0|  0.00%|            super().__setattr__(name, value)
  3445|         0|            0|            0|  0.00%|
  3446|         0|            0|            0|  0.00%|        def __delattr__(self, name: str, /) -> Never:
  3447|         0|            0|            0|  0.00%|            self._raise_attribute_error(name)
  3448|         0|            0|            0|  0.00%|
  3449|         0|            0|            0|  0.00%|        def _raise_attribute_error(self, name: str) -> Never:
  3450|         0|            0|            0|  0.00%|            # Match the Python 3.12 error messages exactly
  3451|         0|            0|            0|  0.00%|            if name == "__name__":
  3452|         0|            0|            0|  0.00%|                raise AttributeError("readonly attribute")
  3453|         0|            0|            0|  0.00%|            elif name in {"__value__", "__type_params__", "__parameters__", "__module__"}:
  3454|         0|            0|            0|  0.00%|                raise AttributeError(
  3455|         0|            0|            0|  0.00%|                    f"attribute '{name}' of 'typing.TypeAliasType' objects "
  3456|         0|            0|            0|  0.00%|                    "is not writable"
  3457|         0|            0|            0|  0.00%|                )
  3458|         0|            0|            0|  0.00%|            else:
  3459|         0|            0|            0|  0.00%|                raise AttributeError(
  3460|         0|            0|            0|  0.00%|                    f"'typing.TypeAliasType' object has no attribute '{name}'"
  3461|         0|            0|            0|  0.00%|                )
  3462|         0|            0|            0|  0.00%|
  3463|         0|            0|            0|  0.00%|        def __repr__(self) -> str:
  3464|         0|            0|            0|  0.00%|            return self.__name__
  3465|         0|            0|            0|  0.00%|
  3466|         0|            0|            0|  0.00%|        def __getitem__(self, parameters):
  3467|         0|            0|            0|  0.00%|            if not isinstance(parameters, tuple):
  3468|         0|            0|            0|  0.00%|                parameters = (parameters,)
  3469|         0|            0|            0|  0.00%|            parameters = [
  3470|         0|            0|            0|  0.00%|                typing._type_check(
  3471|         0|            0|            0|  0.00%|                    item, f'Subscripting {self.__name__} requires a type.'
  3472|         0|            0|            0|  0.00%|                )
  3473|         0|            0|            0|  0.00%|                for item in parameters
  3474|         0|            0|            0|  0.00%|            ]
  3475|         0|            0|            0|  0.00%|            return typing._GenericAlias(self, tuple(parameters))
  3476|         0|            0|            0|  0.00%|
  3477|         0|            0|            0|  0.00%|        def __reduce__(self):
  3478|         0|            0|            0|  0.00%|            return self.__name__
  3479|         0|            0|            0|  0.00%|
  3480|         0|            0|            0|  0.00%|        def __init_subclass__(cls, *args, **kwargs):
  3481|         0|            0|            0|  0.00%|            raise TypeError(
  3482|         0|            0|            0|  0.00%|                "type 'typing_extensions.TypeAliasType' is not an acceptable base type"
  3483|         0|            0|            0|  0.00%|            )
  3484|         0|            0|            0|  0.00%|
  3485|         0|            0|            0|  0.00%|        # The presence of this method convinces typing._type_check
  3486|         0|            0|            0|  0.00%|        # that TypeAliasTypes are types.
  3487|         0|            0|            0|  0.00%|        def __call__(self):
  3488|         0|            0|            0|  0.00%|            raise TypeError("Type alias is not callable")
  3489|         0|            0|            0|  0.00%|
  3490|         0|            0|            0|  0.00%|        if sys.version_info >= (3, 10):
  3491|         0|            0|            0|  0.00%|            def __or__(self, right):
  3492|         0|            0|            0|  0.00%|                # For forward compatibility with 3.12, reject Unions
  3493|         0|            0|            0|  0.00%|                # that are not accepted by the built-in Union.
  3494|         0|            0|            0|  0.00%|                if not _is_unionable(right):
  3495|         0|            0|            0|  0.00%|                    return NotImplemented
  3496|         0|            0|            0|  0.00%|                return typing.Union[self, right]
  3497|         0|            0|            0|  0.00%|
  3498|         0|            0|            0|  0.00%|            def __ror__(self, left):
  3499|         0|            0|            0|  0.00%|                if not _is_unionable(left):
  3500|         0|            0|            0|  0.00%|                    return NotImplemented
  3501|         0|            0|            0|  0.00%|                return typing.Union[left, self]
  3502|         0|            0|            0|  0.00%|
  3503|         0|            0|            0|  0.00%|
  3504|         0|            0|            0|  0.00%|if hasattr(typing, "is_protocol"):
  3505|         0|            0|            0|  0.00%|    is_protocol = typing.is_protocol
  3506|         0|            0|            0|  0.00%|    get_protocol_members = typing.get_protocol_members
  3507|         0|            0|            0|  0.00%|else:
  3508|         0|            0|            0|  0.00%|    def is_protocol(tp: type, /) -> bool:
  3509|         0|            0|            0|  0.00%|        """Return True if the given type is a Protocol.
  3510|         0|            0|            0|  0.00%|
  3511|         0|            0|            0|  0.00%|        Example::
  3512|         0|            0|            0|  0.00%|
  3513|         0|            0|            0|  0.00%|            >>> from typing_extensions import Protocol, is_protocol
  3514|         0|            0|            0|  0.00%|            >>> class P(Protocol):
  3515|         0|            0|            0|  0.00%|            ...     def a(self) -> str: ...
  3516|         0|            0|            0|  0.00%|            ...     b: int
  3517|         0|            0|            0|  0.00%|            >>> is_protocol(P)
  3518|         0|            0|            0|  0.00%|            True
  3519|         0|            0|            0|  0.00%|            >>> is_protocol(int)
  3520|         0|            0|            0|  0.00%|            False
  3521|         0|            0|            0|  0.00%|        """
  3522|         0|            0|            0|  0.00%|        return (
  3523|         0|            0|            0|  0.00%|            isinstance(tp, type)
  3524|         0|            0|            0|  0.00%|            and getattr(tp, '_is_protocol', False)
  3525|         0|            0|            0|  0.00%|            and tp is not Protocol
  3526|         0|            0|            0|  0.00%|            and tp is not typing.Protocol
  3527|         0|            0|            0|  0.00%|        )
  3528|         0|            0|            0|  0.00%|
  3529|         0|            0|            0|  0.00%|    def get_protocol_members(tp: type, /) -> typing.FrozenSet[str]:
  3530|         0|            0|            0|  0.00%|        """Return the set of members defined in a Protocol.
  3531|         0|            0|            0|  0.00%|
  3532|         0|            0|            0|  0.00%|        Example::
  3533|         0|            0|            0|  0.00%|
  3534|         0|            0|            0|  0.00%|            >>> from typing_extensions import Protocol, get_protocol_members
  3535|         0|            0|            0|  0.00%|            >>> class P(Protocol):
  3536|         0|            0|            0|  0.00%|            ...     def a(self) -> str: ...
  3537|         0|            0|            0|  0.00%|            ...     b: int
  3538|         0|            0|            0|  0.00%|            >>> get_protocol_members(P)
  3539|         0|            0|            0|  0.00%|            frozenset({'a', 'b'})
  3540|         0|            0|            0|  0.00%|
  3541|         0|            0|            0|  0.00%|        Raise a TypeError for arguments that are not Protocols.
  3542|         0|            0|            0|  0.00%|        """
  3543|         0|            0|            0|  0.00%|        if not is_protocol(tp):
  3544|         0|            0|            0|  0.00%|            raise TypeError(f'{tp!r} is not a Protocol')
  3545|         0|            0|            0|  0.00%|        if hasattr(tp, '__protocol_attrs__'):
  3546|         0|            0|            0|  0.00%|            return frozenset(tp.__protocol_attrs__)
  3547|         0|            0|            0|  0.00%|        return frozenset(_get_protocol_attrs(tp))
  3548|         0|            0|            0|  0.00%|
  3549|         0|            0|            0|  0.00%|
  3550|         0|            0|            0|  0.00%|if hasattr(typing, "Doc"):
  3551|         0|            0|            0|  0.00%|    Doc = typing.Doc
  3552|         0|            0|            0|  0.00%|else:
  3553|         0|            0|            0|  0.00%|    class Doc:
  3554|         0|            0|            0|  0.00%|        """Define the documentation of a type annotation using ``Annotated``, to be
  3555|         0|            0|            0|  0.00%|         used in class attributes, function and method parameters, return values,
  3556|         0|            0|            0|  0.00%|         and variables.
  3557|         0|            0|            0|  0.00%|
  3558|         0|            0|            0|  0.00%|        The value should be a positional-only string literal to allow static tools
  3559|         0|            0|            0|  0.00%|        like editors and documentation generators to use it.
  3560|         0|            0|            0|  0.00%|
  3561|         0|            0|            0|  0.00%|        This complements docstrings.
  3562|         0|            0|            0|  0.00%|
  3563|         0|            0|            0|  0.00%|        The string value passed is available in the attribute ``documentation``.
  3564|         0|            0|            0|  0.00%|
  3565|         0|            0|            0|  0.00%|        Example::
  3566|         0|            0|            0|  0.00%|
  3567|         0|            0|            0|  0.00%|            >>> from typing_extensions import Annotated, Doc
  3568|         0|            0|            0|  0.00%|            >>> def hi(to: Annotated[str, Doc("Who to say hi to")]) -> None: ...
  3569|         0|            0|            0|  0.00%|        """
  3570|         0|            0|            0|  0.00%|        def __init__(self, documentation: str, /) -> None:
  3571|         0|            0|            0|  0.00%|            self.documentation = documentation
  3572|         0|            0|            0|  0.00%|
  3573|         0|            0|            0|  0.00%|        def __repr__(self) -> str:
  3574|         0|            0|            0|  0.00%|            return f"Doc({self.documentation!r})"
  3575|         0|            0|            0|  0.00%|
  3576|         0|            0|            0|  0.00%|        def __hash__(self) -> int:
  3577|         0|            0|            0|  0.00%|            return hash(self.documentation)
  3578|         0|            0|            0|  0.00%|
  3579|         0|            0|            0|  0.00%|        def __eq__(self, other: object) -> bool:
  3580|         0|            0|            0|  0.00%|            if not isinstance(other, Doc):
  3581|         0|            0|            0|  0.00%|                return NotImplemented
  3582|         0|            0|            0|  0.00%|            return self.documentation == other.documentation
  3583|         0|            0|            0|  0.00%|
  3584|         0|            0|            0|  0.00%|
  3585|         0|            0|            0|  0.00%|_CapsuleType = getattr(_types, "CapsuleType", None)
  3586|         0|            0|            0|  0.00%|
  3587|         0|            0|            0|  0.00%|if _CapsuleType is None:
  3588|         0|            0|            0|  0.00%|    try:
  3589|         0|            0|            0|  0.00%|        import _socket
  3590|         0|            0|            0|  0.00%|    except ImportError:
  3591|         0|            0|            0|  0.00%|        pass
  3592|         0|            0|            0|  0.00%|    else:
  3593|         0|            0|            0|  0.00%|        _CAPI = getattr(_socket, "CAPI", None)
  3594|         0|            0|            0|  0.00%|        if _CAPI is not None:
  3595|         0|            0|            0|  0.00%|            _CapsuleType = type(_CAPI)
  3596|         0|            0|            0|  0.00%|
  3597|         0|            0|            0|  0.00%|if _CapsuleType is not None:
  3598|         0|            0|            0|  0.00%|    CapsuleType = _CapsuleType
  3599|         0|            0|            0|  0.00%|    __all__.append("CapsuleType")
  3600|         0|            0|            0|  0.00%|
  3601|         0|            0|            0|  0.00%|
  3602|         0|            0|            0|  0.00%|# Aliases for items that have always been in typing.
  3603|         0|            0|            0|  0.00%|# Explicitly assign these (rather than using `from typing import *` at the top),
  3604|         0|            0|            0|  0.00%|# so that we get a CI error if one of these is deleted from typing.py
  3605|         0|            0|            0|  0.00%|# in a future version of Python
  3606|         0|            0|            0|  0.00%|AbstractSet = typing.AbstractSet
  3607|         0|            0|            0|  0.00%|AnyStr = typing.AnyStr
  3608|         0|            0|            0|  0.00%|BinaryIO = typing.BinaryIO
  3609|         0|            0|            0|  0.00%|Callable = typing.Callable
  3610|         0|            0|            0|  0.00%|Collection = typing.Collection
  3611|         0|            0|            0|  0.00%|Container = typing.Container
  3612|         0|            0|            0|  0.00%|Dict = typing.Dict
  3613|         0|            0|            0|  0.00%|ForwardRef = typing.ForwardRef
  3614|         0|            0|            0|  0.00%|FrozenSet = typing.FrozenSet
  3615|         0|            0|            0|  0.00%|Generic = typing.Generic
  3616|         0|            0|            0|  0.00%|Hashable = typing.Hashable
  3617|         0|            0|            0|  0.00%|IO = typing.IO
  3618|         0|            0|            0|  0.00%|ItemsView = typing.ItemsView
  3619|         0|            0|            0|  0.00%|Iterable = typing.Iterable
  3620|         0|            0|            0|  0.00%|Iterator = typing.Iterator
  3621|         0|            0|            0|  0.00%|KeysView = typing.KeysView
  3622|         0|            0|            0|  0.00%|List = typing.List
  3623|         0|            0|            0|  0.00%|Mapping = typing.Mapping
  3624|         0|            0|            0|  0.00%|MappingView = typing.MappingView
  3625|         0|            0|            0|  0.00%|Match = typing.Match
  3626|         0|            0|            0|  0.00%|MutableMapping = typing.MutableMapping
  3627|         0|            0|            0|  0.00%|MutableSequence = typing.MutableSequence
  3628|         0|            0|            0|  0.00%|MutableSet = typing.MutableSet
  3629|         0|            0|            0|  0.00%|Optional = typing.Optional
  3630|         0|            0|            0|  0.00%|Pattern = typing.Pattern
  3631|         0|            0|            0|  0.00%|Reversible = typing.Reversible
  3632|         0|            0|            0|  0.00%|Sequence = typing.Sequence
  3633|         0|            0|            0|  0.00%|Set = typing.Set
  3634|         0|            0|            0|  0.00%|Sized = typing.Sized
  3635|         0|            0|            0|  0.00%|TextIO = typing.TextIO
  3636|         0|            0|            0|  0.00%|Tuple = typing.Tuple
  3637|         0|            0|            0|  0.00%|Union = typing.Union
  3638|         0|            0|            0|  0.00%|ValuesView = typing.ValuesView
  3639|         0|            0|            0|  0.00%|cast = typing.cast
  3640|         0|            0|            0|  0.00%|no_type_check = typing.no_type_check
  3641|         0|            0|            0|  0.00%|no_type_check_decorator = typing.no_type_check_decorator
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic_core/core_schema.py
File duration: 0.000111341s (0.11%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""
     2|         0|            0|            0|  0.00%|This module contains definitions to build schemas which `pydantic_core` can
     3|         0|            0|            0|  0.00%|validate and serialize.
     4|         0|            0|            0|  0.00%|"""
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|from __future__ import annotations as _annotations
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|import sys
     9|         0|            0|            0|  0.00%|import warnings
    10|         0|            0|            0|  0.00%|from collections.abc import Mapping
    11|         0|            0|            0|  0.00%|from datetime import date, datetime, time, timedelta
    12|         0|            0|            0|  0.00%|from decimal import Decimal
    13|         0|            0|            0|  0.00%|from typing import TYPE_CHECKING, Any, Callable, Dict, Hashable, List, Pattern, Set, Tuple, Type, Union
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|from typing_extensions import deprecated
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|if sys.version_info < (3, 12):
    18|         0|            0|            0|  0.00%|    from typing_extensions import TypedDict
    19|         0|            0|            0|  0.00%|else:
    20|         0|            0|            0|  0.00%|    from typing import TypedDict
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|if sys.version_info < (3, 11):
    23|         0|            0|            0|  0.00%|    from typing_extensions import Protocol, Required, TypeAlias
    24|         0|            0|            0|  0.00%|else:
    25|         0|            0|            0|  0.00%|    from typing import Protocol, Required, TypeAlias
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|if sys.version_info < (3, 9):
    28|         0|            0|            0|  0.00%|    from typing_extensions import Literal
    29|         0|            0|            0|  0.00%|else:
    30|         0|            0|            0|  0.00%|    from typing import Literal
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|if TYPE_CHECKING:
    33|         0|            0|            0|  0.00%|    from pydantic_core import PydanticUndefined
    34|         0|            0|            0|  0.00%|else:
    35|         0|            0|            0|  0.00%|    # The initial build of pydantic_core requires PydanticUndefined to generate
    36|         0|            0|            0|  0.00%|    # the core schema; so we need to conditionally skip it. mypy doesn't like
    37|         0|            0|            0|  0.00%|    # this at all, hence the TYPE_CHECKING branch above.
    38|         0|            0|            0|  0.00%|    try:
    39|         0|            0|            0|  0.00%|        from pydantic_core import PydanticUndefined
    40|         0|            0|            0|  0.00%|    except ImportError:
    41|         0|            0|            0|  0.00%|        PydanticUndefined = object()
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|
    44|         0|            0|            0|  0.00%|ExtraBehavior = Literal['allow', 'forbid', 'ignore']
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|class CoreConfig(TypedDict, total=False):
    48|         0|            0|            0|  0.00%|    """
    49|         0|            0|            0|  0.00%|    Base class for schema configuration options.
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|    Attributes:
    52|         0|            0|            0|  0.00%|        title: The name of the configuration.
    53|         0|            0|            0|  0.00%|        strict: Whether the configuration should strictly adhere to specified rules.
    54|         0|            0|            0|  0.00%|        extra_fields_behavior: The behavior for handling extra fields.
    55|         0|            0|            0|  0.00%|        typed_dict_total: Whether the TypedDict should be considered total. Default is `True`.
    56|         0|            0|            0|  0.00%|        from_attributes: Whether to use attributes for models, dataclasses, and tagged union keys.
    57|         0|            0|            0|  0.00%|        loc_by_alias: Whether to use the used alias (or first alias for "field required" errors) instead of
    58|         0|            0|            0|  0.00%|            `field_names` to construct error `loc`s. Default is `True`.
    59|         0|            0|            0|  0.00%|        revalidate_instances: Whether instances of models and dataclasses should re-validate. Default is 'never'.
    60|         0|            0|            0|  0.00%|        validate_default: Whether to validate default values during validation. Default is `False`.
    61|         0|            0|            0|  0.00%|        populate_by_name: Whether an aliased field may be populated by its name as given by the model attribute,
    62|         0|            0|            0|  0.00%|            as well as the alias. (Replaces 'allow_population_by_field_name' in Pydantic v1.) Default is `False`.
    63|         0|            0|            0|  0.00%|        str_max_length: The maximum length for string fields.
    64|         0|            0|            0|  0.00%|        str_min_length: The minimum length for string fields.
    65|         0|            0|            0|  0.00%|        str_strip_whitespace: Whether to strip whitespace from string fields.
    66|         0|            0|            0|  0.00%|        str_to_lower: Whether to convert string fields to lowercase.
    67|         0|            0|            0|  0.00%|        str_to_upper: Whether to convert string fields to uppercase.
    68|         0|            0|            0|  0.00%|        allow_inf_nan: Whether to allow infinity and NaN values for float fields. Default is `True`.
    69|         0|            0|            0|  0.00%|        ser_json_timedelta: The serialization option for `timedelta` values. Default is 'iso8601'.
    70|         0|            0|            0|  0.00%|        ser_json_bytes: The serialization option for `bytes` values. Default is 'utf8'.
    71|         0|            0|            0|  0.00%|        ser_json_inf_nan: The serialization option for infinity and NaN values
    72|         0|            0|            0|  0.00%|            in float fields. Default is 'null'.
    73|         0|            0|            0|  0.00%|        hide_input_in_errors: Whether to hide input data from `ValidationError` representation.
    74|         0|            0|            0|  0.00%|        validation_error_cause: Whether to add user-python excs to the __cause__ of a ValidationError.
    75|         0|            0|            0|  0.00%|            Requires exceptiongroup backport pre Python 3.11.
    76|         0|            0|            0|  0.00%|        coerce_numbers_to_str: Whether to enable coercion of any `Number` type to `str` (not applicable in `strict` mode).
    77|         0|            0|            0|  0.00%|        regex_engine: The regex engine to use for regex pattern validation. Default is 'rust-regex'. See `StringSchema`.
    78|         0|            0|            0|  0.00%|        cache_strings: Whether to cache strings. Default is `True`, `True` or `'all'` is required to cache strings
    79|         0|            0|            0|  0.00%|            during general validation since validators don't know if they're in a key or a value.
    80|         0|            0|            0|  0.00%|    """
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|    title: str
    83|         0|            0|            0|  0.00%|    strict: bool
    84|         0|            0|            0|  0.00%|    # settings related to typed dicts, model fields, dataclass fields
    85|         0|            0|            0|  0.00%|    extra_fields_behavior: ExtraBehavior
    86|         0|            0|            0|  0.00%|    typed_dict_total: bool  # default: True
    87|         0|            0|            0|  0.00%|    # used for models, dataclasses, and tagged union keys
    88|         0|            0|            0|  0.00%|    from_attributes: bool
    89|         0|            0|            0|  0.00%|    # whether to use the used alias (or first alias for "field required" errors) instead of field_names
    90|         0|            0|            0|  0.00%|    # to construct error `loc`s, default True
    91|         0|            0|            0|  0.00%|    loc_by_alias: bool
    92|         0|            0|            0|  0.00%|    # whether instances of models and dataclasses (including subclass instances) should re-validate, default 'never'
    93|         0|            0|            0|  0.00%|    revalidate_instances: Literal['always', 'never', 'subclass-instances']
    94|         0|            0|            0|  0.00%|    # whether to validate default values during validation, default False
    95|         0|            0|            0|  0.00%|    validate_default: bool
    96|         0|            0|            0|  0.00%|    # used on typed-dicts and arguments
    97|         0|            0|            0|  0.00%|    populate_by_name: bool  # replaces `allow_population_by_field_name` in pydantic v1
    98|         0|            0|            0|  0.00%|    # fields related to string fields only
    99|         0|            0|            0|  0.00%|    str_max_length: int
   100|         0|            0|            0|  0.00%|    str_min_length: int
   101|         0|            0|            0|  0.00%|    str_strip_whitespace: bool
   102|         0|            0|            0|  0.00%|    str_to_lower: bool
   103|         0|            0|            0|  0.00%|    str_to_upper: bool
   104|         0|            0|            0|  0.00%|    # fields related to float fields only
   105|         0|            0|            0|  0.00%|    allow_inf_nan: bool  # default: True
   106|         0|            0|            0|  0.00%|    # the config options are used to customise serialization to JSON
   107|         0|            0|            0|  0.00%|    ser_json_timedelta: Literal['iso8601', 'float']  # default: 'iso8601'
   108|         0|            0|            0|  0.00%|    ser_json_bytes: Literal['utf8', 'base64', 'hex']  # default: 'utf8'
   109|         0|            0|            0|  0.00%|    ser_json_inf_nan: Literal['null', 'constants', 'strings']  # default: 'null'
   110|         0|            0|            0|  0.00%|    # used to hide input data from ValidationError repr
   111|         0|            0|            0|  0.00%|    hide_input_in_errors: bool
   112|         0|            0|            0|  0.00%|    validation_error_cause: bool  # default: False
   113|         0|            0|            0|  0.00%|    coerce_numbers_to_str: bool  # default: False
   114|         0|            0|            0|  0.00%|    regex_engine: Literal['rust-regex', 'python-re']  # default: 'rust-regex'
   115|         0|            0|            0|  0.00%|    cache_strings: Union[bool, Literal['all', 'keys', 'none']]  # default: 'True'
   116|         0|            0|            0|  0.00%|
   117|         0|            0|            0|  0.00%|
   118|         0|            0|            0|  0.00%|IncExCall: TypeAlias = 'set[int | str] | dict[int | str, IncExCall] | None'
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|
   121|         0|            0|            0|  0.00%|class SerializationInfo(Protocol):
   122|         0|            0|            0|  0.00%|    @property
   123|         0|            0|            0|  0.00%|    def include(self) -> IncExCall: ...
   124|         0|            0|            0|  0.00%|
   125|         0|            0|            0|  0.00%|    @property
   126|         0|            0|            0|  0.00%|    def exclude(self) -> IncExCall: ...
   127|         0|            0|            0|  0.00%|
   128|         0|            0|            0|  0.00%|    @property
   129|         0|            0|            0|  0.00%|    def context(self) -> Any | None:
   130|         0|            0|            0|  0.00%|        """Current serialization context."""
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|    @property
   133|         0|            0|            0|  0.00%|    def mode(self) -> str: ...
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|    @property
   136|         0|            0|            0|  0.00%|    def by_alias(self) -> bool: ...
   137|         0|            0|            0|  0.00%|
   138|         0|            0|            0|  0.00%|    @property
   139|         0|            0|            0|  0.00%|    def exclude_unset(self) -> bool: ...
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|    @property
   142|         0|            0|            0|  0.00%|    def exclude_defaults(self) -> bool: ...
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|    @property
   145|         0|            0|            0|  0.00%|    def exclude_none(self) -> bool: ...
   146|         0|            0|            0|  0.00%|
   147|         0|            0|            0|  0.00%|    @property
   148|         0|            0|            0|  0.00%|    def serialize_as_any(self) -> bool: ...
   149|         0|            0|            0|  0.00%|
   150|         0|            0|            0|  0.00%|    def round_trip(self) -> bool: ...
   151|         0|            0|            0|  0.00%|
   152|         0|            0|            0|  0.00%|    def mode_is_json(self) -> bool: ...
   153|         0|            0|            0|  0.00%|
   154|         0|            0|            0|  0.00%|    def __str__(self) -> str: ...
   155|         0|            0|            0|  0.00%|
   156|         0|            0|            0|  0.00%|    def __repr__(self) -> str: ...
   157|         0|            0|            0|  0.00%|
   158|         0|            0|            0|  0.00%|
   159|         0|            0|            0|  0.00%|class FieldSerializationInfo(SerializationInfo, Protocol):
   160|         0|            0|            0|  0.00%|    @property
   161|         0|            0|            0|  0.00%|    def field_name(self) -> str: ...
   162|         0|            0|            0|  0.00%|
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|class ValidationInfo(Protocol):
   165|         0|            0|            0|  0.00%|    """
   166|         0|            0|            0|  0.00%|    Argument passed to validation functions.
   167|         0|            0|            0|  0.00%|    """
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|    @property
   170|         0|            0|            0|  0.00%|    def context(self) -> Any | None:
   171|         0|            0|            0|  0.00%|        """Current validation context."""
   172|         0|            0|            0|  0.00%|        ...
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|    @property
   175|         0|            0|            0|  0.00%|    def config(self) -> CoreConfig | None:
   176|         0|            0|            0|  0.00%|        """The CoreConfig that applies to this validation."""
   177|         0|            0|            0|  0.00%|        ...
   178|         0|            0|            0|  0.00%|
   179|         0|            0|            0|  0.00%|    @property
   180|         0|            0|            0|  0.00%|    def mode(self) -> Literal['python', 'json']:
   181|         0|            0|            0|  0.00%|        """The type of input data we are currently validating"""
   182|         0|            0|            0|  0.00%|        ...
   183|         0|            0|            0|  0.00%|
   184|         0|            0|            0|  0.00%|    @property
   185|         0|            0|            0|  0.00%|    def data(self) -> Dict[str, Any]:
   186|         0|            0|            0|  0.00%|        """The data being validated for this model."""
   187|         0|            0|            0|  0.00%|        ...
   188|         0|            0|            0|  0.00%|
   189|         0|            0|            0|  0.00%|    @property
   190|         0|            0|            0|  0.00%|    def field_name(self) -> str | None:
   191|         0|            0|            0|  0.00%|        """
   192|         0|            0|            0|  0.00%|        The name of the current field being validated if this validator is
   193|         0|            0|            0|  0.00%|        attached to a model field.
   194|         0|            0|            0|  0.00%|        """
   195|         0|            0|            0|  0.00%|        ...
   196|         0|            0|            0|  0.00%|
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|ExpectedSerializationTypes = Literal[
   199|         0|            0|            0|  0.00%|    'none',
   200|         0|            0|            0|  0.00%|    'int',
   201|         0|            0|            0|  0.00%|    'bool',
   202|         0|            0|            0|  0.00%|    'float',
   203|         0|            0|            0|  0.00%|    'str',
   204|         0|            0|            0|  0.00%|    'bytes',
   205|         0|            0|            0|  0.00%|    'bytearray',
   206|         0|            0|            0|  0.00%|    'list',
   207|         0|            0|            0|  0.00%|    'tuple',
   208|         0|            0|            0|  0.00%|    'set',
   209|         0|            0|            0|  0.00%|    'frozenset',
   210|         0|            0|            0|  0.00%|    'generator',
   211|         0|            0|            0|  0.00%|    'dict',
   212|         0|            0|            0|  0.00%|    'datetime',
   213|         0|            0|            0|  0.00%|    'date',
   214|         0|            0|            0|  0.00%|    'time',
   215|         0|            0|            0|  0.00%|    'timedelta',
   216|         0|            0|            0|  0.00%|    'url',
   217|         0|            0|            0|  0.00%|    'multi-host-url',
   218|         0|            0|            0|  0.00%|    'json',
   219|         0|            0|            0|  0.00%|    'uuid',
   220|         0|            0|            0|  0.00%|]
   221|         0|            0|            0|  0.00%|
   222|         0|            0|            0|  0.00%|
   223|         0|            0|            0|  0.00%|class SimpleSerSchema(TypedDict, total=False):
   224|         0|            0|            0|  0.00%|    type: Required[ExpectedSerializationTypes]
   225|         0|            0|            0|  0.00%|
   226|         0|            0|            0|  0.00%|
   227|         0|            0|            0|  0.00%|def simple_ser_schema(type: ExpectedSerializationTypes) -> SimpleSerSchema:
   228|         0|            0|            0|  0.00%|    """
   229|         0|            0|            0|  0.00%|    Returns a schema for serialization with a custom type.
   230|         0|            0|            0|  0.00%|
   231|         0|            0|            0|  0.00%|    Args:
   232|         0|            0|            0|  0.00%|        type: The type to use for serialization
   233|         0|            0|            0|  0.00%|    """
   234|         0|            0|            0|  0.00%|    return SimpleSerSchema(type=type)
   235|         0|            0|            0|  0.00%|
   236|         0|            0|            0|  0.00%|
   237|         0|            0|            0|  0.00%|# (input_value: Any, /) -> Any
   238|         0|            0|            0|  0.00%|GeneralPlainNoInfoSerializerFunction = Callable[[Any], Any]
   239|         0|            0|            0|  0.00%|# (input_value: Any, info: FieldSerializationInfo, /) -> Any
   240|         0|            0|            0|  0.00%|GeneralPlainInfoSerializerFunction = Callable[[Any, SerializationInfo], Any]
   241|         0|            0|            0|  0.00%|# (model: Any, input_value: Any, /) -> Any
   242|         0|            0|            0|  0.00%|FieldPlainNoInfoSerializerFunction = Callable[[Any, Any], Any]
   243|         0|            0|            0|  0.00%|# (model: Any, input_value: Any, info: FieldSerializationInfo, /) -> Any
   244|         0|            0|            0|  0.00%|FieldPlainInfoSerializerFunction = Callable[[Any, Any, FieldSerializationInfo], Any]
   245|         0|            0|            0|  0.00%|SerializerFunction = Union[
   246|         0|            0|            0|  0.00%|    GeneralPlainNoInfoSerializerFunction,
   247|         0|            0|            0|  0.00%|    GeneralPlainInfoSerializerFunction,
   248|         0|            0|            0|  0.00%|    FieldPlainNoInfoSerializerFunction,
   249|         0|            0|            0|  0.00%|    FieldPlainInfoSerializerFunction,
   250|         0|            0|            0|  0.00%|]
   251|         0|            0|            0|  0.00%|
   252|         0|            0|            0|  0.00%|WhenUsed = Literal['always', 'unless-none', 'json', 'json-unless-none']
   253|         0|            0|            0|  0.00%|"""
   254|         0|            0|            0|  0.00%|Values have the following meanings:
   255|         0|            0|            0|  0.00%|
   256|         0|            0|            0|  0.00%|* `'always'` means always use
   257|         0|            0|            0|  0.00%|* `'unless-none'` means use unless the value is `None`
   258|         0|            0|            0|  0.00%|* `'json'` means use when serializing to JSON
   259|         0|            0|            0|  0.00%|* `'json-unless-none'` means use when serializing to JSON and the value is not `None`
   260|         0|            0|            0|  0.00%|"""
   261|         0|            0|            0|  0.00%|
   262|         0|            0|            0|  0.00%|
   263|         0|            0|            0|  0.00%|class PlainSerializerFunctionSerSchema(TypedDict, total=False):
   264|         0|            0|            0|  0.00%|    type: Required[Literal['function-plain']]
   265|         0|            0|            0|  0.00%|    function: Required[SerializerFunction]
   266|         0|            0|            0|  0.00%|    is_field_serializer: bool  # default False
   267|         0|            0|            0|  0.00%|    info_arg: bool  # default False
   268|         0|            0|            0|  0.00%|    return_schema: CoreSchema  # if omitted, AnySchema is used
   269|         0|            0|            0|  0.00%|    when_used: WhenUsed  # default: 'always'
   270|         0|            0|            0|  0.00%|
   271|         0|            0|            0|  0.00%|
   272|         0|            0|            0|  0.00%|def plain_serializer_function_ser_schema(
   273|         0|            0|            0|  0.00%|    function: SerializerFunction,
   274|         0|            0|            0|  0.00%|    *,
   275|         0|            0|            0|  0.00%|    is_field_serializer: bool | None = None,
   276|         0|            0|            0|  0.00%|    info_arg: bool | None = None,
   277|         0|            0|            0|  0.00%|    return_schema: CoreSchema | None = None,
   278|         0|            0|            0|  0.00%|    when_used: WhenUsed = 'always',
   279|         0|            0|            0|  0.00%|) -> PlainSerializerFunctionSerSchema:
   280|         0|            0|            0|  0.00%|    """
   281|         0|            0|            0|  0.00%|    Returns a schema for serialization with a function, can be either a "general" or "field" function.
   282|         0|            0|            0|  0.00%|
   283|         0|            0|            0|  0.00%|    Args:
   284|         0|            0|            0|  0.00%|        function: The function to use for serialization
   285|         0|            0|            0|  0.00%|        is_field_serializer: Whether the serializer is for a field, e.g. takes `model` as the first argument,
   286|         0|            0|            0|  0.00%|            and `info` includes `field_name`
   287|         0|            0|            0|  0.00%|        info_arg: Whether the function takes an `info` argument
   288|         0|            0|            0|  0.00%|        return_schema: Schema to use for serializing return value
   289|         0|            0|            0|  0.00%|        when_used: When the function should be called
   290|         0|            0|            0|  0.00%|    """
   291|         0|            0|            0|  0.00%|    if when_used == 'always':
   292|         0|            0|            0|  0.00%|        # just to avoid extra elements in schema, and to use the actual default defined in rust
   293|         0|            0|            0|  0.00%|        when_used = None  # type: ignore
   294|         0|            0|            0|  0.00%|    return _dict_not_none(
   295|         0|            0|            0|  0.00%|        type='function-plain',
   296|         0|            0|            0|  0.00%|        function=function,
   297|         0|            0|            0|  0.00%|        is_field_serializer=is_field_serializer,
   298|         0|            0|            0|  0.00%|        info_arg=info_arg,
   299|         0|            0|            0|  0.00%|        return_schema=return_schema,
   300|         0|            0|            0|  0.00%|        when_used=when_used,
   301|         0|            0|            0|  0.00%|    )
   302|         0|            0|            0|  0.00%|
   303|         0|            0|            0|  0.00%|
   304|         0|            0|            0|  0.00%|class SerializerFunctionWrapHandler(Protocol):  # pragma: no cover
   305|         0|            0|            0|  0.00%|    def __call__(self, input_value: Any, index_key: int | str | None = None, /) -> Any: ...
   306|         0|            0|            0|  0.00%|
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|# (input_value: Any, serializer: SerializerFunctionWrapHandler, /) -> Any
   309|         0|            0|            0|  0.00%|GeneralWrapNoInfoSerializerFunction = Callable[[Any, SerializerFunctionWrapHandler], Any]
   310|         0|            0|            0|  0.00%|# (input_value: Any, serializer: SerializerFunctionWrapHandler, info: SerializationInfo, /) -> Any
   311|         0|            0|            0|  0.00%|GeneralWrapInfoSerializerFunction = Callable[[Any, SerializerFunctionWrapHandler, SerializationInfo], Any]
   312|         0|            0|            0|  0.00%|# (model: Any, input_value: Any, serializer: SerializerFunctionWrapHandler, /) -> Any
   313|         0|            0|            0|  0.00%|FieldWrapNoInfoSerializerFunction = Callable[[Any, Any, SerializerFunctionWrapHandler], Any]
   314|         0|            0|            0|  0.00%|# (model: Any, input_value: Any, serializer: SerializerFunctionWrapHandler, info: FieldSerializationInfo, /) -> Any
   315|         0|            0|            0|  0.00%|FieldWrapInfoSerializerFunction = Callable[[Any, Any, SerializerFunctionWrapHandler, FieldSerializationInfo], Any]
   316|         0|            0|            0|  0.00%|WrapSerializerFunction = Union[
   317|         0|            0|            0|  0.00%|    GeneralWrapNoInfoSerializerFunction,
   318|         0|            0|            0|  0.00%|    GeneralWrapInfoSerializerFunction,
   319|         0|            0|            0|  0.00%|    FieldWrapNoInfoSerializerFunction,
   320|         0|            0|            0|  0.00%|    FieldWrapInfoSerializerFunction,
   321|         0|            0|            0|  0.00%|]
   322|         0|            0|            0|  0.00%|
   323|         0|            0|            0|  0.00%|
   324|         0|            0|            0|  0.00%|class WrapSerializerFunctionSerSchema(TypedDict, total=False):
   325|         0|            0|            0|  0.00%|    type: Required[Literal['function-wrap']]
   326|         0|            0|            0|  0.00%|    function: Required[WrapSerializerFunction]
   327|         0|            0|            0|  0.00%|    is_field_serializer: bool  # default False
   328|         0|            0|            0|  0.00%|    info_arg: bool  # default False
   329|         0|            0|            0|  0.00%|    schema: CoreSchema  # if omitted, the schema on which this serializer is defined is used
   330|         0|            0|            0|  0.00%|    return_schema: CoreSchema  # if omitted, AnySchema is used
   331|         0|            0|            0|  0.00%|    when_used: WhenUsed  # default: 'always'
   332|         0|            0|            0|  0.00%|
   333|         0|            0|            0|  0.00%|
   334|         0|            0|            0|  0.00%|def wrap_serializer_function_ser_schema(
   335|         0|            0|            0|  0.00%|    function: WrapSerializerFunction,
   336|         0|            0|            0|  0.00%|    *,
   337|         0|            0|            0|  0.00%|    is_field_serializer: bool | None = None,
   338|         0|            0|            0|  0.00%|    info_arg: bool | None = None,
   339|         0|            0|            0|  0.00%|    schema: CoreSchema | None = None,
   340|         0|            0|            0|  0.00%|    return_schema: CoreSchema | None = None,
   341|         0|            0|            0|  0.00%|    when_used: WhenUsed = 'always',
   342|         0|            0|            0|  0.00%|) -> WrapSerializerFunctionSerSchema:
   343|         0|            0|            0|  0.00%|    """
   344|         0|            0|            0|  0.00%|    Returns a schema for serialization with a wrap function, can be either a "general" or "field" function.
   345|         0|            0|            0|  0.00%|
   346|         0|            0|            0|  0.00%|    Args:
   347|         0|            0|            0|  0.00%|        function: The function to use for serialization
   348|         0|            0|            0|  0.00%|        is_field_serializer: Whether the serializer is for a field, e.g. takes `model` as the first argument,
   349|         0|            0|            0|  0.00%|            and `info` includes `field_name`
   350|         0|            0|            0|  0.00%|        info_arg: Whether the function takes an `info` argument
   351|         0|            0|            0|  0.00%|        schema: The schema to use for the inner serialization
   352|         0|            0|            0|  0.00%|        return_schema: Schema to use for serializing return value
   353|         0|            0|            0|  0.00%|        when_used: When the function should be called
   354|         0|            0|            0|  0.00%|    """
   355|         0|            0|            0|  0.00%|    if when_used == 'always':
   356|         0|            0|            0|  0.00%|        # just to avoid extra elements in schema, and to use the actual default defined in rust
   357|         0|            0|            0|  0.00%|        when_used = None  # type: ignore
   358|         0|            0|            0|  0.00%|    return _dict_not_none(
   359|         0|            0|            0|  0.00%|        type='function-wrap',
   360|         0|            0|            0|  0.00%|        function=function,
   361|         0|            0|            0|  0.00%|        is_field_serializer=is_field_serializer,
   362|         0|            0|            0|  0.00%|        info_arg=info_arg,
   363|         0|            0|            0|  0.00%|        schema=schema,
   364|         0|            0|            0|  0.00%|        return_schema=return_schema,
   365|         0|            0|            0|  0.00%|        when_used=when_used,
   366|         0|            0|            0|  0.00%|    )
   367|         0|            0|            0|  0.00%|
   368|         0|            0|            0|  0.00%|
   369|         0|            0|            0|  0.00%|class FormatSerSchema(TypedDict, total=False):
   370|         0|            0|            0|  0.00%|    type: Required[Literal['format']]
   371|         0|            0|            0|  0.00%|    formatting_string: Required[str]
   372|         0|            0|            0|  0.00%|    when_used: WhenUsed  # default: 'json-unless-none'
   373|         0|            0|            0|  0.00%|
   374|         0|            0|            0|  0.00%|
   375|         0|            0|            0|  0.00%|def format_ser_schema(formatting_string: str, *, when_used: WhenUsed = 'json-unless-none') -> FormatSerSchema:
   376|         0|            0|            0|  0.00%|    """
   377|         0|            0|            0|  0.00%|    Returns a schema for serialization using python's `format` method.
   378|         0|            0|            0|  0.00%|
   379|         0|            0|            0|  0.00%|    Args:
   380|         0|            0|            0|  0.00%|        formatting_string: String defining the format to use
   381|         0|            0|            0|  0.00%|        when_used: Same meaning as for [general_function_plain_ser_schema], but with a different default
   382|         0|            0|            0|  0.00%|    """
   383|         0|            0|            0|  0.00%|    if when_used == 'json-unless-none':
   384|         0|            0|            0|  0.00%|        # just to avoid extra elements in schema, and to use the actual default defined in rust
   385|         0|            0|            0|  0.00%|        when_used = None  # type: ignore
   386|         0|            0|            0|  0.00%|    return _dict_not_none(type='format', formatting_string=formatting_string, when_used=when_used)
   387|         0|            0|            0|  0.00%|
   388|         0|            0|            0|  0.00%|
   389|         0|            0|            0|  0.00%|class ToStringSerSchema(TypedDict, total=False):
   390|         0|            0|            0|  0.00%|    type: Required[Literal['to-string']]
   391|         0|            0|            0|  0.00%|    when_used: WhenUsed  # default: 'json-unless-none'
   392|         0|            0|            0|  0.00%|
   393|         0|            0|            0|  0.00%|
   394|         0|            0|            0|  0.00%|def to_string_ser_schema(*, when_used: WhenUsed = 'json-unless-none') -> ToStringSerSchema:
   395|         0|            0|            0|  0.00%|    """
   396|         0|            0|            0|  0.00%|    Returns a schema for serialization using python's `str()` / `__str__` method.
   397|         0|            0|            0|  0.00%|
   398|         0|            0|            0|  0.00%|    Args:
   399|         0|            0|            0|  0.00%|        when_used: Same meaning as for [general_function_plain_ser_schema], but with a different default
   400|         0|            0|            0|  0.00%|    """
   401|         0|            0|            0|  0.00%|    s = dict(type='to-string')
   402|         0|            0|            0|  0.00%|    if when_used != 'json-unless-none':
   403|         0|            0|            0|  0.00%|        # just to avoid extra elements in schema, and to use the actual default defined in rust
   404|         0|            0|            0|  0.00%|        s['when_used'] = when_used
   405|         0|            0|            0|  0.00%|    return s  # type: ignore
   406|         0|            0|            0|  0.00%|
   407|         0|            0|            0|  0.00%|
   408|         0|            0|            0|  0.00%|class ModelSerSchema(TypedDict, total=False):
   409|         0|            0|            0|  0.00%|    type: Required[Literal['model']]
   410|         0|            0|            0|  0.00%|    cls: Required[Type[Any]]
   411|         0|            0|            0|  0.00%|    schema: Required[CoreSchema]
   412|         0|            0|            0|  0.00%|
   413|         0|            0|            0|  0.00%|
   414|         0|            0|            0|  0.00%|def model_ser_schema(cls: Type[Any], schema: CoreSchema) -> ModelSerSchema:
   415|         0|            0|            0|  0.00%|    """
   416|         0|            0|            0|  0.00%|    Returns a schema for serialization using a model.
   417|         0|            0|            0|  0.00%|
   418|         0|            0|            0|  0.00%|    Args:
   419|         0|            0|            0|  0.00%|        cls: The expected class type, used to generate warnings if the wrong type is passed
   420|         0|            0|            0|  0.00%|        schema: Internal schema to use to serialize the model dict
   421|         0|            0|            0|  0.00%|    """
   422|         0|            0|            0|  0.00%|    return ModelSerSchema(type='model', cls=cls, schema=schema)
   423|         0|            0|            0|  0.00%|
   424|         0|            0|            0|  0.00%|
   425|         0|            0|            0|  0.00%|SerSchema = Union[
   426|         0|            0|            0|  0.00%|    SimpleSerSchema,
   427|         0|            0|            0|  0.00%|    PlainSerializerFunctionSerSchema,
   428|         0|            0|            0|  0.00%|    WrapSerializerFunctionSerSchema,
   429|         0|            0|            0|  0.00%|    FormatSerSchema,
   430|         0|            0|            0|  0.00%|    ToStringSerSchema,
   431|         0|            0|            0|  0.00%|    ModelSerSchema,
   432|         0|            0|            0|  0.00%|]
   433|         0|            0|            0|  0.00%|
   434|         0|            0|            0|  0.00%|
   435|         0|            0|            0|  0.00%|class ComputedField(TypedDict, total=False):
   436|         0|            0|            0|  0.00%|    type: Required[Literal['computed-field']]
   437|         0|            0|            0|  0.00%|    property_name: Required[str]
   438|         0|            0|            0|  0.00%|    return_schema: Required[CoreSchema]
   439|         0|            0|            0|  0.00%|    alias: str
   440|         0|            0|            0|  0.00%|    metadata: Any
   441|         0|            0|            0|  0.00%|
   442|         0|            0|            0|  0.00%|
   443|         0|            0|            0|  0.00%|def computed_field(
   444|         0|            0|            0|  0.00%|    property_name: str, return_schema: CoreSchema, *, alias: str | None = None, metadata: Any = None
   445|         0|            0|            0|  0.00%|) -> ComputedField:
   446|         0|            0|            0|  0.00%|    """
   447|         0|            0|            0|  0.00%|    ComputedFields are properties of a model or dataclass that are included in serialization.
   448|         0|            0|            0|  0.00%|
   449|         0|            0|            0|  0.00%|    Args:
   450|         0|            0|            0|  0.00%|        property_name: The name of the property on the model or dataclass
   451|         0|            0|            0|  0.00%|        return_schema: The schema used for the type returned by the computed field
   452|         0|            0|            0|  0.00%|        alias: The name to use in the serialized output
   453|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
   454|         0|            0|            0|  0.00%|    """
   455|         0|            0|            0|  0.00%|    return _dict_not_none(
   456|         0|            0|            0|  0.00%|        type='computed-field', property_name=property_name, return_schema=return_schema, alias=alias, metadata=metadata
   457|         0|            0|            0|  0.00%|    )
   458|         0|            0|            0|  0.00%|
   459|         0|            0|            0|  0.00%|
   460|         0|            0|            0|  0.00%|class AnySchema(TypedDict, total=False):
   461|         0|            0|            0|  0.00%|    type: Required[Literal['any']]
   462|         0|            0|            0|  0.00%|    ref: str
   463|         0|            0|            0|  0.00%|    metadata: Any
   464|         0|            0|            0|  0.00%|    serialization: SerSchema
   465|         0|            0|            0|  0.00%|
   466|         0|            0|            0|  0.00%|
   467|         0|            0|            0|  0.00%|def any_schema(*, ref: str | None = None, metadata: Any = None, serialization: SerSchema | None = None) -> AnySchema:
   468|         0|            0|            0|  0.00%|    """
   469|         0|            0|            0|  0.00%|    Returns a schema that matches any value, e.g.:
   470|         0|            0|            0|  0.00%|
   471|         0|            0|            0|  0.00%|    ```py
   472|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
   473|         0|            0|            0|  0.00%|
   474|         0|            0|            0|  0.00%|    schema = core_schema.any_schema()
   475|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
   476|         0|            0|            0|  0.00%|    assert v.validate_python(1) == 1
   477|         0|            0|            0|  0.00%|    ```
   478|         0|            0|            0|  0.00%|
   479|         0|            0|            0|  0.00%|    Args:
   480|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
   481|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
   482|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
   483|         0|            0|            0|  0.00%|    """
   484|         0|            0|            0|  0.00%|    return _dict_not_none(type='any', ref=ref, metadata=metadata, serialization=serialization)
   485|         0|            0|            0|  0.00%|
   486|         0|            0|            0|  0.00%|
   487|         0|            0|            0|  0.00%|class NoneSchema(TypedDict, total=False):
   488|         0|            0|            0|  0.00%|    type: Required[Literal['none']]
   489|         0|            0|            0|  0.00%|    ref: str
   490|         0|            0|            0|  0.00%|    metadata: Any
   491|         0|            0|            0|  0.00%|    serialization: SerSchema
   492|         0|            0|            0|  0.00%|
   493|         0|            0|            0|  0.00%|
   494|         0|            0|            0|  0.00%|def none_schema(*, ref: str | None = None, metadata: Any = None, serialization: SerSchema | None = None) -> NoneSchema:
   495|         0|            0|            0|  0.00%|    """
   496|         0|            0|            0|  0.00%|    Returns a schema that matches a None value, e.g.:
   497|         0|            0|            0|  0.00%|
   498|         0|            0|            0|  0.00%|    ```py
   499|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
   500|         0|            0|            0|  0.00%|
   501|         0|            0|            0|  0.00%|    schema = core_schema.none_schema()
   502|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
   503|         0|            0|            0|  0.00%|    assert v.validate_python(None) is None
   504|         0|            0|            0|  0.00%|    ```
   505|         0|            0|            0|  0.00%|
   506|         0|            0|            0|  0.00%|    Args:
   507|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
   508|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
   509|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
   510|         0|            0|            0|  0.00%|    """
   511|         0|            0|            0|  0.00%|    return _dict_not_none(type='none', ref=ref, metadata=metadata, serialization=serialization)
   512|         0|            0|            0|  0.00%|
   513|         0|            0|            0|  0.00%|
   514|         0|            0|            0|  0.00%|class BoolSchema(TypedDict, total=False):
   515|         0|            0|            0|  0.00%|    type: Required[Literal['bool']]
   516|         0|            0|            0|  0.00%|    strict: bool
   517|         0|            0|            0|  0.00%|    ref: str
   518|         0|            0|            0|  0.00%|    metadata: Any
   519|         0|            0|            0|  0.00%|    serialization: SerSchema
   520|         0|            0|            0|  0.00%|
   521|         0|            0|            0|  0.00%|
   522|         0|            0|            0|  0.00%|def bool_schema(
   523|         0|            0|            0|  0.00%|    strict: bool | None = None, ref: str | None = None, metadata: Any = None, serialization: SerSchema | None = None
   524|         0|            0|            0|  0.00%|) -> BoolSchema:
   525|         0|            0|            0|  0.00%|    """
   526|         0|            0|            0|  0.00%|    Returns a schema that matches a bool value, e.g.:
   527|         0|            0|            0|  0.00%|
   528|         0|            0|            0|  0.00%|    ```py
   529|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
   530|         0|            0|            0|  0.00%|
   531|         0|            0|            0|  0.00%|    schema = core_schema.bool_schema()
   532|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
   533|         0|            0|            0|  0.00%|    assert v.validate_python('True') is True
   534|         0|            0|            0|  0.00%|    ```
   535|         0|            0|            0|  0.00%|
   536|         0|            0|            0|  0.00%|    Args:
   537|         0|            0|            0|  0.00%|        strict: Whether the value should be a bool or a value that can be converted to a bool
   538|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
   539|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
   540|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
   541|         0|            0|            0|  0.00%|    """
   542|         0|            0|            0|  0.00%|    return _dict_not_none(type='bool', strict=strict, ref=ref, metadata=metadata, serialization=serialization)
   543|         0|            0|            0|  0.00%|
   544|         0|            0|            0|  0.00%|
   545|         0|            0|            0|  0.00%|class IntSchema(TypedDict, total=False):
   546|         0|            0|            0|  0.00%|    type: Required[Literal['int']]
   547|         0|            0|            0|  0.00%|    multiple_of: int
   548|         0|            0|            0|  0.00%|    le: int
   549|         0|            0|            0|  0.00%|    ge: int
   550|         0|            0|            0|  0.00%|    lt: int
   551|         0|            0|            0|  0.00%|    gt: int
   552|         0|            0|            0|  0.00%|    strict: bool
   553|         0|            0|            0|  0.00%|    ref: str
   554|         0|            0|            0|  0.00%|    metadata: Any
   555|         0|            0|            0|  0.00%|    serialization: SerSchema
   556|         0|            0|            0|  0.00%|
   557|         0|            0|            0|  0.00%|
   558|         0|            0|            0|  0.00%|def int_schema(
   559|         0|            0|            0|  0.00%|    *,
   560|         0|            0|            0|  0.00%|    multiple_of: int | None = None,
   561|         0|            0|            0|  0.00%|    le: int | None = None,
   562|         0|            0|            0|  0.00%|    ge: int | None = None,
   563|         0|            0|            0|  0.00%|    lt: int | None = None,
   564|         0|            0|            0|  0.00%|    gt: int | None = None,
   565|         0|            0|            0|  0.00%|    strict: bool | None = None,
   566|         0|            0|            0|  0.00%|    ref: str | None = None,
   567|         0|            0|            0|  0.00%|    metadata: Any = None,
   568|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
   569|         0|            0|            0|  0.00%|) -> IntSchema:
   570|         0|            0|            0|  0.00%|    """
   571|         0|            0|            0|  0.00%|    Returns a schema that matches a int value, e.g.:
   572|         0|            0|            0|  0.00%|
   573|         0|            0|            0|  0.00%|    ```py
   574|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
   575|         0|            0|            0|  0.00%|
   576|         0|            0|            0|  0.00%|    schema = core_schema.int_schema(multiple_of=2, le=6, ge=2)
   577|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
   578|         0|            0|            0|  0.00%|    assert v.validate_python('4') == 4
   579|         0|            0|            0|  0.00%|    ```
   580|         0|            0|            0|  0.00%|
   581|         0|            0|            0|  0.00%|    Args:
   582|         0|            0|            0|  0.00%|        multiple_of: The value must be a multiple of this number
   583|         0|            0|            0|  0.00%|        le: The value must be less than or equal to this number
   584|         0|            0|            0|  0.00%|        ge: The value must be greater than or equal to this number
   585|         0|            0|            0|  0.00%|        lt: The value must be strictly less than this number
   586|         0|            0|            0|  0.00%|        gt: The value must be strictly greater than this number
   587|         0|            0|            0|  0.00%|        strict: Whether the value should be a int or a value that can be converted to a int
   588|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
   589|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
   590|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
   591|         0|            0|            0|  0.00%|    """
   592|         0|            0|            0|  0.00%|    return _dict_not_none(
   593|         0|            0|            0|  0.00%|        type='int',
   594|         0|            0|            0|  0.00%|        multiple_of=multiple_of,
   595|         0|            0|            0|  0.00%|        le=le,
   596|         0|            0|            0|  0.00%|        ge=ge,
   597|         0|            0|            0|  0.00%|        lt=lt,
   598|         0|            0|            0|  0.00%|        gt=gt,
   599|         0|            0|            0|  0.00%|        strict=strict,
   600|         0|            0|            0|  0.00%|        ref=ref,
   601|         0|            0|            0|  0.00%|        metadata=metadata,
   602|         0|            0|            0|  0.00%|        serialization=serialization,
   603|         0|            0|            0|  0.00%|    )
   604|         0|            0|            0|  0.00%|
   605|         0|            0|            0|  0.00%|
   606|         0|            0|            0|  0.00%|class FloatSchema(TypedDict, total=False):
   607|         0|            0|            0|  0.00%|    type: Required[Literal['float']]
   608|         0|            0|            0|  0.00%|    allow_inf_nan: bool  # whether 'NaN', '+inf', '-inf' should be forbidden. default: True
   609|         0|            0|            0|  0.00%|    multiple_of: float
   610|         0|            0|            0|  0.00%|    le: float
   611|         0|            0|            0|  0.00%|    ge: float
   612|         0|            0|            0|  0.00%|    lt: float
   613|         0|            0|            0|  0.00%|    gt: float
   614|         0|            0|            0|  0.00%|    strict: bool
   615|         0|            0|            0|  0.00%|    ref: str
   616|         0|            0|            0|  0.00%|    metadata: Any
   617|         0|            0|            0|  0.00%|    serialization: SerSchema
   618|         0|            0|            0|  0.00%|
   619|         0|            0|            0|  0.00%|
   620|         0|            0|            0|  0.00%|def float_schema(
   621|         0|            0|            0|  0.00%|    *,
   622|         0|            0|            0|  0.00%|    allow_inf_nan: bool | None = None,
   623|         0|            0|            0|  0.00%|    multiple_of: float | None = None,
   624|         0|            0|            0|  0.00%|    le: float | None = None,
   625|         0|            0|            0|  0.00%|    ge: float | None = None,
   626|         0|            0|            0|  0.00%|    lt: float | None = None,
   627|         0|            0|            0|  0.00%|    gt: float | None = None,
   628|         0|            0|            0|  0.00%|    strict: bool | None = None,
   629|         0|            0|            0|  0.00%|    ref: str | None = None,
   630|         0|            0|            0|  0.00%|    metadata: Any = None,
   631|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
   632|         0|            0|            0|  0.00%|) -> FloatSchema:
   633|         0|            0|            0|  0.00%|    """
   634|         0|            0|            0|  0.00%|    Returns a schema that matches a float value, e.g.:
   635|         0|            0|            0|  0.00%|
   636|         0|            0|            0|  0.00%|    ```py
   637|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
   638|         0|            0|            0|  0.00%|
   639|         0|            0|            0|  0.00%|    schema = core_schema.float_schema(le=0.8, ge=0.2)
   640|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
   641|         0|            0|            0|  0.00%|    assert v.validate_python('0.5') == 0.5
   642|         0|            0|            0|  0.00%|    ```
   643|         0|            0|            0|  0.00%|
   644|         0|            0|            0|  0.00%|    Args:
   645|         0|            0|            0|  0.00%|        allow_inf_nan: Whether to allow inf and nan values
   646|         0|            0|            0|  0.00%|        multiple_of: The value must be a multiple of this number
   647|         0|            0|            0|  0.00%|        le: The value must be less than or equal to this number
   648|         0|            0|            0|  0.00%|        ge: The value must be greater than or equal to this number
   649|         0|            0|            0|  0.00%|        lt: The value must be strictly less than this number
   650|         0|            0|            0|  0.00%|        gt: The value must be strictly greater than this number
   651|         0|            0|            0|  0.00%|        strict: Whether the value should be a float or a value that can be converted to a float
   652|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
   653|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
   654|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
   655|         0|            0|            0|  0.00%|    """
   656|         0|            0|            0|  0.00%|    return _dict_not_none(
   657|         0|            0|            0|  0.00%|        type='float',
   658|         0|            0|            0|  0.00%|        allow_inf_nan=allow_inf_nan,
   659|         0|            0|            0|  0.00%|        multiple_of=multiple_of,
   660|         0|            0|            0|  0.00%|        le=le,
   661|         0|            0|            0|  0.00%|        ge=ge,
   662|         0|            0|            0|  0.00%|        lt=lt,
   663|         0|            0|            0|  0.00%|        gt=gt,
   664|         0|            0|            0|  0.00%|        strict=strict,
   665|         0|            0|            0|  0.00%|        ref=ref,
   666|         0|            0|            0|  0.00%|        metadata=metadata,
   667|         0|            0|            0|  0.00%|        serialization=serialization,
   668|         0|            0|            0|  0.00%|    )
   669|         0|            0|            0|  0.00%|
   670|         0|            0|            0|  0.00%|
   671|         0|            0|            0|  0.00%|class DecimalSchema(TypedDict, total=False):
   672|         0|            0|            0|  0.00%|    type: Required[Literal['decimal']]
   673|         0|            0|            0|  0.00%|    allow_inf_nan: bool  # whether 'NaN', '+inf', '-inf' should be forbidden. default: False
   674|         0|            0|            0|  0.00%|    multiple_of: Decimal
   675|         0|            0|            0|  0.00%|    le: Decimal
   676|         0|            0|            0|  0.00%|    ge: Decimal
   677|         0|            0|            0|  0.00%|    lt: Decimal
   678|         0|            0|            0|  0.00%|    gt: Decimal
   679|         0|            0|            0|  0.00%|    max_digits: int
   680|         0|            0|            0|  0.00%|    decimal_places: int
   681|         0|            0|            0|  0.00%|    strict: bool
   682|         0|            0|            0|  0.00%|    ref: str
   683|         0|            0|            0|  0.00%|    metadata: Any
   684|         0|            0|            0|  0.00%|    serialization: SerSchema
   685|         0|            0|            0|  0.00%|
   686|         0|            0|            0|  0.00%|
   687|         0|            0|            0|  0.00%|def decimal_schema(
   688|         0|            0|            0|  0.00%|    *,
   689|         0|            0|            0|  0.00%|    allow_inf_nan: bool = None,
   690|         0|            0|            0|  0.00%|    multiple_of: Decimal | None = None,
   691|         0|            0|            0|  0.00%|    le: Decimal | None = None,
   692|         0|            0|            0|  0.00%|    ge: Decimal | None = None,
   693|         0|            0|            0|  0.00%|    lt: Decimal | None = None,
   694|         0|            0|            0|  0.00%|    gt: Decimal | None = None,
   695|         0|            0|            0|  0.00%|    max_digits: int | None = None,
   696|         0|            0|            0|  0.00%|    decimal_places: int | None = None,
   697|         0|            0|            0|  0.00%|    strict: bool | None = None,
   698|         0|            0|            0|  0.00%|    ref: str | None = None,
   699|         0|            0|            0|  0.00%|    metadata: Any = None,
   700|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
   701|         0|            0|            0|  0.00%|) -> DecimalSchema:
   702|         0|            0|            0|  0.00%|    """
   703|         0|            0|            0|  0.00%|    Returns a schema that matches a decimal value, e.g.:
   704|         0|            0|            0|  0.00%|
   705|         0|            0|            0|  0.00%|    ```py
   706|         0|            0|            0|  0.00%|    from decimal import Decimal
   707|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
   708|         0|            0|            0|  0.00%|
   709|         0|            0|            0|  0.00%|    schema = core_schema.decimal_schema(le=0.8, ge=0.2)
   710|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
   711|         0|            0|            0|  0.00%|    assert v.validate_python('0.5') == Decimal('0.5')
   712|         0|            0|            0|  0.00%|    ```
   713|         0|            0|            0|  0.00%|
   714|         0|            0|            0|  0.00%|    Args:
   715|         0|            0|            0|  0.00%|        allow_inf_nan: Whether to allow inf and nan values
   716|         0|            0|            0|  0.00%|        multiple_of: The value must be a multiple of this number
   717|         0|            0|            0|  0.00%|        le: The value must be less than or equal to this number
   718|         0|            0|            0|  0.00%|        ge: The value must be greater than or equal to this number
   719|         0|            0|            0|  0.00%|        lt: The value must be strictly less than this number
   720|         0|            0|            0|  0.00%|        gt: The value must be strictly greater than this number
   721|         0|            0|            0|  0.00%|        max_digits: The maximum number of decimal digits allowed
   722|         0|            0|            0|  0.00%|        decimal_places: The maximum number of decimal places allowed
   723|         0|            0|            0|  0.00%|        strict: Whether the value should be a float or a value that can be converted to a float
   724|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
   725|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
   726|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
   727|         0|            0|            0|  0.00%|    """
   728|         0|            0|            0|  0.00%|    return _dict_not_none(
   729|         0|            0|            0|  0.00%|        type='decimal',
   730|         0|            0|            0|  0.00%|        gt=gt,
   731|         0|            0|            0|  0.00%|        ge=ge,
   732|         0|            0|            0|  0.00%|        lt=lt,
   733|         0|            0|            0|  0.00%|        le=le,
   734|         0|            0|            0|  0.00%|        max_digits=max_digits,
   735|         0|            0|            0|  0.00%|        decimal_places=decimal_places,
   736|         0|            0|            0|  0.00%|        multiple_of=multiple_of,
   737|         0|            0|            0|  0.00%|        allow_inf_nan=allow_inf_nan,
   738|         0|            0|            0|  0.00%|        strict=strict,
   739|         0|            0|            0|  0.00%|        ref=ref,
   740|         0|            0|            0|  0.00%|        metadata=metadata,
   741|         0|            0|            0|  0.00%|        serialization=serialization,
   742|         0|            0|            0|  0.00%|    )
   743|         0|            0|            0|  0.00%|
   744|         0|            0|            0|  0.00%|
   745|         0|            0|            0|  0.00%|class StringSchema(TypedDict, total=False):
   746|         0|            0|            0|  0.00%|    type: Required[Literal['str']]
   747|         0|            0|            0|  0.00%|    pattern: Union[str, Pattern[str]]
   748|         0|            0|            0|  0.00%|    max_length: int
   749|         0|            0|            0|  0.00%|    min_length: int
   750|         0|            0|            0|  0.00%|    strip_whitespace: bool
   751|         0|            0|            0|  0.00%|    to_lower: bool
   752|         0|            0|            0|  0.00%|    to_upper: bool
   753|         0|            0|            0|  0.00%|    regex_engine: Literal['rust-regex', 'python-re']  # default: 'rust-regex'
   754|         0|            0|            0|  0.00%|    strict: bool
   755|         0|            0|            0|  0.00%|    coerce_numbers_to_str: bool
   756|         0|            0|            0|  0.00%|    ref: str
   757|         0|            0|            0|  0.00%|    metadata: Any
   758|         0|            0|            0|  0.00%|    serialization: SerSchema
   759|         0|            0|            0|  0.00%|
   760|         0|            0|            0|  0.00%|
   761|         2|  3.57628e-06|  1.78814e-06|  0.00%|def str_schema(
   762|         0|            0|            0|  0.00%|    *,
   763|         0|            0|            0|  0.00%|    pattern: str | Pattern[str] | None = None,
   764|         0|            0|            0|  0.00%|    max_length: int | None = None,
   765|         0|            0|            0|  0.00%|    min_length: int | None = None,
   766|         0|            0|            0|  0.00%|    strip_whitespace: bool | None = None,
   767|         0|            0|            0|  0.00%|    to_lower: bool | None = None,
   768|         0|            0|            0|  0.00%|    to_upper: bool | None = None,
   769|         0|            0|            0|  0.00%|    regex_engine: Literal['rust-regex', 'python-re'] | None = None,
   770|         0|            0|            0|  0.00%|    strict: bool | None = None,
   771|         0|            0|            0|  0.00%|    coerce_numbers_to_str: bool | None = None,
   772|         0|            0|            0|  0.00%|    ref: str | None = None,
   773|         0|            0|            0|  0.00%|    metadata: Any = None,
   774|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
   775|         0|            0|            0|  0.00%|) -> StringSchema:
   776|         0|            0|            0|  0.00%|    """
   777|         0|            0|            0|  0.00%|    Returns a schema that matches a string value, e.g.:
   778|         0|            0|            0|  0.00%|
   779|         0|            0|            0|  0.00%|    ```py
   780|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
   781|         0|            0|            0|  0.00%|
   782|         0|            0|            0|  0.00%|    schema = core_schema.str_schema(max_length=10, min_length=2)
   783|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
   784|         0|            0|            0|  0.00%|    assert v.validate_python('hello') == 'hello'
   785|         0|            0|            0|  0.00%|    ```
   786|         0|            0|            0|  0.00%|
   787|         0|            0|            0|  0.00%|    Args:
   788|         0|            0|            0|  0.00%|        pattern: A regex pattern that the value must match
   789|         0|            0|            0|  0.00%|        max_length: The value must be at most this length
   790|         0|            0|            0|  0.00%|        min_length: The value must be at least this length
   791|         0|            0|            0|  0.00%|        strip_whitespace: Whether to strip whitespace from the value
   792|         0|            0|            0|  0.00%|        to_lower: Whether to convert the value to lowercase
   793|         0|            0|            0|  0.00%|        to_upper: Whether to convert the value to uppercase
   794|         0|            0|            0|  0.00%|        regex_engine: The regex engine to use for pattern validation. Default is 'rust-regex'.
   795|         0|            0|            0|  0.00%|            - `rust-regex` uses the [`regex`](https://docs.rs/regex) Rust
   796|         0|            0|            0|  0.00%|              crate, which is non-backtracking and therefore more DDoS
   797|         0|            0|            0|  0.00%|              resistant, but does not support all regex features.
   798|         0|            0|            0|  0.00%|            - `python-re` use the [`re`](https://docs.python.org/3/library/re.html) module,
   799|         0|            0|            0|  0.00%|              which supports all regex features, but may be slower.
   800|         0|            0|            0|  0.00%|        strict: Whether the value should be a string or a value that can be converted to a string
   801|         0|            0|            0|  0.00%|        coerce_numbers_to_str: Whether to enable coercion of any `Number` type to `str` (not applicable in `strict` mode).
   802|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
   803|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
   804|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
   805|         0|            0|            0|  0.00%|    """
   806|         4|  2.14577e-05|  5.36442e-06|  0.02%|    return _dict_not_none(
(call)|         2|  3.83854e-05|  1.91927e-05|  0.04%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic_core/core_schema.py:3958 _dict_not_none
   807|         2|  3.33786e-06|  1.66893e-06|  0.00%|        type='str',
   808|         2|   2.6226e-06|   1.3113e-06|  0.00%|        pattern=pattern,
   809|         2|  3.09944e-06|  1.54972e-06|  0.00%|        max_length=max_length,
   810|         2|  2.14577e-06|  1.07288e-06|  0.00%|        min_length=min_length,
   811|         2|  3.09944e-06|  1.54972e-06|  0.00%|        strip_whitespace=strip_whitespace,
   812|         2|  3.09944e-06|  1.54972e-06|  0.00%|        to_lower=to_lower,
   813|         2|  2.38419e-06|  1.19209e-06|  0.00%|        to_upper=to_upper,
   814|         2|  2.38419e-06|  1.19209e-06|  0.00%|        regex_engine=regex_engine,
   815|         2|   2.6226e-06|   1.3113e-06|  0.00%|        strict=strict,
   816|         2|  3.33786e-06|  1.66893e-06|  0.00%|        coerce_numbers_to_str=coerce_numbers_to_str,
   817|         2|  4.52995e-06|  2.26498e-06|  0.00%|        ref=ref,
   818|         2|   2.6226e-06|   1.3113e-06|  0.00%|        metadata=metadata,
   819|         2|  2.86102e-06|  1.43051e-06|  0.00%|        serialization=serialization,
   820|         0|            0|            0|  0.00%|    )
   821|         0|            0|            0|  0.00%|
   822|         0|            0|            0|  0.00%|
   823|         0|            0|            0|  0.00%|class BytesSchema(TypedDict, total=False):
   824|         0|            0|            0|  0.00%|    type: Required[Literal['bytes']]
   825|         0|            0|            0|  0.00%|    max_length: int
   826|         0|            0|            0|  0.00%|    min_length: int
   827|         0|            0|            0|  0.00%|    strict: bool
   828|         0|            0|            0|  0.00%|    ref: str
   829|         0|            0|            0|  0.00%|    metadata: Any
   830|         0|            0|            0|  0.00%|    serialization: SerSchema
   831|         0|            0|            0|  0.00%|
   832|         0|            0|            0|  0.00%|
   833|         0|            0|            0|  0.00%|def bytes_schema(
   834|         0|            0|            0|  0.00%|    *,
   835|         0|            0|            0|  0.00%|    max_length: int | None = None,
   836|         0|            0|            0|  0.00%|    min_length: int | None = None,
   837|         0|            0|            0|  0.00%|    strict: bool | None = None,
   838|         0|            0|            0|  0.00%|    ref: str | None = None,
   839|         0|            0|            0|  0.00%|    metadata: Any = None,
   840|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
   841|         0|            0|            0|  0.00%|) -> BytesSchema:
   842|         0|            0|            0|  0.00%|    """
   843|         0|            0|            0|  0.00%|    Returns a schema that matches a bytes value, e.g.:
   844|         0|            0|            0|  0.00%|
   845|         0|            0|            0|  0.00%|    ```py
   846|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
   847|         0|            0|            0|  0.00%|
   848|         0|            0|            0|  0.00%|    schema = core_schema.bytes_schema(max_length=10, min_length=2)
   849|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
   850|         0|            0|            0|  0.00%|    assert v.validate_python(b'hello') == b'hello'
   851|         0|            0|            0|  0.00%|    ```
   852|         0|            0|            0|  0.00%|
   853|         0|            0|            0|  0.00%|    Args:
   854|         0|            0|            0|  0.00%|        max_length: The value must be at most this length
   855|         0|            0|            0|  0.00%|        min_length: The value must be at least this length
   856|         0|            0|            0|  0.00%|        strict: Whether the value should be a bytes or a value that can be converted to a bytes
   857|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
   858|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
   859|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
   860|         0|            0|            0|  0.00%|    """
   861|         0|            0|            0|  0.00%|    return _dict_not_none(
   862|         0|            0|            0|  0.00%|        type='bytes',
   863|         0|            0|            0|  0.00%|        max_length=max_length,
   864|         0|            0|            0|  0.00%|        min_length=min_length,
   865|         0|            0|            0|  0.00%|        strict=strict,
   866|         0|            0|            0|  0.00%|        ref=ref,
   867|         0|            0|            0|  0.00%|        metadata=metadata,
   868|         0|            0|            0|  0.00%|        serialization=serialization,
   869|         0|            0|            0|  0.00%|    )
   870|         0|            0|            0|  0.00%|
   871|         0|            0|            0|  0.00%|
   872|         0|            0|            0|  0.00%|class DateSchema(TypedDict, total=False):
   873|         0|            0|            0|  0.00%|    type: Required[Literal['date']]
   874|         0|            0|            0|  0.00%|    strict: bool
   875|         0|            0|            0|  0.00%|    le: date
   876|         0|            0|            0|  0.00%|    ge: date
   877|         0|            0|            0|  0.00%|    lt: date
   878|         0|            0|            0|  0.00%|    gt: date
   879|         0|            0|            0|  0.00%|    now_op: Literal['past', 'future']
   880|         0|            0|            0|  0.00%|    # defaults to current local utc offset from `time.localtime().tm_gmtoff`
   881|         0|            0|            0|  0.00%|    # value is restricted to -86_400 < offset < 86_400 by bounds in generate_self_schema.py
   882|         0|            0|            0|  0.00%|    now_utc_offset: int
   883|         0|            0|            0|  0.00%|    ref: str
   884|         0|            0|            0|  0.00%|    metadata: Any
   885|         0|            0|            0|  0.00%|    serialization: SerSchema
   886|         0|            0|            0|  0.00%|
   887|         0|            0|            0|  0.00%|
   888|         0|            0|            0|  0.00%|def date_schema(
   889|         0|            0|            0|  0.00%|    *,
   890|         0|            0|            0|  0.00%|    strict: bool | None = None,
   891|         0|            0|            0|  0.00%|    le: date | None = None,
   892|         0|            0|            0|  0.00%|    ge: date | None = None,
   893|         0|            0|            0|  0.00%|    lt: date | None = None,
   894|         0|            0|            0|  0.00%|    gt: date | None = None,
   895|         0|            0|            0|  0.00%|    now_op: Literal['past', 'future'] | None = None,
   896|         0|            0|            0|  0.00%|    now_utc_offset: int | None = None,
   897|         0|            0|            0|  0.00%|    ref: str | None = None,
   898|         0|            0|            0|  0.00%|    metadata: Any = None,
   899|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
   900|         0|            0|            0|  0.00%|) -> DateSchema:
   901|         0|            0|            0|  0.00%|    """
   902|         0|            0|            0|  0.00%|    Returns a schema that matches a date value, e.g.:
   903|         0|            0|            0|  0.00%|
   904|         0|            0|            0|  0.00%|    ```py
   905|         0|            0|            0|  0.00%|    from datetime import date
   906|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
   907|         0|            0|            0|  0.00%|
   908|         0|            0|            0|  0.00%|    schema = core_schema.date_schema(le=date(2020, 1, 1), ge=date(2019, 1, 1))
   909|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
   910|         0|            0|            0|  0.00%|    assert v.validate_python(date(2019, 6, 1)) == date(2019, 6, 1)
   911|         0|            0|            0|  0.00%|    ```
   912|         0|            0|            0|  0.00%|
   913|         0|            0|            0|  0.00%|    Args:
   914|         0|            0|            0|  0.00%|        strict: Whether the value should be a date or a value that can be converted to a date
   915|         0|            0|            0|  0.00%|        le: The value must be less than or equal to this date
   916|         0|            0|            0|  0.00%|        ge: The value must be greater than or equal to this date
   917|         0|            0|            0|  0.00%|        lt: The value must be strictly less than this date
   918|         0|            0|            0|  0.00%|        gt: The value must be strictly greater than this date
   919|         0|            0|            0|  0.00%|        now_op: The value must be in the past or future relative to the current date
   920|         0|            0|            0|  0.00%|        now_utc_offset: The value must be in the past or future relative to the current date with this utc offset
   921|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
   922|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
   923|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
   924|         0|            0|            0|  0.00%|    """
   925|         0|            0|            0|  0.00%|    return _dict_not_none(
   926|         0|            0|            0|  0.00%|        type='date',
   927|         0|            0|            0|  0.00%|        strict=strict,
   928|         0|            0|            0|  0.00%|        le=le,
   929|         0|            0|            0|  0.00%|        ge=ge,
   930|         0|            0|            0|  0.00%|        lt=lt,
   931|         0|            0|            0|  0.00%|        gt=gt,
   932|         0|            0|            0|  0.00%|        now_op=now_op,
   933|         0|            0|            0|  0.00%|        now_utc_offset=now_utc_offset,
   934|         0|            0|            0|  0.00%|        ref=ref,
   935|         0|            0|            0|  0.00%|        metadata=metadata,
   936|         0|            0|            0|  0.00%|        serialization=serialization,
   937|         0|            0|            0|  0.00%|    )
   938|         0|            0|            0|  0.00%|
   939|         0|            0|            0|  0.00%|
   940|         0|            0|            0|  0.00%|class TimeSchema(TypedDict, total=False):
   941|         0|            0|            0|  0.00%|    type: Required[Literal['time']]
   942|         0|            0|            0|  0.00%|    strict: bool
   943|         0|            0|            0|  0.00%|    le: time
   944|         0|            0|            0|  0.00%|    ge: time
   945|         0|            0|            0|  0.00%|    lt: time
   946|         0|            0|            0|  0.00%|    gt: time
   947|         0|            0|            0|  0.00%|    tz_constraint: Union[Literal['aware', 'naive'], int]
   948|         0|            0|            0|  0.00%|    microseconds_precision: Literal['truncate', 'error']
   949|         0|            0|            0|  0.00%|    ref: str
   950|         0|            0|            0|  0.00%|    metadata: Any
   951|         0|            0|            0|  0.00%|    serialization: SerSchema
   952|         0|            0|            0|  0.00%|
   953|         0|            0|            0|  0.00%|
   954|         0|            0|            0|  0.00%|def time_schema(
   955|         0|            0|            0|  0.00%|    *,
   956|         0|            0|            0|  0.00%|    strict: bool | None = None,
   957|         0|            0|            0|  0.00%|    le: time | None = None,
   958|         0|            0|            0|  0.00%|    ge: time | None = None,
   959|         0|            0|            0|  0.00%|    lt: time | None = None,
   960|         0|            0|            0|  0.00%|    gt: time | None = None,
   961|         0|            0|            0|  0.00%|    tz_constraint: Literal['aware', 'naive'] | int | None = None,
   962|         0|            0|            0|  0.00%|    microseconds_precision: Literal['truncate', 'error'] = 'truncate',
   963|         0|            0|            0|  0.00%|    ref: str | None = None,
   964|         0|            0|            0|  0.00%|    metadata: Any = None,
   965|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
   966|         0|            0|            0|  0.00%|) -> TimeSchema:
   967|         0|            0|            0|  0.00%|    """
   968|         0|            0|            0|  0.00%|    Returns a schema that matches a time value, e.g.:
   969|         0|            0|            0|  0.00%|
   970|         0|            0|            0|  0.00%|    ```py
   971|         0|            0|            0|  0.00%|    from datetime import time
   972|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
   973|         0|            0|            0|  0.00%|
   974|         0|            0|            0|  0.00%|    schema = core_schema.time_schema(le=time(12, 0, 0), ge=time(6, 0, 0))
   975|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
   976|         0|            0|            0|  0.00%|    assert v.validate_python(time(9, 0, 0)) == time(9, 0, 0)
   977|         0|            0|            0|  0.00%|    ```
   978|         0|            0|            0|  0.00%|
   979|         0|            0|            0|  0.00%|    Args:
   980|         0|            0|            0|  0.00%|        strict: Whether the value should be a time or a value that can be converted to a time
   981|         0|            0|            0|  0.00%|        le: The value must be less than or equal to this time
   982|         0|            0|            0|  0.00%|        ge: The value must be greater than or equal to this time
   983|         0|            0|            0|  0.00%|        lt: The value must be strictly less than this time
   984|         0|            0|            0|  0.00%|        gt: The value must be strictly greater than this time
   985|         0|            0|            0|  0.00%|        tz_constraint: The value must be timezone aware or naive, or an int to indicate required tz offset
   986|         0|            0|            0|  0.00%|        microseconds_precision: The behavior when seconds have more than 6 digits or microseconds is too large
   987|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
   988|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
   989|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
   990|         0|            0|            0|  0.00%|    """
   991|         0|            0|            0|  0.00%|    return _dict_not_none(
   992|         0|            0|            0|  0.00%|        type='time',
   993|         0|            0|            0|  0.00%|        strict=strict,
   994|         0|            0|            0|  0.00%|        le=le,
   995|         0|            0|            0|  0.00%|        ge=ge,
   996|         0|            0|            0|  0.00%|        lt=lt,
   997|         0|            0|            0|  0.00%|        gt=gt,
   998|         0|            0|            0|  0.00%|        tz_constraint=tz_constraint,
   999|         0|            0|            0|  0.00%|        microseconds_precision=microseconds_precision,
  1000|         0|            0|            0|  0.00%|        ref=ref,
  1001|         0|            0|            0|  0.00%|        metadata=metadata,
  1002|         0|            0|            0|  0.00%|        serialization=serialization,
  1003|         0|            0|            0|  0.00%|    )
  1004|         0|            0|            0|  0.00%|
  1005|         0|            0|            0|  0.00%|
  1006|         0|            0|            0|  0.00%|class DatetimeSchema(TypedDict, total=False):
  1007|         0|            0|            0|  0.00%|    type: Required[Literal['datetime']]
  1008|         0|            0|            0|  0.00%|    strict: bool
  1009|         0|            0|            0|  0.00%|    le: datetime
  1010|         0|            0|            0|  0.00%|    ge: datetime
  1011|         0|            0|            0|  0.00%|    lt: datetime
  1012|         0|            0|            0|  0.00%|    gt: datetime
  1013|         0|            0|            0|  0.00%|    now_op: Literal['past', 'future']
  1014|         0|            0|            0|  0.00%|    tz_constraint: Union[Literal['aware', 'naive'], int]
  1015|         0|            0|            0|  0.00%|    # defaults to current local utc offset from `time.localtime().tm_gmtoff`
  1016|         0|            0|            0|  0.00%|    # value is restricted to -86_400 < offset < 86_400 by bounds in generate_self_schema.py
  1017|         0|            0|            0|  0.00%|    now_utc_offset: int
  1018|         0|            0|            0|  0.00%|    microseconds_precision: Literal['truncate', 'error']  # default: 'truncate'
  1019|         0|            0|            0|  0.00%|    ref: str
  1020|         0|            0|            0|  0.00%|    metadata: Any
  1021|         0|            0|            0|  0.00%|    serialization: SerSchema
  1022|         0|            0|            0|  0.00%|
  1023|         0|            0|            0|  0.00%|
  1024|         0|            0|            0|  0.00%|def datetime_schema(
  1025|         0|            0|            0|  0.00%|    *,
  1026|         0|            0|            0|  0.00%|    strict: bool | None = None,
  1027|         0|            0|            0|  0.00%|    le: datetime | None = None,
  1028|         0|            0|            0|  0.00%|    ge: datetime | None = None,
  1029|         0|            0|            0|  0.00%|    lt: datetime | None = None,
  1030|         0|            0|            0|  0.00%|    gt: datetime | None = None,
  1031|         0|            0|            0|  0.00%|    now_op: Literal['past', 'future'] | None = None,
  1032|         0|            0|            0|  0.00%|    tz_constraint: Literal['aware', 'naive'] | int | None = None,
  1033|         0|            0|            0|  0.00%|    now_utc_offset: int | None = None,
  1034|         0|            0|            0|  0.00%|    microseconds_precision: Literal['truncate', 'error'] = 'truncate',
  1035|         0|            0|            0|  0.00%|    ref: str | None = None,
  1036|         0|            0|            0|  0.00%|    metadata: Any = None,
  1037|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  1038|         0|            0|            0|  0.00%|) -> DatetimeSchema:
  1039|         0|            0|            0|  0.00%|    """
  1040|         0|            0|            0|  0.00%|    Returns a schema that matches a datetime value, e.g.:
  1041|         0|            0|            0|  0.00%|
  1042|         0|            0|            0|  0.00%|    ```py
  1043|         0|            0|            0|  0.00%|    from datetime import datetime
  1044|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  1045|         0|            0|            0|  0.00%|
  1046|         0|            0|            0|  0.00%|    schema = core_schema.datetime_schema()
  1047|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  1048|         0|            0|            0|  0.00%|    now = datetime.now()
  1049|         0|            0|            0|  0.00%|    assert v.validate_python(str(now)) == now
  1050|         0|            0|            0|  0.00%|    ```
  1051|         0|            0|            0|  0.00%|
  1052|         0|            0|            0|  0.00%|    Args:
  1053|         0|            0|            0|  0.00%|        strict: Whether the value should be a datetime or a value that can be converted to a datetime
  1054|         0|            0|            0|  0.00%|        le: The value must be less than or equal to this datetime
  1055|         0|            0|            0|  0.00%|        ge: The value must be greater than or equal to this datetime
  1056|         0|            0|            0|  0.00%|        lt: The value must be strictly less than this datetime
  1057|         0|            0|            0|  0.00%|        gt: The value must be strictly greater than this datetime
  1058|         0|            0|            0|  0.00%|        now_op: The value must be in the past or future relative to the current datetime
  1059|         0|            0|            0|  0.00%|        tz_constraint: The value must be timezone aware or naive, or an int to indicate required tz offset
  1060|         0|            0|            0|  0.00%|            TODO: use of a tzinfo where offset changes based on the datetime is not yet supported
  1061|         0|            0|            0|  0.00%|        now_utc_offset: The value must be in the past or future relative to the current datetime with this utc offset
  1062|         0|            0|            0|  0.00%|        microseconds_precision: The behavior when seconds have more than 6 digits or microseconds is too large
  1063|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  1064|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  1065|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  1066|         0|            0|            0|  0.00%|    """
  1067|         0|            0|            0|  0.00%|    return _dict_not_none(
  1068|         0|            0|            0|  0.00%|        type='datetime',
  1069|         0|            0|            0|  0.00%|        strict=strict,
  1070|         0|            0|            0|  0.00%|        le=le,
  1071|         0|            0|            0|  0.00%|        ge=ge,
  1072|         0|            0|            0|  0.00%|        lt=lt,
  1073|         0|            0|            0|  0.00%|        gt=gt,
  1074|         0|            0|            0|  0.00%|        now_op=now_op,
  1075|         0|            0|            0|  0.00%|        tz_constraint=tz_constraint,
  1076|         0|            0|            0|  0.00%|        now_utc_offset=now_utc_offset,
  1077|         0|            0|            0|  0.00%|        microseconds_precision=microseconds_precision,
  1078|         0|            0|            0|  0.00%|        ref=ref,
  1079|         0|            0|            0|  0.00%|        metadata=metadata,
  1080|         0|            0|            0|  0.00%|        serialization=serialization,
  1081|         0|            0|            0|  0.00%|    )
  1082|         0|            0|            0|  0.00%|
  1083|         0|            0|            0|  0.00%|
  1084|         0|            0|            0|  0.00%|class TimedeltaSchema(TypedDict, total=False):
  1085|         0|            0|            0|  0.00%|    type: Required[Literal['timedelta']]
  1086|         0|            0|            0|  0.00%|    strict: bool
  1087|         0|            0|            0|  0.00%|    le: timedelta
  1088|         0|            0|            0|  0.00%|    ge: timedelta
  1089|         0|            0|            0|  0.00%|    lt: timedelta
  1090|         0|            0|            0|  0.00%|    gt: timedelta
  1091|         0|            0|            0|  0.00%|    microseconds_precision: Literal['truncate', 'error']
  1092|         0|            0|            0|  0.00%|    ref: str
  1093|         0|            0|            0|  0.00%|    metadata: Any
  1094|         0|            0|            0|  0.00%|    serialization: SerSchema
  1095|         0|            0|            0|  0.00%|
  1096|         0|            0|            0|  0.00%|
  1097|         0|            0|            0|  0.00%|def timedelta_schema(
  1098|         0|            0|            0|  0.00%|    *,
  1099|         0|            0|            0|  0.00%|    strict: bool | None = None,
  1100|         0|            0|            0|  0.00%|    le: timedelta | None = None,
  1101|         0|            0|            0|  0.00%|    ge: timedelta | None = None,
  1102|         0|            0|            0|  0.00%|    lt: timedelta | None = None,
  1103|         0|            0|            0|  0.00%|    gt: timedelta | None = None,
  1104|         0|            0|            0|  0.00%|    microseconds_precision: Literal['truncate', 'error'] = 'truncate',
  1105|         0|            0|            0|  0.00%|    ref: str | None = None,
  1106|         0|            0|            0|  0.00%|    metadata: Any = None,
  1107|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  1108|         0|            0|            0|  0.00%|) -> TimedeltaSchema:
  1109|         0|            0|            0|  0.00%|    """
  1110|         0|            0|            0|  0.00%|    Returns a schema that matches a timedelta value, e.g.:
  1111|         0|            0|            0|  0.00%|
  1112|         0|            0|            0|  0.00%|    ```py
  1113|         0|            0|            0|  0.00%|    from datetime import timedelta
  1114|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  1115|         0|            0|            0|  0.00%|
  1116|         0|            0|            0|  0.00%|    schema = core_schema.timedelta_schema(le=timedelta(days=1), ge=timedelta(days=0))
  1117|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  1118|         0|            0|            0|  0.00%|    assert v.validate_python(timedelta(hours=12)) == timedelta(hours=12)
  1119|         0|            0|            0|  0.00%|    ```
  1120|         0|            0|            0|  0.00%|
  1121|         0|            0|            0|  0.00%|    Args:
  1122|         0|            0|            0|  0.00%|        strict: Whether the value should be a timedelta or a value that can be converted to a timedelta
  1123|         0|            0|            0|  0.00%|        le: The value must be less than or equal to this timedelta
  1124|         0|            0|            0|  0.00%|        ge: The value must be greater than or equal to this timedelta
  1125|         0|            0|            0|  0.00%|        lt: The value must be strictly less than this timedelta
  1126|         0|            0|            0|  0.00%|        gt: The value must be strictly greater than this timedelta
  1127|         0|            0|            0|  0.00%|        microseconds_precision: The behavior when seconds have more than 6 digits or microseconds is too large
  1128|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  1129|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  1130|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  1131|         0|            0|            0|  0.00%|    """
  1132|         0|            0|            0|  0.00%|    return _dict_not_none(
  1133|         0|            0|            0|  0.00%|        type='timedelta',
  1134|         0|            0|            0|  0.00%|        strict=strict,
  1135|         0|            0|            0|  0.00%|        le=le,
  1136|         0|            0|            0|  0.00%|        ge=ge,
  1137|         0|            0|            0|  0.00%|        lt=lt,
  1138|         0|            0|            0|  0.00%|        gt=gt,
  1139|         0|            0|            0|  0.00%|        microseconds_precision=microseconds_precision,
  1140|         0|            0|            0|  0.00%|        ref=ref,
  1141|         0|            0|            0|  0.00%|        metadata=metadata,
  1142|         0|            0|            0|  0.00%|        serialization=serialization,
  1143|         0|            0|            0|  0.00%|    )
  1144|         0|            0|            0|  0.00%|
  1145|         0|            0|            0|  0.00%|
  1146|         0|            0|            0|  0.00%|class LiteralSchema(TypedDict, total=False):
  1147|         0|            0|            0|  0.00%|    type: Required[Literal['literal']]
  1148|         0|            0|            0|  0.00%|    expected: Required[List[Any]]
  1149|         0|            0|            0|  0.00%|    ref: str
  1150|         0|            0|            0|  0.00%|    metadata: Any
  1151|         0|            0|            0|  0.00%|    serialization: SerSchema
  1152|         0|            0|            0|  0.00%|
  1153|         0|            0|            0|  0.00%|
  1154|         0|            0|            0|  0.00%|def literal_schema(
  1155|         0|            0|            0|  0.00%|    expected: list[Any], *, ref: str | None = None, metadata: Any = None, serialization: SerSchema | None = None
  1156|         0|            0|            0|  0.00%|) -> LiteralSchema:
  1157|         0|            0|            0|  0.00%|    """
  1158|         0|            0|            0|  0.00%|    Returns a schema that matches a literal value, e.g.:
  1159|         0|            0|            0|  0.00%|
  1160|         0|            0|            0|  0.00%|    ```py
  1161|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  1162|         0|            0|            0|  0.00%|
  1163|         0|            0|            0|  0.00%|    schema = core_schema.literal_schema(['hello', 'world'])
  1164|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  1165|         0|            0|            0|  0.00%|    assert v.validate_python('hello') == 'hello'
  1166|         0|            0|            0|  0.00%|    ```
  1167|         0|            0|            0|  0.00%|
  1168|         0|            0|            0|  0.00%|    Args:
  1169|         0|            0|            0|  0.00%|        expected: The value must be one of these values
  1170|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  1171|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  1172|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  1173|         0|            0|            0|  0.00%|    """
  1174|         0|            0|            0|  0.00%|    return _dict_not_none(type='literal', expected=expected, ref=ref, metadata=metadata, serialization=serialization)
  1175|         0|            0|            0|  0.00%|
  1176|         0|            0|            0|  0.00%|
  1177|         0|            0|            0|  0.00%|class EnumSchema(TypedDict, total=False):
  1178|         0|            0|            0|  0.00%|    type: Required[Literal['enum']]
  1179|         0|            0|            0|  0.00%|    cls: Required[Any]
  1180|         0|            0|            0|  0.00%|    members: Required[List[Any]]
  1181|         0|            0|            0|  0.00%|    sub_type: Literal['str', 'int', 'float']
  1182|         0|            0|            0|  0.00%|    missing: Callable[[Any], Any]
  1183|         0|            0|            0|  0.00%|    strict: bool
  1184|         0|            0|            0|  0.00%|    ref: str
  1185|         0|            0|            0|  0.00%|    metadata: Any
  1186|         0|            0|            0|  0.00%|    serialization: SerSchema
  1187|         0|            0|            0|  0.00%|
  1188|         0|            0|            0|  0.00%|
  1189|         0|            0|            0|  0.00%|def enum_schema(
  1190|         0|            0|            0|  0.00%|    cls: Any,
  1191|         0|            0|            0|  0.00%|    members: list[Any],
  1192|         0|            0|            0|  0.00%|    *,
  1193|         0|            0|            0|  0.00%|    sub_type: Literal['str', 'int', 'float'] | None = None,
  1194|         0|            0|            0|  0.00%|    missing: Callable[[Any], Any] | None = None,
  1195|         0|            0|            0|  0.00%|    strict: bool | None = None,
  1196|         0|            0|            0|  0.00%|    ref: str | None = None,
  1197|         0|            0|            0|  0.00%|    metadata: Any = None,
  1198|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  1199|         0|            0|            0|  0.00%|) -> EnumSchema:
  1200|         0|            0|            0|  0.00%|    """
  1201|         0|            0|            0|  0.00%|    Returns a schema that matches an enum value, e.g.:
  1202|         0|            0|            0|  0.00%|
  1203|         0|            0|            0|  0.00%|    ```py
  1204|         0|            0|            0|  0.00%|    from enum import Enum
  1205|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  1206|         0|            0|            0|  0.00%|
  1207|         0|            0|            0|  0.00%|    class Color(Enum):
  1208|         0|            0|            0|  0.00%|        RED = 1
  1209|         0|            0|            0|  0.00%|        GREEN = 2
  1210|         0|            0|            0|  0.00%|        BLUE = 3
  1211|         0|            0|            0|  0.00%|
  1212|         0|            0|            0|  0.00%|    schema = core_schema.enum_schema(Color, list(Color.__members__.values()))
  1213|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  1214|         0|            0|            0|  0.00%|    assert v.validate_python(2) is Color.GREEN
  1215|         0|            0|            0|  0.00%|    ```
  1216|         0|            0|            0|  0.00%|
  1217|         0|            0|            0|  0.00%|    Args:
  1218|         0|            0|            0|  0.00%|        cls: The enum class
  1219|         0|            0|            0|  0.00%|        members: The members of the enum, generally `list(MyEnum.__members__.values())`
  1220|         0|            0|            0|  0.00%|        sub_type: The type of the enum, either 'str' or 'int' or None for plain enums
  1221|         0|            0|            0|  0.00%|        missing: A function to use when the value is not found in the enum, from `_missing_`
  1222|         0|            0|            0|  0.00%|        strict: Whether to use strict mode, defaults to False
  1223|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  1224|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  1225|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  1226|         0|            0|            0|  0.00%|    """
  1227|         0|            0|            0|  0.00%|    return _dict_not_none(
  1228|         0|            0|            0|  0.00%|        type='enum',
  1229|         0|            0|            0|  0.00%|        cls=cls,
  1230|         0|            0|            0|  0.00%|        members=members,
  1231|         0|            0|            0|  0.00%|        sub_type=sub_type,
  1232|         0|            0|            0|  0.00%|        missing=missing,
  1233|         0|            0|            0|  0.00%|        strict=strict,
  1234|         0|            0|            0|  0.00%|        ref=ref,
  1235|         0|            0|            0|  0.00%|        metadata=metadata,
  1236|         0|            0|            0|  0.00%|        serialization=serialization,
  1237|         0|            0|            0|  0.00%|    )
  1238|         0|            0|            0|  0.00%|
  1239|         0|            0|            0|  0.00%|
  1240|         0|            0|            0|  0.00%|# must match input/parse_json.rs::JsonType::try_from
  1241|         0|            0|            0|  0.00%|JsonType = Literal['null', 'bool', 'int', 'float', 'str', 'list', 'dict']
  1242|         0|            0|            0|  0.00%|
  1243|         0|            0|            0|  0.00%|
  1244|         0|            0|            0|  0.00%|class IsInstanceSchema(TypedDict, total=False):
  1245|         0|            0|            0|  0.00%|    type: Required[Literal['is-instance']]
  1246|         0|            0|            0|  0.00%|    cls: Required[Any]
  1247|         0|            0|            0|  0.00%|    cls_repr: str
  1248|         0|            0|            0|  0.00%|    ref: str
  1249|         0|            0|            0|  0.00%|    metadata: Any
  1250|         0|            0|            0|  0.00%|    serialization: SerSchema
  1251|         0|            0|            0|  0.00%|
  1252|         0|            0|            0|  0.00%|
  1253|         0|            0|            0|  0.00%|def is_instance_schema(
  1254|         0|            0|            0|  0.00%|    cls: Any,
  1255|         0|            0|            0|  0.00%|    *,
  1256|         0|            0|            0|  0.00%|    cls_repr: str | None = None,
  1257|         0|            0|            0|  0.00%|    ref: str | None = None,
  1258|         0|            0|            0|  0.00%|    metadata: Any = None,
  1259|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  1260|         0|            0|            0|  0.00%|) -> IsInstanceSchema:
  1261|         0|            0|            0|  0.00%|    """
  1262|         0|            0|            0|  0.00%|    Returns a schema that checks if a value is an instance of a class, equivalent to python's `isinstance` method, e.g.:
  1263|         0|            0|            0|  0.00%|
  1264|         0|            0|            0|  0.00%|    ```py
  1265|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  1266|         0|            0|            0|  0.00%|
  1267|         0|            0|            0|  0.00%|    class A:
  1268|         0|            0|            0|  0.00%|        pass
  1269|         0|            0|            0|  0.00%|
  1270|         0|            0|            0|  0.00%|    schema = core_schema.is_instance_schema(cls=A)
  1271|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  1272|         0|            0|            0|  0.00%|    v.validate_python(A())
  1273|         0|            0|            0|  0.00%|    ```
  1274|         0|            0|            0|  0.00%|
  1275|         0|            0|            0|  0.00%|    Args:
  1276|         0|            0|            0|  0.00%|        cls: The value must be an instance of this class
  1277|         0|            0|            0|  0.00%|        cls_repr: If provided this string is used in the validator name instead of `repr(cls)`
  1278|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  1279|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  1280|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  1281|         0|            0|            0|  0.00%|    """
  1282|         0|            0|            0|  0.00%|    return _dict_not_none(
  1283|         0|            0|            0|  0.00%|        type='is-instance', cls=cls, cls_repr=cls_repr, ref=ref, metadata=metadata, serialization=serialization
  1284|         0|            0|            0|  0.00%|    )
  1285|         0|            0|            0|  0.00%|
  1286|         0|            0|            0|  0.00%|
  1287|         0|            0|            0|  0.00%|class IsSubclassSchema(TypedDict, total=False):
  1288|         0|            0|            0|  0.00%|    type: Required[Literal['is-subclass']]
  1289|         0|            0|            0|  0.00%|    cls: Required[Type[Any]]
  1290|         0|            0|            0|  0.00%|    cls_repr: str
  1291|         0|            0|            0|  0.00%|    ref: str
  1292|         0|            0|            0|  0.00%|    metadata: Any
  1293|         0|            0|            0|  0.00%|    serialization: SerSchema
  1294|         0|            0|            0|  0.00%|
  1295|         0|            0|            0|  0.00%|
  1296|         0|            0|            0|  0.00%|def is_subclass_schema(
  1297|         0|            0|            0|  0.00%|    cls: Type[Any],
  1298|         0|            0|            0|  0.00%|    *,
  1299|         0|            0|            0|  0.00%|    cls_repr: str | None = None,
  1300|         0|            0|            0|  0.00%|    ref: str | None = None,
  1301|         0|            0|            0|  0.00%|    metadata: Any = None,
  1302|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  1303|         0|            0|            0|  0.00%|) -> IsInstanceSchema:
  1304|         0|            0|            0|  0.00%|    """
  1305|         0|            0|            0|  0.00%|    Returns a schema that checks if a value is a subtype of a class, equivalent to python's `issubclass` method, e.g.:
  1306|         0|            0|            0|  0.00%|
  1307|         0|            0|            0|  0.00%|    ```py
  1308|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  1309|         0|            0|            0|  0.00%|
  1310|         0|            0|            0|  0.00%|    class A:
  1311|         0|            0|            0|  0.00%|        pass
  1312|         0|            0|            0|  0.00%|
  1313|         0|            0|            0|  0.00%|    class B(A):
  1314|         0|            0|            0|  0.00%|        pass
  1315|         0|            0|            0|  0.00%|
  1316|         0|            0|            0|  0.00%|    schema = core_schema.is_subclass_schema(cls=A)
  1317|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  1318|         0|            0|            0|  0.00%|    v.validate_python(B)
  1319|         0|            0|            0|  0.00%|    ```
  1320|         0|            0|            0|  0.00%|
  1321|         0|            0|            0|  0.00%|    Args:
  1322|         0|            0|            0|  0.00%|        cls: The value must be a subclass of this class
  1323|         0|            0|            0|  0.00%|        cls_repr: If provided this string is used in the validator name instead of `repr(cls)`
  1324|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  1325|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  1326|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  1327|         0|            0|            0|  0.00%|    """
  1328|         0|            0|            0|  0.00%|    return _dict_not_none(
  1329|         0|            0|            0|  0.00%|        type='is-subclass', cls=cls, cls_repr=cls_repr, ref=ref, metadata=metadata, serialization=serialization
  1330|         0|            0|            0|  0.00%|    )
  1331|         0|            0|            0|  0.00%|
  1332|         0|            0|            0|  0.00%|
  1333|         0|            0|            0|  0.00%|class CallableSchema(TypedDict, total=False):
  1334|         0|            0|            0|  0.00%|    type: Required[Literal['callable']]
  1335|         0|            0|            0|  0.00%|    ref: str
  1336|         0|            0|            0|  0.00%|    metadata: Any
  1337|         0|            0|            0|  0.00%|    serialization: SerSchema
  1338|         0|            0|            0|  0.00%|
  1339|         0|            0|            0|  0.00%|
  1340|         0|            0|            0|  0.00%|def callable_schema(
  1341|         0|            0|            0|  0.00%|    *, ref: str | None = None, metadata: Any = None, serialization: SerSchema | None = None
  1342|         0|            0|            0|  0.00%|) -> CallableSchema:
  1343|         0|            0|            0|  0.00%|    """
  1344|         0|            0|            0|  0.00%|    Returns a schema that checks if a value is callable, equivalent to python's `callable` method, e.g.:
  1345|         0|            0|            0|  0.00%|
  1346|         0|            0|            0|  0.00%|    ```py
  1347|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  1348|         0|            0|            0|  0.00%|
  1349|         0|            0|            0|  0.00%|    schema = core_schema.callable_schema()
  1350|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  1351|         0|            0|            0|  0.00%|    v.validate_python(min)
  1352|         0|            0|            0|  0.00%|    ```
  1353|         0|            0|            0|  0.00%|
  1354|         0|            0|            0|  0.00%|    Args:
  1355|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  1356|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  1357|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  1358|         0|            0|            0|  0.00%|    """
  1359|         0|            0|            0|  0.00%|    return _dict_not_none(type='callable', ref=ref, metadata=metadata, serialization=serialization)
  1360|         0|            0|            0|  0.00%|
  1361|         0|            0|            0|  0.00%|
  1362|         0|            0|            0|  0.00%|class UuidSchema(TypedDict, total=False):
  1363|         0|            0|            0|  0.00%|    type: Required[Literal['uuid']]
  1364|         0|            0|            0|  0.00%|    version: Literal[1, 3, 4, 5]
  1365|         0|            0|            0|  0.00%|    strict: bool
  1366|         0|            0|            0|  0.00%|    ref: str
  1367|         0|            0|            0|  0.00%|    metadata: Any
  1368|         0|            0|            0|  0.00%|    serialization: SerSchema
  1369|         0|            0|            0|  0.00%|
  1370|         0|            0|            0|  0.00%|
  1371|         0|            0|            0|  0.00%|def uuid_schema(
  1372|         0|            0|            0|  0.00%|    *,
  1373|         0|            0|            0|  0.00%|    version: Literal[1, 3, 4, 5] | None = None,
  1374|         0|            0|            0|  0.00%|    strict: bool | None = None,
  1375|         0|            0|            0|  0.00%|    ref: str | None = None,
  1376|         0|            0|            0|  0.00%|    metadata: Any = None,
  1377|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  1378|         0|            0|            0|  0.00%|) -> UuidSchema:
  1379|         0|            0|            0|  0.00%|    return _dict_not_none(
  1380|         0|            0|            0|  0.00%|        type='uuid', version=version, strict=strict, ref=ref, metadata=metadata, serialization=serialization
  1381|         0|            0|            0|  0.00%|    )
  1382|         0|            0|            0|  0.00%|
  1383|         0|            0|            0|  0.00%|
  1384|         0|            0|            0|  0.00%|class IncExSeqSerSchema(TypedDict, total=False):
  1385|         0|            0|            0|  0.00%|    type: Required[Literal['include-exclude-sequence']]
  1386|         0|            0|            0|  0.00%|    include: Set[int]
  1387|         0|            0|            0|  0.00%|    exclude: Set[int]
  1388|         0|            0|            0|  0.00%|
  1389|         0|            0|            0|  0.00%|
  1390|         0|            0|            0|  0.00%|def filter_seq_schema(*, include: Set[int] | None = None, exclude: Set[int] | None = None) -> IncExSeqSerSchema:
  1391|         0|            0|            0|  0.00%|    return _dict_not_none(type='include-exclude-sequence', include=include, exclude=exclude)
  1392|         0|            0|            0|  0.00%|
  1393|         0|            0|            0|  0.00%|
  1394|         0|            0|            0|  0.00%|IncExSeqOrElseSerSchema = Union[IncExSeqSerSchema, SerSchema]
  1395|         0|            0|            0|  0.00%|
  1396|         0|            0|            0|  0.00%|
  1397|         0|            0|            0|  0.00%|class ListSchema(TypedDict, total=False):
  1398|         0|            0|            0|  0.00%|    type: Required[Literal['list']]
  1399|         0|            0|            0|  0.00%|    items_schema: CoreSchema
  1400|         0|            0|            0|  0.00%|    min_length: int
  1401|         0|            0|            0|  0.00%|    max_length: int
  1402|         0|            0|            0|  0.00%|    fail_fast: bool
  1403|         0|            0|            0|  0.00%|    strict: bool
  1404|         0|            0|            0|  0.00%|    ref: str
  1405|         0|            0|            0|  0.00%|    metadata: Any
  1406|         0|            0|            0|  0.00%|    serialization: IncExSeqOrElseSerSchema
  1407|         0|            0|            0|  0.00%|
  1408|         0|            0|            0|  0.00%|
  1409|         0|            0|            0|  0.00%|def list_schema(
  1410|         0|            0|            0|  0.00%|    items_schema: CoreSchema | None = None,
  1411|         0|            0|            0|  0.00%|    *,
  1412|         0|            0|            0|  0.00%|    min_length: int | None = None,
  1413|         0|            0|            0|  0.00%|    max_length: int | None = None,
  1414|         0|            0|            0|  0.00%|    fail_fast: bool | None = None,
  1415|         0|            0|            0|  0.00%|    strict: bool | None = None,
  1416|         0|            0|            0|  0.00%|    ref: str | None = None,
  1417|         0|            0|            0|  0.00%|    metadata: Any = None,
  1418|         0|            0|            0|  0.00%|    serialization: IncExSeqOrElseSerSchema | None = None,
  1419|         0|            0|            0|  0.00%|) -> ListSchema:
  1420|         0|            0|            0|  0.00%|    """
  1421|         0|            0|            0|  0.00%|    Returns a schema that matches a list value, e.g.:
  1422|         0|            0|            0|  0.00%|
  1423|         0|            0|            0|  0.00%|    ```py
  1424|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  1425|         0|            0|            0|  0.00%|
  1426|         0|            0|            0|  0.00%|    schema = core_schema.list_schema(core_schema.int_schema(), min_length=0, max_length=10)
  1427|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  1428|         0|            0|            0|  0.00%|    assert v.validate_python(['4']) == [4]
  1429|         0|            0|            0|  0.00%|    ```
  1430|         0|            0|            0|  0.00%|
  1431|         0|            0|            0|  0.00%|    Args:
  1432|         0|            0|            0|  0.00%|        items_schema: The value must be a list of items that match this schema
  1433|         0|            0|            0|  0.00%|        min_length: The value must be a list with at least this many items
  1434|         0|            0|            0|  0.00%|        max_length: The value must be a list with at most this many items
  1435|         0|            0|            0|  0.00%|        fail_fast: Stop validation on the first error
  1436|         0|            0|            0|  0.00%|        strict: The value must be a list with exactly this many items
  1437|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  1438|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  1439|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  1440|         0|            0|            0|  0.00%|    """
  1441|         0|            0|            0|  0.00%|    return _dict_not_none(
  1442|         0|            0|            0|  0.00%|        type='list',
  1443|         0|            0|            0|  0.00%|        items_schema=items_schema,
  1444|         0|            0|            0|  0.00%|        min_length=min_length,
  1445|         0|            0|            0|  0.00%|        max_length=max_length,
  1446|         0|            0|            0|  0.00%|        fail_fast=fail_fast,
  1447|         0|            0|            0|  0.00%|        strict=strict,
  1448|         0|            0|            0|  0.00%|        ref=ref,
  1449|         0|            0|            0|  0.00%|        metadata=metadata,
  1450|         0|            0|            0|  0.00%|        serialization=serialization,
  1451|         0|            0|            0|  0.00%|    )
  1452|         0|            0|            0|  0.00%|
  1453|         0|            0|            0|  0.00%|
  1454|         0|            0|            0|  0.00%|# @deprecated('tuple_positional_schema is deprecated. Use pydantic_core.core_schema.tuple_schema instead.')
  1455|         0|            0|            0|  0.00%|def tuple_positional_schema(
  1456|         0|            0|            0|  0.00%|    items_schema: list[CoreSchema],
  1457|         0|            0|            0|  0.00%|    *,
  1458|         0|            0|            0|  0.00%|    extras_schema: CoreSchema | None = None,
  1459|         0|            0|            0|  0.00%|    strict: bool | None = None,
  1460|         0|            0|            0|  0.00%|    ref: str | None = None,
  1461|         0|            0|            0|  0.00%|    metadata: Any = None,
  1462|         0|            0|            0|  0.00%|    serialization: IncExSeqOrElseSerSchema | None = None,
  1463|         0|            0|            0|  0.00%|) -> TupleSchema:
  1464|         0|            0|            0|  0.00%|    """
  1465|         0|            0|            0|  0.00%|    Returns a schema that matches a tuple of schemas, e.g.:
  1466|         0|            0|            0|  0.00%|
  1467|         0|            0|            0|  0.00%|    ```py
  1468|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  1469|         0|            0|            0|  0.00%|
  1470|         0|            0|            0|  0.00%|    schema = core_schema.tuple_positional_schema(
  1471|         0|            0|            0|  0.00%|        [core_schema.int_schema(), core_schema.str_schema()]
  1472|         0|            0|            0|  0.00%|    )
  1473|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  1474|         0|            0|            0|  0.00%|    assert v.validate_python((1, 'hello')) == (1, 'hello')
  1475|         0|            0|            0|  0.00%|    ```
  1476|         0|            0|            0|  0.00%|
  1477|         0|            0|            0|  0.00%|    Args:
  1478|         0|            0|            0|  0.00%|        items_schema: The value must be a tuple with items that match these schemas
  1479|         0|            0|            0|  0.00%|        extras_schema: The value must be a tuple with items that match this schema
  1480|         0|            0|            0|  0.00%|            This was inspired by JSON schema's `prefixItems` and `items` fields.
  1481|         0|            0|            0|  0.00%|            In python's `typing.Tuple`, you can't specify a type for "extra" items -- they must all be the same type
  1482|         0|            0|            0|  0.00%|            if the length is variable. So this field won't be set from a `typing.Tuple` annotation on a pydantic model.
  1483|         0|            0|            0|  0.00%|        strict: The value must be a tuple with exactly this many items
  1484|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  1485|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  1486|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  1487|         0|            0|            0|  0.00%|    """
  1488|         0|            0|            0|  0.00%|    if extras_schema is not None:
  1489|         0|            0|            0|  0.00%|        variadic_item_index = len(items_schema)
  1490|         0|            0|            0|  0.00%|        items_schema = items_schema + [extras_schema]
  1491|         0|            0|            0|  0.00%|    else:
  1492|         0|            0|            0|  0.00%|        variadic_item_index = None
  1493|         0|            0|            0|  0.00%|    return tuple_schema(
  1494|         0|            0|            0|  0.00%|        items_schema=items_schema,
  1495|         0|            0|            0|  0.00%|        variadic_item_index=variadic_item_index,
  1496|         0|            0|            0|  0.00%|        strict=strict,
  1497|         0|            0|            0|  0.00%|        ref=ref,
  1498|         0|            0|            0|  0.00%|        metadata=metadata,
  1499|         0|            0|            0|  0.00%|        serialization=serialization,
  1500|         0|            0|            0|  0.00%|    )
  1501|         0|            0|            0|  0.00%|
  1502|         0|            0|            0|  0.00%|
  1503|         0|            0|            0|  0.00%|# @deprecated('tuple_variable_schema is deprecated. Use pydantic_core.core_schema.tuple_schema instead.')
  1504|         0|            0|            0|  0.00%|def tuple_variable_schema(
  1505|         0|            0|            0|  0.00%|    items_schema: CoreSchema | None = None,
  1506|         0|            0|            0|  0.00%|    *,
  1507|         0|            0|            0|  0.00%|    min_length: int | None = None,
  1508|         0|            0|            0|  0.00%|    max_length: int | None = None,
  1509|         0|            0|            0|  0.00%|    strict: bool | None = None,
  1510|         0|            0|            0|  0.00%|    ref: str | None = None,
  1511|         0|            0|            0|  0.00%|    metadata: Any = None,
  1512|         0|            0|            0|  0.00%|    serialization: IncExSeqOrElseSerSchema | None = None,
  1513|         0|            0|            0|  0.00%|) -> TupleSchema:
  1514|         0|            0|            0|  0.00%|    """
  1515|         0|            0|            0|  0.00%|    Returns a schema that matches a tuple of a given schema, e.g.:
  1516|         0|            0|            0|  0.00%|
  1517|         0|            0|            0|  0.00%|    ```py
  1518|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  1519|         0|            0|            0|  0.00%|
  1520|         0|            0|            0|  0.00%|    schema = core_schema.tuple_variable_schema(
  1521|         0|            0|            0|  0.00%|        items_schema=core_schema.int_schema(), min_length=0, max_length=10
  1522|         0|            0|            0|  0.00%|    )
  1523|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  1524|         0|            0|            0|  0.00%|    assert v.validate_python(('1', 2, 3)) == (1, 2, 3)
  1525|         0|            0|            0|  0.00%|    ```
  1526|         0|            0|            0|  0.00%|
  1527|         0|            0|            0|  0.00%|    Args:
  1528|         0|            0|            0|  0.00%|        items_schema: The value must be a tuple with items that match this schema
  1529|         0|            0|            0|  0.00%|        min_length: The value must be a tuple with at least this many items
  1530|         0|            0|            0|  0.00%|        max_length: The value must be a tuple with at most this many items
  1531|         0|            0|            0|  0.00%|        strict: The value must be a tuple with exactly this many items
  1532|         0|            0|            0|  0.00%|        ref: Optional unique identifier of the schema, used to reference the schema in other places
  1533|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  1534|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  1535|         0|            0|            0|  0.00%|    """
  1536|         0|            0|            0|  0.00%|    return tuple_schema(
  1537|         0|            0|            0|  0.00%|        items_schema=[items_schema or any_schema()],
  1538|         0|            0|            0|  0.00%|        variadic_item_index=0,
  1539|         0|            0|            0|  0.00%|        min_length=min_length,
  1540|         0|            0|            0|  0.00%|        max_length=max_length,
  1541|         0|            0|            0|  0.00%|        strict=strict,
  1542|         0|            0|            0|  0.00%|        ref=ref,
  1543|         0|            0|            0|  0.00%|        metadata=metadata,
  1544|         0|            0|            0|  0.00%|        serialization=serialization,
  1545|         0|            0|            0|  0.00%|    )
  1546|         0|            0|            0|  0.00%|
  1547|         0|            0|            0|  0.00%|
  1548|         0|            0|            0|  0.00%|class TupleSchema(TypedDict, total=False):
  1549|         0|            0|            0|  0.00%|    type: Required[Literal['tuple']]
  1550|         0|            0|            0|  0.00%|    items_schema: Required[List[CoreSchema]]
  1551|         0|            0|            0|  0.00%|    variadic_item_index: int
  1552|         0|            0|            0|  0.00%|    min_length: int
  1553|         0|            0|            0|  0.00%|    max_length: int
  1554|         0|            0|            0|  0.00%|    fail_fast: bool
  1555|         0|            0|            0|  0.00%|    strict: bool
  1556|         0|            0|            0|  0.00%|    ref: str
  1557|         0|            0|            0|  0.00%|    metadata: Any
  1558|         0|            0|            0|  0.00%|    serialization: IncExSeqOrElseSerSchema
  1559|         0|            0|            0|  0.00%|
  1560|         0|            0|            0|  0.00%|
  1561|         0|            0|            0|  0.00%|def tuple_schema(
  1562|         0|            0|            0|  0.00%|    items_schema: list[CoreSchema],
  1563|         0|            0|            0|  0.00%|    *,
  1564|         0|            0|            0|  0.00%|    variadic_item_index: int | None = None,
  1565|         0|            0|            0|  0.00%|    min_length: int | None = None,
  1566|         0|            0|            0|  0.00%|    max_length: int | None = None,
  1567|         0|            0|            0|  0.00%|    fail_fast: bool | None = None,
  1568|         0|            0|            0|  0.00%|    strict: bool | None = None,
  1569|         0|            0|            0|  0.00%|    ref: str | None = None,
  1570|         0|            0|            0|  0.00%|    metadata: Any = None,
  1571|         0|            0|            0|  0.00%|    serialization: IncExSeqOrElseSerSchema | None = None,
  1572|         0|            0|            0|  0.00%|) -> TupleSchema:
  1573|         0|            0|            0|  0.00%|    """
  1574|         0|            0|            0|  0.00%|    Returns a schema that matches a tuple of schemas, with an optional variadic item, e.g.:
  1575|         0|            0|            0|  0.00%|
  1576|         0|            0|            0|  0.00%|    ```py
  1577|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  1578|         0|            0|            0|  0.00%|
  1579|         0|            0|            0|  0.00%|    schema = core_schema.tuple_schema(
  1580|         0|            0|            0|  0.00%|        [core_schema.int_schema(), core_schema.str_schema(), core_schema.float_schema()],
  1581|         0|            0|            0|  0.00%|        variadic_item_index=1,
  1582|         0|            0|            0|  0.00%|    )
  1583|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  1584|         0|            0|            0|  0.00%|    assert v.validate_python((1, 'hello', 'world', 1.5)) == (1, 'hello', 'world', 1.5)
  1585|         0|            0|            0|  0.00%|    ```
  1586|         0|            0|            0|  0.00%|
  1587|         0|            0|            0|  0.00%|    Args:
  1588|         0|            0|            0|  0.00%|        items_schema: The value must be a tuple with items that match these schemas
  1589|         0|            0|            0|  0.00%|        variadic_item_index: The index of the schema in `items_schema` to be treated as variadic (following PEP 646)
  1590|         0|            0|            0|  0.00%|        min_length: The value must be a tuple with at least this many items
  1591|         0|            0|            0|  0.00%|        max_length: The value must be a tuple with at most this many items
  1592|         0|            0|            0|  0.00%|        fail_fast: Stop validation on the first error
  1593|         0|            0|            0|  0.00%|        strict: The value must be a tuple with exactly this many items
  1594|         0|            0|            0|  0.00%|        ref: Optional unique identifier of the schema, used to reference the schema in other places
  1595|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  1596|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  1597|         0|            0|            0|  0.00%|    """
  1598|         0|            0|            0|  0.00%|    return _dict_not_none(
  1599|         0|            0|            0|  0.00%|        type='tuple',
  1600|         0|            0|            0|  0.00%|        items_schema=items_schema,
  1601|         0|            0|            0|  0.00%|        variadic_item_index=variadic_item_index,
  1602|         0|            0|            0|  0.00%|        min_length=min_length,
  1603|         0|            0|            0|  0.00%|        max_length=max_length,
  1604|         0|            0|            0|  0.00%|        fail_fast=fail_fast,
  1605|         0|            0|            0|  0.00%|        strict=strict,
  1606|         0|            0|            0|  0.00%|        ref=ref,
  1607|         0|            0|            0|  0.00%|        metadata=metadata,
  1608|         0|            0|            0|  0.00%|        serialization=serialization,
  1609|         0|            0|            0|  0.00%|    )
  1610|         0|            0|            0|  0.00%|
  1611|         0|            0|            0|  0.00%|
  1612|         0|            0|            0|  0.00%|class SetSchema(TypedDict, total=False):
  1613|         0|            0|            0|  0.00%|    type: Required[Literal['set']]
  1614|         0|            0|            0|  0.00%|    items_schema: CoreSchema
  1615|         0|            0|            0|  0.00%|    min_length: int
  1616|         0|            0|            0|  0.00%|    max_length: int
  1617|         0|            0|            0|  0.00%|    fail_fast: bool
  1618|         0|            0|            0|  0.00%|    strict: bool
  1619|         0|            0|            0|  0.00%|    ref: str
  1620|         0|            0|            0|  0.00%|    metadata: Any
  1621|         0|            0|            0|  0.00%|    serialization: SerSchema
  1622|         0|            0|            0|  0.00%|
  1623|         0|            0|            0|  0.00%|
  1624|         0|            0|            0|  0.00%|def set_schema(
  1625|         0|            0|            0|  0.00%|    items_schema: CoreSchema | None = None,
  1626|         0|            0|            0|  0.00%|    *,
  1627|         0|            0|            0|  0.00%|    min_length: int | None = None,
  1628|         0|            0|            0|  0.00%|    max_length: int | None = None,
  1629|         0|            0|            0|  0.00%|    fail_fast: bool | None = None,
  1630|         0|            0|            0|  0.00%|    strict: bool | None = None,
  1631|         0|            0|            0|  0.00%|    ref: str | None = None,
  1632|         0|            0|            0|  0.00%|    metadata: Any = None,
  1633|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  1634|         0|            0|            0|  0.00%|) -> SetSchema:
  1635|         0|            0|            0|  0.00%|    """
  1636|         0|            0|            0|  0.00%|    Returns a schema that matches a set of a given schema, e.g.:
  1637|         0|            0|            0|  0.00%|
  1638|         0|            0|            0|  0.00%|    ```py
  1639|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  1640|         0|            0|            0|  0.00%|
  1641|         0|            0|            0|  0.00%|    schema = core_schema.set_schema(
  1642|         0|            0|            0|  0.00%|        items_schema=core_schema.int_schema(), min_length=0, max_length=10
  1643|         0|            0|            0|  0.00%|    )
  1644|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  1645|         0|            0|            0|  0.00%|    assert v.validate_python({1, '2', 3}) == {1, 2, 3}
  1646|         0|            0|            0|  0.00%|    ```
  1647|         0|            0|            0|  0.00%|
  1648|         0|            0|            0|  0.00%|    Args:
  1649|         0|            0|            0|  0.00%|        items_schema: The value must be a set with items that match this schema
  1650|         0|            0|            0|  0.00%|        min_length: The value must be a set with at least this many items
  1651|         0|            0|            0|  0.00%|        max_length: The value must be a set with at most this many items
  1652|         0|            0|            0|  0.00%|        fail_fast: Stop validation on the first error
  1653|         0|            0|            0|  0.00%|        strict: The value must be a set with exactly this many items
  1654|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  1655|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  1656|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  1657|         0|            0|            0|  0.00%|    """
  1658|         0|            0|            0|  0.00%|    return _dict_not_none(
  1659|         0|            0|            0|  0.00%|        type='set',
  1660|         0|            0|            0|  0.00%|        items_schema=items_schema,
  1661|         0|            0|            0|  0.00%|        min_length=min_length,
  1662|         0|            0|            0|  0.00%|        max_length=max_length,
  1663|         0|            0|            0|  0.00%|        fail_fast=fail_fast,
  1664|         0|            0|            0|  0.00%|        strict=strict,
  1665|         0|            0|            0|  0.00%|        ref=ref,
  1666|         0|            0|            0|  0.00%|        metadata=metadata,
  1667|         0|            0|            0|  0.00%|        serialization=serialization,
  1668|         0|            0|            0|  0.00%|    )
  1669|         0|            0|            0|  0.00%|
  1670|         0|            0|            0|  0.00%|
  1671|         0|            0|            0|  0.00%|class FrozenSetSchema(TypedDict, total=False):
  1672|         0|            0|            0|  0.00%|    type: Required[Literal['frozenset']]
  1673|         0|            0|            0|  0.00%|    items_schema: CoreSchema
  1674|         0|            0|            0|  0.00%|    min_length: int
  1675|         0|            0|            0|  0.00%|    max_length: int
  1676|         0|            0|            0|  0.00%|    fail_fast: bool
  1677|         0|            0|            0|  0.00%|    strict: bool
  1678|         0|            0|            0|  0.00%|    ref: str
  1679|         0|            0|            0|  0.00%|    metadata: Any
  1680|         0|            0|            0|  0.00%|    serialization: SerSchema
  1681|         0|            0|            0|  0.00%|
  1682|         0|            0|            0|  0.00%|
  1683|         0|            0|            0|  0.00%|def frozenset_schema(
  1684|         0|            0|            0|  0.00%|    items_schema: CoreSchema | None = None,
  1685|         0|            0|            0|  0.00%|    *,
  1686|         0|            0|            0|  0.00%|    min_length: int | None = None,
  1687|         0|            0|            0|  0.00%|    max_length: int | None = None,
  1688|         0|            0|            0|  0.00%|    fail_fast: bool | None = None,
  1689|         0|            0|            0|  0.00%|    strict: bool | None = None,
  1690|         0|            0|            0|  0.00%|    ref: str | None = None,
  1691|         0|            0|            0|  0.00%|    metadata: Any = None,
  1692|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  1693|         0|            0|            0|  0.00%|) -> FrozenSetSchema:
  1694|         0|            0|            0|  0.00%|    """
  1695|         0|            0|            0|  0.00%|    Returns a schema that matches a frozenset of a given schema, e.g.:
  1696|         0|            0|            0|  0.00%|
  1697|         0|            0|            0|  0.00%|    ```py
  1698|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  1699|         0|            0|            0|  0.00%|
  1700|         0|            0|            0|  0.00%|    schema = core_schema.frozenset_schema(
  1701|         0|            0|            0|  0.00%|        items_schema=core_schema.int_schema(), min_length=0, max_length=10
  1702|         0|            0|            0|  0.00%|    )
  1703|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  1704|         0|            0|            0|  0.00%|    assert v.validate_python(frozenset(range(3))) == frozenset({0, 1, 2})
  1705|         0|            0|            0|  0.00%|    ```
  1706|         0|            0|            0|  0.00%|
  1707|         0|            0|            0|  0.00%|    Args:
  1708|         0|            0|            0|  0.00%|        items_schema: The value must be a frozenset with items that match this schema
  1709|         0|            0|            0|  0.00%|        min_length: The value must be a frozenset with at least this many items
  1710|         0|            0|            0|  0.00%|        max_length: The value must be a frozenset with at most this many items
  1711|         0|            0|            0|  0.00%|        fail_fast: Stop validation on the first error
  1712|         0|            0|            0|  0.00%|        strict: The value must be a frozenset with exactly this many items
  1713|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  1714|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  1715|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  1716|         0|            0|            0|  0.00%|    """
  1717|         0|            0|            0|  0.00%|    return _dict_not_none(
  1718|         0|            0|            0|  0.00%|        type='frozenset',
  1719|         0|            0|            0|  0.00%|        items_schema=items_schema,
  1720|         0|            0|            0|  0.00%|        min_length=min_length,
  1721|         0|            0|            0|  0.00%|        max_length=max_length,
  1722|         0|            0|            0|  0.00%|        fail_fast=fail_fast,
  1723|         0|            0|            0|  0.00%|        strict=strict,
  1724|         0|            0|            0|  0.00%|        ref=ref,
  1725|         0|            0|            0|  0.00%|        metadata=metadata,
  1726|         0|            0|            0|  0.00%|        serialization=serialization,
  1727|         0|            0|            0|  0.00%|    )
  1728|         0|            0|            0|  0.00%|
  1729|         0|            0|            0|  0.00%|
  1730|         0|            0|            0|  0.00%|class GeneratorSchema(TypedDict, total=False):
  1731|         0|            0|            0|  0.00%|    type: Required[Literal['generator']]
  1732|         0|            0|            0|  0.00%|    items_schema: CoreSchema
  1733|         0|            0|            0|  0.00%|    min_length: int
  1734|         0|            0|            0|  0.00%|    max_length: int
  1735|         0|            0|            0|  0.00%|    ref: str
  1736|         0|            0|            0|  0.00%|    metadata: Any
  1737|         0|            0|            0|  0.00%|    serialization: IncExSeqOrElseSerSchema
  1738|         0|            0|            0|  0.00%|
  1739|         0|            0|            0|  0.00%|
  1740|         0|            0|            0|  0.00%|def generator_schema(
  1741|         0|            0|            0|  0.00%|    items_schema: CoreSchema | None = None,
  1742|         0|            0|            0|  0.00%|    *,
  1743|         0|            0|            0|  0.00%|    min_length: int | None = None,
  1744|         0|            0|            0|  0.00%|    max_length: int | None = None,
  1745|         0|            0|            0|  0.00%|    ref: str | None = None,
  1746|         0|            0|            0|  0.00%|    metadata: Any = None,
  1747|         0|            0|            0|  0.00%|    serialization: IncExSeqOrElseSerSchema | None = None,
  1748|         0|            0|            0|  0.00%|) -> GeneratorSchema:
  1749|         0|            0|            0|  0.00%|    """
  1750|         0|            0|            0|  0.00%|    Returns a schema that matches a generator value, e.g.:
  1751|         0|            0|            0|  0.00%|
  1752|         0|            0|            0|  0.00%|    ```py
  1753|         0|            0|            0|  0.00%|    from typing import Iterator
  1754|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  1755|         0|            0|            0|  0.00%|
  1756|         0|            0|            0|  0.00%|    def gen() -> Iterator[int]:
  1757|         0|            0|            0|  0.00%|        yield 1
  1758|         0|            0|            0|  0.00%|
  1759|         0|            0|            0|  0.00%|    schema = core_schema.generator_schema(items_schema=core_schema.int_schema())
  1760|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  1761|         0|            0|            0|  0.00%|    v.validate_python(gen())
  1762|         0|            0|            0|  0.00%|    ```
  1763|         0|            0|            0|  0.00%|
  1764|         0|            0|            0|  0.00%|    Unlike other types, validated generators do not raise ValidationErrors eagerly,
  1765|         0|            0|            0|  0.00%|    but instead will raise a ValidationError when a violating value is actually read from the generator.
  1766|         0|            0|            0|  0.00%|    This is to ensure that "validated" generators retain the benefit of lazy evaluation.
  1767|         0|            0|            0|  0.00%|
  1768|         0|            0|            0|  0.00%|    Args:
  1769|         0|            0|            0|  0.00%|        items_schema: The value must be a generator with items that match this schema
  1770|         0|            0|            0|  0.00%|        min_length: The value must be a generator that yields at least this many items
  1771|         0|            0|            0|  0.00%|        max_length: The value must be a generator that yields at most this many items
  1772|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  1773|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  1774|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  1775|         0|            0|            0|  0.00%|    """
  1776|         0|            0|            0|  0.00%|    return _dict_not_none(
  1777|         0|            0|            0|  0.00%|        type='generator',
  1778|         0|            0|            0|  0.00%|        items_schema=items_schema,
  1779|         0|            0|            0|  0.00%|        min_length=min_length,
  1780|         0|            0|            0|  0.00%|        max_length=max_length,
  1781|         0|            0|            0|  0.00%|        ref=ref,
  1782|         0|            0|            0|  0.00%|        metadata=metadata,
  1783|         0|            0|            0|  0.00%|        serialization=serialization,
  1784|         0|            0|            0|  0.00%|    )
  1785|         0|            0|            0|  0.00%|
  1786|         0|            0|            0|  0.00%|
  1787|         0|            0|            0|  0.00%|IncExDict = Set[Union[int, str]]
  1788|         0|            0|            0|  0.00%|
  1789|         0|            0|            0|  0.00%|
  1790|         0|            0|            0|  0.00%|class IncExDictSerSchema(TypedDict, total=False):
  1791|         0|            0|            0|  0.00%|    type: Required[Literal['include-exclude-dict']]
  1792|         0|            0|            0|  0.00%|    include: IncExDict
  1793|         0|            0|            0|  0.00%|    exclude: IncExDict
  1794|         0|            0|            0|  0.00%|
  1795|         0|            0|            0|  0.00%|
  1796|         0|            0|            0|  0.00%|def filter_dict_schema(*, include: IncExDict | None = None, exclude: IncExDict | None = None) -> IncExDictSerSchema:
  1797|         0|            0|            0|  0.00%|    return _dict_not_none(type='include-exclude-dict', include=include, exclude=exclude)
  1798|         0|            0|            0|  0.00%|
  1799|         0|            0|            0|  0.00%|
  1800|         0|            0|            0|  0.00%|IncExDictOrElseSerSchema = Union[IncExDictSerSchema, SerSchema]
  1801|         0|            0|            0|  0.00%|
  1802|         0|            0|            0|  0.00%|
  1803|         0|            0|            0|  0.00%|class DictSchema(TypedDict, total=False):
  1804|         0|            0|            0|  0.00%|    type: Required[Literal['dict']]
  1805|         0|            0|            0|  0.00%|    keys_schema: CoreSchema  # default: AnySchema
  1806|         0|            0|            0|  0.00%|    values_schema: CoreSchema  # default: AnySchema
  1807|         0|            0|            0|  0.00%|    min_length: int
  1808|         0|            0|            0|  0.00%|    max_length: int
  1809|         0|            0|            0|  0.00%|    strict: bool
  1810|         0|            0|            0|  0.00%|    ref: str
  1811|         0|            0|            0|  0.00%|    metadata: Any
  1812|         0|            0|            0|  0.00%|    serialization: IncExDictOrElseSerSchema
  1813|         0|            0|            0|  0.00%|
  1814|         0|            0|            0|  0.00%|
  1815|         0|            0|            0|  0.00%|def dict_schema(
  1816|         0|            0|            0|  0.00%|    keys_schema: CoreSchema | None = None,
  1817|         0|            0|            0|  0.00%|    values_schema: CoreSchema | None = None,
  1818|         0|            0|            0|  0.00%|    *,
  1819|         0|            0|            0|  0.00%|    min_length: int | None = None,
  1820|         0|            0|            0|  0.00%|    max_length: int | None = None,
  1821|         0|            0|            0|  0.00%|    strict: bool | None = None,
  1822|         0|            0|            0|  0.00%|    ref: str | None = None,
  1823|         0|            0|            0|  0.00%|    metadata: Any = None,
  1824|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  1825|         0|            0|            0|  0.00%|) -> DictSchema:
  1826|         0|            0|            0|  0.00%|    """
  1827|         0|            0|            0|  0.00%|    Returns a schema that matches a dict value, e.g.:
  1828|         0|            0|            0|  0.00%|
  1829|         0|            0|            0|  0.00%|    ```py
  1830|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  1831|         0|            0|            0|  0.00%|
  1832|         0|            0|            0|  0.00%|    schema = core_schema.dict_schema(
  1833|         0|            0|            0|  0.00%|        keys_schema=core_schema.str_schema(), values_schema=core_schema.int_schema()
  1834|         0|            0|            0|  0.00%|    )
  1835|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  1836|         0|            0|            0|  0.00%|    assert v.validate_python({'a': '1', 'b': 2}) == {'a': 1, 'b': 2}
  1837|         0|            0|            0|  0.00%|    ```
  1838|         0|            0|            0|  0.00%|
  1839|         0|            0|            0|  0.00%|    Args:
  1840|         0|            0|            0|  0.00%|        keys_schema: The value must be a dict with keys that match this schema
  1841|         0|            0|            0|  0.00%|        values_schema: The value must be a dict with values that match this schema
  1842|         0|            0|            0|  0.00%|        min_length: The value must be a dict with at least this many items
  1843|         0|            0|            0|  0.00%|        max_length: The value must be a dict with at most this many items
  1844|         0|            0|            0|  0.00%|        strict: Whether the keys and values should be validated with strict mode
  1845|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  1846|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  1847|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  1848|         0|            0|            0|  0.00%|    """
  1849|         0|            0|            0|  0.00%|    return _dict_not_none(
  1850|         0|            0|            0|  0.00%|        type='dict',
  1851|         0|            0|            0|  0.00%|        keys_schema=keys_schema,
  1852|         0|            0|            0|  0.00%|        values_schema=values_schema,
  1853|         0|            0|            0|  0.00%|        min_length=min_length,
  1854|         0|            0|            0|  0.00%|        max_length=max_length,
  1855|         0|            0|            0|  0.00%|        strict=strict,
  1856|         0|            0|            0|  0.00%|        ref=ref,
  1857|         0|            0|            0|  0.00%|        metadata=metadata,
  1858|         0|            0|            0|  0.00%|        serialization=serialization,
  1859|         0|            0|            0|  0.00%|    )
  1860|         0|            0|            0|  0.00%|
  1861|         0|            0|            0|  0.00%|
  1862|         0|            0|            0|  0.00%|# (input_value: Any, /) -> Any
  1863|         0|            0|            0|  0.00%|NoInfoValidatorFunction = Callable[[Any], Any]
  1864|         0|            0|            0|  0.00%|
  1865|         0|            0|            0|  0.00%|
  1866|         0|            0|            0|  0.00%|class NoInfoValidatorFunctionSchema(TypedDict):
  1867|         0|            0|            0|  0.00%|    type: Literal['no-info']
  1868|         0|            0|            0|  0.00%|    function: NoInfoValidatorFunction
  1869|         0|            0|            0|  0.00%|
  1870|         0|            0|            0|  0.00%|
  1871|         0|            0|            0|  0.00%|# (input_value: Any, info: ValidationInfo, /) -> Any
  1872|         0|            0|            0|  0.00%|WithInfoValidatorFunction = Callable[[Any, ValidationInfo], Any]
  1873|         0|            0|            0|  0.00%|
  1874|         0|            0|            0|  0.00%|
  1875|         0|            0|            0|  0.00%|class WithInfoValidatorFunctionSchema(TypedDict, total=False):
  1876|         0|            0|            0|  0.00%|    type: Required[Literal['with-info']]
  1877|         0|            0|            0|  0.00%|    function: Required[WithInfoValidatorFunction]
  1878|         0|            0|            0|  0.00%|    field_name: str
  1879|         0|            0|            0|  0.00%|
  1880|         0|            0|            0|  0.00%|
  1881|         0|            0|            0|  0.00%|ValidationFunction = Union[NoInfoValidatorFunctionSchema, WithInfoValidatorFunctionSchema]
  1882|         0|            0|            0|  0.00%|
  1883|         0|            0|            0|  0.00%|
  1884|         0|            0|            0|  0.00%|class _ValidatorFunctionSchema(TypedDict, total=False):
  1885|         0|            0|            0|  0.00%|    function: Required[ValidationFunction]
  1886|         0|            0|            0|  0.00%|    schema: Required[CoreSchema]
  1887|         0|            0|            0|  0.00%|    ref: str
  1888|         0|            0|            0|  0.00%|    metadata: Any
  1889|         0|            0|            0|  0.00%|    serialization: SerSchema
  1890|         0|            0|            0|  0.00%|
  1891|         0|            0|            0|  0.00%|
  1892|         0|            0|            0|  0.00%|class BeforeValidatorFunctionSchema(_ValidatorFunctionSchema, total=False):
  1893|         0|            0|            0|  0.00%|    type: Required[Literal['function-before']]
  1894|         0|            0|            0|  0.00%|
  1895|         0|            0|            0|  0.00%|
  1896|         0|            0|            0|  0.00%|def no_info_before_validator_function(
  1897|         0|            0|            0|  0.00%|    function: NoInfoValidatorFunction,
  1898|         0|            0|            0|  0.00%|    schema: CoreSchema,
  1899|         0|            0|            0|  0.00%|    *,
  1900|         0|            0|            0|  0.00%|    ref: str | None = None,
  1901|         0|            0|            0|  0.00%|    metadata: Any = None,
  1902|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  1903|         0|            0|            0|  0.00%|) -> BeforeValidatorFunctionSchema:
  1904|         0|            0|            0|  0.00%|    """
  1905|         0|            0|            0|  0.00%|    Returns a schema that calls a validator function before validating, no `info` argument is provided, e.g.:
  1906|         0|            0|            0|  0.00%|
  1907|         0|            0|            0|  0.00%|    ```py
  1908|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  1909|         0|            0|            0|  0.00%|
  1910|         0|            0|            0|  0.00%|    def fn(v: bytes) -> str:
  1911|         0|            0|            0|  0.00%|        return v.decode() + 'world'
  1912|         0|            0|            0|  0.00%|
  1913|         0|            0|            0|  0.00%|    func_schema = core_schema.no_info_before_validator_function(
  1914|         0|            0|            0|  0.00%|        function=fn, schema=core_schema.str_schema()
  1915|         0|            0|            0|  0.00%|    )
  1916|         0|            0|            0|  0.00%|    schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})
  1917|         0|            0|            0|  0.00%|
  1918|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  1919|         0|            0|            0|  0.00%|    assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}
  1920|         0|            0|            0|  0.00%|    ```
  1921|         0|            0|            0|  0.00%|
  1922|         0|            0|            0|  0.00%|    Args:
  1923|         0|            0|            0|  0.00%|        function: The validator function to call
  1924|         0|            0|            0|  0.00%|        schema: The schema to validate the output of the validator function
  1925|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  1926|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  1927|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  1928|         0|            0|            0|  0.00%|    """
  1929|         0|            0|            0|  0.00%|    return _dict_not_none(
  1930|         0|            0|            0|  0.00%|        type='function-before',
  1931|         0|            0|            0|  0.00%|        function={'type': 'no-info', 'function': function},
  1932|         0|            0|            0|  0.00%|        schema=schema,
  1933|         0|            0|            0|  0.00%|        ref=ref,
  1934|         0|            0|            0|  0.00%|        metadata=metadata,
  1935|         0|            0|            0|  0.00%|        serialization=serialization,
  1936|         0|            0|            0|  0.00%|    )
  1937|         0|            0|            0|  0.00%|
  1938|         0|            0|            0|  0.00%|
  1939|         0|            0|            0|  0.00%|def with_info_before_validator_function(
  1940|         0|            0|            0|  0.00%|    function: WithInfoValidatorFunction,
  1941|         0|            0|            0|  0.00%|    schema: CoreSchema,
  1942|         0|            0|            0|  0.00%|    *,
  1943|         0|            0|            0|  0.00%|    field_name: str | None = None,
  1944|         0|            0|            0|  0.00%|    ref: str | None = None,
  1945|         0|            0|            0|  0.00%|    metadata: Any = None,
  1946|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  1947|         0|            0|            0|  0.00%|) -> BeforeValidatorFunctionSchema:
  1948|         0|            0|            0|  0.00%|    """
  1949|         0|            0|            0|  0.00%|    Returns a schema that calls a validator function before validation, the function is called with
  1950|         0|            0|            0|  0.00%|    an `info` argument, e.g.:
  1951|         0|            0|            0|  0.00%|
  1952|         0|            0|            0|  0.00%|    ```py
  1953|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  1954|         0|            0|            0|  0.00%|
  1955|         0|            0|            0|  0.00%|    def fn(v: bytes, info: core_schema.ValidationInfo) -> str:
  1956|         0|            0|            0|  0.00%|        assert info.data is not None
  1957|         0|            0|            0|  0.00%|        assert info.field_name is not None
  1958|         0|            0|            0|  0.00%|        return v.decode() + 'world'
  1959|         0|            0|            0|  0.00%|
  1960|         0|            0|            0|  0.00%|    func_schema = core_schema.with_info_before_validator_function(
  1961|         0|            0|            0|  0.00%|        function=fn, schema=core_schema.str_schema(), field_name='a'
  1962|         0|            0|            0|  0.00%|    )
  1963|         0|            0|            0|  0.00%|    schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})
  1964|         0|            0|            0|  0.00%|
  1965|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  1966|         0|            0|            0|  0.00%|    assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}
  1967|         0|            0|            0|  0.00%|    ```
  1968|         0|            0|            0|  0.00%|
  1969|         0|            0|            0|  0.00%|    Args:
  1970|         0|            0|            0|  0.00%|        function: The validator function to call
  1971|         0|            0|            0|  0.00%|        field_name: The name of the field
  1972|         0|            0|            0|  0.00%|        schema: The schema to validate the output of the validator function
  1973|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  1974|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  1975|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  1976|         0|            0|            0|  0.00%|    """
  1977|         0|            0|            0|  0.00%|    return _dict_not_none(
  1978|         0|            0|            0|  0.00%|        type='function-before',
  1979|         0|            0|            0|  0.00%|        function=_dict_not_none(type='with-info', function=function, field_name=field_name),
  1980|         0|            0|            0|  0.00%|        schema=schema,
  1981|         0|            0|            0|  0.00%|        ref=ref,
  1982|         0|            0|            0|  0.00%|        metadata=metadata,
  1983|         0|            0|            0|  0.00%|        serialization=serialization,
  1984|         0|            0|            0|  0.00%|    )
  1985|         0|            0|            0|  0.00%|
  1986|         0|            0|            0|  0.00%|
  1987|         0|            0|            0|  0.00%|class AfterValidatorFunctionSchema(_ValidatorFunctionSchema, total=False):
  1988|         0|            0|            0|  0.00%|    type: Required[Literal['function-after']]
  1989|         0|            0|            0|  0.00%|
  1990|         0|            0|            0|  0.00%|
  1991|         0|            0|            0|  0.00%|def no_info_after_validator_function(
  1992|         0|            0|            0|  0.00%|    function: NoInfoValidatorFunction,
  1993|         0|            0|            0|  0.00%|    schema: CoreSchema,
  1994|         0|            0|            0|  0.00%|    *,
  1995|         0|            0|            0|  0.00%|    ref: str | None = None,
  1996|         0|            0|            0|  0.00%|    metadata: Any = None,
  1997|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  1998|         0|            0|            0|  0.00%|) -> AfterValidatorFunctionSchema:
  1999|         0|            0|            0|  0.00%|    """
  2000|         0|            0|            0|  0.00%|    Returns a schema that calls a validator function after validating, no `info` argument is provided, e.g.:
  2001|         0|            0|            0|  0.00%|
  2002|         0|            0|            0|  0.00%|    ```py
  2003|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  2004|         0|            0|            0|  0.00%|
  2005|         0|            0|            0|  0.00%|    def fn(v: str) -> str:
  2006|         0|            0|            0|  0.00%|        return v + 'world'
  2007|         0|            0|            0|  0.00%|
  2008|         0|            0|            0|  0.00%|    func_schema = core_schema.no_info_after_validator_function(fn, core_schema.str_schema())
  2009|         0|            0|            0|  0.00%|    schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})
  2010|         0|            0|            0|  0.00%|
  2011|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  2012|         0|            0|            0|  0.00%|    assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}
  2013|         0|            0|            0|  0.00%|    ```
  2014|         0|            0|            0|  0.00%|
  2015|         0|            0|            0|  0.00%|    Args:
  2016|         0|            0|            0|  0.00%|        function: The validator function to call after the schema is validated
  2017|         0|            0|            0|  0.00%|        schema: The schema to validate before the validator function
  2018|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  2019|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  2020|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  2021|         0|            0|            0|  0.00%|    """
  2022|         0|            0|            0|  0.00%|    return _dict_not_none(
  2023|         0|            0|            0|  0.00%|        type='function-after',
  2024|         0|            0|            0|  0.00%|        function={'type': 'no-info', 'function': function},
  2025|         0|            0|            0|  0.00%|        schema=schema,
  2026|         0|            0|            0|  0.00%|        ref=ref,
  2027|         0|            0|            0|  0.00%|        metadata=metadata,
  2028|         0|            0|            0|  0.00%|        serialization=serialization,
  2029|         0|            0|            0|  0.00%|    )
  2030|         0|            0|            0|  0.00%|
  2031|         0|            0|            0|  0.00%|
  2032|         0|            0|            0|  0.00%|def with_info_after_validator_function(
  2033|         0|            0|            0|  0.00%|    function: WithInfoValidatorFunction,
  2034|         0|            0|            0|  0.00%|    schema: CoreSchema,
  2035|         0|            0|            0|  0.00%|    *,
  2036|         0|            0|            0|  0.00%|    field_name: str | None = None,
  2037|         0|            0|            0|  0.00%|    ref: str | None = None,
  2038|         0|            0|            0|  0.00%|    metadata: Any = None,
  2039|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  2040|         0|            0|            0|  0.00%|) -> AfterValidatorFunctionSchema:
  2041|         0|            0|            0|  0.00%|    """
  2042|         0|            0|            0|  0.00%|    Returns a schema that calls a validator function after validation, the function is called with
  2043|         0|            0|            0|  0.00%|    an `info` argument, e.g.:
  2044|         0|            0|            0|  0.00%|
  2045|         0|            0|            0|  0.00%|    ```py
  2046|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  2047|         0|            0|            0|  0.00%|
  2048|         0|            0|            0|  0.00%|    def fn(v: str, info: core_schema.ValidationInfo) -> str:
  2049|         0|            0|            0|  0.00%|        assert info.data is not None
  2050|         0|            0|            0|  0.00%|        assert info.field_name is not None
  2051|         0|            0|            0|  0.00%|        return v + 'world'
  2052|         0|            0|            0|  0.00%|
  2053|         0|            0|            0|  0.00%|    func_schema = core_schema.with_info_after_validator_function(
  2054|         0|            0|            0|  0.00%|        function=fn, schema=core_schema.str_schema(), field_name='a'
  2055|         0|            0|            0|  0.00%|    )
  2056|         0|            0|            0|  0.00%|    schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})
  2057|         0|            0|            0|  0.00%|
  2058|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  2059|         0|            0|            0|  0.00%|    assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}
  2060|         0|            0|            0|  0.00%|    ```
  2061|         0|            0|            0|  0.00%|
  2062|         0|            0|            0|  0.00%|    Args:
  2063|         0|            0|            0|  0.00%|        function: The validator function to call after the schema is validated
  2064|         0|            0|            0|  0.00%|        schema: The schema to validate before the validator function
  2065|         0|            0|            0|  0.00%|        field_name: The name of the field this validators is applied to, if any
  2066|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  2067|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  2068|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  2069|         0|            0|            0|  0.00%|    """
  2070|         0|            0|            0|  0.00%|    return _dict_not_none(
  2071|         0|            0|            0|  0.00%|        type='function-after',
  2072|         0|            0|            0|  0.00%|        function=_dict_not_none(type='with-info', function=function, field_name=field_name),
  2073|         0|            0|            0|  0.00%|        schema=schema,
  2074|         0|            0|            0|  0.00%|        ref=ref,
  2075|         0|            0|            0|  0.00%|        metadata=metadata,
  2076|         0|            0|            0|  0.00%|        serialization=serialization,
  2077|         0|            0|            0|  0.00%|    )
  2078|         0|            0|            0|  0.00%|
  2079|         0|            0|            0|  0.00%|
  2080|         0|            0|            0|  0.00%|class ValidatorFunctionWrapHandler(Protocol):
  2081|         0|            0|            0|  0.00%|    def __call__(self, input_value: Any, outer_location: str | int | None = None, /) -> Any:  # pragma: no cover
  2082|         0|            0|            0|  0.00%|        ...
  2083|         0|            0|            0|  0.00%|
  2084|         0|            0|            0|  0.00%|
  2085|         0|            0|            0|  0.00%|# (input_value: Any, validator: ValidatorFunctionWrapHandler, /) -> Any
  2086|         0|            0|            0|  0.00%|NoInfoWrapValidatorFunction = Callable[[Any, ValidatorFunctionWrapHandler], Any]
  2087|         0|            0|            0|  0.00%|
  2088|         0|            0|            0|  0.00%|
  2089|         0|            0|            0|  0.00%|class NoInfoWrapValidatorFunctionSchema(TypedDict):
  2090|         0|            0|            0|  0.00%|    type: Literal['no-info']
  2091|         0|            0|            0|  0.00%|    function: NoInfoWrapValidatorFunction
  2092|         0|            0|            0|  0.00%|
  2093|         0|            0|            0|  0.00%|
  2094|         0|            0|            0|  0.00%|# (input_value: Any, validator: ValidatorFunctionWrapHandler, info: ValidationInfo, /) -> Any
  2095|         0|            0|            0|  0.00%|WithInfoWrapValidatorFunction = Callable[[Any, ValidatorFunctionWrapHandler, ValidationInfo], Any]
  2096|         0|            0|            0|  0.00%|
  2097|         0|            0|            0|  0.00%|
  2098|         0|            0|            0|  0.00%|class WithInfoWrapValidatorFunctionSchema(TypedDict, total=False):
  2099|         0|            0|            0|  0.00%|    type: Required[Literal['with-info']]
  2100|         0|            0|            0|  0.00%|    function: Required[WithInfoWrapValidatorFunction]
  2101|         0|            0|            0|  0.00%|    field_name: str
  2102|         0|            0|            0|  0.00%|
  2103|         0|            0|            0|  0.00%|
  2104|         0|            0|            0|  0.00%|WrapValidatorFunction = Union[NoInfoWrapValidatorFunctionSchema, WithInfoWrapValidatorFunctionSchema]
  2105|         0|            0|            0|  0.00%|
  2106|         0|            0|            0|  0.00%|
  2107|         0|            0|            0|  0.00%|class WrapValidatorFunctionSchema(TypedDict, total=False):
  2108|         0|            0|            0|  0.00%|    type: Required[Literal['function-wrap']]
  2109|         0|            0|            0|  0.00%|    function: Required[WrapValidatorFunction]
  2110|         0|            0|            0|  0.00%|    schema: Required[CoreSchema]
  2111|         0|            0|            0|  0.00%|    ref: str
  2112|         0|            0|            0|  0.00%|    metadata: Any
  2113|         0|            0|            0|  0.00%|    serialization: SerSchema
  2114|         0|            0|            0|  0.00%|
  2115|         0|            0|            0|  0.00%|
  2116|         0|            0|            0|  0.00%|def no_info_wrap_validator_function(
  2117|         0|            0|            0|  0.00%|    function: NoInfoWrapValidatorFunction,
  2118|         0|            0|            0|  0.00%|    schema: CoreSchema,
  2119|         0|            0|            0|  0.00%|    *,
  2120|         0|            0|            0|  0.00%|    ref: str | None = None,
  2121|         0|            0|            0|  0.00%|    metadata: Any = None,
  2122|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  2123|         0|            0|            0|  0.00%|) -> WrapValidatorFunctionSchema:
  2124|         0|            0|            0|  0.00%|    """
  2125|         0|            0|            0|  0.00%|    Returns a schema which calls a function with a `validator` callable argument which can
  2126|         0|            0|            0|  0.00%|    optionally be used to call inner validation with the function logic, this is much like the
  2127|         0|            0|            0|  0.00%|    "onion" implementation of middleware in many popular web frameworks, no `info` argument is passed, e.g.:
  2128|         0|            0|            0|  0.00%|
  2129|         0|            0|            0|  0.00%|    ```py
  2130|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  2131|         0|            0|            0|  0.00%|
  2132|         0|            0|            0|  0.00%|    def fn(
  2133|         0|            0|            0|  0.00%|        v: str,
  2134|         0|            0|            0|  0.00%|        validator: core_schema.ValidatorFunctionWrapHandler,
  2135|         0|            0|            0|  0.00%|    ) -> str:
  2136|         0|            0|            0|  0.00%|        return validator(input_value=v) + 'world'
  2137|         0|            0|            0|  0.00%|
  2138|         0|            0|            0|  0.00%|    schema = core_schema.no_info_wrap_validator_function(
  2139|         0|            0|            0|  0.00%|        function=fn, schema=core_schema.str_schema()
  2140|         0|            0|            0|  0.00%|    )
  2141|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  2142|         0|            0|            0|  0.00%|    assert v.validate_python('hello ') == 'hello world'
  2143|         0|            0|            0|  0.00%|    ```
  2144|         0|            0|            0|  0.00%|
  2145|         0|            0|            0|  0.00%|    Args:
  2146|         0|            0|            0|  0.00%|        function: The validator function to call
  2147|         0|            0|            0|  0.00%|        schema: The schema to validate the output of the validator function
  2148|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  2149|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  2150|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  2151|         0|            0|            0|  0.00%|    """
  2152|         0|            0|            0|  0.00%|    return _dict_not_none(
  2153|         0|            0|            0|  0.00%|        type='function-wrap',
  2154|         0|            0|            0|  0.00%|        function={'type': 'no-info', 'function': function},
  2155|         0|            0|            0|  0.00%|        schema=schema,
  2156|         0|            0|            0|  0.00%|        ref=ref,
  2157|         0|            0|            0|  0.00%|        metadata=metadata,
  2158|         0|            0|            0|  0.00%|        serialization=serialization,
  2159|         0|            0|            0|  0.00%|    )
  2160|         0|            0|            0|  0.00%|
  2161|         0|            0|            0|  0.00%|
  2162|         0|            0|            0|  0.00%|def with_info_wrap_validator_function(
  2163|         0|            0|            0|  0.00%|    function: WithInfoWrapValidatorFunction,
  2164|         0|            0|            0|  0.00%|    schema: CoreSchema,
  2165|         0|            0|            0|  0.00%|    *,
  2166|         0|            0|            0|  0.00%|    field_name: str | None = None,
  2167|         0|            0|            0|  0.00%|    ref: str | None = None,
  2168|         0|            0|            0|  0.00%|    metadata: Any = None,
  2169|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  2170|         0|            0|            0|  0.00%|) -> WrapValidatorFunctionSchema:
  2171|         0|            0|            0|  0.00%|    """
  2172|         0|            0|            0|  0.00%|    Returns a schema which calls a function with a `validator` callable argument which can
  2173|         0|            0|            0|  0.00%|    optionally be used to call inner validation with the function logic, this is much like the
  2174|         0|            0|            0|  0.00%|    "onion" implementation of middleware in many popular web frameworks, an `info` argument is also passed, e.g.:
  2175|         0|            0|            0|  0.00%|
  2176|         0|            0|            0|  0.00%|    ```py
  2177|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  2178|         0|            0|            0|  0.00%|
  2179|         0|            0|            0|  0.00%|    def fn(
  2180|         0|            0|            0|  0.00%|        v: str,
  2181|         0|            0|            0|  0.00%|        validator: core_schema.ValidatorFunctionWrapHandler,
  2182|         0|            0|            0|  0.00%|        info: core_schema.ValidationInfo,
  2183|         0|            0|            0|  0.00%|    ) -> str:
  2184|         0|            0|            0|  0.00%|        return validator(input_value=v) + 'world'
  2185|         0|            0|            0|  0.00%|
  2186|         0|            0|            0|  0.00%|    schema = core_schema.with_info_wrap_validator_function(
  2187|         0|            0|            0|  0.00%|        function=fn, schema=core_schema.str_schema()
  2188|         0|            0|            0|  0.00%|    )
  2189|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  2190|         0|            0|            0|  0.00%|    assert v.validate_python('hello ') == 'hello world'
  2191|         0|            0|            0|  0.00%|    ```
  2192|         0|            0|            0|  0.00%|
  2193|         0|            0|            0|  0.00%|    Args:
  2194|         0|            0|            0|  0.00%|        function: The validator function to call
  2195|         0|            0|            0|  0.00%|        schema: The schema to validate the output of the validator function
  2196|         0|            0|            0|  0.00%|        field_name: The name of the field this validators is applied to, if any
  2197|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  2198|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  2199|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  2200|         0|            0|            0|  0.00%|    """
  2201|         0|            0|            0|  0.00%|    return _dict_not_none(
  2202|         0|            0|            0|  0.00%|        type='function-wrap',
  2203|         0|            0|            0|  0.00%|        function=_dict_not_none(type='with-info', function=function, field_name=field_name),
  2204|         0|            0|            0|  0.00%|        schema=schema,
  2205|         0|            0|            0|  0.00%|        ref=ref,
  2206|         0|            0|            0|  0.00%|        metadata=metadata,
  2207|         0|            0|            0|  0.00%|        serialization=serialization,
  2208|         0|            0|            0|  0.00%|    )
  2209|         0|            0|            0|  0.00%|
  2210|         0|            0|            0|  0.00%|
  2211|         0|            0|            0|  0.00%|class PlainValidatorFunctionSchema(TypedDict, total=False):
  2212|         0|            0|            0|  0.00%|    type: Required[Literal['function-plain']]
  2213|         0|            0|            0|  0.00%|    function: Required[ValidationFunction]
  2214|         0|            0|            0|  0.00%|    ref: str
  2215|         0|            0|            0|  0.00%|    metadata: Any
  2216|         0|            0|            0|  0.00%|    serialization: SerSchema
  2217|         0|            0|            0|  0.00%|
  2218|         0|            0|            0|  0.00%|
  2219|         0|            0|            0|  0.00%|def no_info_plain_validator_function(
  2220|         0|            0|            0|  0.00%|    function: NoInfoValidatorFunction,
  2221|         0|            0|            0|  0.00%|    *,
  2222|         0|            0|            0|  0.00%|    ref: str | None = None,
  2223|         0|            0|            0|  0.00%|    metadata: Any = None,
  2224|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  2225|         0|            0|            0|  0.00%|) -> PlainValidatorFunctionSchema:
  2226|         0|            0|            0|  0.00%|    """
  2227|         0|            0|            0|  0.00%|    Returns a schema that uses the provided function for validation, no `info` argument is passed, e.g.:
  2228|         0|            0|            0|  0.00%|
  2229|         0|            0|            0|  0.00%|    ```py
  2230|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  2231|         0|            0|            0|  0.00%|
  2232|         0|            0|            0|  0.00%|    def fn(v: str) -> str:
  2233|         0|            0|            0|  0.00%|        assert 'hello' in v
  2234|         0|            0|            0|  0.00%|        return v + 'world'
  2235|         0|            0|            0|  0.00%|
  2236|         0|            0|            0|  0.00%|    schema = core_schema.no_info_plain_validator_function(function=fn)
  2237|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  2238|         0|            0|            0|  0.00%|    assert v.validate_python('hello ') == 'hello world'
  2239|         0|            0|            0|  0.00%|    ```
  2240|         0|            0|            0|  0.00%|
  2241|         0|            0|            0|  0.00%|    Args:
  2242|         0|            0|            0|  0.00%|        function: The validator function to call
  2243|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  2244|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  2245|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  2246|         0|            0|            0|  0.00%|    """
  2247|         0|            0|            0|  0.00%|    return _dict_not_none(
  2248|         0|            0|            0|  0.00%|        type='function-plain',
  2249|         0|            0|            0|  0.00%|        function={'type': 'no-info', 'function': function},
  2250|         0|            0|            0|  0.00%|        ref=ref,
  2251|         0|            0|            0|  0.00%|        metadata=metadata,
  2252|         0|            0|            0|  0.00%|        serialization=serialization,
  2253|         0|            0|            0|  0.00%|    )
  2254|         0|            0|            0|  0.00%|
  2255|         0|            0|            0|  0.00%|
  2256|         0|            0|            0|  0.00%|def with_info_plain_validator_function(
  2257|         0|            0|            0|  0.00%|    function: WithInfoValidatorFunction,
  2258|         0|            0|            0|  0.00%|    *,
  2259|         0|            0|            0|  0.00%|    field_name: str | None = None,
  2260|         0|            0|            0|  0.00%|    ref: str | None = None,
  2261|         0|            0|            0|  0.00%|    metadata: Any = None,
  2262|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  2263|         0|            0|            0|  0.00%|) -> PlainValidatorFunctionSchema:
  2264|         0|            0|            0|  0.00%|    """
  2265|         0|            0|            0|  0.00%|    Returns a schema that uses the provided function for validation, an `info` argument is passed, e.g.:
  2266|         0|            0|            0|  0.00%|
  2267|         0|            0|            0|  0.00%|    ```py
  2268|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  2269|         0|            0|            0|  0.00%|
  2270|         0|            0|            0|  0.00%|    def fn(v: str, info: core_schema.ValidationInfo) -> str:
  2271|         0|            0|            0|  0.00%|        assert 'hello' in v
  2272|         0|            0|            0|  0.00%|        return v + 'world'
  2273|         0|            0|            0|  0.00%|
  2274|         0|            0|            0|  0.00%|    schema = core_schema.with_info_plain_validator_function(function=fn)
  2275|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  2276|         0|            0|            0|  0.00%|    assert v.validate_python('hello ') == 'hello world'
  2277|         0|            0|            0|  0.00%|    ```
  2278|         0|            0|            0|  0.00%|
  2279|         0|            0|            0|  0.00%|    Args:
  2280|         0|            0|            0|  0.00%|        function: The validator function to call
  2281|         0|            0|            0|  0.00%|        field_name: The name of the field this validators is applied to, if any
  2282|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  2283|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  2284|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  2285|         0|            0|            0|  0.00%|    """
  2286|         0|            0|            0|  0.00%|    return _dict_not_none(
  2287|         0|            0|            0|  0.00%|        type='function-plain',
  2288|         0|            0|            0|  0.00%|        function=_dict_not_none(type='with-info', function=function, field_name=field_name),
  2289|         0|            0|            0|  0.00%|        ref=ref,
  2290|         0|            0|            0|  0.00%|        metadata=metadata,
  2291|         0|            0|            0|  0.00%|        serialization=serialization,
  2292|         0|            0|            0|  0.00%|    )
  2293|         0|            0|            0|  0.00%|
  2294|         0|            0|            0|  0.00%|
  2295|         0|            0|            0|  0.00%|class WithDefaultSchema(TypedDict, total=False):
  2296|         0|            0|            0|  0.00%|    type: Required[Literal['default']]
  2297|         0|            0|            0|  0.00%|    schema: Required[CoreSchema]
  2298|         0|            0|            0|  0.00%|    default: Any
  2299|         0|            0|            0|  0.00%|    default_factory: Callable[[], Any]
  2300|         0|            0|            0|  0.00%|    on_error: Literal['raise', 'omit', 'default']  # default: 'raise'
  2301|         0|            0|            0|  0.00%|    validate_default: bool  # default: False
  2302|         0|            0|            0|  0.00%|    strict: bool
  2303|         0|            0|            0|  0.00%|    ref: str
  2304|         0|            0|            0|  0.00%|    metadata: Any
  2305|         0|            0|            0|  0.00%|    serialization: SerSchema
  2306|         0|            0|            0|  0.00%|
  2307|         0|            0|            0|  0.00%|
  2308|         0|            0|            0|  0.00%|def with_default_schema(
  2309|         0|            0|            0|  0.00%|    schema: CoreSchema,
  2310|         0|            0|            0|  0.00%|    *,
  2311|         0|            0|            0|  0.00%|    default: Any = PydanticUndefined,
  2312|         0|            0|            0|  0.00%|    default_factory: Callable[[], Any] | None = None,
  2313|         0|            0|            0|  0.00%|    on_error: Literal['raise', 'omit', 'default'] | None = None,
  2314|         0|            0|            0|  0.00%|    validate_default: bool | None = None,
  2315|         0|            0|            0|  0.00%|    strict: bool | None = None,
  2316|         0|            0|            0|  0.00%|    ref: str | None = None,
  2317|         0|            0|            0|  0.00%|    metadata: Any = None,
  2318|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  2319|         0|            0|            0|  0.00%|) -> WithDefaultSchema:
  2320|         0|            0|            0|  0.00%|    """
  2321|         0|            0|            0|  0.00%|    Returns a schema that adds a default value to the given schema, e.g.:
  2322|         0|            0|            0|  0.00%|
  2323|         0|            0|            0|  0.00%|    ```py
  2324|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  2325|         0|            0|            0|  0.00%|
  2326|         0|            0|            0|  0.00%|    schema = core_schema.with_default_schema(core_schema.str_schema(), default='hello')
  2327|         0|            0|            0|  0.00%|    wrapper_schema = core_schema.typed_dict_schema(
  2328|         0|            0|            0|  0.00%|        {'a': core_schema.typed_dict_field(schema)}
  2329|         0|            0|            0|  0.00%|    )
  2330|         0|            0|            0|  0.00%|    v = SchemaValidator(wrapper_schema)
  2331|         0|            0|            0|  0.00%|    assert v.validate_python({}) == v.validate_python({'a': 'hello'})
  2332|         0|            0|            0|  0.00%|    ```
  2333|         0|            0|            0|  0.00%|
  2334|         0|            0|            0|  0.00%|    Args:
  2335|         0|            0|            0|  0.00%|        schema: The schema to add a default value to
  2336|         0|            0|            0|  0.00%|        default: The default value to use
  2337|         0|            0|            0|  0.00%|        default_factory: A function that returns the default value to use
  2338|         0|            0|            0|  0.00%|        on_error: What to do if the schema validation fails. One of 'raise', 'omit', 'default'
  2339|         0|            0|            0|  0.00%|        validate_default: Whether the default value should be validated
  2340|         0|            0|            0|  0.00%|        strict: Whether the underlying schema should be validated with strict mode
  2341|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  2342|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  2343|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  2344|         0|            0|            0|  0.00%|    """
  2345|         0|            0|            0|  0.00%|    s = _dict_not_none(
  2346|         0|            0|            0|  0.00%|        type='default',
  2347|         0|            0|            0|  0.00%|        schema=schema,
  2348|         0|            0|            0|  0.00%|        default_factory=default_factory,
  2349|         0|            0|            0|  0.00%|        on_error=on_error,
  2350|         0|            0|            0|  0.00%|        validate_default=validate_default,
  2351|         0|            0|            0|  0.00%|        strict=strict,
  2352|         0|            0|            0|  0.00%|        ref=ref,
  2353|         0|            0|            0|  0.00%|        metadata=metadata,
  2354|         0|            0|            0|  0.00%|        serialization=serialization,
  2355|         0|            0|            0|  0.00%|    )
  2356|         0|            0|            0|  0.00%|    if default is not PydanticUndefined:
  2357|         0|            0|            0|  0.00%|        s['default'] = default
  2358|         0|            0|            0|  0.00%|    return s
  2359|         0|            0|            0|  0.00%|
  2360|         0|            0|            0|  0.00%|
  2361|         0|            0|            0|  0.00%|class NullableSchema(TypedDict, total=False):
  2362|         0|            0|            0|  0.00%|    type: Required[Literal['nullable']]
  2363|         0|            0|            0|  0.00%|    schema: Required[CoreSchema]
  2364|         0|            0|            0|  0.00%|    strict: bool
  2365|         0|            0|            0|  0.00%|    ref: str
  2366|         0|            0|            0|  0.00%|    metadata: Any
  2367|         0|            0|            0|  0.00%|    serialization: SerSchema
  2368|         0|            0|            0|  0.00%|
  2369|         0|            0|            0|  0.00%|
  2370|         0|            0|            0|  0.00%|def nullable_schema(
  2371|         0|            0|            0|  0.00%|    schema: CoreSchema,
  2372|         0|            0|            0|  0.00%|    *,
  2373|         0|            0|            0|  0.00%|    strict: bool | None = None,
  2374|         0|            0|            0|  0.00%|    ref: str | None = None,
  2375|         0|            0|            0|  0.00%|    metadata: Any = None,
  2376|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  2377|         0|            0|            0|  0.00%|) -> NullableSchema:
  2378|         0|            0|            0|  0.00%|    """
  2379|         0|            0|            0|  0.00%|    Returns a schema that matches a nullable value, e.g.:
  2380|         0|            0|            0|  0.00%|
  2381|         0|            0|            0|  0.00%|    ```py
  2382|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  2383|         0|            0|            0|  0.00%|
  2384|         0|            0|            0|  0.00%|    schema = core_schema.nullable_schema(core_schema.str_schema())
  2385|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  2386|         0|            0|            0|  0.00%|    assert v.validate_python(None) is None
  2387|         0|            0|            0|  0.00%|    ```
  2388|         0|            0|            0|  0.00%|
  2389|         0|            0|            0|  0.00%|    Args:
  2390|         0|            0|            0|  0.00%|        schema: The schema to wrap
  2391|         0|            0|            0|  0.00%|        strict: Whether the underlying schema should be validated with strict mode
  2392|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  2393|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  2394|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  2395|         0|            0|            0|  0.00%|    """
  2396|         0|            0|            0|  0.00%|    return _dict_not_none(
  2397|         0|            0|            0|  0.00%|        type='nullable', schema=schema, strict=strict, ref=ref, metadata=metadata, serialization=serialization
  2398|         0|            0|            0|  0.00%|    )
  2399|         0|            0|            0|  0.00%|
  2400|         0|            0|            0|  0.00%|
  2401|         0|            0|            0|  0.00%|class UnionSchema(TypedDict, total=False):
  2402|         0|            0|            0|  0.00%|    type: Required[Literal['union']]
  2403|         0|            0|            0|  0.00%|    choices: Required[List[Union[CoreSchema, Tuple[CoreSchema, str]]]]
  2404|         0|            0|            0|  0.00%|    # default true, whether to automatically collapse unions with one element to the inner validator
  2405|         0|            0|            0|  0.00%|    auto_collapse: bool
  2406|         0|            0|            0|  0.00%|    custom_error_type: str
  2407|         0|            0|            0|  0.00%|    custom_error_message: str
  2408|         0|            0|            0|  0.00%|    custom_error_context: Dict[str, Union[str, int, float]]
  2409|         0|            0|            0|  0.00%|    mode: Literal['smart', 'left_to_right']  # default: 'smart'
  2410|         0|            0|            0|  0.00%|    strict: bool
  2411|         0|            0|            0|  0.00%|    ref: str
  2412|         0|            0|            0|  0.00%|    metadata: Any
  2413|         0|            0|            0|  0.00%|    serialization: SerSchema
  2414|         0|            0|            0|  0.00%|
  2415|         0|            0|            0|  0.00%|
  2416|         0|            0|            0|  0.00%|def union_schema(
  2417|         0|            0|            0|  0.00%|    choices: list[CoreSchema | tuple[CoreSchema, str]],
  2418|         0|            0|            0|  0.00%|    *,
  2419|         0|            0|            0|  0.00%|    auto_collapse: bool | None = None,
  2420|         0|            0|            0|  0.00%|    custom_error_type: str | None = None,
  2421|         0|            0|            0|  0.00%|    custom_error_message: str | None = None,
  2422|         0|            0|            0|  0.00%|    custom_error_context: dict[str, str | int] | None = None,
  2423|         0|            0|            0|  0.00%|    mode: Literal['smart', 'left_to_right'] | None = None,
  2424|         0|            0|            0|  0.00%|    strict: bool | None = None,
  2425|         0|            0|            0|  0.00%|    ref: str | None = None,
  2426|         0|            0|            0|  0.00%|    metadata: Any = None,
  2427|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  2428|         0|            0|            0|  0.00%|) -> UnionSchema:
  2429|         0|            0|            0|  0.00%|    """
  2430|         0|            0|            0|  0.00%|    Returns a schema that matches a union value, e.g.:
  2431|         0|            0|            0|  0.00%|
  2432|         0|            0|            0|  0.00%|    ```py
  2433|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  2434|         0|            0|            0|  0.00%|
  2435|         0|            0|            0|  0.00%|    schema = core_schema.union_schema([core_schema.str_schema(), core_schema.int_schema()])
  2436|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  2437|         0|            0|            0|  0.00%|    assert v.validate_python('hello') == 'hello'
  2438|         0|            0|            0|  0.00%|    assert v.validate_python(1) == 1
  2439|         0|            0|            0|  0.00%|    ```
  2440|         0|            0|            0|  0.00%|
  2441|         0|            0|            0|  0.00%|    Args:
  2442|         0|            0|            0|  0.00%|        choices: The schemas to match. If a tuple, the second item is used as the label for the case.
  2443|         0|            0|            0|  0.00%|        auto_collapse: whether to automatically collapse unions with one element to the inner validator, default true
  2444|         0|            0|            0|  0.00%|        custom_error_type: The custom error type to use if the validation fails
  2445|         0|            0|            0|  0.00%|        custom_error_message: The custom error message to use if the validation fails
  2446|         0|            0|            0|  0.00%|        custom_error_context: The custom error context to use if the validation fails
  2447|         0|            0|            0|  0.00%|        mode: How to select which choice to return
  2448|         0|            0|            0|  0.00%|            * `smart` (default) will try to return the choice which is the closest match to the input value
  2449|         0|            0|            0|  0.00%|            * `left_to_right` will return the first choice in `choices` which succeeds validation
  2450|         0|            0|            0|  0.00%|        strict: Whether the underlying schemas should be validated with strict mode
  2451|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  2452|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  2453|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  2454|         0|            0|            0|  0.00%|    """
  2455|         0|            0|            0|  0.00%|    return _dict_not_none(
  2456|         0|            0|            0|  0.00%|        type='union',
  2457|         0|            0|            0|  0.00%|        choices=choices,
  2458|         0|            0|            0|  0.00%|        auto_collapse=auto_collapse,
  2459|         0|            0|            0|  0.00%|        custom_error_type=custom_error_type,
  2460|         0|            0|            0|  0.00%|        custom_error_message=custom_error_message,
  2461|         0|            0|            0|  0.00%|        custom_error_context=custom_error_context,
  2462|         0|            0|            0|  0.00%|        mode=mode,
  2463|         0|            0|            0|  0.00%|        strict=strict,
  2464|         0|            0|            0|  0.00%|        ref=ref,
  2465|         0|            0|            0|  0.00%|        metadata=metadata,
  2466|         0|            0|            0|  0.00%|        serialization=serialization,
  2467|         0|            0|            0|  0.00%|    )
  2468|         0|            0|            0|  0.00%|
  2469|         0|            0|            0|  0.00%|
  2470|         0|            0|            0|  0.00%|class TaggedUnionSchema(TypedDict, total=False):
  2471|         0|            0|            0|  0.00%|    type: Required[Literal['tagged-union']]
  2472|         0|            0|            0|  0.00%|    choices: Required[Dict[Hashable, CoreSchema]]
  2473|         0|            0|            0|  0.00%|    discriminator: Required[Union[str, List[Union[str, int]], List[List[Union[str, int]]], Callable[[Any], Hashable]]]
  2474|         0|            0|            0|  0.00%|    custom_error_type: str
  2475|         0|            0|            0|  0.00%|    custom_error_message: str
  2476|         0|            0|            0|  0.00%|    custom_error_context: Dict[str, Union[str, int, float]]
  2477|         0|            0|            0|  0.00%|    strict: bool
  2478|         0|            0|            0|  0.00%|    from_attributes: bool  # default: True
  2479|         0|            0|            0|  0.00%|    ref: str
  2480|         0|            0|            0|  0.00%|    metadata: Any
  2481|         0|            0|            0|  0.00%|    serialization: SerSchema
  2482|         0|            0|            0|  0.00%|
  2483|         0|            0|            0|  0.00%|
  2484|         0|            0|            0|  0.00%|def tagged_union_schema(
  2485|         0|            0|            0|  0.00%|    choices: Dict[Any, CoreSchema],
  2486|         0|            0|            0|  0.00%|    discriminator: str | list[str | int] | list[list[str | int]] | Callable[[Any], Any],
  2487|         0|            0|            0|  0.00%|    *,
  2488|         0|            0|            0|  0.00%|    custom_error_type: str | None = None,
  2489|         0|            0|            0|  0.00%|    custom_error_message: str | None = None,
  2490|         0|            0|            0|  0.00%|    custom_error_context: dict[str, int | str | float] | None = None,
  2491|         0|            0|            0|  0.00%|    strict: bool | None = None,
  2492|         0|            0|            0|  0.00%|    from_attributes: bool | None = None,
  2493|         0|            0|            0|  0.00%|    ref: str | None = None,
  2494|         0|            0|            0|  0.00%|    metadata: Any = None,
  2495|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  2496|         0|            0|            0|  0.00%|) -> TaggedUnionSchema:
  2497|         0|            0|            0|  0.00%|    """
  2498|         0|            0|            0|  0.00%|    Returns a schema that matches a tagged union value, e.g.:
  2499|         0|            0|            0|  0.00%|
  2500|         0|            0|            0|  0.00%|    ```py
  2501|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  2502|         0|            0|            0|  0.00%|
  2503|         0|            0|            0|  0.00%|    apple_schema = core_schema.typed_dict_schema(
  2504|         0|            0|            0|  0.00%|        {
  2505|         0|            0|            0|  0.00%|            'foo': core_schema.typed_dict_field(core_schema.str_schema()),
  2506|         0|            0|            0|  0.00%|            'bar': core_schema.typed_dict_field(core_schema.int_schema()),
  2507|         0|            0|            0|  0.00%|        }
  2508|         0|            0|            0|  0.00%|    )
  2509|         0|            0|            0|  0.00%|    banana_schema = core_schema.typed_dict_schema(
  2510|         0|            0|            0|  0.00%|        {
  2511|         0|            0|            0|  0.00%|            'foo': core_schema.typed_dict_field(core_schema.str_schema()),
  2512|         0|            0|            0|  0.00%|            'spam': core_schema.typed_dict_field(
  2513|         0|            0|            0|  0.00%|                core_schema.list_schema(items_schema=core_schema.int_schema())
  2514|         0|            0|            0|  0.00%|            ),
  2515|         0|            0|            0|  0.00%|        }
  2516|         0|            0|            0|  0.00%|    )
  2517|         0|            0|            0|  0.00%|    schema = core_schema.tagged_union_schema(
  2518|         0|            0|            0|  0.00%|        choices={
  2519|         0|            0|            0|  0.00%|            'apple': apple_schema,
  2520|         0|            0|            0|  0.00%|            'banana': banana_schema,
  2521|         0|            0|            0|  0.00%|        },
  2522|         0|            0|            0|  0.00%|        discriminator='foo',
  2523|         0|            0|            0|  0.00%|    )
  2524|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  2525|         0|            0|            0|  0.00%|    assert v.validate_python({'foo': 'apple', 'bar': '123'}) == {'foo': 'apple', 'bar': 123}
  2526|         0|            0|            0|  0.00%|    assert v.validate_python({'foo': 'banana', 'spam': [1, 2, 3]}) == {
  2527|         0|            0|            0|  0.00%|        'foo': 'banana',
  2528|         0|            0|            0|  0.00%|        'spam': [1, 2, 3],
  2529|         0|            0|            0|  0.00%|    }
  2530|         0|            0|            0|  0.00%|    ```
  2531|         0|            0|            0|  0.00%|
  2532|         0|            0|            0|  0.00%|    Args:
  2533|         0|            0|            0|  0.00%|        choices: The schemas to match
  2534|         0|            0|            0|  0.00%|            When retrieving a schema from `choices` using the discriminator value, if the value is a str,
  2535|         0|            0|            0|  0.00%|            it should be fed back into the `choices` map until a schema is obtained
  2536|         0|            0|            0|  0.00%|            (This approach is to prevent multiple ownership of a single schema in Rust)
  2537|         0|            0|            0|  0.00%|        discriminator: The discriminator to use to determine the schema to use
  2538|         0|            0|            0|  0.00%|            * If `discriminator` is a str, it is the name of the attribute to use as the discriminator
  2539|         0|            0|            0|  0.00%|            * If `discriminator` is a list of int/str, it should be used as a "path" to access the discriminator
  2540|         0|            0|            0|  0.00%|            * If `discriminator` is a list of lists, each inner list is a path, and the first path that exists is used
  2541|         0|            0|            0|  0.00%|            * If `discriminator` is a callable, it should return the discriminator when called on the value to validate;
  2542|         0|            0|            0|  0.00%|              the callable can return `None` to indicate that there is no matching discriminator present on the input
  2543|         0|            0|            0|  0.00%|        custom_error_type: The custom error type to use if the validation fails
  2544|         0|            0|            0|  0.00%|        custom_error_message: The custom error message to use if the validation fails
  2545|         0|            0|            0|  0.00%|        custom_error_context: The custom error context to use if the validation fails
  2546|         0|            0|            0|  0.00%|        strict: Whether the underlying schemas should be validated with strict mode
  2547|         0|            0|            0|  0.00%|        from_attributes: Whether to use the attributes of the object to retrieve the discriminator value
  2548|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  2549|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  2550|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  2551|         0|            0|            0|  0.00%|    """
  2552|         0|            0|            0|  0.00%|    return _dict_not_none(
  2553|         0|            0|            0|  0.00%|        type='tagged-union',
  2554|         0|            0|            0|  0.00%|        choices=choices,
  2555|         0|            0|            0|  0.00%|        discriminator=discriminator,
  2556|         0|            0|            0|  0.00%|        custom_error_type=custom_error_type,
  2557|         0|            0|            0|  0.00%|        custom_error_message=custom_error_message,
  2558|         0|            0|            0|  0.00%|        custom_error_context=custom_error_context,
  2559|         0|            0|            0|  0.00%|        strict=strict,
  2560|         0|            0|            0|  0.00%|        from_attributes=from_attributes,
  2561|         0|            0|            0|  0.00%|        ref=ref,
  2562|         0|            0|            0|  0.00%|        metadata=metadata,
  2563|         0|            0|            0|  0.00%|        serialization=serialization,
  2564|         0|            0|            0|  0.00%|    )
  2565|         0|            0|            0|  0.00%|
  2566|         0|            0|            0|  0.00%|
  2567|         0|            0|            0|  0.00%|class ChainSchema(TypedDict, total=False):
  2568|         0|            0|            0|  0.00%|    type: Required[Literal['chain']]
  2569|         0|            0|            0|  0.00%|    steps: Required[List[CoreSchema]]
  2570|         0|            0|            0|  0.00%|    ref: str
  2571|         0|            0|            0|  0.00%|    metadata: Any
  2572|         0|            0|            0|  0.00%|    serialization: SerSchema
  2573|         0|            0|            0|  0.00%|
  2574|         0|            0|            0|  0.00%|
  2575|         0|            0|            0|  0.00%|def chain_schema(
  2576|         0|            0|            0|  0.00%|    steps: list[CoreSchema], *, ref: str | None = None, metadata: Any = None, serialization: SerSchema | None = None
  2577|         0|            0|            0|  0.00%|) -> ChainSchema:
  2578|         0|            0|            0|  0.00%|    """
  2579|         0|            0|            0|  0.00%|    Returns a schema that chains the provided validation schemas, e.g.:
  2580|         0|            0|            0|  0.00%|
  2581|         0|            0|            0|  0.00%|    ```py
  2582|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  2583|         0|            0|            0|  0.00%|
  2584|         0|            0|            0|  0.00%|    def fn(v: str, info: core_schema.ValidationInfo) -> str:
  2585|         0|            0|            0|  0.00%|        assert 'hello' in v
  2586|         0|            0|            0|  0.00%|        return v + ' world'
  2587|         0|            0|            0|  0.00%|
  2588|         0|            0|            0|  0.00%|    fn_schema = core_schema.with_info_plain_validator_function(function=fn)
  2589|         0|            0|            0|  0.00%|    schema = core_schema.chain_schema(
  2590|         0|            0|            0|  0.00%|        [fn_schema, fn_schema, fn_schema, core_schema.str_schema()]
  2591|         0|            0|            0|  0.00%|    )
  2592|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  2593|         0|            0|            0|  0.00%|    assert v.validate_python('hello') == 'hello world world world'
  2594|         0|            0|            0|  0.00%|    ```
  2595|         0|            0|            0|  0.00%|
  2596|         0|            0|            0|  0.00%|    Args:
  2597|         0|            0|            0|  0.00%|        steps: The schemas to chain
  2598|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  2599|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  2600|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  2601|         0|            0|            0|  0.00%|    """
  2602|         0|            0|            0|  0.00%|    return _dict_not_none(type='chain', steps=steps, ref=ref, metadata=metadata, serialization=serialization)
  2603|         0|            0|            0|  0.00%|
  2604|         0|            0|            0|  0.00%|
  2605|         0|            0|            0|  0.00%|class LaxOrStrictSchema(TypedDict, total=False):
  2606|         0|            0|            0|  0.00%|    type: Required[Literal['lax-or-strict']]
  2607|         0|            0|            0|  0.00%|    lax_schema: Required[CoreSchema]
  2608|         0|            0|            0|  0.00%|    strict_schema: Required[CoreSchema]
  2609|         0|            0|            0|  0.00%|    strict: bool
  2610|         0|            0|            0|  0.00%|    ref: str
  2611|         0|            0|            0|  0.00%|    metadata: Any
  2612|         0|            0|            0|  0.00%|    serialization: SerSchema
  2613|         0|            0|            0|  0.00%|
  2614|         0|            0|            0|  0.00%|
  2615|         0|            0|            0|  0.00%|def lax_or_strict_schema(
  2616|         0|            0|            0|  0.00%|    lax_schema: CoreSchema,
  2617|         0|            0|            0|  0.00%|    strict_schema: CoreSchema,
  2618|         0|            0|            0|  0.00%|    *,
  2619|         0|            0|            0|  0.00%|    strict: bool | None = None,
  2620|         0|            0|            0|  0.00%|    ref: str | None = None,
  2621|         0|            0|            0|  0.00%|    metadata: Any = None,
  2622|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  2623|         0|            0|            0|  0.00%|) -> LaxOrStrictSchema:
  2624|         0|            0|            0|  0.00%|    """
  2625|         0|            0|            0|  0.00%|    Returns a schema that uses the lax or strict schema, e.g.:
  2626|         0|            0|            0|  0.00%|
  2627|         0|            0|            0|  0.00%|    ```py
  2628|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  2629|         0|            0|            0|  0.00%|
  2630|         0|            0|            0|  0.00%|    def fn(v: str, info: core_schema.ValidationInfo) -> str:
  2631|         0|            0|            0|  0.00%|        assert 'hello' in v
  2632|         0|            0|            0|  0.00%|        return v + ' world'
  2633|         0|            0|            0|  0.00%|
  2634|         0|            0|            0|  0.00%|    lax_schema = core_schema.int_schema(strict=False)
  2635|         0|            0|            0|  0.00%|    strict_schema = core_schema.int_schema(strict=True)
  2636|         0|            0|            0|  0.00%|
  2637|         0|            0|            0|  0.00%|    schema = core_schema.lax_or_strict_schema(
  2638|         0|            0|            0|  0.00%|        lax_schema=lax_schema, strict_schema=strict_schema, strict=True
  2639|         0|            0|            0|  0.00%|    )
  2640|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  2641|         0|            0|            0|  0.00%|    assert v.validate_python(123) == 123
  2642|         0|            0|            0|  0.00%|
  2643|         0|            0|            0|  0.00%|    schema = core_schema.lax_or_strict_schema(
  2644|         0|            0|            0|  0.00%|        lax_schema=lax_schema, strict_schema=strict_schema, strict=False
  2645|         0|            0|            0|  0.00%|    )
  2646|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  2647|         0|            0|            0|  0.00%|    assert v.validate_python('123') == 123
  2648|         0|            0|            0|  0.00%|    ```
  2649|         0|            0|            0|  0.00%|
  2650|         0|            0|            0|  0.00%|    Args:
  2651|         0|            0|            0|  0.00%|        lax_schema: The lax schema to use
  2652|         0|            0|            0|  0.00%|        strict_schema: The strict schema to use
  2653|         0|            0|            0|  0.00%|        strict: Whether the strict schema should be used
  2654|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  2655|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  2656|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  2657|         0|            0|            0|  0.00%|    """
  2658|         0|            0|            0|  0.00%|    return _dict_not_none(
  2659|         0|            0|            0|  0.00%|        type='lax-or-strict',
  2660|         0|            0|            0|  0.00%|        lax_schema=lax_schema,
  2661|         0|            0|            0|  0.00%|        strict_schema=strict_schema,
  2662|         0|            0|            0|  0.00%|        strict=strict,
  2663|         0|            0|            0|  0.00%|        ref=ref,
  2664|         0|            0|            0|  0.00%|        metadata=metadata,
  2665|         0|            0|            0|  0.00%|        serialization=serialization,
  2666|         0|            0|            0|  0.00%|    )
  2667|         0|            0|            0|  0.00%|
  2668|         0|            0|            0|  0.00%|
  2669|         0|            0|            0|  0.00%|class JsonOrPythonSchema(TypedDict, total=False):
  2670|         0|            0|            0|  0.00%|    type: Required[Literal['json-or-python']]
  2671|         0|            0|            0|  0.00%|    json_schema: Required[CoreSchema]
  2672|         0|            0|            0|  0.00%|    python_schema: Required[CoreSchema]
  2673|         0|            0|            0|  0.00%|    ref: str
  2674|         0|            0|            0|  0.00%|    metadata: Any
  2675|         0|            0|            0|  0.00%|    serialization: SerSchema
  2676|         0|            0|            0|  0.00%|
  2677|         0|            0|            0|  0.00%|
  2678|         0|            0|            0|  0.00%|def json_or_python_schema(
  2679|         0|            0|            0|  0.00%|    json_schema: CoreSchema,
  2680|         0|            0|            0|  0.00%|    python_schema: CoreSchema,
  2681|         0|            0|            0|  0.00%|    *,
  2682|         0|            0|            0|  0.00%|    ref: str | None = None,
  2683|         0|            0|            0|  0.00%|    metadata: Any = None,
  2684|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  2685|         0|            0|            0|  0.00%|) -> JsonOrPythonSchema:
  2686|         0|            0|            0|  0.00%|    """
  2687|         0|            0|            0|  0.00%|    Returns a schema that uses the Json or Python schema depending on the input:
  2688|         0|            0|            0|  0.00%|
  2689|         0|            0|            0|  0.00%|    ```py
  2690|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, ValidationError, core_schema
  2691|         0|            0|            0|  0.00%|
  2692|         0|            0|            0|  0.00%|    v = SchemaValidator(
  2693|         0|            0|            0|  0.00%|        core_schema.json_or_python_schema(
  2694|         0|            0|            0|  0.00%|            json_schema=core_schema.int_schema(),
  2695|         0|            0|            0|  0.00%|            python_schema=core_schema.int_schema(strict=True),
  2696|         0|            0|            0|  0.00%|        )
  2697|         0|            0|            0|  0.00%|    )
  2698|         0|            0|            0|  0.00%|
  2699|         0|            0|            0|  0.00%|    assert v.validate_json('"123"') == 123
  2700|         0|            0|            0|  0.00%|
  2701|         0|            0|            0|  0.00%|    try:
  2702|         0|            0|            0|  0.00%|        v.validate_python('123')
  2703|         0|            0|            0|  0.00%|    except ValidationError:
  2704|         0|            0|            0|  0.00%|        pass
  2705|         0|            0|            0|  0.00%|    else:
  2706|         0|            0|            0|  0.00%|        raise AssertionError('Validation should have failed')
  2707|         0|            0|            0|  0.00%|    ```
  2708|         0|            0|            0|  0.00%|
  2709|         0|            0|            0|  0.00%|    Args:
  2710|         0|            0|            0|  0.00%|        json_schema: The schema to use for Json inputs
  2711|         0|            0|            0|  0.00%|        python_schema: The schema to use for Python inputs
  2712|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  2713|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  2714|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  2715|         0|            0|            0|  0.00%|    """
  2716|         0|            0|            0|  0.00%|    return _dict_not_none(
  2717|         0|            0|            0|  0.00%|        type='json-or-python',
  2718|         0|            0|            0|  0.00%|        json_schema=json_schema,
  2719|         0|            0|            0|  0.00%|        python_schema=python_schema,
  2720|         0|            0|            0|  0.00%|        ref=ref,
  2721|         0|            0|            0|  0.00%|        metadata=metadata,
  2722|         0|            0|            0|  0.00%|        serialization=serialization,
  2723|         0|            0|            0|  0.00%|    )
  2724|         0|            0|            0|  0.00%|
  2725|         0|            0|            0|  0.00%|
  2726|         0|            0|            0|  0.00%|class TypedDictField(TypedDict, total=False):
  2727|         0|            0|            0|  0.00%|    type: Required[Literal['typed-dict-field']]
  2728|         0|            0|            0|  0.00%|    schema: Required[CoreSchema]
  2729|         0|            0|            0|  0.00%|    required: bool
  2730|         0|            0|            0|  0.00%|    validation_alias: Union[str, List[Union[str, int]], List[List[Union[str, int]]]]
  2731|         0|            0|            0|  0.00%|    serialization_alias: str
  2732|         0|            0|            0|  0.00%|    serialization_exclude: bool  # default: False
  2733|         0|            0|            0|  0.00%|    metadata: Any
  2734|         0|            0|            0|  0.00%|
  2735|         0|            0|            0|  0.00%|
  2736|         0|            0|            0|  0.00%|def typed_dict_field(
  2737|         0|            0|            0|  0.00%|    schema: CoreSchema,
  2738|         0|            0|            0|  0.00%|    *,
  2739|         0|            0|            0|  0.00%|    required: bool | None = None,
  2740|         0|            0|            0|  0.00%|    validation_alias: str | list[str | int] | list[list[str | int]] | None = None,
  2741|         0|            0|            0|  0.00%|    serialization_alias: str | None = None,
  2742|         0|            0|            0|  0.00%|    serialization_exclude: bool | None = None,
  2743|         0|            0|            0|  0.00%|    metadata: Any = None,
  2744|         0|            0|            0|  0.00%|) -> TypedDictField:
  2745|         0|            0|            0|  0.00%|    """
  2746|         0|            0|            0|  0.00%|    Returns a schema that matches a typed dict field, e.g.:
  2747|         0|            0|            0|  0.00%|
  2748|         0|            0|            0|  0.00%|    ```py
  2749|         0|            0|            0|  0.00%|    from pydantic_core import core_schema
  2750|         0|            0|            0|  0.00%|
  2751|         0|            0|            0|  0.00%|    field = core_schema.typed_dict_field(schema=core_schema.int_schema(), required=True)
  2752|         0|            0|            0|  0.00%|    ```
  2753|         0|            0|            0|  0.00%|
  2754|         0|            0|            0|  0.00%|    Args:
  2755|         0|            0|            0|  0.00%|        schema: The schema to use for the field
  2756|         0|            0|            0|  0.00%|        required: Whether the field is required
  2757|         0|            0|            0|  0.00%|        validation_alias: The alias(es) to use to find the field in the validation data
  2758|         0|            0|            0|  0.00%|        serialization_alias: The alias to use as a key when serializing
  2759|         0|            0|            0|  0.00%|        serialization_exclude: Whether to exclude the field when serializing
  2760|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  2761|         0|            0|            0|  0.00%|    """
  2762|         0|            0|            0|  0.00%|    return _dict_not_none(
  2763|         0|            0|            0|  0.00%|        type='typed-dict-field',
  2764|         0|            0|            0|  0.00%|        schema=schema,
  2765|         0|            0|            0|  0.00%|        required=required,
  2766|         0|            0|            0|  0.00%|        validation_alias=validation_alias,
  2767|         0|            0|            0|  0.00%|        serialization_alias=serialization_alias,
  2768|         0|            0|            0|  0.00%|        serialization_exclude=serialization_exclude,
  2769|         0|            0|            0|  0.00%|        metadata=metadata,
  2770|         0|            0|            0|  0.00%|    )
  2771|         0|            0|            0|  0.00%|
  2772|         0|            0|            0|  0.00%|
  2773|         0|            0|            0|  0.00%|class TypedDictSchema(TypedDict, total=False):
  2774|         0|            0|            0|  0.00%|    type: Required[Literal['typed-dict']]
  2775|         0|            0|            0|  0.00%|    fields: Required[Dict[str, TypedDictField]]
  2776|         0|            0|            0|  0.00%|    computed_fields: List[ComputedField]
  2777|         0|            0|            0|  0.00%|    strict: bool
  2778|         0|            0|            0|  0.00%|    extras_schema: CoreSchema
  2779|         0|            0|            0|  0.00%|    # all these values can be set via config, equivalent fields have `typed_dict_` prefix
  2780|         0|            0|            0|  0.00%|    extra_behavior: ExtraBehavior
  2781|         0|            0|            0|  0.00%|    total: bool  # default: True
  2782|         0|            0|            0|  0.00%|    populate_by_name: bool  # replaces `allow_population_by_field_name` in pydantic v1
  2783|         0|            0|            0|  0.00%|    ref: str
  2784|         0|            0|            0|  0.00%|    metadata: Any
  2785|         0|            0|            0|  0.00%|    serialization: SerSchema
  2786|         0|            0|            0|  0.00%|    config: CoreConfig
  2787|         0|            0|            0|  0.00%|
  2788|         0|            0|            0|  0.00%|
  2789|         0|            0|            0|  0.00%|def typed_dict_schema(
  2790|         0|            0|            0|  0.00%|    fields: Dict[str, TypedDictField],
  2791|         0|            0|            0|  0.00%|    *,
  2792|         0|            0|            0|  0.00%|    computed_fields: list[ComputedField] | None = None,
  2793|         0|            0|            0|  0.00%|    strict: bool | None = None,
  2794|         0|            0|            0|  0.00%|    extras_schema: CoreSchema | None = None,
  2795|         0|            0|            0|  0.00%|    extra_behavior: ExtraBehavior | None = None,
  2796|         0|            0|            0|  0.00%|    total: bool | None = None,
  2797|         0|            0|            0|  0.00%|    populate_by_name: bool | None = None,
  2798|         0|            0|            0|  0.00%|    ref: str | None = None,
  2799|         0|            0|            0|  0.00%|    metadata: Any = None,
  2800|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  2801|         0|            0|            0|  0.00%|    config: CoreConfig | None = None,
  2802|         0|            0|            0|  0.00%|) -> TypedDictSchema:
  2803|         0|            0|            0|  0.00%|    """
  2804|         0|            0|            0|  0.00%|    Returns a schema that matches a typed dict, e.g.:
  2805|         0|            0|            0|  0.00%|
  2806|         0|            0|            0|  0.00%|    ```py
  2807|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  2808|         0|            0|            0|  0.00%|
  2809|         0|            0|            0|  0.00%|    wrapper_schema = core_schema.typed_dict_schema(
  2810|         0|            0|            0|  0.00%|        {'a': core_schema.typed_dict_field(core_schema.str_schema())}
  2811|         0|            0|            0|  0.00%|    )
  2812|         0|            0|            0|  0.00%|    v = SchemaValidator(wrapper_schema)
  2813|         0|            0|            0|  0.00%|    assert v.validate_python({'a': 'hello'}) == {'a': 'hello'}
  2814|         0|            0|            0|  0.00%|    ```
  2815|         0|            0|            0|  0.00%|
  2816|         0|            0|            0|  0.00%|    Args:
  2817|         0|            0|            0|  0.00%|        fields: The fields to use for the typed dict
  2818|         0|            0|            0|  0.00%|        computed_fields: Computed fields to use when serializing the model, only applies when directly inside a model
  2819|         0|            0|            0|  0.00%|        strict: Whether the typed dict is strict
  2820|         0|            0|            0|  0.00%|        extras_schema: The extra validator to use for the typed dict
  2821|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  2822|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  2823|         0|            0|            0|  0.00%|        extra_behavior: The extra behavior to use for the typed dict
  2824|         0|            0|            0|  0.00%|        total: Whether the typed dict is total
  2825|         0|            0|            0|  0.00%|        populate_by_name: Whether the typed dict should populate by name
  2826|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  2827|         0|            0|            0|  0.00%|    """
  2828|         0|            0|            0|  0.00%|    return _dict_not_none(
  2829|         0|            0|            0|  0.00%|        type='typed-dict',
  2830|         0|            0|            0|  0.00%|        fields=fields,
  2831|         0|            0|            0|  0.00%|        computed_fields=computed_fields,
  2832|         0|            0|            0|  0.00%|        strict=strict,
  2833|         0|            0|            0|  0.00%|        extras_schema=extras_schema,
  2834|         0|            0|            0|  0.00%|        extra_behavior=extra_behavior,
  2835|         0|            0|            0|  0.00%|        total=total,
  2836|         0|            0|            0|  0.00%|        populate_by_name=populate_by_name,
  2837|         0|            0|            0|  0.00%|        ref=ref,
  2838|         0|            0|            0|  0.00%|        metadata=metadata,
  2839|         0|            0|            0|  0.00%|        serialization=serialization,
  2840|         0|            0|            0|  0.00%|        config=config,
  2841|         0|            0|            0|  0.00%|    )
  2842|         0|            0|            0|  0.00%|
  2843|         0|            0|            0|  0.00%|
  2844|         0|            0|            0|  0.00%|class ModelField(TypedDict, total=False):
  2845|         0|            0|            0|  0.00%|    type: Required[Literal['model-field']]
  2846|         0|            0|            0|  0.00%|    schema: Required[CoreSchema]
  2847|         0|            0|            0|  0.00%|    validation_alias: Union[str, List[Union[str, int]], List[List[Union[str, int]]]]
  2848|         0|            0|            0|  0.00%|    serialization_alias: str
  2849|         0|            0|            0|  0.00%|    serialization_exclude: bool  # default: False
  2850|         0|            0|            0|  0.00%|    frozen: bool
  2851|         0|            0|            0|  0.00%|    metadata: Any
  2852|         0|            0|            0|  0.00%|
  2853|         0|            0|            0|  0.00%|
  2854|         0|            0|            0|  0.00%|def model_field(
  2855|         0|            0|            0|  0.00%|    schema: CoreSchema,
  2856|         0|            0|            0|  0.00%|    *,
  2857|         0|            0|            0|  0.00%|    validation_alias: str | list[str | int] | list[list[str | int]] | None = None,
  2858|         0|            0|            0|  0.00%|    serialization_alias: str | None = None,
  2859|         0|            0|            0|  0.00%|    serialization_exclude: bool | None = None,
  2860|         0|            0|            0|  0.00%|    frozen: bool | None = None,
  2861|         0|            0|            0|  0.00%|    metadata: Any = None,
  2862|         0|            0|            0|  0.00%|) -> ModelField:
  2863|         0|            0|            0|  0.00%|    """
  2864|         0|            0|            0|  0.00%|    Returns a schema for a model field, e.g.:
  2865|         0|            0|            0|  0.00%|
  2866|         0|            0|            0|  0.00%|    ```py
  2867|         0|            0|            0|  0.00%|    from pydantic_core import core_schema
  2868|         0|            0|            0|  0.00%|
  2869|         0|            0|            0|  0.00%|    field = core_schema.model_field(schema=core_schema.int_schema())
  2870|         0|            0|            0|  0.00%|    ```
  2871|         0|            0|            0|  0.00%|
  2872|         0|            0|            0|  0.00%|    Args:
  2873|         0|            0|            0|  0.00%|        schema: The schema to use for the field
  2874|         0|            0|            0|  0.00%|        validation_alias: The alias(es) to use to find the field in the validation data
  2875|         0|            0|            0|  0.00%|        serialization_alias: The alias to use as a key when serializing
  2876|         0|            0|            0|  0.00%|        serialization_exclude: Whether to exclude the field when serializing
  2877|         0|            0|            0|  0.00%|        frozen: Whether the field is frozen
  2878|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  2879|         0|            0|            0|  0.00%|    """
  2880|         0|            0|            0|  0.00%|    return _dict_not_none(
  2881|         0|            0|            0|  0.00%|        type='model-field',
  2882|         0|            0|            0|  0.00%|        schema=schema,
  2883|         0|            0|            0|  0.00%|        validation_alias=validation_alias,
  2884|         0|            0|            0|  0.00%|        serialization_alias=serialization_alias,
  2885|         0|            0|            0|  0.00%|        serialization_exclude=serialization_exclude,
  2886|         0|            0|            0|  0.00%|        frozen=frozen,
  2887|         0|            0|            0|  0.00%|        metadata=metadata,
  2888|         0|            0|            0|  0.00%|    )
  2889|         0|            0|            0|  0.00%|
  2890|         0|            0|            0|  0.00%|
  2891|         0|            0|            0|  0.00%|class ModelFieldsSchema(TypedDict, total=False):
  2892|         0|            0|            0|  0.00%|    type: Required[Literal['model-fields']]
  2893|         0|            0|            0|  0.00%|    fields: Required[Dict[str, ModelField]]
  2894|         0|            0|            0|  0.00%|    model_name: str
  2895|         0|            0|            0|  0.00%|    computed_fields: List[ComputedField]
  2896|         0|            0|            0|  0.00%|    strict: bool
  2897|         0|            0|            0|  0.00%|    extras_schema: CoreSchema
  2898|         0|            0|            0|  0.00%|    # all these values can be set via config, equivalent fields have `typed_dict_` prefix
  2899|         0|            0|            0|  0.00%|    extra_behavior: ExtraBehavior
  2900|         0|            0|            0|  0.00%|    populate_by_name: bool  # replaces `allow_population_by_field_name` in pydantic v1
  2901|         0|            0|            0|  0.00%|    from_attributes: bool
  2902|         0|            0|            0|  0.00%|    ref: str
  2903|         0|            0|            0|  0.00%|    metadata: Any
  2904|         0|            0|            0|  0.00%|    serialization: SerSchema
  2905|         0|            0|            0|  0.00%|
  2906|         0|            0|            0|  0.00%|
  2907|         0|            0|            0|  0.00%|def model_fields_schema(
  2908|         0|            0|            0|  0.00%|    fields: Dict[str, ModelField],
  2909|         0|            0|            0|  0.00%|    *,
  2910|         0|            0|            0|  0.00%|    model_name: str | None = None,
  2911|         0|            0|            0|  0.00%|    computed_fields: list[ComputedField] | None = None,
  2912|         0|            0|            0|  0.00%|    strict: bool | None = None,
  2913|         0|            0|            0|  0.00%|    extras_schema: CoreSchema | None = None,
  2914|         0|            0|            0|  0.00%|    extra_behavior: ExtraBehavior | None = None,
  2915|         0|            0|            0|  0.00%|    populate_by_name: bool | None = None,
  2916|         0|            0|            0|  0.00%|    from_attributes: bool | None = None,
  2917|         0|            0|            0|  0.00%|    ref: str | None = None,
  2918|         0|            0|            0|  0.00%|    metadata: Any = None,
  2919|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  2920|         0|            0|            0|  0.00%|) -> ModelFieldsSchema:
  2921|         0|            0|            0|  0.00%|    """
  2922|         0|            0|            0|  0.00%|    Returns a schema that matches a typed dict, e.g.:
  2923|         0|            0|            0|  0.00%|
  2924|         0|            0|            0|  0.00%|    ```py
  2925|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  2926|         0|            0|            0|  0.00%|
  2927|         0|            0|            0|  0.00%|    wrapper_schema = core_schema.model_fields_schema(
  2928|         0|            0|            0|  0.00%|        {'a': core_schema.model_field(core_schema.str_schema())}
  2929|         0|            0|            0|  0.00%|    )
  2930|         0|            0|            0|  0.00%|    v = SchemaValidator(wrapper_schema)
  2931|         0|            0|            0|  0.00%|    print(v.validate_python({'a': 'hello'}))
  2932|         0|            0|            0|  0.00%|    #> ({'a': 'hello'}, None, {'a'})
  2933|         0|            0|            0|  0.00%|    ```
  2934|         0|            0|            0|  0.00%|
  2935|         0|            0|            0|  0.00%|    Args:
  2936|         0|            0|            0|  0.00%|        fields: The fields to use for the typed dict
  2937|         0|            0|            0|  0.00%|        model_name: The name of the model, used for error messages, defaults to "Model"
  2938|         0|            0|            0|  0.00%|        computed_fields: Computed fields to use when serializing the model, only applies when directly inside a model
  2939|         0|            0|            0|  0.00%|        strict: Whether the typed dict is strict
  2940|         0|            0|            0|  0.00%|        extras_schema: The extra validator to use for the typed dict
  2941|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  2942|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  2943|         0|            0|            0|  0.00%|        extra_behavior: The extra behavior to use for the typed dict
  2944|         0|            0|            0|  0.00%|        populate_by_name: Whether the typed dict should populate by name
  2945|         0|            0|            0|  0.00%|        from_attributes: Whether the typed dict should be populated from attributes
  2946|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  2947|         0|            0|            0|  0.00%|    """
  2948|         0|            0|            0|  0.00%|    return _dict_not_none(
  2949|         0|            0|            0|  0.00%|        type='model-fields',
  2950|         0|            0|            0|  0.00%|        fields=fields,
  2951|         0|            0|            0|  0.00%|        model_name=model_name,
  2952|         0|            0|            0|  0.00%|        computed_fields=computed_fields,
  2953|         0|            0|            0|  0.00%|        strict=strict,
  2954|         0|            0|            0|  0.00%|        extras_schema=extras_schema,
  2955|         0|            0|            0|  0.00%|        extra_behavior=extra_behavior,
  2956|         0|            0|            0|  0.00%|        populate_by_name=populate_by_name,
  2957|         0|            0|            0|  0.00%|        from_attributes=from_attributes,
  2958|         0|            0|            0|  0.00%|        ref=ref,
  2959|         0|            0|            0|  0.00%|        metadata=metadata,
  2960|         0|            0|            0|  0.00%|        serialization=serialization,
  2961|         0|            0|            0|  0.00%|    )
  2962|         0|            0|            0|  0.00%|
  2963|         0|            0|            0|  0.00%|
  2964|         0|            0|            0|  0.00%|class ModelSchema(TypedDict, total=False):
  2965|         0|            0|            0|  0.00%|    type: Required[Literal['model']]
  2966|         0|            0|            0|  0.00%|    cls: Required[Type[Any]]
  2967|         0|            0|            0|  0.00%|    schema: Required[CoreSchema]
  2968|         0|            0|            0|  0.00%|    custom_init: bool
  2969|         0|            0|            0|  0.00%|    root_model: bool
  2970|         0|            0|            0|  0.00%|    post_init: str
  2971|         0|            0|            0|  0.00%|    revalidate_instances: Literal['always', 'never', 'subclass-instances']  # default: 'never'
  2972|         0|            0|            0|  0.00%|    strict: bool
  2973|         0|            0|            0|  0.00%|    frozen: bool
  2974|         0|            0|            0|  0.00%|    extra_behavior: ExtraBehavior
  2975|         0|            0|            0|  0.00%|    config: CoreConfig
  2976|         0|            0|            0|  0.00%|    ref: str
  2977|         0|            0|            0|  0.00%|    metadata: Any
  2978|         0|            0|            0|  0.00%|    serialization: SerSchema
  2979|         0|            0|            0|  0.00%|
  2980|         0|            0|            0|  0.00%|
  2981|         0|            0|            0|  0.00%|def model_schema(
  2982|         0|            0|            0|  0.00%|    cls: Type[Any],
  2983|         0|            0|            0|  0.00%|    schema: CoreSchema,
  2984|         0|            0|            0|  0.00%|    *,
  2985|         0|            0|            0|  0.00%|    custom_init: bool | None = None,
  2986|         0|            0|            0|  0.00%|    root_model: bool | None = None,
  2987|         0|            0|            0|  0.00%|    post_init: str | None = None,
  2988|         0|            0|            0|  0.00%|    revalidate_instances: Literal['always', 'never', 'subclass-instances'] | None = None,
  2989|         0|            0|            0|  0.00%|    strict: bool | None = None,
  2990|         0|            0|            0|  0.00%|    frozen: bool | None = None,
  2991|         0|            0|            0|  0.00%|    extra_behavior: ExtraBehavior | None = None,
  2992|         0|            0|            0|  0.00%|    config: CoreConfig | None = None,
  2993|         0|            0|            0|  0.00%|    ref: str | None = None,
  2994|         0|            0|            0|  0.00%|    metadata: Any = None,
  2995|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  2996|         0|            0|            0|  0.00%|) -> ModelSchema:
  2997|         0|            0|            0|  0.00%|    """
  2998|         0|            0|            0|  0.00%|    A model schema generally contains a typed-dict schema.
  2999|         0|            0|            0|  0.00%|    It will run the typed dict validator, then create a new class
  3000|         0|            0|            0|  0.00%|    and set the dict and fields set returned from the typed dict validator
  3001|         0|            0|            0|  0.00%|    to `__dict__` and `__pydantic_fields_set__` respectively.
  3002|         0|            0|            0|  0.00%|
  3003|         0|            0|            0|  0.00%|    Example:
  3004|         0|            0|            0|  0.00%|
  3005|         0|            0|            0|  0.00%|    ```py
  3006|         0|            0|            0|  0.00%|    from pydantic_core import CoreConfig, SchemaValidator, core_schema
  3007|         0|            0|            0|  0.00%|
  3008|         0|            0|            0|  0.00%|    class MyModel:
  3009|         0|            0|            0|  0.00%|        __slots__ = (
  3010|         0|            0|            0|  0.00%|            '__dict__',
  3011|         0|            0|            0|  0.00%|            '__pydantic_fields_set__',
  3012|         0|            0|            0|  0.00%|            '__pydantic_extra__',
  3013|         0|            0|            0|  0.00%|            '__pydantic_private__',
  3014|         0|            0|            0|  0.00%|        )
  3015|         0|            0|            0|  0.00%|
  3016|         0|            0|            0|  0.00%|    schema = core_schema.model_schema(
  3017|         0|            0|            0|  0.00%|        cls=MyModel,
  3018|         0|            0|            0|  0.00%|        config=CoreConfig(str_max_length=5),
  3019|         0|            0|            0|  0.00%|        schema=core_schema.model_fields_schema(
  3020|         0|            0|            0|  0.00%|            fields={'a': core_schema.model_field(core_schema.str_schema())},
  3021|         0|            0|            0|  0.00%|        ),
  3022|         0|            0|            0|  0.00%|    )
  3023|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  3024|         0|            0|            0|  0.00%|    assert v.isinstance_python({'a': 'hello'}) is True
  3025|         0|            0|            0|  0.00%|    assert v.isinstance_python({'a': 'too long'}) is False
  3026|         0|            0|            0|  0.00%|    ```
  3027|         0|            0|            0|  0.00%|
  3028|         0|            0|            0|  0.00%|    Args:
  3029|         0|            0|            0|  0.00%|        cls: The class to use for the model
  3030|         0|            0|            0|  0.00%|        schema: The schema to use for the model
  3031|         0|            0|            0|  0.00%|        custom_init: Whether the model has a custom init method
  3032|         0|            0|            0|  0.00%|        root_model: Whether the model is a `RootModel`
  3033|         0|            0|            0|  0.00%|        post_init: The call after init to use for the model
  3034|         0|            0|            0|  0.00%|        revalidate_instances: whether instances of models and dataclasses (including subclass instances)
  3035|         0|            0|            0|  0.00%|            should re-validate defaults to config.revalidate_instances, else 'never'
  3036|         0|            0|            0|  0.00%|        strict: Whether the model is strict
  3037|         0|            0|            0|  0.00%|        frozen: Whether the model is frozen
  3038|         0|            0|            0|  0.00%|        extra_behavior: The extra behavior to use for the model, used in serialization
  3039|         0|            0|            0|  0.00%|        config: The config to use for the model
  3040|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  3041|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  3042|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  3043|         0|            0|            0|  0.00%|    """
  3044|         0|            0|            0|  0.00%|    return _dict_not_none(
  3045|         0|            0|            0|  0.00%|        type='model',
  3046|         0|            0|            0|  0.00%|        cls=cls,
  3047|         0|            0|            0|  0.00%|        schema=schema,
  3048|         0|            0|            0|  0.00%|        custom_init=custom_init,
  3049|         0|            0|            0|  0.00%|        root_model=root_model,
  3050|         0|            0|            0|  0.00%|        post_init=post_init,
  3051|         0|            0|            0|  0.00%|        revalidate_instances=revalidate_instances,
  3052|         0|            0|            0|  0.00%|        strict=strict,
  3053|         0|            0|            0|  0.00%|        frozen=frozen,
  3054|         0|            0|            0|  0.00%|        extra_behavior=extra_behavior,
  3055|         0|            0|            0|  0.00%|        config=config,
  3056|         0|            0|            0|  0.00%|        ref=ref,
  3057|         0|            0|            0|  0.00%|        metadata=metadata,
  3058|         0|            0|            0|  0.00%|        serialization=serialization,
  3059|         0|            0|            0|  0.00%|    )
  3060|         0|            0|            0|  0.00%|
  3061|         0|            0|            0|  0.00%|
  3062|         0|            0|            0|  0.00%|class DataclassField(TypedDict, total=False):
  3063|         0|            0|            0|  0.00%|    type: Required[Literal['dataclass-field']]
  3064|         0|            0|            0|  0.00%|    name: Required[str]
  3065|         0|            0|            0|  0.00%|    schema: Required[CoreSchema]
  3066|         0|            0|            0|  0.00%|    kw_only: bool  # default: True
  3067|         0|            0|            0|  0.00%|    init: bool  # default: True
  3068|         0|            0|            0|  0.00%|    init_only: bool  # default: False
  3069|         0|            0|            0|  0.00%|    frozen: bool  # default: False
  3070|         0|            0|            0|  0.00%|    validation_alias: Union[str, List[Union[str, int]], List[List[Union[str, int]]]]
  3071|         0|            0|            0|  0.00%|    serialization_alias: str
  3072|         0|            0|            0|  0.00%|    serialization_exclude: bool  # default: False
  3073|         0|            0|            0|  0.00%|    metadata: Any
  3074|         0|            0|            0|  0.00%|
  3075|         0|            0|            0|  0.00%|
  3076|         0|            0|            0|  0.00%|def dataclass_field(
  3077|         0|            0|            0|  0.00%|    name: str,
  3078|         0|            0|            0|  0.00%|    schema: CoreSchema,
  3079|         0|            0|            0|  0.00%|    *,
  3080|         0|            0|            0|  0.00%|    kw_only: bool | None = None,
  3081|         0|            0|            0|  0.00%|    init: bool | None = None,
  3082|         0|            0|            0|  0.00%|    init_only: bool | None = None,
  3083|         0|            0|            0|  0.00%|    validation_alias: str | list[str | int] | list[list[str | int]] | None = None,
  3084|         0|            0|            0|  0.00%|    serialization_alias: str | None = None,
  3085|         0|            0|            0|  0.00%|    serialization_exclude: bool | None = None,
  3086|         0|            0|            0|  0.00%|    metadata: Any = None,
  3087|         0|            0|            0|  0.00%|    frozen: bool | None = None,
  3088|         0|            0|            0|  0.00%|) -> DataclassField:
  3089|         0|            0|            0|  0.00%|    """
  3090|         0|            0|            0|  0.00%|    Returns a schema for a dataclass field, e.g.:
  3091|         0|            0|            0|  0.00%|
  3092|         0|            0|            0|  0.00%|    ```py
  3093|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  3094|         0|            0|            0|  0.00%|
  3095|         0|            0|            0|  0.00%|    field = core_schema.dataclass_field(
  3096|         0|            0|            0|  0.00%|        name='a', schema=core_schema.str_schema(), kw_only=False
  3097|         0|            0|            0|  0.00%|    )
  3098|         0|            0|            0|  0.00%|    schema = core_schema.dataclass_args_schema('Foobar', [field])
  3099|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  3100|         0|            0|            0|  0.00%|    assert v.validate_python({'a': 'hello'}) == ({'a': 'hello'}, None)
  3101|         0|            0|            0|  0.00%|    ```
  3102|         0|            0|            0|  0.00%|
  3103|         0|            0|            0|  0.00%|    Args:
  3104|         0|            0|            0|  0.00%|        name: The name to use for the argument parameter
  3105|         0|            0|            0|  0.00%|        schema: The schema to use for the argument parameter
  3106|         0|            0|            0|  0.00%|        kw_only: Whether the field can be set with a positional argument as well as a keyword argument
  3107|         0|            0|            0|  0.00%|        init: Whether the field should be validated during initialization
  3108|         0|            0|            0|  0.00%|        init_only: Whether the field should be omitted  from `__dict__` and passed to `__post_init__`
  3109|         0|            0|            0|  0.00%|        validation_alias: The alias(es) to use to find the field in the validation data
  3110|         0|            0|            0|  0.00%|        serialization_alias: The alias to use as a key when serializing
  3111|         0|            0|            0|  0.00%|        serialization_exclude: Whether to exclude the field when serializing
  3112|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  3113|         0|            0|            0|  0.00%|        frozen: Whether the field is frozen
  3114|         0|            0|            0|  0.00%|    """
  3115|         0|            0|            0|  0.00%|    return _dict_not_none(
  3116|         0|            0|            0|  0.00%|        type='dataclass-field',
  3117|         0|            0|            0|  0.00%|        name=name,
  3118|         0|            0|            0|  0.00%|        schema=schema,
  3119|         0|            0|            0|  0.00%|        kw_only=kw_only,
  3120|         0|            0|            0|  0.00%|        init=init,
  3121|         0|            0|            0|  0.00%|        init_only=init_only,
  3122|         0|            0|            0|  0.00%|        validation_alias=validation_alias,
  3123|         0|            0|            0|  0.00%|        serialization_alias=serialization_alias,
  3124|         0|            0|            0|  0.00%|        serialization_exclude=serialization_exclude,
  3125|         0|            0|            0|  0.00%|        metadata=metadata,
  3126|         0|            0|            0|  0.00%|        frozen=frozen,
  3127|         0|            0|            0|  0.00%|    )
  3128|         0|            0|            0|  0.00%|
  3129|         0|            0|            0|  0.00%|
  3130|         0|            0|            0|  0.00%|class DataclassArgsSchema(TypedDict, total=False):
  3131|         0|            0|            0|  0.00%|    type: Required[Literal['dataclass-args']]
  3132|         0|            0|            0|  0.00%|    dataclass_name: Required[str]
  3133|         0|            0|            0|  0.00%|    fields: Required[List[DataclassField]]
  3134|         0|            0|            0|  0.00%|    computed_fields: List[ComputedField]
  3135|         0|            0|            0|  0.00%|    populate_by_name: bool  # default: False
  3136|         0|            0|            0|  0.00%|    collect_init_only: bool  # default: False
  3137|         0|            0|            0|  0.00%|    ref: str
  3138|         0|            0|            0|  0.00%|    metadata: Any
  3139|         0|            0|            0|  0.00%|    serialization: SerSchema
  3140|         0|            0|            0|  0.00%|    extra_behavior: ExtraBehavior
  3141|         0|            0|            0|  0.00%|
  3142|         0|            0|            0|  0.00%|
  3143|         0|            0|            0|  0.00%|def dataclass_args_schema(
  3144|         0|            0|            0|  0.00%|    dataclass_name: str,
  3145|         0|            0|            0|  0.00%|    fields: list[DataclassField],
  3146|         0|            0|            0|  0.00%|    *,
  3147|         0|            0|            0|  0.00%|    computed_fields: List[ComputedField] | None = None,
  3148|         0|            0|            0|  0.00%|    populate_by_name: bool | None = None,
  3149|         0|            0|            0|  0.00%|    collect_init_only: bool | None = None,
  3150|         0|            0|            0|  0.00%|    ref: str | None = None,
  3151|         0|            0|            0|  0.00%|    metadata: Any = None,
  3152|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  3153|         0|            0|            0|  0.00%|    extra_behavior: ExtraBehavior | None = None,
  3154|         0|            0|            0|  0.00%|) -> DataclassArgsSchema:
  3155|         0|            0|            0|  0.00%|    """
  3156|         0|            0|            0|  0.00%|    Returns a schema for validating dataclass arguments, e.g.:
  3157|         0|            0|            0|  0.00%|
  3158|         0|            0|            0|  0.00%|    ```py
  3159|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  3160|         0|            0|            0|  0.00%|
  3161|         0|            0|            0|  0.00%|    field_a = core_schema.dataclass_field(
  3162|         0|            0|            0|  0.00%|        name='a', schema=core_schema.str_schema(), kw_only=False
  3163|         0|            0|            0|  0.00%|    )
  3164|         0|            0|            0|  0.00%|    field_b = core_schema.dataclass_field(
  3165|         0|            0|            0|  0.00%|        name='b', schema=core_schema.bool_schema(), kw_only=False
  3166|         0|            0|            0|  0.00%|    )
  3167|         0|            0|            0|  0.00%|    schema = core_schema.dataclass_args_schema('Foobar', [field_a, field_b])
  3168|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  3169|         0|            0|            0|  0.00%|    assert v.validate_python({'a': 'hello', 'b': True}) == ({'a': 'hello', 'b': True}, None)
  3170|         0|            0|            0|  0.00%|    ```
  3171|         0|            0|            0|  0.00%|
  3172|         0|            0|            0|  0.00%|    Args:
  3173|         0|            0|            0|  0.00%|        dataclass_name: The name of the dataclass being validated
  3174|         0|            0|            0|  0.00%|        fields: The fields to use for the dataclass
  3175|         0|            0|            0|  0.00%|        computed_fields: Computed fields to use when serializing the dataclass
  3176|         0|            0|            0|  0.00%|        populate_by_name: Whether to populate by name
  3177|         0|            0|            0|  0.00%|        collect_init_only: Whether to collect init only fields into a dict to pass to `__post_init__`
  3178|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  3179|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  3180|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  3181|         0|            0|            0|  0.00%|        extra_behavior: How to handle extra fields
  3182|         0|            0|            0|  0.00%|    """
  3183|         0|            0|            0|  0.00%|    return _dict_not_none(
  3184|         0|            0|            0|  0.00%|        type='dataclass-args',
  3185|         0|            0|            0|  0.00%|        dataclass_name=dataclass_name,
  3186|         0|            0|            0|  0.00%|        fields=fields,
  3187|         0|            0|            0|  0.00%|        computed_fields=computed_fields,
  3188|         0|            0|            0|  0.00%|        populate_by_name=populate_by_name,
  3189|         0|            0|            0|  0.00%|        collect_init_only=collect_init_only,
  3190|         0|            0|            0|  0.00%|        ref=ref,
  3191|         0|            0|            0|  0.00%|        metadata=metadata,
  3192|         0|            0|            0|  0.00%|        serialization=serialization,
  3193|         0|            0|            0|  0.00%|        extra_behavior=extra_behavior,
  3194|         0|            0|            0|  0.00%|    )
  3195|         0|            0|            0|  0.00%|
  3196|         0|            0|            0|  0.00%|
  3197|         0|            0|            0|  0.00%|class DataclassSchema(TypedDict, total=False):
  3198|         0|            0|            0|  0.00%|    type: Required[Literal['dataclass']]
  3199|         0|            0|            0|  0.00%|    cls: Required[Type[Any]]
  3200|         0|            0|            0|  0.00%|    schema: Required[CoreSchema]
  3201|         0|            0|            0|  0.00%|    fields: Required[List[str]]
  3202|         0|            0|            0|  0.00%|    cls_name: str
  3203|         0|            0|            0|  0.00%|    post_init: bool  # default: False
  3204|         0|            0|            0|  0.00%|    revalidate_instances: Literal['always', 'never', 'subclass-instances']  # default: 'never'
  3205|         0|            0|            0|  0.00%|    strict: bool  # default: False
  3206|         0|            0|            0|  0.00%|    frozen: bool  # default False
  3207|         0|            0|            0|  0.00%|    ref: str
  3208|         0|            0|            0|  0.00%|    metadata: Any
  3209|         0|            0|            0|  0.00%|    serialization: SerSchema
  3210|         0|            0|            0|  0.00%|    slots: bool
  3211|         0|            0|            0|  0.00%|    config: CoreConfig
  3212|         0|            0|            0|  0.00%|
  3213|         0|            0|            0|  0.00%|
  3214|         0|            0|            0|  0.00%|def dataclass_schema(
  3215|         0|            0|            0|  0.00%|    cls: Type[Any],
  3216|         0|            0|            0|  0.00%|    schema: CoreSchema,
  3217|         0|            0|            0|  0.00%|    fields: List[str],
  3218|         0|            0|            0|  0.00%|    *,
  3219|         0|            0|            0|  0.00%|    cls_name: str | None = None,
  3220|         0|            0|            0|  0.00%|    post_init: bool | None = None,
  3221|         0|            0|            0|  0.00%|    revalidate_instances: Literal['always', 'never', 'subclass-instances'] | None = None,
  3222|         0|            0|            0|  0.00%|    strict: bool | None = None,
  3223|         0|            0|            0|  0.00%|    ref: str | None = None,
  3224|         0|            0|            0|  0.00%|    metadata: Any = None,
  3225|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  3226|         0|            0|            0|  0.00%|    frozen: bool | None = None,
  3227|         0|            0|            0|  0.00%|    slots: bool | None = None,
  3228|         0|            0|            0|  0.00%|    config: CoreConfig | None = None,
  3229|         0|            0|            0|  0.00%|) -> DataclassSchema:
  3230|         0|            0|            0|  0.00%|    """
  3231|         0|            0|            0|  0.00%|    Returns a schema for a dataclass. As with `ModelSchema`, this schema can only be used as a field within
  3232|         0|            0|            0|  0.00%|    another schema, not as the root type.
  3233|         0|            0|            0|  0.00%|
  3234|         0|            0|            0|  0.00%|    Args:
  3235|         0|            0|            0|  0.00%|        cls: The dataclass type, used to perform subclass checks
  3236|         0|            0|            0|  0.00%|        schema: The schema to use for the dataclass fields
  3237|         0|            0|            0|  0.00%|        fields: Fields of the dataclass, this is used in serialization and in validation during re-validation
  3238|         0|            0|            0|  0.00%|            and while validating assignment
  3239|         0|            0|            0|  0.00%|        cls_name: The name to use in error locs, etc; this is useful for generics (default: `cls.__name__`)
  3240|         0|            0|            0|  0.00%|        post_init: Whether to call `__post_init__` after validation
  3241|         0|            0|            0|  0.00%|        revalidate_instances: whether instances of models and dataclasses (including subclass instances)
  3242|         0|            0|            0|  0.00%|            should re-validate defaults to config.revalidate_instances, else 'never'
  3243|         0|            0|            0|  0.00%|        strict: Whether to require an exact instance of `cls`
  3244|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  3245|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  3246|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  3247|         0|            0|            0|  0.00%|        frozen: Whether the dataclass is frozen
  3248|         0|            0|            0|  0.00%|        slots: Whether `slots=True` on the dataclass, means each field is assigned independently, rather than
  3249|         0|            0|            0|  0.00%|            simply setting `__dict__`, default false
  3250|         0|            0|            0|  0.00%|    """
  3251|         0|            0|            0|  0.00%|    return _dict_not_none(
  3252|         0|            0|            0|  0.00%|        type='dataclass',
  3253|         0|            0|            0|  0.00%|        cls=cls,
  3254|         0|            0|            0|  0.00%|        fields=fields,
  3255|         0|            0|            0|  0.00%|        cls_name=cls_name,
  3256|         0|            0|            0|  0.00%|        schema=schema,
  3257|         0|            0|            0|  0.00%|        post_init=post_init,
  3258|         0|            0|            0|  0.00%|        revalidate_instances=revalidate_instances,
  3259|         0|            0|            0|  0.00%|        strict=strict,
  3260|         0|            0|            0|  0.00%|        ref=ref,
  3261|         0|            0|            0|  0.00%|        metadata=metadata,
  3262|         0|            0|            0|  0.00%|        serialization=serialization,
  3263|         0|            0|            0|  0.00%|        frozen=frozen,
  3264|         0|            0|            0|  0.00%|        slots=slots,
  3265|         0|            0|            0|  0.00%|        config=config,
  3266|         0|            0|            0|  0.00%|    )
  3267|         0|            0|            0|  0.00%|
  3268|         0|            0|            0|  0.00%|
  3269|         0|            0|            0|  0.00%|class ArgumentsParameter(TypedDict, total=False):
  3270|         0|            0|            0|  0.00%|    name: Required[str]
  3271|         0|            0|            0|  0.00%|    schema: Required[CoreSchema]
  3272|         0|            0|            0|  0.00%|    mode: Literal['positional_only', 'positional_or_keyword', 'keyword_only']  # default positional_or_keyword
  3273|         0|            0|            0|  0.00%|    alias: Union[str, List[Union[str, int]], List[List[Union[str, int]]]]
  3274|         0|            0|            0|  0.00%|
  3275|         0|            0|            0|  0.00%|
  3276|         0|            0|            0|  0.00%|def arguments_parameter(
  3277|         0|            0|            0|  0.00%|    name: str,
  3278|         0|            0|            0|  0.00%|    schema: CoreSchema,
  3279|         0|            0|            0|  0.00%|    *,
  3280|         0|            0|            0|  0.00%|    mode: Literal['positional_only', 'positional_or_keyword', 'keyword_only'] | None = None,
  3281|         0|            0|            0|  0.00%|    alias: str | list[str | int] | list[list[str | int]] | None = None,
  3282|         0|            0|            0|  0.00%|) -> ArgumentsParameter:
  3283|         0|            0|            0|  0.00%|    """
  3284|         0|            0|            0|  0.00%|    Returns a schema that matches an argument parameter, e.g.:
  3285|         0|            0|            0|  0.00%|
  3286|         0|            0|            0|  0.00%|    ```py
  3287|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  3288|         0|            0|            0|  0.00%|
  3289|         0|            0|            0|  0.00%|    param = core_schema.arguments_parameter(
  3290|         0|            0|            0|  0.00%|        name='a', schema=core_schema.str_schema(), mode='positional_only'
  3291|         0|            0|            0|  0.00%|    )
  3292|         0|            0|            0|  0.00%|    schema = core_schema.arguments_schema([param])
  3293|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  3294|         0|            0|            0|  0.00%|    assert v.validate_python(('hello',)) == (('hello',), {})
  3295|         0|            0|            0|  0.00%|    ```
  3296|         0|            0|            0|  0.00%|
  3297|         0|            0|            0|  0.00%|    Args:
  3298|         0|            0|            0|  0.00%|        name: The name to use for the argument parameter
  3299|         0|            0|            0|  0.00%|        schema: The schema to use for the argument parameter
  3300|         0|            0|            0|  0.00%|        mode: The mode to use for the argument parameter
  3301|         0|            0|            0|  0.00%|        alias: The alias to use for the argument parameter
  3302|         0|            0|            0|  0.00%|    """
  3303|         0|            0|            0|  0.00%|    return _dict_not_none(name=name, schema=schema, mode=mode, alias=alias)
  3304|         0|            0|            0|  0.00%|
  3305|         0|            0|            0|  0.00%|
  3306|         0|            0|            0|  0.00%|class ArgumentsSchema(TypedDict, total=False):
  3307|         0|            0|            0|  0.00%|    type: Required[Literal['arguments']]
  3308|         0|            0|            0|  0.00%|    arguments_schema: Required[List[ArgumentsParameter]]
  3309|         0|            0|            0|  0.00%|    populate_by_name: bool
  3310|         0|            0|            0|  0.00%|    var_args_schema: CoreSchema
  3311|         0|            0|            0|  0.00%|    var_kwargs_schema: CoreSchema
  3312|         0|            0|            0|  0.00%|    ref: str
  3313|         0|            0|            0|  0.00%|    metadata: Any
  3314|         0|            0|            0|  0.00%|    serialization: SerSchema
  3315|         0|            0|            0|  0.00%|
  3316|         0|            0|            0|  0.00%|
  3317|         0|            0|            0|  0.00%|def arguments_schema(
  3318|         0|            0|            0|  0.00%|    arguments: list[ArgumentsParameter],
  3319|         0|            0|            0|  0.00%|    *,
  3320|         0|            0|            0|  0.00%|    populate_by_name: bool | None = None,
  3321|         0|            0|            0|  0.00%|    var_args_schema: CoreSchema | None = None,
  3322|         0|            0|            0|  0.00%|    var_kwargs_schema: CoreSchema | None = None,
  3323|         0|            0|            0|  0.00%|    ref: str | None = None,
  3324|         0|            0|            0|  0.00%|    metadata: Any = None,
  3325|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  3326|         0|            0|            0|  0.00%|) -> ArgumentsSchema:
  3327|         0|            0|            0|  0.00%|    """
  3328|         0|            0|            0|  0.00%|    Returns a schema that matches an arguments schema, e.g.:
  3329|         0|            0|            0|  0.00%|
  3330|         0|            0|            0|  0.00%|    ```py
  3331|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  3332|         0|            0|            0|  0.00%|
  3333|         0|            0|            0|  0.00%|    param_a = core_schema.arguments_parameter(
  3334|         0|            0|            0|  0.00%|        name='a', schema=core_schema.str_schema(), mode='positional_only'
  3335|         0|            0|            0|  0.00%|    )
  3336|         0|            0|            0|  0.00%|    param_b = core_schema.arguments_parameter(
  3337|         0|            0|            0|  0.00%|        name='b', schema=core_schema.bool_schema(), mode='positional_only'
  3338|         0|            0|            0|  0.00%|    )
  3339|         0|            0|            0|  0.00%|    schema = core_schema.arguments_schema([param_a, param_b])
  3340|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  3341|         0|            0|            0|  0.00%|    assert v.validate_python(('hello', True)) == (('hello', True), {})
  3342|         0|            0|            0|  0.00%|    ```
  3343|         0|            0|            0|  0.00%|
  3344|         0|            0|            0|  0.00%|    Args:
  3345|         0|            0|            0|  0.00%|        arguments: The arguments to use for the arguments schema
  3346|         0|            0|            0|  0.00%|        populate_by_name: Whether to populate by name
  3347|         0|            0|            0|  0.00%|        var_args_schema: The variable args schema to use for the arguments schema
  3348|         0|            0|            0|  0.00%|        var_kwargs_schema: The variable kwargs schema to use for the arguments schema
  3349|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  3350|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  3351|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  3352|         0|            0|            0|  0.00%|    """
  3353|         0|            0|            0|  0.00%|    return _dict_not_none(
  3354|         0|            0|            0|  0.00%|        type='arguments',
  3355|         0|            0|            0|  0.00%|        arguments_schema=arguments,
  3356|         0|            0|            0|  0.00%|        populate_by_name=populate_by_name,
  3357|         0|            0|            0|  0.00%|        var_args_schema=var_args_schema,
  3358|         0|            0|            0|  0.00%|        var_kwargs_schema=var_kwargs_schema,
  3359|         0|            0|            0|  0.00%|        ref=ref,
  3360|         0|            0|            0|  0.00%|        metadata=metadata,
  3361|         0|            0|            0|  0.00%|        serialization=serialization,
  3362|         0|            0|            0|  0.00%|    )
  3363|         0|            0|            0|  0.00%|
  3364|         0|            0|            0|  0.00%|
  3365|         0|            0|            0|  0.00%|class CallSchema(TypedDict, total=False):
  3366|         0|            0|            0|  0.00%|    type: Required[Literal['call']]
  3367|         0|            0|            0|  0.00%|    arguments_schema: Required[CoreSchema]
  3368|         0|            0|            0|  0.00%|    function: Required[Callable[..., Any]]
  3369|         0|            0|            0|  0.00%|    function_name: str  # default function.__name__
  3370|         0|            0|            0|  0.00%|    return_schema: CoreSchema
  3371|         0|            0|            0|  0.00%|    ref: str
  3372|         0|            0|            0|  0.00%|    metadata: Any
  3373|         0|            0|            0|  0.00%|    serialization: SerSchema
  3374|         0|            0|            0|  0.00%|
  3375|         0|            0|            0|  0.00%|
  3376|         0|            0|            0|  0.00%|def call_schema(
  3377|         0|            0|            0|  0.00%|    arguments: CoreSchema,
  3378|         0|            0|            0|  0.00%|    function: Callable[..., Any],
  3379|         0|            0|            0|  0.00%|    *,
  3380|         0|            0|            0|  0.00%|    function_name: str | None = None,
  3381|         0|            0|            0|  0.00%|    return_schema: CoreSchema | None = None,
  3382|         0|            0|            0|  0.00%|    ref: str | None = None,
  3383|         0|            0|            0|  0.00%|    metadata: Any = None,
  3384|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  3385|         0|            0|            0|  0.00%|) -> CallSchema:
  3386|         0|            0|            0|  0.00%|    """
  3387|         0|            0|            0|  0.00%|    Returns a schema that matches an arguments schema, then calls a function, e.g.:
  3388|         0|            0|            0|  0.00%|
  3389|         0|            0|            0|  0.00%|    ```py
  3390|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  3391|         0|            0|            0|  0.00%|
  3392|         0|            0|            0|  0.00%|    param_a = core_schema.arguments_parameter(
  3393|         0|            0|            0|  0.00%|        name='a', schema=core_schema.str_schema(), mode='positional_only'
  3394|         0|            0|            0|  0.00%|    )
  3395|         0|            0|            0|  0.00%|    param_b = core_schema.arguments_parameter(
  3396|         0|            0|            0|  0.00%|        name='b', schema=core_schema.bool_schema(), mode='positional_only'
  3397|         0|            0|            0|  0.00%|    )
  3398|         0|            0|            0|  0.00%|    args_schema = core_schema.arguments_schema([param_a, param_b])
  3399|         0|            0|            0|  0.00%|
  3400|         0|            0|            0|  0.00%|    schema = core_schema.call_schema(
  3401|         0|            0|            0|  0.00%|        arguments=args_schema,
  3402|         0|            0|            0|  0.00%|        function=lambda a, b: a + str(not b),
  3403|         0|            0|            0|  0.00%|        return_schema=core_schema.str_schema(),
  3404|         0|            0|            0|  0.00%|    )
  3405|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  3406|         0|            0|            0|  0.00%|    assert v.validate_python((('hello', True))) == 'helloFalse'
  3407|         0|            0|            0|  0.00%|    ```
  3408|         0|            0|            0|  0.00%|
  3409|         0|            0|            0|  0.00%|    Args:
  3410|         0|            0|            0|  0.00%|        arguments: The arguments to use for the arguments schema
  3411|         0|            0|            0|  0.00%|        function: The function to use for the call schema
  3412|         0|            0|            0|  0.00%|        function_name: The function name to use for the call schema, if not provided `function.__name__` is used
  3413|         0|            0|            0|  0.00%|        return_schema: The return schema to use for the call schema
  3414|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  3415|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  3416|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  3417|         0|            0|            0|  0.00%|    """
  3418|         0|            0|            0|  0.00%|    return _dict_not_none(
  3419|         0|            0|            0|  0.00%|        type='call',
  3420|         0|            0|            0|  0.00%|        arguments_schema=arguments,
  3421|         0|            0|            0|  0.00%|        function=function,
  3422|         0|            0|            0|  0.00%|        function_name=function_name,
  3423|         0|            0|            0|  0.00%|        return_schema=return_schema,
  3424|         0|            0|            0|  0.00%|        ref=ref,
  3425|         0|            0|            0|  0.00%|        metadata=metadata,
  3426|         0|            0|            0|  0.00%|        serialization=serialization,
  3427|         0|            0|            0|  0.00%|    )
  3428|         0|            0|            0|  0.00%|
  3429|         0|            0|            0|  0.00%|
  3430|         0|            0|            0|  0.00%|class CustomErrorSchema(TypedDict, total=False):
  3431|         0|            0|            0|  0.00%|    type: Required[Literal['custom-error']]
  3432|         0|            0|            0|  0.00%|    schema: Required[CoreSchema]
  3433|         0|            0|            0|  0.00%|    custom_error_type: Required[str]
  3434|         0|            0|            0|  0.00%|    custom_error_message: str
  3435|         0|            0|            0|  0.00%|    custom_error_context: Dict[str, Union[str, int, float]]
  3436|         0|            0|            0|  0.00%|    ref: str
  3437|         0|            0|            0|  0.00%|    metadata: Any
  3438|         0|            0|            0|  0.00%|    serialization: SerSchema
  3439|         0|            0|            0|  0.00%|
  3440|         0|            0|            0|  0.00%|
  3441|         0|            0|            0|  0.00%|def custom_error_schema(
  3442|         0|            0|            0|  0.00%|    schema: CoreSchema,
  3443|         0|            0|            0|  0.00%|    custom_error_type: str,
  3444|         0|            0|            0|  0.00%|    *,
  3445|         0|            0|            0|  0.00%|    custom_error_message: str | None = None,
  3446|         0|            0|            0|  0.00%|    custom_error_context: dict[str, Any] | None = None,
  3447|         0|            0|            0|  0.00%|    ref: str | None = None,
  3448|         0|            0|            0|  0.00%|    metadata: Any = None,
  3449|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  3450|         0|            0|            0|  0.00%|) -> CustomErrorSchema:
  3451|         0|            0|            0|  0.00%|    """
  3452|         0|            0|            0|  0.00%|    Returns a schema that matches a custom error value, e.g.:
  3453|         0|            0|            0|  0.00%|
  3454|         0|            0|            0|  0.00%|    ```py
  3455|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  3456|         0|            0|            0|  0.00%|
  3457|         0|            0|            0|  0.00%|    schema = core_schema.custom_error_schema(
  3458|         0|            0|            0|  0.00%|        schema=core_schema.int_schema(),
  3459|         0|            0|            0|  0.00%|        custom_error_type='MyError',
  3460|         0|            0|            0|  0.00%|        custom_error_message='Error msg',
  3461|         0|            0|            0|  0.00%|    )
  3462|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  3463|         0|            0|            0|  0.00%|    v.validate_python(1)
  3464|         0|            0|            0|  0.00%|    ```
  3465|         0|            0|            0|  0.00%|
  3466|         0|            0|            0|  0.00%|    Args:
  3467|         0|            0|            0|  0.00%|        schema: The schema to use for the custom error schema
  3468|         0|            0|            0|  0.00%|        custom_error_type: The custom error type to use for the custom error schema
  3469|         0|            0|            0|  0.00%|        custom_error_message: The custom error message to use for the custom error schema
  3470|         0|            0|            0|  0.00%|        custom_error_context: The custom error context to use for the custom error schema
  3471|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  3472|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  3473|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  3474|         0|            0|            0|  0.00%|    """
  3475|         0|            0|            0|  0.00%|    return _dict_not_none(
  3476|         0|            0|            0|  0.00%|        type='custom-error',
  3477|         0|            0|            0|  0.00%|        schema=schema,
  3478|         0|            0|            0|  0.00%|        custom_error_type=custom_error_type,
  3479|         0|            0|            0|  0.00%|        custom_error_message=custom_error_message,
  3480|         0|            0|            0|  0.00%|        custom_error_context=custom_error_context,
  3481|         0|            0|            0|  0.00%|        ref=ref,
  3482|         0|            0|            0|  0.00%|        metadata=metadata,
  3483|         0|            0|            0|  0.00%|        serialization=serialization,
  3484|         0|            0|            0|  0.00%|    )
  3485|         0|            0|            0|  0.00%|
  3486|         0|            0|            0|  0.00%|
  3487|         0|            0|            0|  0.00%|class JsonSchema(TypedDict, total=False):
  3488|         0|            0|            0|  0.00%|    type: Required[Literal['json']]
  3489|         0|            0|            0|  0.00%|    schema: CoreSchema
  3490|         0|            0|            0|  0.00%|    ref: str
  3491|         0|            0|            0|  0.00%|    metadata: Any
  3492|         0|            0|            0|  0.00%|    serialization: SerSchema
  3493|         0|            0|            0|  0.00%|
  3494|         0|            0|            0|  0.00%|
  3495|         0|            0|            0|  0.00%|def json_schema(
  3496|         0|            0|            0|  0.00%|    schema: CoreSchema | None = None,
  3497|         0|            0|            0|  0.00%|    *,
  3498|         0|            0|            0|  0.00%|    ref: str | None = None,
  3499|         0|            0|            0|  0.00%|    metadata: Any = None,
  3500|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  3501|         0|            0|            0|  0.00%|) -> JsonSchema:
  3502|         0|            0|            0|  0.00%|    """
  3503|         0|            0|            0|  0.00%|    Returns a schema that matches a JSON value, e.g.:
  3504|         0|            0|            0|  0.00%|
  3505|         0|            0|            0|  0.00%|    ```py
  3506|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  3507|         0|            0|            0|  0.00%|
  3508|         0|            0|            0|  0.00%|    dict_schema = core_schema.model_fields_schema(
  3509|         0|            0|            0|  0.00%|        {
  3510|         0|            0|            0|  0.00%|            'field_a': core_schema.model_field(core_schema.str_schema()),
  3511|         0|            0|            0|  0.00%|            'field_b': core_schema.model_field(core_schema.bool_schema()),
  3512|         0|            0|            0|  0.00%|        },
  3513|         0|            0|            0|  0.00%|    )
  3514|         0|            0|            0|  0.00%|
  3515|         0|            0|            0|  0.00%|    class MyModel:
  3516|         0|            0|            0|  0.00%|        __slots__ = (
  3517|         0|            0|            0|  0.00%|            '__dict__',
  3518|         0|            0|            0|  0.00%|            '__pydantic_fields_set__',
  3519|         0|            0|            0|  0.00%|            '__pydantic_extra__',
  3520|         0|            0|            0|  0.00%|            '__pydantic_private__',
  3521|         0|            0|            0|  0.00%|        )
  3522|         0|            0|            0|  0.00%|        field_a: str
  3523|         0|            0|            0|  0.00%|        field_b: bool
  3524|         0|            0|            0|  0.00%|
  3525|         0|            0|            0|  0.00%|    json_schema = core_schema.json_schema(schema=dict_schema)
  3526|         0|            0|            0|  0.00%|    schema = core_schema.model_schema(cls=MyModel, schema=json_schema)
  3527|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  3528|         0|            0|            0|  0.00%|    m = v.validate_python('{"field_a": "hello", "field_b": true}')
  3529|         0|            0|            0|  0.00%|    assert isinstance(m, MyModel)
  3530|         0|            0|            0|  0.00%|    ```
  3531|         0|            0|            0|  0.00%|
  3532|         0|            0|            0|  0.00%|    Args:
  3533|         0|            0|            0|  0.00%|        schema: The schema to use for the JSON schema
  3534|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  3535|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  3536|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  3537|         0|            0|            0|  0.00%|    """
  3538|         0|            0|            0|  0.00%|    return _dict_not_none(type='json', schema=schema, ref=ref, metadata=metadata, serialization=serialization)
  3539|         0|            0|            0|  0.00%|
  3540|         0|            0|            0|  0.00%|
  3541|         0|            0|            0|  0.00%|class UrlSchema(TypedDict, total=False):
  3542|         0|            0|            0|  0.00%|    type: Required[Literal['url']]
  3543|         0|            0|            0|  0.00%|    max_length: int
  3544|         0|            0|            0|  0.00%|    allowed_schemes: List[str]
  3545|         0|            0|            0|  0.00%|    host_required: bool  # default False
  3546|         0|            0|            0|  0.00%|    default_host: str
  3547|         0|            0|            0|  0.00%|    default_port: int
  3548|         0|            0|            0|  0.00%|    default_path: str
  3549|         0|            0|            0|  0.00%|    strict: bool
  3550|         0|            0|            0|  0.00%|    ref: str
  3551|         0|            0|            0|  0.00%|    metadata: Any
  3552|         0|            0|            0|  0.00%|    serialization: SerSchema
  3553|         0|            0|            0|  0.00%|
  3554|         0|            0|            0|  0.00%|
  3555|         0|            0|            0|  0.00%|def url_schema(
  3556|         0|            0|            0|  0.00%|    *,
  3557|         0|            0|            0|  0.00%|    max_length: int | None = None,
  3558|         0|            0|            0|  0.00%|    allowed_schemes: list[str] | None = None,
  3559|         0|            0|            0|  0.00%|    host_required: bool | None = None,
  3560|         0|            0|            0|  0.00%|    default_host: str | None = None,
  3561|         0|            0|            0|  0.00%|    default_port: int | None = None,
  3562|         0|            0|            0|  0.00%|    default_path: str | None = None,
  3563|         0|            0|            0|  0.00%|    strict: bool | None = None,
  3564|         0|            0|            0|  0.00%|    ref: str | None = None,
  3565|         0|            0|            0|  0.00%|    metadata: Any = None,
  3566|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  3567|         0|            0|            0|  0.00%|) -> UrlSchema:
  3568|         0|            0|            0|  0.00%|    """
  3569|         0|            0|            0|  0.00%|    Returns a schema that matches a URL value, e.g.:
  3570|         0|            0|            0|  0.00%|
  3571|         0|            0|            0|  0.00%|    ```py
  3572|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  3573|         0|            0|            0|  0.00%|
  3574|         0|            0|            0|  0.00%|    schema = core_schema.url_schema()
  3575|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  3576|         0|            0|            0|  0.00%|    print(v.validate_python('https://example.com'))
  3577|         0|            0|            0|  0.00%|    #> https://example.com/
  3578|         0|            0|            0|  0.00%|    ```
  3579|         0|            0|            0|  0.00%|
  3580|         0|            0|            0|  0.00%|    Args:
  3581|         0|            0|            0|  0.00%|        max_length: The maximum length of the URL
  3582|         0|            0|            0|  0.00%|        allowed_schemes: The allowed URL schemes
  3583|         0|            0|            0|  0.00%|        host_required: Whether the URL must have a host
  3584|         0|            0|            0|  0.00%|        default_host: The default host to use if the URL does not have a host
  3585|         0|            0|            0|  0.00%|        default_port: The default port to use if the URL does not have a port
  3586|         0|            0|            0|  0.00%|        default_path: The default path to use if the URL does not have a path
  3587|         0|            0|            0|  0.00%|        strict: Whether to use strict URL parsing
  3588|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  3589|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  3590|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  3591|         0|            0|            0|  0.00%|    """
  3592|         0|            0|            0|  0.00%|    return _dict_not_none(
  3593|         0|            0|            0|  0.00%|        type='url',
  3594|         0|            0|            0|  0.00%|        max_length=max_length,
  3595|         0|            0|            0|  0.00%|        allowed_schemes=allowed_schemes,
  3596|         0|            0|            0|  0.00%|        host_required=host_required,
  3597|         0|            0|            0|  0.00%|        default_host=default_host,
  3598|         0|            0|            0|  0.00%|        default_port=default_port,
  3599|         0|            0|            0|  0.00%|        default_path=default_path,
  3600|         0|            0|            0|  0.00%|        strict=strict,
  3601|         0|            0|            0|  0.00%|        ref=ref,
  3602|         0|            0|            0|  0.00%|        metadata=metadata,
  3603|         0|            0|            0|  0.00%|        serialization=serialization,
  3604|         0|            0|            0|  0.00%|    )
  3605|         0|            0|            0|  0.00%|
  3606|         0|            0|            0|  0.00%|
  3607|         0|            0|            0|  0.00%|class MultiHostUrlSchema(TypedDict, total=False):
  3608|         0|            0|            0|  0.00%|    type: Required[Literal['multi-host-url']]
  3609|         0|            0|            0|  0.00%|    max_length: int
  3610|         0|            0|            0|  0.00%|    allowed_schemes: List[str]
  3611|         0|            0|            0|  0.00%|    host_required: bool  # default False
  3612|         0|            0|            0|  0.00%|    default_host: str
  3613|         0|            0|            0|  0.00%|    default_port: int
  3614|         0|            0|            0|  0.00%|    default_path: str
  3615|         0|            0|            0|  0.00%|    strict: bool
  3616|         0|            0|            0|  0.00%|    ref: str
  3617|         0|            0|            0|  0.00%|    metadata: Any
  3618|         0|            0|            0|  0.00%|    serialization: SerSchema
  3619|         0|            0|            0|  0.00%|
  3620|         0|            0|            0|  0.00%|
  3621|         0|            0|            0|  0.00%|def multi_host_url_schema(
  3622|         0|            0|            0|  0.00%|    *,
  3623|         0|            0|            0|  0.00%|    max_length: int | None = None,
  3624|         0|            0|            0|  0.00%|    allowed_schemes: list[str] | None = None,
  3625|         0|            0|            0|  0.00%|    host_required: bool | None = None,
  3626|         0|            0|            0|  0.00%|    default_host: str | None = None,
  3627|         0|            0|            0|  0.00%|    default_port: int | None = None,
  3628|         0|            0|            0|  0.00%|    default_path: str | None = None,
  3629|         0|            0|            0|  0.00%|    strict: bool | None = None,
  3630|         0|            0|            0|  0.00%|    ref: str | None = None,
  3631|         0|            0|            0|  0.00%|    metadata: Any = None,
  3632|         0|            0|            0|  0.00%|    serialization: SerSchema | None = None,
  3633|         0|            0|            0|  0.00%|) -> MultiHostUrlSchema:
  3634|         0|            0|            0|  0.00%|    """
  3635|         0|            0|            0|  0.00%|    Returns a schema that matches a URL value with possibly multiple hosts, e.g.:
  3636|         0|            0|            0|  0.00%|
  3637|         0|            0|            0|  0.00%|    ```py
  3638|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  3639|         0|            0|            0|  0.00%|
  3640|         0|            0|            0|  0.00%|    schema = core_schema.multi_host_url_schema()
  3641|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  3642|         0|            0|            0|  0.00%|    print(v.validate_python('redis://localhost,0.0.0.0,127.0.0.1'))
  3643|         0|            0|            0|  0.00%|    #> redis://localhost,0.0.0.0,127.0.0.1
  3644|         0|            0|            0|  0.00%|    ```
  3645|         0|            0|            0|  0.00%|
  3646|         0|            0|            0|  0.00%|    Args:
  3647|         0|            0|            0|  0.00%|        max_length: The maximum length of the URL
  3648|         0|            0|            0|  0.00%|        allowed_schemes: The allowed URL schemes
  3649|         0|            0|            0|  0.00%|        host_required: Whether the URL must have a host
  3650|         0|            0|            0|  0.00%|        default_host: The default host to use if the URL does not have a host
  3651|         0|            0|            0|  0.00%|        default_port: The default port to use if the URL does not have a port
  3652|         0|            0|            0|  0.00%|        default_path: The default path to use if the URL does not have a path
  3653|         0|            0|            0|  0.00%|        strict: Whether to use strict URL parsing
  3654|         0|            0|            0|  0.00%|        ref: optional unique identifier of the schema, used to reference the schema in other places
  3655|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  3656|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  3657|         0|            0|            0|  0.00%|    """
  3658|         0|            0|            0|  0.00%|    return _dict_not_none(
  3659|         0|            0|            0|  0.00%|        type='multi-host-url',
  3660|         0|            0|            0|  0.00%|        max_length=max_length,
  3661|         0|            0|            0|  0.00%|        allowed_schemes=allowed_schemes,
  3662|         0|            0|            0|  0.00%|        host_required=host_required,
  3663|         0|            0|            0|  0.00%|        default_host=default_host,
  3664|         0|            0|            0|  0.00%|        default_port=default_port,
  3665|         0|            0|            0|  0.00%|        default_path=default_path,
  3666|         0|            0|            0|  0.00%|        strict=strict,
  3667|         0|            0|            0|  0.00%|        ref=ref,
  3668|         0|            0|            0|  0.00%|        metadata=metadata,
  3669|         0|            0|            0|  0.00%|        serialization=serialization,
  3670|         0|            0|            0|  0.00%|    )
  3671|         0|            0|            0|  0.00%|
  3672|         0|            0|            0|  0.00%|
  3673|         0|            0|            0|  0.00%|class DefinitionsSchema(TypedDict, total=False):
  3674|         0|            0|            0|  0.00%|    type: Required[Literal['definitions']]
  3675|         0|            0|            0|  0.00%|    schema: Required[CoreSchema]
  3676|         0|            0|            0|  0.00%|    definitions: Required[List[CoreSchema]]
  3677|         0|            0|            0|  0.00%|    metadata: Any
  3678|         0|            0|            0|  0.00%|    serialization: SerSchema
  3679|         0|            0|            0|  0.00%|
  3680|         0|            0|            0|  0.00%|
  3681|         2|  3.33786e-06|  1.66893e-06|  0.00%|def definitions_schema(schema: CoreSchema, definitions: list[CoreSchema]) -> DefinitionsSchema:
  3682|         0|            0|            0|  0.00%|    """
  3683|         0|            0|            0|  0.00%|    Build a schema that contains both an inner schema and a list of definitions which can be used
  3684|         0|            0|            0|  0.00%|    within the inner schema.
  3685|         0|            0|            0|  0.00%|
  3686|         0|            0|            0|  0.00%|    ```py
  3687|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  3688|         0|            0|            0|  0.00%|
  3689|         0|            0|            0|  0.00%|    schema = core_schema.definitions_schema(
  3690|         0|            0|            0|  0.00%|        core_schema.list_schema(core_schema.definition_reference_schema('foobar')),
  3691|         0|            0|            0|  0.00%|        [core_schema.int_schema(ref='foobar')],
  3692|         0|            0|            0|  0.00%|    )
  3693|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  3694|         0|            0|            0|  0.00%|    assert v.validate_python([1, 2, '3']) == [1, 2, 3]
  3695|         0|            0|            0|  0.00%|    ```
  3696|         0|            0|            0|  0.00%|
  3697|         0|            0|            0|  0.00%|    Args:
  3698|         0|            0|            0|  0.00%|        schema: The inner schema
  3699|         0|            0|            0|  0.00%|        definitions: List of definitions which can be referenced within inner schema
  3700|         0|            0|            0|  0.00%|    """
  3701|         2|   6.4373e-06|  3.21865e-06|  0.01%|    return DefinitionsSchema(type='definitions', schema=schema, definitions=definitions)
  3702|         0|            0|            0|  0.00%|
  3703|         0|            0|            0|  0.00%|
  3704|         0|            0|            0|  0.00%|class DefinitionReferenceSchema(TypedDict, total=False):
  3705|         0|            0|            0|  0.00%|    type: Required[Literal['definition-ref']]
  3706|         0|            0|            0|  0.00%|    schema_ref: Required[str]
  3707|         0|            0|            0|  0.00%|    ref: str
  3708|         0|            0|            0|  0.00%|    metadata: Any
  3709|         0|            0|            0|  0.00%|    serialization: SerSchema
  3710|         0|            0|            0|  0.00%|
  3711|         0|            0|            0|  0.00%|
  3712|         0|            0|            0|  0.00%|def definition_reference_schema(
  3713|         0|            0|            0|  0.00%|    schema_ref: str, ref: str | None = None, metadata: Any = None, serialization: SerSchema | None = None
  3714|         0|            0|            0|  0.00%|) -> DefinitionReferenceSchema:
  3715|         0|            0|            0|  0.00%|    """
  3716|         0|            0|            0|  0.00%|    Returns a schema that points to a schema stored in "definitions", this is useful for nested recursive
  3717|         0|            0|            0|  0.00%|    models and also when you want to define validators separately from the main schema, e.g.:
  3718|         0|            0|            0|  0.00%|
  3719|         0|            0|            0|  0.00%|    ```py
  3720|         0|            0|            0|  0.00%|    from pydantic_core import SchemaValidator, core_schema
  3721|         0|            0|            0|  0.00%|
  3722|         0|            0|            0|  0.00%|    schema_definition = core_schema.definition_reference_schema('list-schema')
  3723|         0|            0|            0|  0.00%|    schema = core_schema.definitions_schema(
  3724|         0|            0|            0|  0.00%|        schema=schema_definition,
  3725|         0|            0|            0|  0.00%|        definitions=[
  3726|         0|            0|            0|  0.00%|            core_schema.list_schema(items_schema=schema_definition, ref='list-schema'),
  3727|         0|            0|            0|  0.00%|        ],
  3728|         0|            0|            0|  0.00%|    )
  3729|         0|            0|            0|  0.00%|    v = SchemaValidator(schema)
  3730|         0|            0|            0|  0.00%|    assert v.validate_python([()]) == [[]]
  3731|         0|            0|            0|  0.00%|    ```
  3732|         0|            0|            0|  0.00%|
  3733|         0|            0|            0|  0.00%|    Args:
  3734|         0|            0|            0|  0.00%|        schema_ref: The schema ref to use for the definition reference schema
  3735|         0|            0|            0|  0.00%|        metadata: Any other information you want to include with the schema, not used by pydantic-core
  3736|         0|            0|            0|  0.00%|        serialization: Custom serialization schema
  3737|         0|            0|            0|  0.00%|    """
  3738|         0|            0|            0|  0.00%|    return _dict_not_none(
  3739|         0|            0|            0|  0.00%|        type='definition-ref', schema_ref=schema_ref, ref=ref, metadata=metadata, serialization=serialization
  3740|         0|            0|            0|  0.00%|    )
  3741|         0|            0|            0|  0.00%|
  3742|         0|            0|            0|  0.00%|
  3743|         0|            0|            0|  0.00%|MYPY = False
  3744|         0|            0|            0|  0.00%|# See https://github.com/python/mypy/issues/14034 for details, in summary mypy is extremely slow to process this
  3745|         0|            0|            0|  0.00%|# union which kills performance not just for pydantic, but even for code using pydantic
  3746|         0|            0|            0|  0.00%|if not MYPY:
  3747|         0|            0|            0|  0.00%|    CoreSchema = Union[
  3748|         0|            0|            0|  0.00%|        AnySchema,
  3749|         0|            0|            0|  0.00%|        NoneSchema,
  3750|         0|            0|            0|  0.00%|        BoolSchema,
  3751|         0|            0|            0|  0.00%|        IntSchema,
  3752|         0|            0|            0|  0.00%|        FloatSchema,
  3753|         0|            0|            0|  0.00%|        DecimalSchema,
  3754|         0|            0|            0|  0.00%|        StringSchema,
  3755|         0|            0|            0|  0.00%|        BytesSchema,
  3756|         0|            0|            0|  0.00%|        DateSchema,
  3757|         0|            0|            0|  0.00%|        TimeSchema,
  3758|         0|            0|            0|  0.00%|        DatetimeSchema,
  3759|         0|            0|            0|  0.00%|        TimedeltaSchema,
  3760|         0|            0|            0|  0.00%|        LiteralSchema,
  3761|         0|            0|            0|  0.00%|        EnumSchema,
  3762|         0|            0|            0|  0.00%|        IsInstanceSchema,
  3763|         0|            0|            0|  0.00%|        IsSubclassSchema,
  3764|         0|            0|            0|  0.00%|        CallableSchema,
  3765|         0|            0|            0|  0.00%|        ListSchema,
  3766|         0|            0|            0|  0.00%|        TupleSchema,
  3767|         0|            0|            0|  0.00%|        SetSchema,
  3768|         0|            0|            0|  0.00%|        FrozenSetSchema,
  3769|         0|            0|            0|  0.00%|        GeneratorSchema,
  3770|         0|            0|            0|  0.00%|        DictSchema,
  3771|         0|            0|            0|  0.00%|        AfterValidatorFunctionSchema,
  3772|         0|            0|            0|  0.00%|        BeforeValidatorFunctionSchema,
  3773|         0|            0|            0|  0.00%|        WrapValidatorFunctionSchema,
  3774|         0|            0|            0|  0.00%|        PlainValidatorFunctionSchema,
  3775|         0|            0|            0|  0.00%|        WithDefaultSchema,
  3776|         0|            0|            0|  0.00%|        NullableSchema,
  3777|         0|            0|            0|  0.00%|        UnionSchema,
  3778|         0|            0|            0|  0.00%|        TaggedUnionSchema,
  3779|         0|            0|            0|  0.00%|        ChainSchema,
  3780|         0|            0|            0|  0.00%|        LaxOrStrictSchema,
  3781|         0|            0|            0|  0.00%|        JsonOrPythonSchema,
  3782|         0|            0|            0|  0.00%|        TypedDictSchema,
  3783|         0|            0|            0|  0.00%|        ModelFieldsSchema,
  3784|         0|            0|            0|  0.00%|        ModelSchema,
  3785|         0|            0|            0|  0.00%|        DataclassArgsSchema,
  3786|         0|            0|            0|  0.00%|        DataclassSchema,
  3787|         0|            0|            0|  0.00%|        ArgumentsSchema,
  3788|         0|            0|            0|  0.00%|        CallSchema,
  3789|         0|            0|            0|  0.00%|        CustomErrorSchema,
  3790|         0|            0|            0|  0.00%|        JsonSchema,
  3791|         0|            0|            0|  0.00%|        UrlSchema,
  3792|         0|            0|            0|  0.00%|        MultiHostUrlSchema,
  3793|         0|            0|            0|  0.00%|        DefinitionsSchema,
  3794|         0|            0|            0|  0.00%|        DefinitionReferenceSchema,
  3795|         0|            0|            0|  0.00%|        UuidSchema,
  3796|         0|            0|            0|  0.00%|    ]
  3797|         0|            0|            0|  0.00%|elif False:
  3798|         0|            0|            0|  0.00%|    CoreSchema: TypeAlias = Mapping[str, Any]
  3799|         0|            0|            0|  0.00%|
  3800|         0|            0|            0|  0.00%|
  3801|         0|            0|            0|  0.00%|# to update this, call `pytest -k test_core_schema_type_literal` and copy the output
  3802|         0|            0|            0|  0.00%|CoreSchemaType = Literal[
  3803|         0|            0|            0|  0.00%|    'any',
  3804|         0|            0|            0|  0.00%|    'none',
  3805|         0|            0|            0|  0.00%|    'bool',
  3806|         0|            0|            0|  0.00%|    'int',
  3807|         0|            0|            0|  0.00%|    'float',
  3808|         0|            0|            0|  0.00%|    'decimal',
  3809|         0|            0|            0|  0.00%|    'str',
  3810|         0|            0|            0|  0.00%|    'bytes',
  3811|         0|            0|            0|  0.00%|    'date',
  3812|         0|            0|            0|  0.00%|    'time',
  3813|         0|            0|            0|  0.00%|    'datetime',
  3814|         0|            0|            0|  0.00%|    'timedelta',
  3815|         0|            0|            0|  0.00%|    'literal',
  3816|         0|            0|            0|  0.00%|    'enum',
  3817|         0|            0|            0|  0.00%|    'is-instance',
  3818|         0|            0|            0|  0.00%|    'is-subclass',
  3819|         0|            0|            0|  0.00%|    'callable',
  3820|         0|            0|            0|  0.00%|    'list',
  3821|         0|            0|            0|  0.00%|    'tuple',
  3822|         0|            0|            0|  0.00%|    'set',
  3823|         0|            0|            0|  0.00%|    'frozenset',
  3824|         0|            0|            0|  0.00%|    'generator',
  3825|         0|            0|            0|  0.00%|    'dict',
  3826|         0|            0|            0|  0.00%|    'function-after',
  3827|         0|            0|            0|  0.00%|    'function-before',
  3828|         0|            0|            0|  0.00%|    'function-wrap',
  3829|         0|            0|            0|  0.00%|    'function-plain',
  3830|         0|            0|            0|  0.00%|    'default',
  3831|         0|            0|            0|  0.00%|    'nullable',
  3832|         0|            0|            0|  0.00%|    'union',
  3833|         0|            0|            0|  0.00%|    'tagged-union',
  3834|         0|            0|            0|  0.00%|    'chain',
  3835|         0|            0|            0|  0.00%|    'lax-or-strict',
  3836|         0|            0|            0|  0.00%|    'json-or-python',
  3837|         0|            0|            0|  0.00%|    'typed-dict',
  3838|         0|            0|            0|  0.00%|    'model-fields',
  3839|         0|            0|            0|  0.00%|    'model',
  3840|         0|            0|            0|  0.00%|    'dataclass-args',
  3841|         0|            0|            0|  0.00%|    'dataclass',
  3842|         0|            0|            0|  0.00%|    'arguments',
  3843|         0|            0|            0|  0.00%|    'call',
  3844|         0|            0|            0|  0.00%|    'custom-error',
  3845|         0|            0|            0|  0.00%|    'json',
  3846|         0|            0|            0|  0.00%|    'url',
  3847|         0|            0|            0|  0.00%|    'multi-host-url',
  3848|         0|            0|            0|  0.00%|    'definitions',
  3849|         0|            0|            0|  0.00%|    'definition-ref',
  3850|         0|            0|            0|  0.00%|    'uuid',
  3851|         0|            0|            0|  0.00%|]
  3852|         0|            0|            0|  0.00%|
  3853|         0|            0|            0|  0.00%|CoreSchemaFieldType = Literal['model-field', 'dataclass-field', 'typed-dict-field', 'computed-field']
  3854|         0|            0|            0|  0.00%|
  3855|         0|            0|            0|  0.00%|
  3856|         0|            0|            0|  0.00%|# used in _pydantic_core.pyi::PydanticKnownError
  3857|         0|            0|            0|  0.00%|# to update this, call `pytest -k test_all_errors` and copy the output
  3858|         0|            0|            0|  0.00%|ErrorType = Literal[
  3859|         0|            0|            0|  0.00%|    'no_such_attribute',
  3860|         0|            0|            0|  0.00%|    'json_invalid',
  3861|         0|            0|            0|  0.00%|    'json_type',
  3862|         0|            0|            0|  0.00%|    'recursion_loop',
  3863|         0|            0|            0|  0.00%|    'missing',
  3864|         0|            0|            0|  0.00%|    'frozen_field',
  3865|         0|            0|            0|  0.00%|    'frozen_instance',
  3866|         0|            0|            0|  0.00%|    'extra_forbidden',
  3867|         0|            0|            0|  0.00%|    'invalid_key',
  3868|         0|            0|            0|  0.00%|    'get_attribute_error',
  3869|         0|            0|            0|  0.00%|    'model_type',
  3870|         0|            0|            0|  0.00%|    'model_attributes_type',
  3871|         0|            0|            0|  0.00%|    'dataclass_type',
  3872|         0|            0|            0|  0.00%|    'dataclass_exact_type',
  3873|         0|            0|            0|  0.00%|    'none_required',
  3874|         0|            0|            0|  0.00%|    'greater_than',
  3875|         0|            0|            0|  0.00%|    'greater_than_equal',
  3876|         0|            0|            0|  0.00%|    'less_than',
  3877|         0|            0|            0|  0.00%|    'less_than_equal',
  3878|         0|            0|            0|  0.00%|    'multiple_of',
  3879|         0|            0|            0|  0.00%|    'finite_number',
  3880|         0|            0|            0|  0.00%|    'too_short',
  3881|         0|            0|            0|  0.00%|    'too_long',
  3882|         0|            0|            0|  0.00%|    'iterable_type',
  3883|         0|            0|            0|  0.00%|    'iteration_error',
  3884|         0|            0|            0|  0.00%|    'string_type',
  3885|         0|            0|            0|  0.00%|    'string_sub_type',
  3886|         0|            0|            0|  0.00%|    'string_unicode',
  3887|         0|            0|            0|  0.00%|    'string_too_short',
  3888|         0|            0|            0|  0.00%|    'string_too_long',
  3889|         0|            0|            0|  0.00%|    'string_pattern_mismatch',
  3890|         0|            0|            0|  0.00%|    'enum',
  3891|         0|            0|            0|  0.00%|    'dict_type',
  3892|         0|            0|            0|  0.00%|    'mapping_type',
  3893|         0|            0|            0|  0.00%|    'list_type',
  3894|         0|            0|            0|  0.00%|    'tuple_type',
  3895|         0|            0|            0|  0.00%|    'set_type',
  3896|         0|            0|            0|  0.00%|    'bool_type',
  3897|         0|            0|            0|  0.00%|    'bool_parsing',
  3898|         0|            0|            0|  0.00%|    'int_type',
  3899|         0|            0|            0|  0.00%|    'int_parsing',
  3900|         0|            0|            0|  0.00%|    'int_parsing_size',
  3901|         0|            0|            0|  0.00%|    'int_from_float',
  3902|         0|            0|            0|  0.00%|    'float_type',
  3903|         0|            0|            0|  0.00%|    'float_parsing',
  3904|         0|            0|            0|  0.00%|    'bytes_type',
  3905|         0|            0|            0|  0.00%|    'bytes_too_short',
  3906|         0|            0|            0|  0.00%|    'bytes_too_long',
  3907|         0|            0|            0|  0.00%|    'value_error',
  3908|         0|            0|            0|  0.00%|    'assertion_error',
  3909|         0|            0|            0|  0.00%|    'literal_error',
  3910|         0|            0|            0|  0.00%|    'date_type',
  3911|         0|            0|            0|  0.00%|    'date_parsing',
  3912|         0|            0|            0|  0.00%|    'date_from_datetime_parsing',
  3913|         0|            0|            0|  0.00%|    'date_from_datetime_inexact',
  3914|         0|            0|            0|  0.00%|    'date_past',
  3915|         0|            0|            0|  0.00%|    'date_future',
  3916|         0|            0|            0|  0.00%|    'time_type',
  3917|         0|            0|            0|  0.00%|    'time_parsing',
  3918|         0|            0|            0|  0.00%|    'datetime_type',
  3919|         0|            0|            0|  0.00%|    'datetime_parsing',
  3920|         0|            0|            0|  0.00%|    'datetime_object_invalid',
  3921|         0|            0|            0|  0.00%|    'datetime_from_date_parsing',
  3922|         0|            0|            0|  0.00%|    'datetime_past',
  3923|         0|            0|            0|  0.00%|    'datetime_future',
  3924|         0|            0|            0|  0.00%|    'timezone_naive',
  3925|         0|            0|            0|  0.00%|    'timezone_aware',
  3926|         0|            0|            0|  0.00%|    'timezone_offset',
  3927|         0|            0|            0|  0.00%|    'time_delta_type',
  3928|         0|            0|            0|  0.00%|    'time_delta_parsing',
  3929|         0|            0|            0|  0.00%|    'frozen_set_type',
  3930|         0|            0|            0|  0.00%|    'is_instance_of',
  3931|         0|            0|            0|  0.00%|    'is_subclass_of',
  3932|         0|            0|            0|  0.00%|    'callable_type',
  3933|         0|            0|            0|  0.00%|    'union_tag_invalid',
  3934|         0|            0|            0|  0.00%|    'union_tag_not_found',
  3935|         0|            0|            0|  0.00%|    'arguments_type',
  3936|         0|            0|            0|  0.00%|    'missing_argument',
  3937|         0|            0|            0|  0.00%|    'unexpected_keyword_argument',
  3938|         0|            0|            0|  0.00%|    'missing_keyword_only_argument',
  3939|         0|            0|            0|  0.00%|    'unexpected_positional_argument',
  3940|         0|            0|            0|  0.00%|    'missing_positional_only_argument',
  3941|         0|            0|            0|  0.00%|    'multiple_argument_values',
  3942|         0|            0|            0|  0.00%|    'url_type',
  3943|         0|            0|            0|  0.00%|    'url_parsing',
  3944|         0|            0|            0|  0.00%|    'url_syntax_violation',
  3945|         0|            0|            0|  0.00%|    'url_too_long',
  3946|         0|            0|            0|  0.00%|    'url_scheme',
  3947|         0|            0|            0|  0.00%|    'uuid_type',
  3948|         0|            0|            0|  0.00%|    'uuid_parsing',
  3949|         0|            0|            0|  0.00%|    'uuid_version',
  3950|         0|            0|            0|  0.00%|    'decimal_type',
  3951|         0|            0|            0|  0.00%|    'decimal_parsing',
  3952|         0|            0|            0|  0.00%|    'decimal_max_digits',
  3953|         0|            0|            0|  0.00%|    'decimal_max_places',
  3954|         0|            0|            0|  0.00%|    'decimal_whole_digits',
  3955|         0|            0|            0|  0.00%|]
  3956|         0|            0|            0|  0.00%|
  3957|         0|            0|            0|  0.00%|
  3958|         2|  4.29153e-06|  2.14577e-06|  0.00%|def _dict_not_none(**kwargs: Any) -> Any:
  3959|        28|  3.40939e-05|  1.21764e-06|  0.04%|    return {k: v for k, v in kwargs.items() if v is not None}
  3960|         0|            0|            0|  0.00%|
  3961|         0|            0|            0|  0.00%|
  3962|         0|            0|            0|  0.00%|###############################################################################
  3963|         0|            0|            0|  0.00%|# All this stuff is deprecated by #980 and will be removed eventually
  3964|         0|            0|            0|  0.00%|# They're kept because some code external code will be using them
  3965|         0|            0|            0|  0.00%|
  3966|         0|            0|            0|  0.00%|
  3967|         0|            0|            0|  0.00%|@deprecated('`field_before_validator_function` is deprecated, use `with_info_before_validator_function` instead.')
  3968|         0|            0|            0|  0.00%|def field_before_validator_function(function: WithInfoValidatorFunction, field_name: str, schema: CoreSchema, **kwargs):
  3969|         0|            0|            0|  0.00%|    warnings.warn(
  3970|         0|            0|            0|  0.00%|        '`field_before_validator_function` is deprecated, use `with_info_before_validator_function` instead.',
  3971|         0|            0|            0|  0.00%|        DeprecationWarning,
  3972|         0|            0|            0|  0.00%|    )
  3973|         0|            0|            0|  0.00%|    return with_info_before_validator_function(function, schema, field_name=field_name, **kwargs)
  3974|         0|            0|            0|  0.00%|
  3975|         0|            0|            0|  0.00%|
  3976|         0|            0|            0|  0.00%|@deprecated('`general_before_validator_function` is deprecated, use `with_info_before_validator_function` instead.')
  3977|         0|            0|            0|  0.00%|def general_before_validator_function(*args, **kwargs):
  3978|         0|            0|            0|  0.00%|    warnings.warn(
  3979|         0|            0|            0|  0.00%|        '`general_before_validator_function` is deprecated, use `with_info_before_validator_function` instead.',
  3980|         0|            0|            0|  0.00%|        DeprecationWarning,
  3981|         0|            0|            0|  0.00%|    )
  3982|         0|            0|            0|  0.00%|    return with_info_before_validator_function(*args, **kwargs)
  3983|         0|            0|            0|  0.00%|
  3984|         0|            0|            0|  0.00%|
  3985|         0|            0|            0|  0.00%|@deprecated('`field_after_validator_function` is deprecated, use `with_info_after_validator_function` instead.')
  3986|         0|            0|            0|  0.00%|def field_after_validator_function(function: WithInfoValidatorFunction, field_name: str, schema: CoreSchema, **kwargs):
  3987|         0|            0|            0|  0.00%|    warnings.warn(
  3988|         0|            0|            0|  0.00%|        '`field_after_validator_function` is deprecated, use `with_info_after_validator_function` instead.',
  3989|         0|            0|            0|  0.00%|        DeprecationWarning,
  3990|         0|            0|            0|  0.00%|    )
  3991|         0|            0|            0|  0.00%|    return with_info_after_validator_function(function, schema, field_name=field_name, **kwargs)
  3992|         0|            0|            0|  0.00%|
  3993|         0|            0|            0|  0.00%|
  3994|         0|            0|            0|  0.00%|@deprecated('`general_after_validator_function` is deprecated, use `with_info_after_validator_function` instead.')
  3995|         0|            0|            0|  0.00%|def general_after_validator_function(*args, **kwargs):
  3996|         0|            0|            0|  0.00%|    warnings.warn(
  3997|         0|            0|            0|  0.00%|        '`general_after_validator_function` is deprecated, use `with_info_after_validator_function` instead.',
  3998|         0|            0|            0|  0.00%|        DeprecationWarning,
  3999|         0|            0|            0|  0.00%|    )
  4000|         0|            0|            0|  0.00%|    return with_info_after_validator_function(*args, **kwargs)
  4001|         0|            0|            0|  0.00%|
  4002|         0|            0|            0|  0.00%|
  4003|         0|            0|            0|  0.00%|@deprecated('`field_wrap_validator_function` is deprecated, use `with_info_wrap_validator_function` instead.')
  4004|         0|            0|            0|  0.00%|def field_wrap_validator_function(
  4005|         0|            0|            0|  0.00%|    function: WithInfoWrapValidatorFunction, field_name: str, schema: CoreSchema, **kwargs
  4006|         0|            0|            0|  0.00%|):
  4007|         0|            0|            0|  0.00%|    warnings.warn(
  4008|         0|            0|            0|  0.00%|        '`field_wrap_validator_function` is deprecated, use `with_info_wrap_validator_function` instead.',
  4009|         0|            0|            0|  0.00%|        DeprecationWarning,
  4010|         0|            0|            0|  0.00%|    )
  4011|         0|            0|            0|  0.00%|    return with_info_wrap_validator_function(function, schema, field_name=field_name, **kwargs)
  4012|         0|            0|            0|  0.00%|
  4013|         0|            0|            0|  0.00%|
  4014|         0|            0|            0|  0.00%|@deprecated('`general_wrap_validator_function` is deprecated, use `with_info_wrap_validator_function` instead.')
  4015|         0|            0|            0|  0.00%|def general_wrap_validator_function(*args, **kwargs):
  4016|         0|            0|            0|  0.00%|    warnings.warn(
  4017|         0|            0|            0|  0.00%|        '`general_wrap_validator_function` is deprecated, use `with_info_wrap_validator_function` instead.',
  4018|         0|            0|            0|  0.00%|        DeprecationWarning,
  4019|         0|            0|            0|  0.00%|    )
  4020|         0|            0|            0|  0.00%|    return with_info_wrap_validator_function(*args, **kwargs)
  4021|         0|            0|            0|  0.00%|
  4022|         0|            0|            0|  0.00%|
  4023|         0|            0|            0|  0.00%|@deprecated('`field_plain_validator_function` is deprecated, use `with_info_plain_validator_function` instead.')
  4024|         0|            0|            0|  0.00%|def field_plain_validator_function(function: WithInfoValidatorFunction, field_name: str, **kwargs):
  4025|         0|            0|            0|  0.00%|    warnings.warn(
  4026|         0|            0|            0|  0.00%|        '`field_plain_validator_function` is deprecated, use `with_info_plain_validator_function` instead.',
  4027|         0|            0|            0|  0.00%|        DeprecationWarning,
  4028|         0|            0|            0|  0.00%|    )
  4029|         0|            0|            0|  0.00%|    return with_info_plain_validator_function(function, field_name=field_name, **kwargs)
  4030|         0|            0|            0|  0.00%|
  4031|         0|            0|            0|  0.00%|
  4032|         0|            0|            0|  0.00%|@deprecated('`general_plain_validator_function` is deprecated, use `with_info_plain_validator_function` instead.')
  4033|         0|            0|            0|  0.00%|def general_plain_validator_function(*args, **kwargs):
  4034|         0|            0|            0|  0.00%|    warnings.warn(
  4035|         0|            0|            0|  0.00%|        '`general_plain_validator_function` is deprecated, use `with_info_plain_validator_function` instead.',
  4036|         0|            0|            0|  0.00%|        DeprecationWarning,
  4037|         0|            0|            0|  0.00%|    )
  4038|         0|            0|            0|  0.00%|    return with_info_plain_validator_function(*args, **kwargs)
  4039|         0|            0|            0|  0.00%|
  4040|         0|            0|            0|  0.00%|
  4041|         0|            0|            0|  0.00%|_deprecated_import_lookup = {
  4042|         0|            0|            0|  0.00%|    'FieldValidationInfo': ValidationInfo,
  4043|         0|            0|            0|  0.00%|    'FieldValidatorFunction': WithInfoValidatorFunction,
  4044|         0|            0|            0|  0.00%|    'GeneralValidatorFunction': WithInfoValidatorFunction,
  4045|         0|            0|            0|  0.00%|    'FieldWrapValidatorFunction': WithInfoWrapValidatorFunction,
  4046|         0|            0|            0|  0.00%|}
  4047|         0|            0|            0|  0.00%|
  4048|         0|            0|            0|  0.00%|if TYPE_CHECKING:
  4049|         0|            0|            0|  0.00%|    FieldValidationInfo = ValidationInfo
  4050|         0|            0|            0|  0.00%|
  4051|         0|            0|            0|  0.00%|
  4052|         0|            0|            0|  0.00%|def __getattr__(attr_name: str) -> object:
  4053|         0|            0|            0|  0.00%|    new_attr = _deprecated_import_lookup.get(attr_name)
  4054|         0|            0|            0|  0.00%|    if new_attr is None:
  4055|         0|            0|            0|  0.00%|        raise AttributeError(f"module 'pydantic_core' has no attribute '{attr_name}'")
  4056|         0|            0|            0|  0.00%|    else:
  4057|         0|            0|            0|  0.00%|        import warnings
  4058|         0|            0|            0|  0.00%|
  4059|         0|            0|            0|  0.00%|        msg = f'`{attr_name}` is deprecated, use `{new_attr.__name__}` instead.'
  4060|         0|            0|            0|  0.00%|        warnings.warn(msg, DeprecationWarning, stacklevel=1)
  4061|         0|            0|            0|  0.00%|        return new_attr
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/plugin/_schema_validator.py
File duration: 0.000108242s (0.11%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Pluggable schema validator for pydantic."""
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|from __future__ import annotations
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|import functools
     6|         0|            0|            0|  0.00%|from typing import TYPE_CHECKING, Any, Callable, Iterable, TypeVar
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|from pydantic_core import CoreConfig, CoreSchema, SchemaValidator, ValidationError
     9|         0|            0|            0|  0.00%|from typing_extensions import Literal, ParamSpec
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|if TYPE_CHECKING:
    12|         0|            0|            0|  0.00%|    from . import BaseValidateHandlerProtocol, PydanticPluginProtocol, SchemaKind, SchemaTypePath
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|P = ParamSpec('P')
    16|         0|            0|            0|  0.00%|R = TypeVar('R')
    17|         0|            0|            0|  0.00%|Event = Literal['on_validate_python', 'on_validate_json', 'on_validate_strings']
    18|         0|            0|            0|  0.00%|events: list[Event] = list(Event.__args__)  # type: ignore
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|
    21|         2|  7.62939e-06|   3.8147e-06|  0.01%|def create_schema_validator(
    22|         0|            0|            0|  0.00%|    schema: CoreSchema,
    23|         0|            0|            0|  0.00%|    schema_type: Any,
    24|         0|            0|            0|  0.00%|    schema_type_module: str,
    25|         0|            0|            0|  0.00%|    schema_type_name: str,
    26|         0|            0|            0|  0.00%|    schema_kind: SchemaKind,
    27|         0|            0|            0|  0.00%|    config: CoreConfig | None = None,
    28|         0|            0|            0|  0.00%|    plugin_settings: dict[str, Any] | None = None,
    29|         0|            0|            0|  0.00%|) -> SchemaValidator | PluggableSchemaValidator:
    30|         0|            0|            0|  0.00%|    """Create a `SchemaValidator` or `PluggableSchemaValidator` if plugins are installed.
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|    Returns:
    33|         0|            0|            0|  0.00%|        If plugins are installed then return `PluggableSchemaValidator`, otherwise return `SchemaValidator`.
    34|         0|            0|            0|  0.00%|    """
    35|         2|  4.22001e-05|     2.11e-05|  0.04%|    from . import SchemaTypePath
(call)|         2|  1.16825e-05|  5.84126e-06|  0.01%|# <frozen importlib._bootstrap>:645 parent
(call)|         2|  4.52995e-05|  2.26498e-05|  0.05%|# <frozen importlib._bootstrap>:1390 _handle_fromlist
    36|         2|  1.52588e-05|  7.62939e-06|  0.02%|    from ._loader import get_plugins
(call)|         2|  7.62939e-06|   3.8147e-06|  0.01%|# <frozen importlib._bootstrap>:645 parent
    37|         0|            0|            0|  0.00%|
    38|         2|  2.57492e-05|  1.28746e-05|  0.03%|    plugins = get_plugins()
(call)|         2|  0.000138283|  6.91414e-05|  0.14%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/plugin/_loader.py:21 get_plugins
    39|         2|  4.05312e-06|  2.02656e-06|  0.00%|    if plugins:
    40|         0|            0|            0|  0.00%|        return PluggableSchemaValidator(
    41|         0|            0|            0|  0.00%|            schema,
    42|         0|            0|            0|  0.00%|            schema_type,
    43|         0|            0|            0|  0.00%|            SchemaTypePath(schema_type_module, schema_type_name),
    44|         0|            0|            0|  0.00%|            schema_kind,
    45|         0|            0|            0|  0.00%|            config,
    46|         0|            0|            0|  0.00%|            plugins,
    47|         0|            0|            0|  0.00%|            plugin_settings or {},
    48|         0|            0|            0|  0.00%|        )
    49|         0|            0|            0|  0.00%|    else:
    50|         2|  1.33514e-05|  6.67572e-06|  0.01%|        return SchemaValidator(schema, config)
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|class PluggableSchemaValidator:
    54|         0|            0|            0|  0.00%|    """Pluggable schema validator."""
    55|         0|            0|            0|  0.00%|
    56|         0|            0|            0|  0.00%|    __slots__ = '_schema_validator', 'validate_json', 'validate_python', 'validate_strings'
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|    def __init__(
    59|         0|            0|            0|  0.00%|        self,
    60|         0|            0|            0|  0.00%|        schema: CoreSchema,
    61|         0|            0|            0|  0.00%|        schema_type: Any,
    62|         0|            0|            0|  0.00%|        schema_type_path: SchemaTypePath,
    63|         0|            0|            0|  0.00%|        schema_kind: SchemaKind,
    64|         0|            0|            0|  0.00%|        config: CoreConfig | None,
    65|         0|            0|            0|  0.00%|        plugins: Iterable[PydanticPluginProtocol],
    66|         0|            0|            0|  0.00%|        plugin_settings: dict[str, Any],
    67|         0|            0|            0|  0.00%|    ) -> None:
    68|         0|            0|            0|  0.00%|        self._schema_validator = SchemaValidator(schema, config)
    69|         0|            0|            0|  0.00%|
    70|         0|            0|            0|  0.00%|        python_event_handlers: list[BaseValidateHandlerProtocol] = []
    71|         0|            0|            0|  0.00%|        json_event_handlers: list[BaseValidateHandlerProtocol] = []
    72|         0|            0|            0|  0.00%|        strings_event_handlers: list[BaseValidateHandlerProtocol] = []
    73|         0|            0|            0|  0.00%|        for plugin in plugins:
    74|         0|            0|            0|  0.00%|            try:
    75|         0|            0|            0|  0.00%|                p, j, s = plugin.new_schema_validator(
    76|         0|            0|            0|  0.00%|                    schema, schema_type, schema_type_path, schema_kind, config, plugin_settings
    77|         0|            0|            0|  0.00%|                )
    78|         0|            0|            0|  0.00%|            except TypeError as e:  # pragma: no cover
    79|         0|            0|            0|  0.00%|                raise TypeError(f'Error using plugin `{plugin.__module__}:{plugin.__class__.__name__}`: {e}') from e
    80|         0|            0|            0|  0.00%|            if p is not None:
    81|         0|            0|            0|  0.00%|                python_event_handlers.append(p)
    82|         0|            0|            0|  0.00%|            if j is not None:
    83|         0|            0|            0|  0.00%|                json_event_handlers.append(j)
    84|         0|            0|            0|  0.00%|            if s is not None:
    85|         0|            0|            0|  0.00%|                strings_event_handlers.append(s)
    86|         0|            0|            0|  0.00%|
    87|         0|            0|            0|  0.00%|        self.validate_python = build_wrapper(self._schema_validator.validate_python, python_event_handlers)
    88|         0|            0|            0|  0.00%|        self.validate_json = build_wrapper(self._schema_validator.validate_json, json_event_handlers)
    89|         0|            0|            0|  0.00%|        self.validate_strings = build_wrapper(self._schema_validator.validate_strings, strings_event_handlers)
    90|         0|            0|            0|  0.00%|
    91|         0|            0|            0|  0.00%|    def __getattr__(self, name: str) -> Any:
    92|         0|            0|            0|  0.00%|        return getattr(self._schema_validator, name)
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|
    95|         0|            0|            0|  0.00%|def build_wrapper(func: Callable[P, R], event_handlers: list[BaseValidateHandlerProtocol]) -> Callable[P, R]:
    96|         0|            0|            0|  0.00%|    if not event_handlers:
    97|         0|            0|            0|  0.00%|        return func
    98|         0|            0|            0|  0.00%|    else:
    99|         0|            0|            0|  0.00%|        on_enters = tuple(h.on_enter for h in event_handlers if filter_handlers(h, 'on_enter'))
   100|         0|            0|            0|  0.00%|        on_successes = tuple(h.on_success for h in event_handlers if filter_handlers(h, 'on_success'))
   101|         0|            0|            0|  0.00%|        on_errors = tuple(h.on_error for h in event_handlers if filter_handlers(h, 'on_error'))
   102|         0|            0|            0|  0.00%|        on_exceptions = tuple(h.on_exception for h in event_handlers if filter_handlers(h, 'on_exception'))
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|        @functools.wraps(func)
   105|         0|            0|            0|  0.00%|        def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:
   106|         0|            0|            0|  0.00%|            for on_enter_handler in on_enters:
   107|         0|            0|            0|  0.00%|                on_enter_handler(*args, **kwargs)
   108|         0|            0|            0|  0.00%|
   109|         0|            0|            0|  0.00%|            try:
   110|         0|            0|            0|  0.00%|                result = func(*args, **kwargs)
   111|         0|            0|            0|  0.00%|            except ValidationError as error:
   112|         0|            0|            0|  0.00%|                for on_error_handler in on_errors:
   113|         0|            0|            0|  0.00%|                    on_error_handler(error)
   114|         0|            0|            0|  0.00%|                raise
   115|         0|            0|            0|  0.00%|            except Exception as exception:
   116|         0|            0|            0|  0.00%|                for on_exception_handler in on_exceptions:
   117|         0|            0|            0|  0.00%|                    on_exception_handler(exception)
   118|         0|            0|            0|  0.00%|                raise
   119|         0|            0|            0|  0.00%|            else:
   120|         0|            0|            0|  0.00%|                for on_success_handler in on_successes:
   121|         0|            0|            0|  0.00%|                    on_success_handler(result)
   122|         0|            0|            0|  0.00%|                return result
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|        return wrapper
   125|         0|            0|            0|  0.00%|
   126|         0|            0|            0|  0.00%|
   127|         0|            0|            0|  0.00%|def filter_handlers(handler_cls: BaseValidateHandlerProtocol, method_name: str) -> bool:
   128|         0|            0|            0|  0.00%|    """Filter out handler methods which are not implemented by the plugin directly - e.g. are missing
   129|         0|            0|            0|  0.00%|    or are inherited from the protocol.
   130|         0|            0|            0|  0.00%|    """
   131|         0|            0|            0|  0.00%|    handler = getattr(handler_cls, method_name, None)
   132|         0|            0|            0|  0.00%|    if handler is None:
   133|         0|            0|            0|  0.00%|        return False
   134|         0|            0|            0|  0.00%|    elif handler.__module__ == 'pydantic.plugin':
   135|         0|            0|            0|  0.00%|        # this is the original handler, from the protocol due to runtime inheritance
   136|         0|            0|            0|  0.00%|        # we don't want to call it
   137|         0|            0|            0|  0.00%|        return False
   138|         0|            0|            0|  0.00%|    else:
   139|         0|            0|            0|  0.00%|        return True
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_schema_generation_shared.py
File duration: 9.56059e-05s (0.10%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Types and utility functions used by various other internal tools."""
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|from __future__ import annotations
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|from typing import TYPE_CHECKING, Any, Callable
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|from pydantic_core import core_schema
     8|         0|            0|            0|  0.00%|from typing_extensions import Literal
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|from ..annotated_handlers import GetCoreSchemaHandler, GetJsonSchemaHandler
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|if TYPE_CHECKING:
    13|         0|            0|            0|  0.00%|    from ..json_schema import GenerateJsonSchema, JsonSchemaValue
    14|         0|            0|            0|  0.00%|    from ._core_utils import CoreSchemaOrField
    15|         0|            0|            0|  0.00%|    from ._generate_schema import GenerateSchema
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|    GetJsonSchemaFunction = Callable[[CoreSchemaOrField, GetJsonSchemaHandler], JsonSchemaValue]
    18|         0|            0|            0|  0.00%|    HandlerOverride = Callable[[CoreSchemaOrField], JsonSchemaValue]
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|class GenerateJsonSchemaHandler(GetJsonSchemaHandler):
    22|         0|            0|            0|  0.00%|    """JsonSchemaHandler implementation that doesn't do ref unwrapping by default.
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|    This is used for any Annotated metadata so that we don't end up with conflicting
    25|         0|            0|            0|  0.00%|    modifications to the definition schema.
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|    Used internally by Pydantic, please do not rely on this implementation.
    28|         0|            0|            0|  0.00%|    See `GetJsonSchemaHandler` for the handler API.
    29|         0|            0|            0|  0.00%|    """
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|    def __init__(self, generate_json_schema: GenerateJsonSchema, handler_override: HandlerOverride | None) -> None:
    32|         0|            0|            0|  0.00%|        self.generate_json_schema = generate_json_schema
    33|         0|            0|            0|  0.00%|        self.handler = handler_override or generate_json_schema.generate_inner
    34|         0|            0|            0|  0.00%|        self.mode = generate_json_schema.mode
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|    def __call__(self, core_schema: CoreSchemaOrField, /) -> JsonSchemaValue:
    37|         0|            0|            0|  0.00%|        return self.handler(core_schema)
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|    def resolve_ref_schema(self, maybe_ref_json_schema: JsonSchemaValue) -> JsonSchemaValue:
    40|         0|            0|            0|  0.00%|        """Resolves `$ref` in the json schema.
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|        This returns the input json schema if there is no `$ref` in json schema.
    43|         0|            0|            0|  0.00%|
    44|         0|            0|            0|  0.00%|        Args:
    45|         0|            0|            0|  0.00%|            maybe_ref_json_schema: The input json schema that may contains `$ref`.
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|        Returns:
    48|         0|            0|            0|  0.00%|            Resolved json schema.
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|        Raises:
    51|         0|            0|            0|  0.00%|            LookupError: If it can't find the definition for `$ref`.
    52|         0|            0|            0|  0.00%|        """
    53|         0|            0|            0|  0.00%|        if '$ref' not in maybe_ref_json_schema:
    54|         0|            0|            0|  0.00%|            return maybe_ref_json_schema
    55|         0|            0|            0|  0.00%|        ref = maybe_ref_json_schema['$ref']
    56|         0|            0|            0|  0.00%|        json_schema = self.generate_json_schema.get_schema_from_definitions(ref)
    57|         0|            0|            0|  0.00%|        if json_schema is None:
    58|         0|            0|            0|  0.00%|            raise LookupError(
    59|         0|            0|            0|  0.00%|                f'Could not find a ref for {ref}.'
    60|         0|            0|            0|  0.00%|                ' Maybe you tried to call resolve_ref_schema from within a recursive model?'
    61|         0|            0|            0|  0.00%|            )
    62|         0|            0|            0|  0.00%|        return json_schema
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|class CallbackGetCoreSchemaHandler(GetCoreSchemaHandler):
    66|         0|            0|            0|  0.00%|    """Wrapper to use an arbitrary function as a `GetCoreSchemaHandler`.
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|    Used internally by Pydantic, please do not rely on this implementation.
    69|         0|            0|            0|  0.00%|    See `GetCoreSchemaHandler` for the handler API.
    70|         0|            0|            0|  0.00%|    """
    71|         0|            0|            0|  0.00%|
    72|         4|   1.0252e-05|    2.563e-06|  0.01%|    def __init__(
    73|         0|            0|            0|  0.00%|        self,
    74|         0|            0|            0|  0.00%|        handler: Callable[[Any], core_schema.CoreSchema],
    75|         0|            0|            0|  0.00%|        generate_schema: GenerateSchema,
    76|         0|            0|            0|  0.00%|        ref_mode: Literal['to-def', 'unpack'] = 'to-def',
    77|         0|            0|            0|  0.00%|    ) -> None:
    78|         4|  9.05991e-06|  2.26498e-06|  0.01%|        self._handler = handler
    79|         4|  4.52995e-06|  1.13249e-06|  0.00%|        self._generate_schema = generate_schema
    80|         4|  4.76837e-06|  1.19209e-06|  0.00%|        self._ref_mode = ref_mode
    81|         0|            0|            0|  0.00%|
    82|         4|  1.21593e-05|  3.03984e-06|  0.01%|    def __call__(self, source_type: Any, /) -> core_schema.CoreSchema:
    83|         4|  3.14713e-05|  7.86781e-06|  0.03%|        schema = self._handler(source_type)
(call)|         2|  0.000935078|  0.000467539|  0.96%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:1868 inner_handler
(call)|         2|   0.00121164|  0.000605822|  1.25%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_internal/_generate_schema.py:1971 new_handler
    84|         4|  7.15256e-06|  1.78814e-06|  0.01%|        ref = schema.get('ref')
    85|         4|  5.96046e-06|  1.49012e-06|  0.01%|        if self._ref_mode == 'to-def':
    86|         4|  5.24521e-06|   1.3113e-06|  0.01%|            if ref is not None:
    87|         0|            0|            0|  0.00%|                self._generate_schema.defs.definitions[ref] = schema
    88|         0|            0|            0|  0.00%|                return core_schema.definition_reference_schema(ref)
    89|         4|  5.00679e-06|   1.2517e-06|  0.01%|            return schema
    90|         0|            0|            0|  0.00%|        else:  # ref_mode = 'unpack
    91|         0|            0|            0|  0.00%|            return self.resolve_ref_schema(schema)
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|    def _get_types_namespace(self) -> dict[str, Any] | None:
    94|         0|            0|            0|  0.00%|        return self._generate_schema._types_namespace
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|    def generate_schema(self, source_type: Any, /) -> core_schema.CoreSchema:
    97|         0|            0|            0|  0.00%|        return self._generate_schema.generate_schema(source_type)
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|    @property
   100|         0|            0|            0|  0.00%|    def field_name(self) -> str | None:
   101|         0|            0|            0|  0.00%|        return self._generate_schema.field_name_stack.get()
   102|         0|            0|            0|  0.00%|
   103|         0|            0|            0|  0.00%|    def resolve_ref_schema(self, maybe_ref_schema: core_schema.CoreSchema) -> core_schema.CoreSchema:
   104|         0|            0|            0|  0.00%|        """Resolves reference in the core schema.
   105|         0|            0|            0|  0.00%|
   106|         0|            0|            0|  0.00%|        Args:
   107|         0|            0|            0|  0.00%|            maybe_ref_schema: The input core schema that may contains reference.
   108|         0|            0|            0|  0.00%|
   109|         0|            0|            0|  0.00%|        Returns:
   110|         0|            0|            0|  0.00%|            Resolved core schema.
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|        Raises:
   113|         0|            0|            0|  0.00%|            LookupError: If it can't find the definition for reference.
   114|         0|            0|            0|  0.00%|        """
   115|         0|            0|            0|  0.00%|        if maybe_ref_schema['type'] == 'definition-ref':
   116|         0|            0|            0|  0.00%|            ref = maybe_ref_schema['schema_ref']
   117|         0|            0|            0|  0.00%|            if ref not in self._generate_schema.defs.definitions:
   118|         0|            0|            0|  0.00%|                raise LookupError(
   119|         0|            0|            0|  0.00%|                    f'Could not find a ref for {ref}.'
   120|         0|            0|            0|  0.00%|                    ' Maybe you tried to call resolve_ref_schema from within a recursive model?'
   121|         0|            0|            0|  0.00%|                )
   122|         0|            0|            0|  0.00%|            return self._generate_schema.defs.definitions[ref]
   123|         0|            0|            0|  0.00%|        elif maybe_ref_schema['type'] == 'definitions':
   124|         0|            0|            0|  0.00%|            return self.resolve_ref_schema(maybe_ref_schema['schema'])
   125|         0|            0|            0|  0.00%|        return maybe_ref_schema
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/dependencies/models.py
File duration: 7.4625e-05s (0.08%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|from typing import Any, Callable, List, Optional, Sequence
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|from fastapi._compat import ModelField
     4|         0|            0|            0|  0.00%|from fastapi.security.base import SecurityBase
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|class SecurityRequirement:
     8|         0|            0|            0|  0.00%|    def __init__(
     9|         0|            0|            0|  0.00%|        self, security_scheme: SecurityBase, scopes: Optional[Sequence[str]] = None
    10|         0|            0|            0|  0.00%|    ):
    11|         0|            0|            0|  0.00%|        self.security_scheme = security_scheme
    12|         0|            0|            0|  0.00%|        self.scopes = scopes
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|class Dependant:
    16|         1|  4.52995e-06|  4.52995e-06|  0.00%|    def __init__(
    17|         0|            0|            0|  0.00%|        self,
    18|         0|            0|            0|  0.00%|        *,
    19|         0|            0|            0|  0.00%|        path_params: Optional[List[ModelField]] = None,
    20|         0|            0|            0|  0.00%|        query_params: Optional[List[ModelField]] = None,
    21|         0|            0|            0|  0.00%|        header_params: Optional[List[ModelField]] = None,
    22|         0|            0|            0|  0.00%|        cookie_params: Optional[List[ModelField]] = None,
    23|         0|            0|            0|  0.00%|        body_params: Optional[List[ModelField]] = None,
    24|         0|            0|            0|  0.00%|        dependencies: Optional[List["Dependant"]] = None,
    25|         0|            0|            0|  0.00%|        security_schemes: Optional[List[SecurityRequirement]] = None,
    26|         0|            0|            0|  0.00%|        name: Optional[str] = None,
    27|         0|            0|            0|  0.00%|        call: Optional[Callable[..., Any]] = None,
    28|         0|            0|            0|  0.00%|        request_param_name: Optional[str] = None,
    29|         0|            0|            0|  0.00%|        websocket_param_name: Optional[str] = None,
    30|         0|            0|            0|  0.00%|        http_connection_param_name: Optional[str] = None,
    31|         0|            0|            0|  0.00%|        response_param_name: Optional[str] = None,
    32|         0|            0|            0|  0.00%|        background_tasks_param_name: Optional[str] = None,
    33|         0|            0|            0|  0.00%|        security_scopes_param_name: Optional[str] = None,
    34|         0|            0|            0|  0.00%|        security_scopes: Optional[List[str]] = None,
    35|         0|            0|            0|  0.00%|        use_cache: bool = True,
    36|         0|            0|            0|  0.00%|        path: Optional[str] = None,
    37|         0|            0|            0|  0.00%|    ) -> None:
    38|         1|  8.82149e-06|  8.82149e-06|  0.01%|        self.path_params = path_params or []
    39|         1|   2.6226e-06|   2.6226e-06|  0.00%|        self.query_params = query_params or []
    40|         1|  4.76837e-06|  4.76837e-06|  0.00%|        self.header_params = header_params or []
    41|         1|  2.86102e-06|  2.86102e-06|  0.00%|        self.cookie_params = cookie_params or []
    42|         1|  2.14577e-06|  2.14577e-06|  0.00%|        self.body_params = body_params or []
    43|         1|  3.09944e-06|  3.09944e-06|  0.00%|        self.dependencies = dependencies or []
    44|         1|   2.6226e-06|   2.6226e-06|  0.00%|        self.security_requirements = security_schemes or []
    45|         1|  4.29153e-06|  4.29153e-06|  0.00%|        self.request_param_name = request_param_name
    46|         1|   2.6226e-06|   2.6226e-06|  0.00%|        self.websocket_param_name = websocket_param_name
    47|         1|   2.6226e-06|   2.6226e-06|  0.00%|        self.http_connection_param_name = http_connection_param_name
    48|         1|  2.38419e-06|  2.38419e-06|  0.00%|        self.response_param_name = response_param_name
    49|         1|   2.6226e-06|   2.6226e-06|  0.00%|        self.background_tasks_param_name = background_tasks_param_name
    50|         1|   2.6226e-06|   2.6226e-06|  0.00%|        self.security_scopes = security_scopes
    51|         1|  2.86102e-06|  2.86102e-06|  0.00%|        self.security_scopes_param_name = security_scopes_param_name
    52|         1|  8.58307e-06|  8.58307e-06|  0.01%|        self.name = name
    53|         1|   2.6226e-06|   2.6226e-06|  0.00%|        self.call = call
    54|         1|   2.6226e-06|   2.6226e-06|  0.00%|        self.use_cache = use_cache
    55|         0|            0|            0|  0.00%|        # Store the path to be able to re-generate a dependable from it in overrides
    56|         1|  2.38419e-06|  2.38419e-06|  0.00%|        self.path = path
    57|         0|            0|            0|  0.00%|        # Save the cache key at creation to optimize performance
    58|         1|  6.91414e-06|  6.91414e-06|  0.01%|        self.cache_key = (self.call, tuple(sorted(set(self.security_scopes or []))))
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/plugin/_loader.py
File duration: 5.50747e-05s (0.06%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|from __future__ import annotations
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|import importlib.metadata as importlib_metadata
     4|         0|            0|            0|  0.00%|import os
     5|         0|            0|            0|  0.00%|import warnings
     6|         0|            0|            0|  0.00%|from typing import TYPE_CHECKING, Final, Iterable
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|if TYPE_CHECKING:
     9|         0|            0|            0|  0.00%|    from . import PydanticPluginProtocol
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|PYDANTIC_ENTRY_POINT_GROUP: Final[str] = 'pydantic'
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|# cache of plugins
    15|         0|            0|            0|  0.00%|_plugins: dict[str, PydanticPluginProtocol] | None = None
    16|         0|            0|            0|  0.00%|# return no plugins while loading plugins to avoid recursion and errors while import plugins
    17|         0|            0|            0|  0.00%|# this means that if plugins use pydantic
    18|         0|            0|            0|  0.00%|_loading_plugins: bool = False
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|
    21|         2|  9.05991e-06|  4.52995e-06|  0.01%|def get_plugins() -> Iterable[PydanticPluginProtocol]:
    22|         0|            0|            0|  0.00%|    """Load plugins for Pydantic.
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|    Inspired by: https://github.com/pytest-dev/pluggy/blob/1.3.0/src/pluggy/_manager.py#L376-L402
    25|         0|            0|            0|  0.00%|    """
    26|         2|  2.38419e-05|  1.19209e-05|  0.02%|    disabled_plugins = os.getenv('PYDANTIC_DISABLE_PLUGINS')
(call)|         2|  8.32081e-05|   4.1604e-05|  0.09%|# <frozen os>:779 getenv
    27|         0|            0|            0|  0.00%|    global _plugins, _loading_plugins
    28|         2|  5.96046e-06|  2.98023e-06|  0.01%|    if _loading_plugins:
    29|         0|            0|            0|  0.00%|        # this happens when plugins themselves use pydantic, we return no plugins
    30|         0|            0|            0|  0.00%|        return ()
    31|         2|  5.48363e-06|  2.74181e-06|  0.01%|    elif disabled_plugins in ('__all__', '1', 'true'):
    32|         0|            0|            0|  0.00%|        return ()
    33|         2|  5.24521e-06|   2.6226e-06|  0.01%|    elif _plugins is None:
    34|         0|            0|            0|  0.00%|        _plugins = {}
    35|         0|            0|            0|  0.00%|        # set _loading_plugins so any plugins that use pydantic don't themselves use plugins
    36|         0|            0|            0|  0.00%|        _loading_plugins = True
    37|         0|            0|            0|  0.00%|        try:
    38|         0|            0|            0|  0.00%|            for dist in importlib_metadata.distributions():
    39|         0|            0|            0|  0.00%|                for entry_point in dist.entry_points:
    40|         0|            0|            0|  0.00%|                    if entry_point.group != PYDANTIC_ENTRY_POINT_GROUP:
    41|         0|            0|            0|  0.00%|                        continue
    42|         0|            0|            0|  0.00%|                    if entry_point.value in _plugins:
    43|         0|            0|            0|  0.00%|                        continue
    44|         0|            0|            0|  0.00%|                    if disabled_plugins is not None and entry_point.name in disabled_plugins.split(','):
    45|         0|            0|            0|  0.00%|                        continue
    46|         0|            0|            0|  0.00%|                    try:
    47|         0|            0|            0|  0.00%|                        _plugins[entry_point.value] = entry_point.load()
    48|         0|            0|            0|  0.00%|                    except (ImportError, AttributeError) as e:
    49|         0|            0|            0|  0.00%|                        warnings.warn(
    50|         0|            0|            0|  0.00%|                            f'{e.__class__.__name__} while loading the `{entry_point.name}` Pydantic plugin, '
    51|         0|            0|            0|  0.00%|                            f'this plugin will not be installed.\n\n{e!r}'
    52|         0|            0|            0|  0.00%|                        )
    53|         0|            0|            0|  0.00%|        finally:
    54|         0|            0|            0|  0.00%|            _loading_plugins = False
    55|         0|            0|            0|  0.00%|
    56|         2|  5.48363e-06|  2.74181e-06|  0.01%|    return _plugins.values()
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/dataclasses.py
File duration: 5.07832e-05s (0.05%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|import re
     2|         0|            0|            0|  0.00%|import sys
     3|         0|            0|            0|  0.00%|import copy
     4|         0|            0|            0|  0.00%|import types
     5|         0|            0|            0|  0.00%|import inspect
     6|         0|            0|            0|  0.00%|import keyword
     7|         0|            0|            0|  0.00%|import functools
     8|         0|            0|            0|  0.00%|import itertools
     9|         0|            0|            0|  0.00%|import abc
    10|         0|            0|            0|  0.00%|import _thread
    11|         0|            0|            0|  0.00%|from types import FunctionType, GenericAlias
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|__all__ = ['dataclass',
    15|         0|            0|            0|  0.00%|           'field',
    16|         0|            0|            0|  0.00%|           'Field',
    17|         0|            0|            0|  0.00%|           'FrozenInstanceError',
    18|         0|            0|            0|  0.00%|           'InitVar',
    19|         0|            0|            0|  0.00%|           'KW_ONLY',
    20|         0|            0|            0|  0.00%|           'MISSING',
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|           # Helper functions.
    23|         0|            0|            0|  0.00%|           'fields',
    24|         0|            0|            0|  0.00%|           'asdict',
    25|         0|            0|            0|  0.00%|           'astuple',
    26|         0|            0|            0|  0.00%|           'make_dataclass',
    27|         0|            0|            0|  0.00%|           'replace',
    28|         0|            0|            0|  0.00%|           'is_dataclass',
    29|         0|            0|            0|  0.00%|           ]
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|# Conditions for adding methods.  The boxes indicate what action the
    32|         0|            0|            0|  0.00%|# dataclass decorator takes.  For all of these tables, when I talk
    33|         0|            0|            0|  0.00%|# about init=, repr=, eq=, order=, unsafe_hash=, or frozen=, I'm
    34|         0|            0|            0|  0.00%|# referring to the arguments to the @dataclass decorator.  When
    35|         0|            0|            0|  0.00%|# checking if a dunder method already exists, I mean check for an
    36|         0|            0|            0|  0.00%|# entry in the class's __dict__.  I never check to see if an attribute
    37|         0|            0|            0|  0.00%|# is defined in a base class.
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|# Key:
    40|         0|            0|            0|  0.00%|# +=========+=========================================+
    41|         0|            0|            0|  0.00%|# + Value   | Meaning                                 |
    42|         0|            0|            0|  0.00%|# +=========+=========================================+
    43|         0|            0|            0|  0.00%|# | <blank> | No action: no method is added.          |
    44|         0|            0|            0|  0.00%|# +---------+-----------------------------------------+
    45|         0|            0|            0|  0.00%|# | add     | Generated method is added.              |
    46|         0|            0|            0|  0.00%|# +---------+-----------------------------------------+
    47|         0|            0|            0|  0.00%|# | raise   | TypeError is raised.                    |
    48|         0|            0|            0|  0.00%|# +---------+-----------------------------------------+
    49|         0|            0|            0|  0.00%|# | None    | Attribute is set to None.               |
    50|         0|            0|            0|  0.00%|# +=========+=========================================+
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|# __init__
    53|         0|            0|            0|  0.00%|#
    54|         0|            0|            0|  0.00%|#   +--- init= parameter
    55|         0|            0|            0|  0.00%|#   |
    56|         0|            0|            0|  0.00%|#   v     |       |       |
    57|         0|            0|            0|  0.00%|#         |  no   |  yes  |  <--- class has __init__ in __dict__?
    58|         0|            0|            0|  0.00%|# +=======+=======+=======+
    59|         0|            0|            0|  0.00%|# | False |       |       |
    60|         0|            0|            0|  0.00%|# +-------+-------+-------+
    61|         0|            0|            0|  0.00%|# | True  | add   |       |  <- the default
    62|         0|            0|            0|  0.00%|# +=======+=======+=======+
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|# __repr__
    65|         0|            0|            0|  0.00%|#
    66|         0|            0|            0|  0.00%|#    +--- repr= parameter
    67|         0|            0|            0|  0.00%|#    |
    68|         0|            0|            0|  0.00%|#    v    |       |       |
    69|         0|            0|            0|  0.00%|#         |  no   |  yes  |  <--- class has __repr__ in __dict__?
    70|         0|            0|            0|  0.00%|# +=======+=======+=======+
    71|         0|            0|            0|  0.00%|# | False |       |       |
    72|         0|            0|            0|  0.00%|# +-------+-------+-------+
    73|         0|            0|            0|  0.00%|# | True  | add   |       |  <- the default
    74|         0|            0|            0|  0.00%|# +=======+=======+=======+
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|# __setattr__
    78|         0|            0|            0|  0.00%|# __delattr__
    79|         0|            0|            0|  0.00%|#
    80|         0|            0|            0|  0.00%|#    +--- frozen= parameter
    81|         0|            0|            0|  0.00%|#    |
    82|         0|            0|            0|  0.00%|#    v    |       |       |
    83|         0|            0|            0|  0.00%|#         |  no   |  yes  |  <--- class has __setattr__ or __delattr__ in __dict__?
    84|         0|            0|            0|  0.00%|# +=======+=======+=======+
    85|         0|            0|            0|  0.00%|# | False |       |       |  <- the default
    86|         0|            0|            0|  0.00%|# +-------+-------+-------+
    87|         0|            0|            0|  0.00%|# | True  | add   | raise |
    88|         0|            0|            0|  0.00%|# +=======+=======+=======+
    89|         0|            0|            0|  0.00%|# Raise because not adding these methods would break the "frozen-ness"
    90|         0|            0|            0|  0.00%|# of the class.
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|# __eq__
    93|         0|            0|            0|  0.00%|#
    94|         0|            0|            0|  0.00%|#    +--- eq= parameter
    95|         0|            0|            0|  0.00%|#    |
    96|         0|            0|            0|  0.00%|#    v    |       |       |
    97|         0|            0|            0|  0.00%|#         |  no   |  yes  |  <--- class has __eq__ in __dict__?
    98|         0|            0|            0|  0.00%|# +=======+=======+=======+
    99|         0|            0|            0|  0.00%|# | False |       |       |
   100|         0|            0|            0|  0.00%|# +-------+-------+-------+
   101|         0|            0|            0|  0.00%|# | True  | add   |       |  <- the default
   102|         0|            0|            0|  0.00%|# +=======+=======+=======+
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|# __lt__
   105|         0|            0|            0|  0.00%|# __le__
   106|         0|            0|            0|  0.00%|# __gt__
   107|         0|            0|            0|  0.00%|# __ge__
   108|         0|            0|            0|  0.00%|#
   109|         0|            0|            0|  0.00%|#    +--- order= parameter
   110|         0|            0|            0|  0.00%|#    |
   111|         0|            0|            0|  0.00%|#    v    |       |       |
   112|         0|            0|            0|  0.00%|#         |  no   |  yes  |  <--- class has any comparison method in __dict__?
   113|         0|            0|            0|  0.00%|# +=======+=======+=======+
   114|         0|            0|            0|  0.00%|# | False |       |       |  <- the default
   115|         0|            0|            0|  0.00%|# +-------+-------+-------+
   116|         0|            0|            0|  0.00%|# | True  | add   | raise |
   117|         0|            0|            0|  0.00%|# +=======+=======+=======+
   118|         0|            0|            0|  0.00%|# Raise because to allow this case would interfere with using
   119|         0|            0|            0|  0.00%|# functools.total_ordering.
   120|         0|            0|            0|  0.00%|
   121|         0|            0|            0|  0.00%|# __hash__
   122|         0|            0|            0|  0.00%|
   123|         0|            0|            0|  0.00%|#    +------------------- unsafe_hash= parameter
   124|         0|            0|            0|  0.00%|#    |       +----------- eq= parameter
   125|         0|            0|            0|  0.00%|#    |       |       +--- frozen= parameter
   126|         0|            0|            0|  0.00%|#    |       |       |
   127|         0|            0|            0|  0.00%|#    v       v       v    |        |        |
   128|         0|            0|            0|  0.00%|#                         |   no   |  yes   |  <--- class has explicitly defined __hash__
   129|         0|            0|            0|  0.00%|# +=======+=======+=======+========+========+
   130|         0|            0|            0|  0.00%|# | False | False | False |        |        | No __eq__, use the base class __hash__
   131|         0|            0|            0|  0.00%|# +-------+-------+-------+--------+--------+
   132|         0|            0|            0|  0.00%|# | False | False | True  |        |        | No __eq__, use the base class __hash__
   133|         0|            0|            0|  0.00%|# +-------+-------+-------+--------+--------+
   134|         0|            0|            0|  0.00%|# | False | True  | False | None   |        | <-- the default, not hashable
   135|         0|            0|            0|  0.00%|# +-------+-------+-------+--------+--------+
   136|         0|            0|            0|  0.00%|# | False | True  | True  | add    |        | Frozen, so hashable, allows override
   137|         0|            0|            0|  0.00%|# +-------+-------+-------+--------+--------+
   138|         0|            0|            0|  0.00%|# | True  | False | False | add    | raise  | Has no __eq__, but hashable
   139|         0|            0|            0|  0.00%|# +-------+-------+-------+--------+--------+
   140|         0|            0|            0|  0.00%|# | True  | False | True  | add    | raise  | Has no __eq__, but hashable
   141|         0|            0|            0|  0.00%|# +-------+-------+-------+--------+--------+
   142|         0|            0|            0|  0.00%|# | True  | True  | False | add    | raise  | Not frozen, but hashable
   143|         0|            0|            0|  0.00%|# +-------+-------+-------+--------+--------+
   144|         0|            0|            0|  0.00%|# | True  | True  | True  | add    | raise  | Frozen, so hashable
   145|         0|            0|            0|  0.00%|# +=======+=======+=======+========+========+
   146|         0|            0|            0|  0.00%|# For boxes that are blank, __hash__ is untouched and therefore
   147|         0|            0|            0|  0.00%|# inherited from the base class.  If the base is object, then
   148|         0|            0|            0|  0.00%|# id-based hashing is used.
   149|         0|            0|            0|  0.00%|#
   150|         0|            0|            0|  0.00%|# Note that a class may already have __hash__=None if it specified an
   151|         0|            0|            0|  0.00%|# __eq__ method in the class body (not one that was created by
   152|         0|            0|            0|  0.00%|# @dataclass).
   153|         0|            0|            0|  0.00%|#
   154|         0|            0|            0|  0.00%|# See _hash_action (below) for a coded version of this table.
   155|         0|            0|            0|  0.00%|
   156|         0|            0|            0|  0.00%|# __match_args__
   157|         0|            0|            0|  0.00%|#
   158|         0|            0|            0|  0.00%|#    +--- match_args= parameter
   159|         0|            0|            0|  0.00%|#    |
   160|         0|            0|            0|  0.00%|#    v    |       |       |
   161|         0|            0|            0|  0.00%|#         |  no   |  yes  |  <--- class has __match_args__ in __dict__?
   162|         0|            0|            0|  0.00%|# +=======+=======+=======+
   163|         0|            0|            0|  0.00%|# | False |       |       |
   164|         0|            0|            0|  0.00%|# +-------+-------+-------+
   165|         0|            0|            0|  0.00%|# | True  | add   |       |  <- the default
   166|         0|            0|            0|  0.00%|# +=======+=======+=======+
   167|         0|            0|            0|  0.00%|# __match_args__ is always added unless the class already defines it. It is a
   168|         0|            0|            0|  0.00%|# tuple of __init__ parameter names; non-init fields must be matched by keyword.
   169|         0|            0|            0|  0.00%|
   170|         0|            0|            0|  0.00%|
   171|         0|            0|            0|  0.00%|# Raised when an attempt is made to modify a frozen class.
   172|         0|            0|            0|  0.00%|class FrozenInstanceError(AttributeError): pass
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|# A sentinel object for default values to signal that a default
   175|         0|            0|            0|  0.00%|# factory will be used.  This is given a nice repr() which will appear
   176|         0|            0|            0|  0.00%|# in the function signature of dataclasses' constructors.
   177|         0|            0|            0|  0.00%|class _HAS_DEFAULT_FACTORY_CLASS:
   178|         0|            0|            0|  0.00%|    def __repr__(self):
   179|         0|            0|            0|  0.00%|        return '<factory>'
   180|         0|            0|            0|  0.00%|_HAS_DEFAULT_FACTORY = _HAS_DEFAULT_FACTORY_CLASS()
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|# A sentinel object to detect if a parameter is supplied or not.  Use
   183|         0|            0|            0|  0.00%|# a class to give it a better repr.
   184|         0|            0|            0|  0.00%|class _MISSING_TYPE:
   185|         0|            0|            0|  0.00%|    pass
   186|         0|            0|            0|  0.00%|MISSING = _MISSING_TYPE()
   187|         0|            0|            0|  0.00%|
   188|         0|            0|            0|  0.00%|# A sentinel object to indicate that following fields are keyword-only by
   189|         0|            0|            0|  0.00%|# default.  Use a class to give it a better repr.
   190|         0|            0|            0|  0.00%|class _KW_ONLY_TYPE:
   191|         0|            0|            0|  0.00%|    pass
   192|         0|            0|            0|  0.00%|KW_ONLY = _KW_ONLY_TYPE()
   193|         0|            0|            0|  0.00%|
   194|         0|            0|            0|  0.00%|# Since most per-field metadata will be unused, create an empty
   195|         0|            0|            0|  0.00%|# read-only proxy that can be shared among all fields.
   196|         0|            0|            0|  0.00%|_EMPTY_METADATA = types.MappingProxyType({})
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|# Markers for the various kinds of fields and pseudo-fields.
   199|         0|            0|            0|  0.00%|class _FIELD_BASE:
   200|         0|            0|            0|  0.00%|    def __init__(self, name):
   201|         0|            0|            0|  0.00%|        self.name = name
   202|         0|            0|            0|  0.00%|    def __repr__(self):
   203|         0|            0|            0|  0.00%|        return self.name
   204|         0|            0|            0|  0.00%|_FIELD = _FIELD_BASE('_FIELD')
   205|         0|            0|            0|  0.00%|_FIELD_CLASSVAR = _FIELD_BASE('_FIELD_CLASSVAR')
   206|         0|            0|            0|  0.00%|_FIELD_INITVAR = _FIELD_BASE('_FIELD_INITVAR')
   207|         0|            0|            0|  0.00%|
   208|         0|            0|            0|  0.00%|# The name of an attribute on the class where we store the Field
   209|         0|            0|            0|  0.00%|# objects.  Also used to check if a class is a Data Class.
   210|         0|            0|            0|  0.00%|_FIELDS = '__dataclass_fields__'
   211|         0|            0|            0|  0.00%|
   212|         0|            0|            0|  0.00%|# The name of an attribute on the class that stores the parameters to
   213|         0|            0|            0|  0.00%|# @dataclass.
   214|         0|            0|            0|  0.00%|_PARAMS = '__dataclass_params__'
   215|         0|            0|            0|  0.00%|
   216|         0|            0|            0|  0.00%|# The name of the function, that if it exists, is called at the end of
   217|         0|            0|            0|  0.00%|# __init__.
   218|         0|            0|            0|  0.00%|_POST_INIT_NAME = '__post_init__'
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|# String regex that string annotations for ClassVar or InitVar must match.
   221|         0|            0|            0|  0.00%|# Allows "identifier.identifier[" or "identifier[".
   222|         0|            0|            0|  0.00%|# https://bugs.python.org/issue33453 for details.
   223|         0|            0|            0|  0.00%|_MODULE_IDENTIFIER_RE = re.compile(r'^(?:\s*(\w+)\s*\.)?\s*(\w+)')
   224|         0|            0|            0|  0.00%|
   225|         0|            0|            0|  0.00%|# Atomic immutable types which don't require any recursive handling and for which deepcopy
   226|         0|            0|            0|  0.00%|# returns the same object. We can provide a fast-path for these types in asdict and astuple.
   227|         0|            0|            0|  0.00%|_ATOMIC_TYPES = frozenset({
   228|         0|            0|            0|  0.00%|    # Common JSON Serializable types
   229|         0|            0|            0|  0.00%|    types.NoneType,
   230|         0|            0|            0|  0.00%|    bool,
   231|         0|            0|            0|  0.00%|    int,
   232|         0|            0|            0|  0.00%|    float,
   233|         0|            0|            0|  0.00%|    str,
   234|         0|            0|            0|  0.00%|    # Other common types
   235|         0|            0|            0|  0.00%|    complex,
   236|         0|            0|            0|  0.00%|    bytes,
   237|         0|            0|            0|  0.00%|    # Other types that are also unaffected by deepcopy
   238|         0|            0|            0|  0.00%|    types.EllipsisType,
   239|         0|            0|            0|  0.00%|    types.NotImplementedType,
   240|         0|            0|            0|  0.00%|    types.CodeType,
   241|         0|            0|            0|  0.00%|    types.BuiltinFunctionType,
   242|         0|            0|            0|  0.00%|    types.FunctionType,
   243|         0|            0|            0|  0.00%|    type,
   244|         0|            0|            0|  0.00%|    range,
   245|         0|            0|            0|  0.00%|    property,
   246|         0|            0|            0|  0.00%|})
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|# This function's logic is copied from "recursive_repr" function in
   249|         0|            0|            0|  0.00%|# reprlib module to avoid dependency.
   250|         0|            0|            0|  0.00%|def _recursive_repr(user_function):
   251|         0|            0|            0|  0.00%|    # Decorator to make a repr function return "..." for a recursive
   252|         0|            0|            0|  0.00%|    # call.
   253|         0|            0|            0|  0.00%|    repr_running = set()
   254|         0|            0|            0|  0.00%|
   255|         0|            0|            0|  0.00%|    @functools.wraps(user_function)
   256|         0|            0|            0|  0.00%|    def wrapper(self):
   257|         0|            0|            0|  0.00%|        key = id(self), _thread.get_ident()
   258|         0|            0|            0|  0.00%|        if key in repr_running:
   259|         0|            0|            0|  0.00%|            return '...'
   260|         0|            0|            0|  0.00%|        repr_running.add(key)
   261|         0|            0|            0|  0.00%|        try:
   262|         0|            0|            0|  0.00%|            result = user_function(self)
   263|         0|            0|            0|  0.00%|        finally:
   264|         0|            0|            0|  0.00%|            repr_running.discard(key)
   265|         0|            0|            0|  0.00%|        return result
   266|         0|            0|            0|  0.00%|    return wrapper
   267|         0|            0|            0|  0.00%|
   268|         0|            0|            0|  0.00%|class InitVar:
   269|         0|            0|            0|  0.00%|    __slots__ = ('type', )
   270|         0|            0|            0|  0.00%|
   271|         0|            0|            0|  0.00%|    def __init__(self, type):
   272|         0|            0|            0|  0.00%|        self.type = type
   273|         0|            0|            0|  0.00%|
   274|         0|            0|            0|  0.00%|    def __repr__(self):
   275|         0|            0|            0|  0.00%|        if isinstance(self.type, type):
   276|         0|            0|            0|  0.00%|            type_name = self.type.__name__
   277|         0|            0|            0|  0.00%|        else:
   278|         0|            0|            0|  0.00%|            # typing objects, e.g. List[int]
   279|         0|            0|            0|  0.00%|            type_name = repr(self.type)
   280|         0|            0|            0|  0.00%|        return f'dataclasses.InitVar[{type_name}]'
   281|         0|            0|            0|  0.00%|
   282|         0|            0|            0|  0.00%|    def __class_getitem__(cls, type):
   283|         0|            0|            0|  0.00%|        return InitVar(type)
   284|         0|            0|            0|  0.00%|
   285|         0|            0|            0|  0.00%|# Instances of Field are only ever created from within this module,
   286|         0|            0|            0|  0.00%|# and only from the field() function, although Field instances are
   287|         0|            0|            0|  0.00%|# exposed externally as (conceptually) read-only objects.
   288|         0|            0|            0|  0.00%|#
   289|         0|            0|            0|  0.00%|# name and type are filled in after the fact, not in __init__.
   290|         0|            0|            0|  0.00%|# They're not known at the time this class is instantiated, but it's
   291|         0|            0|            0|  0.00%|# convenient if they're available later.
   292|         0|            0|            0|  0.00%|#
   293|         0|            0|            0|  0.00%|# When cls._FIELDS is filled in with a list of Field objects, the name
   294|         0|            0|            0|  0.00%|# and type fields will have been populated.
   295|         0|            0|            0|  0.00%|class Field:
   296|         0|            0|            0|  0.00%|    __slots__ = ('name',
   297|         0|            0|            0|  0.00%|                 'type',
   298|         0|            0|            0|  0.00%|                 'default',
   299|         0|            0|            0|  0.00%|                 'default_factory',
   300|         0|            0|            0|  0.00%|                 'repr',
   301|         0|            0|            0|  0.00%|                 'hash',
   302|         0|            0|            0|  0.00%|                 'init',
   303|         0|            0|            0|  0.00%|                 'compare',
   304|         0|            0|            0|  0.00%|                 'metadata',
   305|         0|            0|            0|  0.00%|                 'kw_only',
   306|         0|            0|            0|  0.00%|                 '_field_type',  # Private: not to be used by user code.
   307|         0|            0|            0|  0.00%|                 )
   308|         0|            0|            0|  0.00%|
   309|         0|            0|            0|  0.00%|    def __init__(self, default, default_factory, init, repr, hash, compare,
   310|         0|            0|            0|  0.00%|                 metadata, kw_only):
   311|         0|            0|            0|  0.00%|        self.name = None
   312|         0|            0|            0|  0.00%|        self.type = None
   313|         0|            0|            0|  0.00%|        self.default = default
   314|         0|            0|            0|  0.00%|        self.default_factory = default_factory
   315|         0|            0|            0|  0.00%|        self.init = init
   316|         0|            0|            0|  0.00%|        self.repr = repr
   317|         0|            0|            0|  0.00%|        self.hash = hash
   318|         0|            0|            0|  0.00%|        self.compare = compare
   319|         0|            0|            0|  0.00%|        self.metadata = (_EMPTY_METADATA
   320|         0|            0|            0|  0.00%|                         if metadata is None else
   321|         0|            0|            0|  0.00%|                         types.MappingProxyType(metadata))
   322|         0|            0|            0|  0.00%|        self.kw_only = kw_only
   323|         0|            0|            0|  0.00%|        self._field_type = None
   324|         0|            0|            0|  0.00%|
   325|         0|            0|            0|  0.00%|    @_recursive_repr
   326|         0|            0|            0|  0.00%|    def __repr__(self):
   327|         0|            0|            0|  0.00%|        return ('Field('
   328|         0|            0|            0|  0.00%|                f'name={self.name!r},'
   329|         0|            0|            0|  0.00%|                f'type={self.type!r},'
   330|         0|            0|            0|  0.00%|                f'default={self.default!r},'
   331|         0|            0|            0|  0.00%|                f'default_factory={self.default_factory!r},'
   332|         0|            0|            0|  0.00%|                f'init={self.init!r},'
   333|         0|            0|            0|  0.00%|                f'repr={self.repr!r},'
   334|         0|            0|            0|  0.00%|                f'hash={self.hash!r},'
   335|         0|            0|            0|  0.00%|                f'compare={self.compare!r},'
   336|         0|            0|            0|  0.00%|                f'metadata={self.metadata!r},'
   337|         0|            0|            0|  0.00%|                f'kw_only={self.kw_only!r},'
   338|         0|            0|            0|  0.00%|                f'_field_type={self._field_type}'
   339|         0|            0|            0|  0.00%|                ')')
   340|         0|            0|            0|  0.00%|
   341|         0|            0|            0|  0.00%|    # This is used to support the PEP 487 __set_name__ protocol in the
   342|         0|            0|            0|  0.00%|    # case where we're using a field that contains a descriptor as a
   343|         0|            0|            0|  0.00%|    # default value.  For details on __set_name__, see
   344|         0|            0|            0|  0.00%|    # https://peps.python.org/pep-0487/#implementation-details.
   345|         0|            0|            0|  0.00%|    #
   346|         0|            0|            0|  0.00%|    # Note that in _process_class, this Field object is overwritten
   347|         0|            0|            0|  0.00%|    # with the default value, so the end result is a descriptor that
   348|         0|            0|            0|  0.00%|    # had __set_name__ called on it at the right time.
   349|         0|            0|            0|  0.00%|    def __set_name__(self, owner, name):
   350|         0|            0|            0|  0.00%|        func = getattr(type(self.default), '__set_name__', None)
   351|         0|            0|            0|  0.00%|        if func:
   352|         0|            0|            0|  0.00%|            # There is a __set_name__ method on the descriptor, call
   353|         0|            0|            0|  0.00%|            # it.
   354|         0|            0|            0|  0.00%|            func(self.default, owner, name)
   355|         0|            0|            0|  0.00%|
   356|         0|            0|            0|  0.00%|    __class_getitem__ = classmethod(GenericAlias)
   357|         0|            0|            0|  0.00%|
   358|         0|            0|            0|  0.00%|
   359|         0|            0|            0|  0.00%|class _DataclassParams:
   360|         0|            0|            0|  0.00%|    __slots__ = ('init',
   361|         0|            0|            0|  0.00%|                 'repr',
   362|         0|            0|            0|  0.00%|                 'eq',
   363|         0|            0|            0|  0.00%|                 'order',
   364|         0|            0|            0|  0.00%|                 'unsafe_hash',
   365|         0|            0|            0|  0.00%|                 'frozen',
   366|         0|            0|            0|  0.00%|                 'match_args',
   367|         0|            0|            0|  0.00%|                 'kw_only',
   368|         0|            0|            0|  0.00%|                 'slots',
   369|         0|            0|            0|  0.00%|                 'weakref_slot',
   370|         0|            0|            0|  0.00%|                 )
   371|         0|            0|            0|  0.00%|
   372|         0|            0|            0|  0.00%|    def __init__(self,
   373|         0|            0|            0|  0.00%|                 init, repr, eq, order, unsafe_hash, frozen,
   374|         0|            0|            0|  0.00%|                 match_args, kw_only, slots, weakref_slot):
   375|         0|            0|            0|  0.00%|        self.init = init
   376|         0|            0|            0|  0.00%|        self.repr = repr
   377|         0|            0|            0|  0.00%|        self.eq = eq
   378|         0|            0|            0|  0.00%|        self.order = order
   379|         0|            0|            0|  0.00%|        self.unsafe_hash = unsafe_hash
   380|         0|            0|            0|  0.00%|        self.frozen = frozen
   381|         0|            0|            0|  0.00%|        self.match_args = match_args
   382|         0|            0|            0|  0.00%|        self.kw_only = kw_only
   383|         0|            0|            0|  0.00%|        self.slots = slots
   384|         0|            0|            0|  0.00%|        self.weakref_slot = weakref_slot
   385|         0|            0|            0|  0.00%|
   386|         0|            0|            0|  0.00%|    def __repr__(self):
   387|         0|            0|            0|  0.00%|        return ('_DataclassParams('
   388|         0|            0|            0|  0.00%|                f'init={self.init!r},'
   389|         0|            0|            0|  0.00%|                f'repr={self.repr!r},'
   390|         0|            0|            0|  0.00%|                f'eq={self.eq!r},'
   391|         0|            0|            0|  0.00%|                f'order={self.order!r},'
   392|         0|            0|            0|  0.00%|                f'unsafe_hash={self.unsafe_hash!r},'
   393|         0|            0|            0|  0.00%|                f'frozen={self.frozen!r},'
   394|         0|            0|            0|  0.00%|                f'match_args={self.match_args!r},'
   395|         0|            0|            0|  0.00%|                f'kw_only={self.kw_only!r},'
   396|         0|            0|            0|  0.00%|                f'slots={self.slots!r},'
   397|         0|            0|            0|  0.00%|                f'weakref_slot={self.weakref_slot!r}'
   398|         0|            0|            0|  0.00%|                ')')
   399|         0|            0|            0|  0.00%|
   400|         0|            0|            0|  0.00%|
   401|         0|            0|            0|  0.00%|# This function is used instead of exposing Field creation directly,
   402|         0|            0|            0|  0.00%|# so that a type checker can be told (via overloads) that this is a
   403|         0|            0|            0|  0.00%|# function whose type depends on its parameters.
   404|         0|            0|            0|  0.00%|def field(*, default=MISSING, default_factory=MISSING, init=True, repr=True,
   405|         0|            0|            0|  0.00%|          hash=None, compare=True, metadata=None, kw_only=MISSING):
   406|         0|            0|            0|  0.00%|    """Return an object to identify dataclass fields.
   407|         0|            0|            0|  0.00%|
   408|         0|            0|            0|  0.00%|    default is the default value of the field.  default_factory is a
   409|         0|            0|            0|  0.00%|    0-argument function called to initialize a field's value.  If init
   410|         0|            0|            0|  0.00%|    is true, the field will be a parameter to the class's __init__()
   411|         0|            0|            0|  0.00%|    function.  If repr is true, the field will be included in the
   412|         0|            0|            0|  0.00%|    object's repr().  If hash is true, the field will be included in the
   413|         0|            0|            0|  0.00%|    object's hash().  If compare is true, the field will be used in
   414|         0|            0|            0|  0.00%|    comparison functions.  metadata, if specified, must be a mapping
   415|         0|            0|            0|  0.00%|    which is stored but not otherwise examined by dataclass.  If kw_only
   416|         0|            0|            0|  0.00%|    is true, the field will become a keyword-only parameter to
   417|         0|            0|            0|  0.00%|    __init__().
   418|         0|            0|            0|  0.00%|
   419|         0|            0|            0|  0.00%|    It is an error to specify both default and default_factory.
   420|         0|            0|            0|  0.00%|    """
   421|         0|            0|            0|  0.00%|
   422|         0|            0|            0|  0.00%|    if default is not MISSING and default_factory is not MISSING:
   423|         0|            0|            0|  0.00%|        raise ValueError('cannot specify both default and default_factory')
   424|         0|            0|            0|  0.00%|    return Field(default, default_factory, init, repr, hash, compare,
   425|         0|            0|            0|  0.00%|                 metadata, kw_only)
   426|         0|            0|            0|  0.00%|
   427|         0|            0|            0|  0.00%|
   428|         0|            0|            0|  0.00%|def _fields_in_init_order(fields):
   429|         0|            0|            0|  0.00%|    # Returns the fields as __init__ will output them.  It returns 2 tuples:
   430|         0|            0|            0|  0.00%|    # the first for normal args, and the second for keyword args.
   431|         0|            0|            0|  0.00%|
   432|         0|            0|            0|  0.00%|    return (tuple(f for f in fields if f.init and not f.kw_only),
   433|         0|            0|            0|  0.00%|            tuple(f for f in fields if f.init and f.kw_only)
   434|         0|            0|            0|  0.00%|            )
   435|         0|            0|            0|  0.00%|
   436|         0|            0|            0|  0.00%|
   437|         0|            0|            0|  0.00%|def _tuple_str(obj_name, fields):
   438|         0|            0|            0|  0.00%|    # Return a string representing each field of obj_name as a tuple
   439|         0|            0|            0|  0.00%|    # member.  So, if fields is ['x', 'y'] and obj_name is "self",
   440|         0|            0|            0|  0.00%|    # return "(self.x,self.y)".
   441|         0|            0|            0|  0.00%|
   442|         0|            0|            0|  0.00%|    # Special case for the 0-tuple.
   443|         0|            0|            0|  0.00%|    if not fields:
   444|         0|            0|            0|  0.00%|        return '()'
   445|         0|            0|            0|  0.00%|    # Note the trailing comma, needed if this turns out to be a 1-tuple.
   446|         0|            0|            0|  0.00%|    return f'({",".join([f"{obj_name}.{f.name}" for f in fields])},)'
   447|         0|            0|            0|  0.00%|
   448|         0|            0|            0|  0.00%|
   449|         0|            0|            0|  0.00%|def _create_fn(name, args, body, *, globals=None, locals=None,
   450|         0|            0|            0|  0.00%|               return_type=MISSING):
   451|         0|            0|            0|  0.00%|    # Note that we may mutate locals. Callers beware!
   452|         0|            0|            0|  0.00%|    # The only callers are internal to this module, so no
   453|         0|            0|            0|  0.00%|    # worries about external callers.
   454|         0|            0|            0|  0.00%|    if locals is None:
   455|         0|            0|            0|  0.00%|        locals = {}
   456|         0|            0|            0|  0.00%|    return_annotation = ''
   457|         0|            0|            0|  0.00%|    if return_type is not MISSING:
   458|         0|            0|            0|  0.00%|        locals['__dataclass_return_type__'] = return_type
   459|         0|            0|            0|  0.00%|        return_annotation = '->__dataclass_return_type__'
   460|         0|            0|            0|  0.00%|    args = ','.join(args)
   461|         0|            0|            0|  0.00%|    body = '\n'.join(f'  {b}' for b in body)
   462|         0|            0|            0|  0.00%|
   463|         0|            0|            0|  0.00%|    # Compute the text of the entire function.
   464|         0|            0|            0|  0.00%|    txt = f' def {name}({args}){return_annotation}:\n{body}'
   465|         0|            0|            0|  0.00%|
   466|         0|            0|            0|  0.00%|    # Free variables in exec are resolved in the global namespace.
   467|         0|            0|            0|  0.00%|    # The global namespace we have is user-provided, so we can't modify it for
   468|         0|            0|            0|  0.00%|    # our purposes. So we put the things we need into locals and introduce a
   469|         0|            0|            0|  0.00%|    # scope to allow the function we're creating to close over them.
   470|         0|            0|            0|  0.00%|    local_vars = ', '.join(locals.keys())
   471|         0|            0|            0|  0.00%|    txt = f"def __create_fn__({local_vars}):\n{txt}\n return {name}"
   472|         0|            0|            0|  0.00%|    ns = {}
   473|         0|            0|            0|  0.00%|    exec(txt, globals, ns)
   474|         0|            0|            0|  0.00%|    return ns['__create_fn__'](**locals)
   475|         0|            0|            0|  0.00%|
   476|         0|            0|            0|  0.00%|
   477|         0|            0|            0|  0.00%|def _field_assign(frozen, name, value, self_name):
   478|         0|            0|            0|  0.00%|    # If we're a frozen class, then assign to our fields in __init__
   479|         0|            0|            0|  0.00%|    # via object.__setattr__.  Otherwise, just use a simple
   480|         0|            0|            0|  0.00%|    # assignment.
   481|         0|            0|            0|  0.00%|    #
   482|         0|            0|            0|  0.00%|    # self_name is what "self" is called in this function: don't
   483|         0|            0|            0|  0.00%|    # hard-code "self", since that might be a field name.
   484|         0|            0|            0|  0.00%|    if frozen:
   485|         0|            0|            0|  0.00%|        return f'__dataclass_builtins_object__.__setattr__({self_name},{name!r},{value})'
   486|         0|            0|            0|  0.00%|    return f'{self_name}.{name}={value}'
   487|         0|            0|            0|  0.00%|
   488|         0|            0|            0|  0.00%|
   489|         0|            0|            0|  0.00%|def _field_init(f, frozen, globals, self_name, slots):
   490|         0|            0|            0|  0.00%|    # Return the text of the line in the body of __init__ that will
   491|         0|            0|            0|  0.00%|    # initialize this field.
   492|         0|            0|            0|  0.00%|
   493|         0|            0|            0|  0.00%|    default_name = f'__dataclass_dflt_{f.name}__'
   494|         0|            0|            0|  0.00%|    if f.default_factory is not MISSING:
   495|         0|            0|            0|  0.00%|        if f.init:
   496|         0|            0|            0|  0.00%|            # This field has a default factory.  If a parameter is
   497|         0|            0|            0|  0.00%|            # given, use it.  If not, call the factory.
   498|         0|            0|            0|  0.00%|            globals[default_name] = f.default_factory
   499|         0|            0|            0|  0.00%|            value = (f'{default_name}() '
   500|         0|            0|            0|  0.00%|                     f'if {f.name} is __dataclass_HAS_DEFAULT_FACTORY__ '
   501|         0|            0|            0|  0.00%|                     f'else {f.name}')
   502|         0|            0|            0|  0.00%|        else:
   503|         0|            0|            0|  0.00%|            # This is a field that's not in the __init__ params, but
   504|         0|            0|            0|  0.00%|            # has a default factory function.  It needs to be
   505|         0|            0|            0|  0.00%|            # initialized here by calling the factory function,
   506|         0|            0|            0|  0.00%|            # because there's no other way to initialize it.
   507|         0|            0|            0|  0.00%|
   508|         0|            0|            0|  0.00%|            # For a field initialized with a default=defaultvalue, the
   509|         0|            0|            0|  0.00%|            # class dict just has the default value
   510|         0|            0|            0|  0.00%|            # (cls.fieldname=defaultvalue).  But that won't work for a
   511|         0|            0|            0|  0.00%|            # default factory, the factory must be called in __init__
   512|         0|            0|            0|  0.00%|            # and we must assign that to self.fieldname.  We can't
   513|         0|            0|            0|  0.00%|            # fall back to the class dict's value, both because it's
   514|         0|            0|            0|  0.00%|            # not set, and because it might be different per-class
   515|         0|            0|            0|  0.00%|            # (which, after all, is why we have a factory function!).
   516|         0|            0|            0|  0.00%|
   517|         0|            0|            0|  0.00%|            globals[default_name] = f.default_factory
   518|         0|            0|            0|  0.00%|            value = f'{default_name}()'
   519|         0|            0|            0|  0.00%|    else:
   520|         0|            0|            0|  0.00%|        # No default factory.
   521|         0|            0|            0|  0.00%|        if f.init:
   522|         0|            0|            0|  0.00%|            if f.default is MISSING:
   523|         0|            0|            0|  0.00%|                # There's no default, just do an assignment.
   524|         0|            0|            0|  0.00%|                value = f.name
   525|         0|            0|            0|  0.00%|            elif f.default is not MISSING:
   526|         0|            0|            0|  0.00%|                globals[default_name] = f.default
   527|         0|            0|            0|  0.00%|                value = f.name
   528|         0|            0|            0|  0.00%|        else:
   529|         0|            0|            0|  0.00%|            # If the class has slots, then initialize this field.
   530|         0|            0|            0|  0.00%|            if slots and f.default is not MISSING:
   531|         0|            0|            0|  0.00%|                globals[default_name] = f.default
   532|         0|            0|            0|  0.00%|                value = default_name
   533|         0|            0|            0|  0.00%|            else:
   534|         0|            0|            0|  0.00%|                # This field does not need initialization: reading from it will
   535|         0|            0|            0|  0.00%|                # just use the class attribute that contains the default.
   536|         0|            0|            0|  0.00%|                # Signify that to the caller by returning None.
   537|         0|            0|            0|  0.00%|                return None
   538|         0|            0|            0|  0.00%|
   539|         0|            0|            0|  0.00%|    # Only test this now, so that we can create variables for the
   540|         0|            0|            0|  0.00%|    # default.  However, return None to signify that we're not going
   541|         0|            0|            0|  0.00%|    # to actually do the assignment statement for InitVars.
   542|         0|            0|            0|  0.00%|    if f._field_type is _FIELD_INITVAR:
   543|         0|            0|            0|  0.00%|        return None
   544|         0|            0|            0|  0.00%|
   545|         0|            0|            0|  0.00%|    # Now, actually generate the field assignment.
   546|         0|            0|            0|  0.00%|    return _field_assign(frozen, f.name, value, self_name)
   547|         0|            0|            0|  0.00%|
   548|         0|            0|            0|  0.00%|
   549|         0|            0|            0|  0.00%|def _init_param(f):
   550|         0|            0|            0|  0.00%|    # Return the __init__ parameter string for this field.  For
   551|         0|            0|            0|  0.00%|    # example, the equivalent of 'x:int=3' (except instead of 'int',
   552|         0|            0|            0|  0.00%|    # reference a variable set to int, and instead of '3', reference a
   553|         0|            0|            0|  0.00%|    # variable set to 3).
   554|         0|            0|            0|  0.00%|    if f.default is MISSING and f.default_factory is MISSING:
   555|         0|            0|            0|  0.00%|        # There's no default, and no default_factory, just output the
   556|         0|            0|            0|  0.00%|        # variable name and type.
   557|         0|            0|            0|  0.00%|        default = ''
   558|         0|            0|            0|  0.00%|    elif f.default is not MISSING:
   559|         0|            0|            0|  0.00%|        # There's a default, this will be the name that's used to look
   560|         0|            0|            0|  0.00%|        # it up.
   561|         0|            0|            0|  0.00%|        default = f'=__dataclass_dflt_{f.name}__'
   562|         0|            0|            0|  0.00%|    elif f.default_factory is not MISSING:
   563|         0|            0|            0|  0.00%|        # There's a factory function.  Set a marker.
   564|         0|            0|            0|  0.00%|        default = '=__dataclass_HAS_DEFAULT_FACTORY__'
   565|         0|            0|            0|  0.00%|    return f'{f.name}:__dataclass_type_{f.name}__{default}'
   566|         0|            0|            0|  0.00%|
   567|         0|            0|            0|  0.00%|
   568|         0|            0|            0|  0.00%|def _init_fn(fields, std_fields, kw_only_fields, frozen, has_post_init,
   569|         0|            0|            0|  0.00%|             self_name, globals, slots):
   570|         0|            0|            0|  0.00%|    # fields contains both real fields and InitVar pseudo-fields.
   571|         0|            0|            0|  0.00%|
   572|         0|            0|            0|  0.00%|    # Make sure we don't have fields without defaults following fields
   573|         0|            0|            0|  0.00%|    # with defaults.  This actually would be caught when exec-ing the
   574|         0|            0|            0|  0.00%|    # function source code, but catching it here gives a better error
   575|         0|            0|            0|  0.00%|    # message, and future-proofs us in case we build up the function
   576|         0|            0|            0|  0.00%|    # using ast.
   577|         0|            0|            0|  0.00%|
   578|         0|            0|            0|  0.00%|    seen_default = False
   579|         0|            0|            0|  0.00%|    for f in std_fields:
   580|         0|            0|            0|  0.00%|        # Only consider the non-kw-only fields in the __init__ call.
   581|         0|            0|            0|  0.00%|        if f.init:
   582|         0|            0|            0|  0.00%|            if not (f.default is MISSING and f.default_factory is MISSING):
   583|         0|            0|            0|  0.00%|                seen_default = True
   584|         0|            0|            0|  0.00%|            elif seen_default:
   585|         0|            0|            0|  0.00%|                raise TypeError(f'non-default argument {f.name!r} '
   586|         0|            0|            0|  0.00%|                                'follows default argument')
   587|         0|            0|            0|  0.00%|
   588|         0|            0|            0|  0.00%|    locals = {f'__dataclass_type_{f.name}__': f.type for f in fields}
   589|         0|            0|            0|  0.00%|    locals.update({
   590|         0|            0|            0|  0.00%|        '__dataclass_HAS_DEFAULT_FACTORY__': _HAS_DEFAULT_FACTORY,
   591|         0|            0|            0|  0.00%|        '__dataclass_builtins_object__': object,
   592|         0|            0|            0|  0.00%|    })
   593|         0|            0|            0|  0.00%|
   594|         0|            0|            0|  0.00%|    body_lines = []
   595|         0|            0|            0|  0.00%|    for f in fields:
   596|         0|            0|            0|  0.00%|        line = _field_init(f, frozen, locals, self_name, slots)
   597|         0|            0|            0|  0.00%|        # line is None means that this field doesn't require
   598|         0|            0|            0|  0.00%|        # initialization (it's a pseudo-field).  Just skip it.
   599|         0|            0|            0|  0.00%|        if line:
   600|         0|            0|            0|  0.00%|            body_lines.append(line)
   601|         0|            0|            0|  0.00%|
   602|         0|            0|            0|  0.00%|    # Does this class have a post-init function?
   603|         0|            0|            0|  0.00%|    if has_post_init:
   604|         0|            0|            0|  0.00%|        params_str = ','.join(f.name for f in fields
   605|         0|            0|            0|  0.00%|                              if f._field_type is _FIELD_INITVAR)
   606|         0|            0|            0|  0.00%|        body_lines.append(f'{self_name}.{_POST_INIT_NAME}({params_str})')
   607|         0|            0|            0|  0.00%|
   608|         0|            0|            0|  0.00%|    # If no body lines, use 'pass'.
   609|         0|            0|            0|  0.00%|    if not body_lines:
   610|         0|            0|            0|  0.00%|        body_lines = ['pass']
   611|         0|            0|            0|  0.00%|
   612|         0|            0|            0|  0.00%|    _init_params = [_init_param(f) for f in std_fields]
   613|         0|            0|            0|  0.00%|    if kw_only_fields:
   614|         0|            0|            0|  0.00%|        # Add the keyword-only args.  Because the * can only be added if
   615|         0|            0|            0|  0.00%|        # there's at least one keyword-only arg, there needs to be a test here
   616|         0|            0|            0|  0.00%|        # (instead of just concatenting the lists together).
   617|         0|            0|            0|  0.00%|        _init_params += ['*']
   618|         0|            0|            0|  0.00%|        _init_params += [_init_param(f) for f in kw_only_fields]
   619|         0|            0|            0|  0.00%|    return _create_fn('__init__',
   620|         0|            0|            0|  0.00%|                      [self_name] + _init_params,
   621|         0|            0|            0|  0.00%|                      body_lines,
   622|         0|            0|            0|  0.00%|                      locals=locals,
   623|         0|            0|            0|  0.00%|                      globals=globals,
   624|         0|            0|            0|  0.00%|                      return_type=None)
   625|         0|            0|            0|  0.00%|
   626|         0|            0|            0|  0.00%|
   627|         0|            0|            0|  0.00%|def _repr_fn(fields, globals):
   628|         0|            0|            0|  0.00%|    fn = _create_fn('__repr__',
   629|         0|            0|            0|  0.00%|                    ('self',),
   630|         0|            0|            0|  0.00%|                    ['return self.__class__.__qualname__ + f"(' +
   631|         0|            0|            0|  0.00%|                     ', '.join([f"{f.name}={{self.{f.name}!r}}"
   632|         0|            0|            0|  0.00%|                                for f in fields]) +
   633|         0|            0|            0|  0.00%|                     ')"'],
   634|         0|            0|            0|  0.00%|                     globals=globals)
   635|         0|            0|            0|  0.00%|    return _recursive_repr(fn)
   636|         0|            0|            0|  0.00%|
   637|         0|            0|            0|  0.00%|
   638|         0|            0|            0|  0.00%|def _frozen_get_del_attr(cls, fields, globals):
   639|         0|            0|            0|  0.00%|    locals = {'cls': cls,
   640|         0|            0|            0|  0.00%|              'FrozenInstanceError': FrozenInstanceError}
   641|         0|            0|            0|  0.00%|    condition = 'type(self) is cls'
   642|         0|            0|            0|  0.00%|    if fields:
   643|         0|            0|            0|  0.00%|        condition += ' or name in {' + ', '.join(repr(f.name) for f in fields) + '}'
   644|         0|            0|            0|  0.00%|    return (_create_fn('__setattr__',
   645|         0|            0|            0|  0.00%|                      ('self', 'name', 'value'),
   646|         0|            0|            0|  0.00%|                      (f'if {condition}:',
   647|         0|            0|            0|  0.00%|                        ' raise FrozenInstanceError(f"cannot assign to field {name!r}")',
   648|         0|            0|            0|  0.00%|                       f'super(cls, self).__setattr__(name, value)'),
   649|         0|            0|            0|  0.00%|                       locals=locals,
   650|         0|            0|            0|  0.00%|                       globals=globals),
   651|         0|            0|            0|  0.00%|            _create_fn('__delattr__',
   652|         0|            0|            0|  0.00%|                      ('self', 'name'),
   653|         0|            0|            0|  0.00%|                      (f'if {condition}:',
   654|         0|            0|            0|  0.00%|                        ' raise FrozenInstanceError(f"cannot delete field {name!r}")',
   655|         0|            0|            0|  0.00%|                       f'super(cls, self).__delattr__(name)'),
   656|         0|            0|            0|  0.00%|                       locals=locals,
   657|         0|            0|            0|  0.00%|                       globals=globals),
   658|         0|            0|            0|  0.00%|            )
   659|         0|            0|            0|  0.00%|
   660|         0|            0|            0|  0.00%|
   661|         0|            0|            0|  0.00%|def _cmp_fn(name, op, self_tuple, other_tuple, globals):
   662|         0|            0|            0|  0.00%|    # Create a comparison function.  If the fields in the object are
   663|         0|            0|            0|  0.00%|    # named 'x' and 'y', then self_tuple is the string
   664|         0|            0|            0|  0.00%|    # '(self.x,self.y)' and other_tuple is the string
   665|         0|            0|            0|  0.00%|    # '(other.x,other.y)'.
   666|         0|            0|            0|  0.00%|
   667|         0|            0|            0|  0.00%|    return _create_fn(name,
   668|         0|            0|            0|  0.00%|                      ('self', 'other'),
   669|         0|            0|            0|  0.00%|                      [ 'if other.__class__ is self.__class__:',
   670|         0|            0|            0|  0.00%|                       f' return {self_tuple}{op}{other_tuple}',
   671|         0|            0|            0|  0.00%|                        'return NotImplemented'],
   672|         0|            0|            0|  0.00%|                      globals=globals)
   673|         0|            0|            0|  0.00%|
   674|         0|            0|            0|  0.00%|
   675|         0|            0|            0|  0.00%|def _hash_fn(fields, globals):
   676|         0|            0|            0|  0.00%|    self_tuple = _tuple_str('self', fields)
   677|         0|            0|            0|  0.00%|    return _create_fn('__hash__',
   678|         0|            0|            0|  0.00%|                      ('self',),
   679|         0|            0|            0|  0.00%|                      [f'return hash({self_tuple})'],
   680|         0|            0|            0|  0.00%|                      globals=globals)
   681|         0|            0|            0|  0.00%|
   682|         0|            0|            0|  0.00%|
   683|         0|            0|            0|  0.00%|def _is_classvar(a_type, typing):
   684|         0|            0|            0|  0.00%|    # This test uses a typing internal class, but it's the best way to
   685|         0|            0|            0|  0.00%|    # test if this is a ClassVar.
   686|         0|            0|            0|  0.00%|    return (a_type is typing.ClassVar
   687|         0|            0|            0|  0.00%|            or (type(a_type) is typing._GenericAlias
   688|         0|            0|            0|  0.00%|                and a_type.__origin__ is typing.ClassVar))
   689|         0|            0|            0|  0.00%|
   690|         0|            0|            0|  0.00%|
   691|         0|            0|            0|  0.00%|def _is_initvar(a_type, dataclasses):
   692|         0|            0|            0|  0.00%|    # The module we're checking against is the module we're
   693|         0|            0|            0|  0.00%|    # currently in (dataclasses.py).
   694|         0|            0|            0|  0.00%|    return (a_type is dataclasses.InitVar
   695|         0|            0|            0|  0.00%|            or type(a_type) is dataclasses.InitVar)
   696|         0|            0|            0|  0.00%|
   697|         0|            0|            0|  0.00%|def _is_kw_only(a_type, dataclasses):
   698|         0|            0|            0|  0.00%|    return a_type is dataclasses.KW_ONLY
   699|         0|            0|            0|  0.00%|
   700|         0|            0|            0|  0.00%|
   701|         0|            0|            0|  0.00%|def _is_type(annotation, cls, a_module, a_type, is_type_predicate):
   702|         0|            0|            0|  0.00%|    # Given a type annotation string, does it refer to a_type in
   703|         0|            0|            0|  0.00%|    # a_module?  For example, when checking that annotation denotes a
   704|         0|            0|            0|  0.00%|    # ClassVar, then a_module is typing, and a_type is
   705|         0|            0|            0|  0.00%|    # typing.ClassVar.
   706|         0|            0|            0|  0.00%|
   707|         0|            0|            0|  0.00%|    # It's possible to look up a_module given a_type, but it involves
   708|         0|            0|            0|  0.00%|    # looking in sys.modules (again!), and seems like a waste since
   709|         0|            0|            0|  0.00%|    # the caller already knows a_module.
   710|         0|            0|            0|  0.00%|
   711|         0|            0|            0|  0.00%|    # - annotation is a string type annotation
   712|         0|            0|            0|  0.00%|    # - cls is the class that this annotation was found in
   713|         0|            0|            0|  0.00%|    # - a_module is the module we want to match
   714|         0|            0|            0|  0.00%|    # - a_type is the type in that module we want to match
   715|         0|            0|            0|  0.00%|    # - is_type_predicate is a function called with (obj, a_module)
   716|         0|            0|            0|  0.00%|    #   that determines if obj is of the desired type.
   717|         0|            0|            0|  0.00%|
   718|         0|            0|            0|  0.00%|    # Since this test does not do a local namespace lookup (and
   719|         0|            0|            0|  0.00%|    # instead only a module (global) lookup), there are some things it
   720|         0|            0|            0|  0.00%|    # gets wrong.
   721|         0|            0|            0|  0.00%|
   722|         0|            0|            0|  0.00%|    # With string annotations, cv0 will be detected as a ClassVar:
   723|         0|            0|            0|  0.00%|    #   CV = ClassVar
   724|         0|            0|            0|  0.00%|    #   @dataclass
   725|         0|            0|            0|  0.00%|    #   class C0:
   726|         0|            0|            0|  0.00%|    #     cv0: CV
   727|         0|            0|            0|  0.00%|
   728|         0|            0|            0|  0.00%|    # But in this example cv1 will not be detected as a ClassVar:
   729|         0|            0|            0|  0.00%|    #   @dataclass
   730|         0|            0|            0|  0.00%|    #   class C1:
   731|         0|            0|            0|  0.00%|    #     CV = ClassVar
   732|         0|            0|            0|  0.00%|    #     cv1: CV
   733|         0|            0|            0|  0.00%|
   734|         0|            0|            0|  0.00%|    # In C1, the code in this function (_is_type) will look up "CV" in
   735|         0|            0|            0|  0.00%|    # the module and not find it, so it will not consider cv1 as a
   736|         0|            0|            0|  0.00%|    # ClassVar.  This is a fairly obscure corner case, and the best
   737|         0|            0|            0|  0.00%|    # way to fix it would be to eval() the string "CV" with the
   738|         0|            0|            0|  0.00%|    # correct global and local namespaces.  However that would involve
   739|         0|            0|            0|  0.00%|    # a eval() penalty for every single field of every dataclass
   740|         0|            0|            0|  0.00%|    # that's defined.  It was judged not worth it.
   741|         0|            0|            0|  0.00%|
   742|         0|            0|            0|  0.00%|    match = _MODULE_IDENTIFIER_RE.match(annotation)
   743|         0|            0|            0|  0.00%|    if match:
   744|         0|            0|            0|  0.00%|        ns = None
   745|         0|            0|            0|  0.00%|        module_name = match.group(1)
   746|         0|            0|            0|  0.00%|        if not module_name:
   747|         0|            0|            0|  0.00%|            # No module name, assume the class's module did
   748|         0|            0|            0|  0.00%|            # "from dataclasses import InitVar".
   749|         0|            0|            0|  0.00%|            ns = sys.modules.get(cls.__module__).__dict__
   750|         0|            0|            0|  0.00%|        else:
   751|         0|            0|            0|  0.00%|            # Look up module_name in the class's module.
   752|         0|            0|            0|  0.00%|            module = sys.modules.get(cls.__module__)
   753|         0|            0|            0|  0.00%|            if module and module.__dict__.get(module_name) is a_module:
   754|         0|            0|            0|  0.00%|                ns = sys.modules.get(a_type.__module__).__dict__
   755|         0|            0|            0|  0.00%|        if ns and is_type_predicate(ns.get(match.group(2)), a_module):
   756|         0|            0|            0|  0.00%|            return True
   757|         0|            0|            0|  0.00%|    return False
   758|         0|            0|            0|  0.00%|
   759|         0|            0|            0|  0.00%|
   760|         0|            0|            0|  0.00%|def _get_field(cls, a_name, a_type, default_kw_only):
   761|         0|            0|            0|  0.00%|    # Return a Field object for this field name and type.  ClassVars and
   762|         0|            0|            0|  0.00%|    # InitVars are also returned, but marked as such (see f._field_type).
   763|         0|            0|            0|  0.00%|    # default_kw_only is the value of kw_only to use if there isn't a field()
   764|         0|            0|            0|  0.00%|    # that defines it.
   765|         0|            0|            0|  0.00%|
   766|         0|            0|            0|  0.00%|    # If the default value isn't derived from Field, then it's only a
   767|         0|            0|            0|  0.00%|    # normal default value.  Convert it to a Field().
   768|         0|            0|            0|  0.00%|    default = getattr(cls, a_name, MISSING)
   769|         0|            0|            0|  0.00%|    if isinstance(default, Field):
   770|         0|            0|            0|  0.00%|        f = default
   771|         0|            0|            0|  0.00%|    else:
   772|         0|            0|            0|  0.00%|        if isinstance(default, types.MemberDescriptorType):
   773|         0|            0|            0|  0.00%|            # This is a field in __slots__, so it has no default value.
   774|         0|            0|            0|  0.00%|            default = MISSING
   775|         0|            0|            0|  0.00%|        f = field(default=default)
   776|         0|            0|            0|  0.00%|
   777|         0|            0|            0|  0.00%|    # Only at this point do we know the name and the type.  Set them.
   778|         0|            0|            0|  0.00%|    f.name = a_name
   779|         0|            0|            0|  0.00%|    f.type = a_type
   780|         0|            0|            0|  0.00%|
   781|         0|            0|            0|  0.00%|    # Assume it's a normal field until proven otherwise.  We're next
   782|         0|            0|            0|  0.00%|    # going to decide if it's a ClassVar or InitVar, everything else
   783|         0|            0|            0|  0.00%|    # is just a normal field.
   784|         0|            0|            0|  0.00%|    f._field_type = _FIELD
   785|         0|            0|            0|  0.00%|
   786|         0|            0|            0|  0.00%|    # In addition to checking for actual types here, also check for
   787|         0|            0|            0|  0.00%|    # string annotations.  get_type_hints() won't always work for us
   788|         0|            0|            0|  0.00%|    # (see https://github.com/python/typing/issues/508 for example),
   789|         0|            0|            0|  0.00%|    # plus it's expensive and would require an eval for every string
   790|         0|            0|            0|  0.00%|    # annotation.  So, make a best effort to see if this is a ClassVar
   791|         0|            0|            0|  0.00%|    # or InitVar using regex's and checking that the thing referenced
   792|         0|            0|            0|  0.00%|    # is actually of the correct type.
   793|         0|            0|            0|  0.00%|
   794|         0|            0|            0|  0.00%|    # For the complete discussion, see https://bugs.python.org/issue33453
   795|         0|            0|            0|  0.00%|
   796|         0|            0|            0|  0.00%|    # If typing has not been imported, then it's impossible for any
   797|         0|            0|            0|  0.00%|    # annotation to be a ClassVar.  So, only look for ClassVar if
   798|         0|            0|            0|  0.00%|    # typing has been imported by any module (not necessarily cls's
   799|         0|            0|            0|  0.00%|    # module).
   800|         0|            0|            0|  0.00%|    typing = sys.modules.get('typing')
   801|         0|            0|            0|  0.00%|    if typing:
   802|         0|            0|            0|  0.00%|        if (_is_classvar(a_type, typing)
   803|         0|            0|            0|  0.00%|            or (isinstance(f.type, str)
   804|         0|            0|            0|  0.00%|                and _is_type(f.type, cls, typing, typing.ClassVar,
   805|         0|            0|            0|  0.00%|                             _is_classvar))):
   806|         0|            0|            0|  0.00%|            f._field_type = _FIELD_CLASSVAR
   807|         0|            0|            0|  0.00%|
   808|         0|            0|            0|  0.00%|    # If the type is InitVar, or if it's a matching string annotation,
   809|         0|            0|            0|  0.00%|    # then it's an InitVar.
   810|         0|            0|            0|  0.00%|    if f._field_type is _FIELD:
   811|         0|            0|            0|  0.00%|        # The module we're checking against is the module we're
   812|         0|            0|            0|  0.00%|        # currently in (dataclasses.py).
   813|         0|            0|            0|  0.00%|        dataclasses = sys.modules[__name__]
   814|         0|            0|            0|  0.00%|        if (_is_initvar(a_type, dataclasses)
   815|         0|            0|            0|  0.00%|            or (isinstance(f.type, str)
   816|         0|            0|            0|  0.00%|                and _is_type(f.type, cls, dataclasses, dataclasses.InitVar,
   817|         0|            0|            0|  0.00%|                             _is_initvar))):
   818|         0|            0|            0|  0.00%|            f._field_type = _FIELD_INITVAR
   819|         0|            0|            0|  0.00%|
   820|         0|            0|            0|  0.00%|    # Validations for individual fields.  This is delayed until now,
   821|         0|            0|            0|  0.00%|    # instead of in the Field() constructor, since only here do we
   822|         0|            0|            0|  0.00%|    # know the field name, which allows for better error reporting.
   823|         0|            0|            0|  0.00%|
   824|         0|            0|            0|  0.00%|    # Special restrictions for ClassVar and InitVar.
   825|         0|            0|            0|  0.00%|    if f._field_type in (_FIELD_CLASSVAR, _FIELD_INITVAR):
   826|         0|            0|            0|  0.00%|        if f.default_factory is not MISSING:
   827|         0|            0|            0|  0.00%|            raise TypeError(f'field {f.name} cannot have a '
   828|         0|            0|            0|  0.00%|                            'default factory')
   829|         0|            0|            0|  0.00%|        # Should I check for other field settings? default_factory
   830|         0|            0|            0|  0.00%|        # seems the most serious to check for.  Maybe add others.  For
   831|         0|            0|            0|  0.00%|        # example, how about init=False (or really,
   832|         0|            0|            0|  0.00%|        # init=<not-the-default-init-value>)?  It makes no sense for
   833|         0|            0|            0|  0.00%|        # ClassVar and InitVar to specify init=<anything>.
   834|         0|            0|            0|  0.00%|
   835|         0|            0|            0|  0.00%|    # kw_only validation and assignment.
   836|         0|            0|            0|  0.00%|    if f._field_type in (_FIELD, _FIELD_INITVAR):
   837|         0|            0|            0|  0.00%|        # For real and InitVar fields, if kw_only wasn't specified use the
   838|         0|            0|            0|  0.00%|        # default value.
   839|         0|            0|            0|  0.00%|        if f.kw_only is MISSING:
   840|         0|            0|            0|  0.00%|            f.kw_only = default_kw_only
   841|         0|            0|            0|  0.00%|    else:
   842|         0|            0|            0|  0.00%|        # Make sure kw_only isn't set for ClassVars
   843|         0|            0|            0|  0.00%|        assert f._field_type is _FIELD_CLASSVAR
   844|         0|            0|            0|  0.00%|        if f.kw_only is not MISSING:
   845|         0|            0|            0|  0.00%|            raise TypeError(f'field {f.name} is a ClassVar but specifies '
   846|         0|            0|            0|  0.00%|                            'kw_only')
   847|         0|            0|            0|  0.00%|
   848|         0|            0|            0|  0.00%|    # For real fields, disallow mutable defaults.  Use unhashable as a proxy
   849|         0|            0|            0|  0.00%|    # indicator for mutability.  Read the __hash__ attribute from the class,
   850|         0|            0|            0|  0.00%|    # not the instance.
   851|         0|            0|            0|  0.00%|    if f._field_type is _FIELD and f.default.__class__.__hash__ is None:
   852|         0|            0|            0|  0.00%|        raise ValueError(f'mutable default {type(f.default)} for field '
   853|         0|            0|            0|  0.00%|                         f'{f.name} is not allowed: use default_factory')
   854|         0|            0|            0|  0.00%|
   855|         0|            0|            0|  0.00%|    return f
   856|         0|            0|            0|  0.00%|
   857|         0|            0|            0|  0.00%|def _set_qualname(cls, value):
   858|         0|            0|            0|  0.00%|    # Ensure that the functions returned from _create_fn uses the proper
   859|         0|            0|            0|  0.00%|    # __qualname__ (the class they belong to).
   860|         0|            0|            0|  0.00%|    if isinstance(value, FunctionType):
   861|         0|            0|            0|  0.00%|        value.__qualname__ = f"{cls.__qualname__}.{value.__name__}"
   862|         0|            0|            0|  0.00%|    return value
   863|         0|            0|            0|  0.00%|
   864|         0|            0|            0|  0.00%|def _set_new_attribute(cls, name, value):
   865|         0|            0|            0|  0.00%|    # Never overwrites an existing attribute.  Returns True if the
   866|         0|            0|            0|  0.00%|    # attribute already exists.
   867|         0|            0|            0|  0.00%|    if name in cls.__dict__:
   868|         0|            0|            0|  0.00%|        return True
   869|         0|            0|            0|  0.00%|    _set_qualname(cls, value)
   870|         0|            0|            0|  0.00%|    setattr(cls, name, value)
   871|         0|            0|            0|  0.00%|    return False
   872|         0|            0|            0|  0.00%|
   873|         0|            0|            0|  0.00%|
   874|         0|            0|            0|  0.00%|# Decide if/how we're going to create a hash function.  Key is
   875|         0|            0|            0|  0.00%|# (unsafe_hash, eq, frozen, does-hash-exist).  Value is the action to
   876|         0|            0|            0|  0.00%|# take.  The common case is to do nothing, so instead of providing a
   877|         0|            0|            0|  0.00%|# function that is a no-op, use None to signify that.
   878|         0|            0|            0|  0.00%|
   879|         0|            0|            0|  0.00%|def _hash_set_none(cls, fields, globals):
   880|         0|            0|            0|  0.00%|    return None
   881|         0|            0|            0|  0.00%|
   882|         0|            0|            0|  0.00%|def _hash_add(cls, fields, globals):
   883|         0|            0|            0|  0.00%|    flds = [f for f in fields if (f.compare if f.hash is None else f.hash)]
   884|         0|            0|            0|  0.00%|    return _set_qualname(cls, _hash_fn(flds, globals))
   885|         0|            0|            0|  0.00%|
   886|         0|            0|            0|  0.00%|def _hash_exception(cls, fields, globals):
   887|         0|            0|            0|  0.00%|    # Raise an exception.
   888|         0|            0|            0|  0.00%|    raise TypeError(f'Cannot overwrite attribute __hash__ '
   889|         0|            0|            0|  0.00%|                    f'in class {cls.__name__}')
   890|         0|            0|            0|  0.00%|
   891|         0|            0|            0|  0.00%|#
   892|         0|            0|            0|  0.00%|#                +-------------------------------------- unsafe_hash?
   893|         0|            0|            0|  0.00%|#                |      +------------------------------- eq?
   894|         0|            0|            0|  0.00%|#                |      |      +------------------------ frozen?
   895|         0|            0|            0|  0.00%|#                |      |      |      +----------------  has-explicit-hash?
   896|         0|            0|            0|  0.00%|#                |      |      |      |
   897|         0|            0|            0|  0.00%|#                |      |      |      |        +-------  action
   898|         0|            0|            0|  0.00%|#                |      |      |      |        |
   899|         0|            0|            0|  0.00%|#                v      v      v      v        v
   900|         0|            0|            0|  0.00%|_hash_action = {(False, False, False, False): None,
   901|         0|            0|            0|  0.00%|                (False, False, False, True ): None,
   902|         0|            0|            0|  0.00%|                (False, False, True,  False): None,
   903|         0|            0|            0|  0.00%|                (False, False, True,  True ): None,
   904|         0|            0|            0|  0.00%|                (False, True,  False, False): _hash_set_none,
   905|         0|            0|            0|  0.00%|                (False, True,  False, True ): None,
   906|         0|            0|            0|  0.00%|                (False, True,  True,  False): _hash_add,
   907|         0|            0|            0|  0.00%|                (False, True,  True,  True ): None,
   908|         0|            0|            0|  0.00%|                (True,  False, False, False): _hash_add,
   909|         0|            0|            0|  0.00%|                (True,  False, False, True ): _hash_exception,
   910|         0|            0|            0|  0.00%|                (True,  False, True,  False): _hash_add,
   911|         0|            0|            0|  0.00%|                (True,  False, True,  True ): _hash_exception,
   912|         0|            0|            0|  0.00%|                (True,  True,  False, False): _hash_add,
   913|         0|            0|            0|  0.00%|                (True,  True,  False, True ): _hash_exception,
   914|         0|            0|            0|  0.00%|                (True,  True,  True,  False): _hash_add,
   915|         0|            0|            0|  0.00%|                (True,  True,  True,  True ): _hash_exception,
   916|         0|            0|            0|  0.00%|                }
   917|         0|            0|            0|  0.00%|# See https://bugs.python.org/issue32929#msg312829 for an if-statement
   918|         0|            0|            0|  0.00%|# version of this table.
   919|         0|            0|            0|  0.00%|
   920|         0|            0|            0|  0.00%|
   921|         0|            0|            0|  0.00%|def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
   922|         0|            0|            0|  0.00%|                   match_args, kw_only, slots, weakref_slot):
   923|         0|            0|            0|  0.00%|    # Now that dicts retain insertion order, there's no reason to use
   924|         0|            0|            0|  0.00%|    # an ordered dict.  I am leveraging that ordering here, because
   925|         0|            0|            0|  0.00%|    # derived class fields overwrite base class fields, but the order
   926|         0|            0|            0|  0.00%|    # is defined by the base class, which is found first.
   927|         0|            0|            0|  0.00%|    fields = {}
   928|         0|            0|            0|  0.00%|
   929|         0|            0|            0|  0.00%|    if cls.__module__ in sys.modules:
   930|         0|            0|            0|  0.00%|        globals = sys.modules[cls.__module__].__dict__
   931|         0|            0|            0|  0.00%|    else:
   932|         0|            0|            0|  0.00%|        # Theoretically this can happen if someone writes
   933|         0|            0|            0|  0.00%|        # a custom string to cls.__module__.  In which case
   934|         0|            0|            0|  0.00%|        # such dataclass won't be fully introspectable
   935|         0|            0|            0|  0.00%|        # (w.r.t. typing.get_type_hints) but will still function
   936|         0|            0|            0|  0.00%|        # correctly.
   937|         0|            0|            0|  0.00%|        globals = {}
   938|         0|            0|            0|  0.00%|
   939|         0|            0|            0|  0.00%|    setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
   940|         0|            0|            0|  0.00%|                                           unsafe_hash, frozen,
   941|         0|            0|            0|  0.00%|                                           match_args, kw_only,
   942|         0|            0|            0|  0.00%|                                           slots, weakref_slot))
   943|         0|            0|            0|  0.00%|
   944|         0|            0|            0|  0.00%|    # Find our base classes in reverse MRO order, and exclude
   945|         0|            0|            0|  0.00%|    # ourselves.  In reversed order so that more derived classes
   946|         0|            0|            0|  0.00%|    # override earlier field definitions in base classes.  As long as
   947|         0|            0|            0|  0.00%|    # we're iterating over them, see if any are frozen.
   948|         0|            0|            0|  0.00%|    any_frozen_base = False
   949|         0|            0|            0|  0.00%|    has_dataclass_bases = False
   950|         0|            0|            0|  0.00%|    for b in cls.__mro__[-1:0:-1]:
   951|         0|            0|            0|  0.00%|        # Only process classes that have been processed by our
   952|         0|            0|            0|  0.00%|        # decorator.  That is, they have a _FIELDS attribute.
   953|         0|            0|            0|  0.00%|        base_fields = getattr(b, _FIELDS, None)
   954|         0|            0|            0|  0.00%|        if base_fields is not None:
   955|         0|            0|            0|  0.00%|            has_dataclass_bases = True
   956|         0|            0|            0|  0.00%|            for f in base_fields.values():
   957|         0|            0|            0|  0.00%|                fields[f.name] = f
   958|         0|            0|            0|  0.00%|            if getattr(b, _PARAMS).frozen:
   959|         0|            0|            0|  0.00%|                any_frozen_base = True
   960|         0|            0|            0|  0.00%|
   961|         0|            0|            0|  0.00%|    # Annotations defined specifically in this class (not in base classes).
   962|         0|            0|            0|  0.00%|    #
   963|         0|            0|            0|  0.00%|    # Fields are found from cls_annotations, which is guaranteed to be
   964|         0|            0|            0|  0.00%|    # ordered.  Default values are from class attributes, if a field
   965|         0|            0|            0|  0.00%|    # has a default.  If the default value is a Field(), then it
   966|         0|            0|            0|  0.00%|    # contains additional info beyond (and possibly including) the
   967|         0|            0|            0|  0.00%|    # actual default value.  Pseudo-fields ClassVars and InitVars are
   968|         0|            0|            0|  0.00%|    # included, despite the fact that they're not real fields.  That's
   969|         0|            0|            0|  0.00%|    # dealt with later.
   970|         0|            0|            0|  0.00%|    cls_annotations = inspect.get_annotations(cls)
   971|         0|            0|            0|  0.00%|
   972|         0|            0|            0|  0.00%|    # Now find fields in our class.  While doing so, validate some
   973|         0|            0|            0|  0.00%|    # things, and set the default values (as class attributes) where
   974|         0|            0|            0|  0.00%|    # we can.
   975|         0|            0|            0|  0.00%|    cls_fields = []
   976|         0|            0|            0|  0.00%|    # Get a reference to this module for the _is_kw_only() test.
   977|         0|            0|            0|  0.00%|    KW_ONLY_seen = False
   978|         0|            0|            0|  0.00%|    dataclasses = sys.modules[__name__]
   979|         0|            0|            0|  0.00%|    for name, type in cls_annotations.items():
   980|         0|            0|            0|  0.00%|        # See if this is a marker to change the value of kw_only.
   981|         0|            0|            0|  0.00%|        if (_is_kw_only(type, dataclasses)
   982|         0|            0|            0|  0.00%|            or (isinstance(type, str)
   983|         0|            0|            0|  0.00%|                and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
   984|         0|            0|            0|  0.00%|                             _is_kw_only))):
   985|         0|            0|            0|  0.00%|            # Switch the default to kw_only=True, and ignore this
   986|         0|            0|            0|  0.00%|            # annotation: it's not a real field.
   987|         0|            0|            0|  0.00%|            if KW_ONLY_seen:
   988|         0|            0|            0|  0.00%|                raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
   989|         0|            0|            0|  0.00%|                                'has already been specified')
   990|         0|            0|            0|  0.00%|            KW_ONLY_seen = True
   991|         0|            0|            0|  0.00%|            kw_only = True
   992|         0|            0|            0|  0.00%|        else:
   993|         0|            0|            0|  0.00%|            # Otherwise it's a field of some type.
   994|         0|            0|            0|  0.00%|            cls_fields.append(_get_field(cls, name, type, kw_only))
   995|         0|            0|            0|  0.00%|
   996|         0|            0|            0|  0.00%|    for f in cls_fields:
   997|         0|            0|            0|  0.00%|        fields[f.name] = f
   998|         0|            0|            0|  0.00%|
   999|         0|            0|            0|  0.00%|        # If the class attribute (which is the default value for this
  1000|         0|            0|            0|  0.00%|        # field) exists and is of type 'Field', replace it with the
  1001|         0|            0|            0|  0.00%|        # real default.  This is so that normal class introspection
  1002|         0|            0|            0|  0.00%|        # sees a real default value, not a Field.
  1003|         0|            0|            0|  0.00%|        if isinstance(getattr(cls, f.name, None), Field):
  1004|         0|            0|            0|  0.00%|            if f.default is MISSING:
  1005|         0|            0|            0|  0.00%|                # If there's no default, delete the class attribute.
  1006|         0|            0|            0|  0.00%|                # This happens if we specify field(repr=False), for
  1007|         0|            0|            0|  0.00%|                # example (that is, we specified a field object, but
  1008|         0|            0|            0|  0.00%|                # no default value).  Also if we're using a default
  1009|         0|            0|            0|  0.00%|                # factory.  The class attribute should not be set at
  1010|         0|            0|            0|  0.00%|                # all in the post-processed class.
  1011|         0|            0|            0|  0.00%|                delattr(cls, f.name)
  1012|         0|            0|            0|  0.00%|            else:
  1013|         0|            0|            0|  0.00%|                setattr(cls, f.name, f.default)
  1014|         0|            0|            0|  0.00%|
  1015|         0|            0|            0|  0.00%|    # Do we have any Field members that don't also have annotations?
  1016|         0|            0|            0|  0.00%|    for name, value in cls.__dict__.items():
  1017|         0|            0|            0|  0.00%|        if isinstance(value, Field) and not name in cls_annotations:
  1018|         0|            0|            0|  0.00%|            raise TypeError(f'{name!r} is a field but has no type annotation')
  1019|         0|            0|            0|  0.00%|
  1020|         0|            0|            0|  0.00%|    # Check rules that apply if we are derived from any dataclasses.
  1021|         0|            0|            0|  0.00%|    if has_dataclass_bases:
  1022|         0|            0|            0|  0.00%|        # Raise an exception if any of our bases are frozen, but we're not.
  1023|         0|            0|            0|  0.00%|        if any_frozen_base and not frozen:
  1024|         0|            0|            0|  0.00%|            raise TypeError('cannot inherit non-frozen dataclass from a '
  1025|         0|            0|            0|  0.00%|                            'frozen one')
  1026|         0|            0|            0|  0.00%|
  1027|         0|            0|            0|  0.00%|        # Raise an exception if we're frozen, but none of our bases are.
  1028|         0|            0|            0|  0.00%|        if not any_frozen_base and frozen:
  1029|         0|            0|            0|  0.00%|            raise TypeError('cannot inherit frozen dataclass from a '
  1030|         0|            0|            0|  0.00%|                            'non-frozen one')
  1031|         0|            0|            0|  0.00%|
  1032|         0|            0|            0|  0.00%|    # Remember all of the fields on our class (including bases).  This
  1033|         0|            0|            0|  0.00%|    # also marks this class as being a dataclass.
  1034|         0|            0|            0|  0.00%|    setattr(cls, _FIELDS, fields)
  1035|         0|            0|            0|  0.00%|
  1036|         0|            0|            0|  0.00%|    # Was this class defined with an explicit __hash__?  Note that if
  1037|         0|            0|            0|  0.00%|    # __eq__ is defined in this class, then python will automatically
  1038|         0|            0|            0|  0.00%|    # set __hash__ to None.  This is a heuristic, as it's possible
  1039|         0|            0|            0|  0.00%|    # that such a __hash__ == None was not auto-generated, but it
  1040|         0|            0|            0|  0.00%|    # close enough.
  1041|         0|            0|            0|  0.00%|    class_hash = cls.__dict__.get('__hash__', MISSING)
  1042|         0|            0|            0|  0.00%|    has_explicit_hash = not (class_hash is MISSING or
  1043|         0|            0|            0|  0.00%|                             (class_hash is None and '__eq__' in cls.__dict__))
  1044|         0|            0|            0|  0.00%|
  1045|         0|            0|            0|  0.00%|    # If we're generating ordering methods, we must be generating the
  1046|         0|            0|            0|  0.00%|    # eq methods.
  1047|         0|            0|            0|  0.00%|    if order and not eq:
  1048|         0|            0|            0|  0.00%|        raise ValueError('eq must be true if order is true')
  1049|         0|            0|            0|  0.00%|
  1050|         0|            0|            0|  0.00%|    # Include InitVars and regular fields (so, not ClassVars).  This is
  1051|         0|            0|            0|  0.00%|    # initialized here, outside of the "if init:" test, because std_init_fields
  1052|         0|            0|            0|  0.00%|    # is used with match_args, below.
  1053|         0|            0|            0|  0.00%|    all_init_fields = [f for f in fields.values()
  1054|         0|            0|            0|  0.00%|                       if f._field_type in (_FIELD, _FIELD_INITVAR)]
  1055|         0|            0|            0|  0.00%|    (std_init_fields,
  1056|         0|            0|            0|  0.00%|     kw_only_init_fields) = _fields_in_init_order(all_init_fields)
  1057|         0|            0|            0|  0.00%|
  1058|         0|            0|            0|  0.00%|    if init:
  1059|         0|            0|            0|  0.00%|        # Does this class have a post-init function?
  1060|         0|            0|            0|  0.00%|        has_post_init = hasattr(cls, _POST_INIT_NAME)
  1061|         0|            0|            0|  0.00%|
  1062|         0|            0|            0|  0.00%|        _set_new_attribute(cls, '__init__',
  1063|         0|            0|            0|  0.00%|                           _init_fn(all_init_fields,
  1064|         0|            0|            0|  0.00%|                                    std_init_fields,
  1065|         0|            0|            0|  0.00%|                                    kw_only_init_fields,
  1066|         0|            0|            0|  0.00%|                                    frozen,
  1067|         0|            0|            0|  0.00%|                                    has_post_init,
  1068|         0|            0|            0|  0.00%|                                    # The name to use for the "self"
  1069|         0|            0|            0|  0.00%|                                    # param in __init__.  Use "self"
  1070|         0|            0|            0|  0.00%|                                    # if possible.
  1071|         0|            0|            0|  0.00%|                                    '__dataclass_self__' if 'self' in fields
  1072|         0|            0|            0|  0.00%|                                            else 'self',
  1073|         0|            0|            0|  0.00%|                                    globals,
  1074|         0|            0|            0|  0.00%|                                    slots,
  1075|         0|            0|            0|  0.00%|                          ))
  1076|         0|            0|            0|  0.00%|
  1077|         0|            0|            0|  0.00%|    # Get the fields as a list, and include only real fields.  This is
  1078|         0|            0|            0|  0.00%|    # used in all of the following methods.
  1079|         0|            0|            0|  0.00%|    field_list = [f for f in fields.values() if f._field_type is _FIELD]
  1080|         0|            0|            0|  0.00%|
  1081|         0|            0|            0|  0.00%|    if repr:
  1082|         0|            0|            0|  0.00%|        flds = [f for f in field_list if f.repr]
  1083|         0|            0|            0|  0.00%|        _set_new_attribute(cls, '__repr__', _repr_fn(flds, globals))
  1084|         0|            0|            0|  0.00%|
  1085|         0|            0|            0|  0.00%|    if eq:
  1086|         0|            0|            0|  0.00%|        # Create __eq__ method.  There's no need for a __ne__ method,
  1087|         0|            0|            0|  0.00%|        # since python will call __eq__ and negate it.
  1088|         0|            0|            0|  0.00%|        flds = [f for f in field_list if f.compare]
  1089|         0|            0|            0|  0.00%|        self_tuple = _tuple_str('self', flds)
  1090|         0|            0|            0|  0.00%|        other_tuple = _tuple_str('other', flds)
  1091|         0|            0|            0|  0.00%|        _set_new_attribute(cls, '__eq__',
  1092|         0|            0|            0|  0.00%|                           _cmp_fn('__eq__', '==',
  1093|         0|            0|            0|  0.00%|                                   self_tuple, other_tuple,
  1094|         0|            0|            0|  0.00%|                                   globals=globals))
  1095|         0|            0|            0|  0.00%|
  1096|         0|            0|            0|  0.00%|    if order:
  1097|         0|            0|            0|  0.00%|        # Create and set the ordering methods.
  1098|         0|            0|            0|  0.00%|        flds = [f for f in field_list if f.compare]
  1099|         0|            0|            0|  0.00%|        self_tuple = _tuple_str('self', flds)
  1100|         0|            0|            0|  0.00%|        other_tuple = _tuple_str('other', flds)
  1101|         0|            0|            0|  0.00%|        for name, op in [('__lt__', '<'),
  1102|         0|            0|            0|  0.00%|                         ('__le__', '<='),
  1103|         0|            0|            0|  0.00%|                         ('__gt__', '>'),
  1104|         0|            0|            0|  0.00%|                         ('__ge__', '>='),
  1105|         0|            0|            0|  0.00%|                         ]:
  1106|         0|            0|            0|  0.00%|            if _set_new_attribute(cls, name,
  1107|         0|            0|            0|  0.00%|                                  _cmp_fn(name, op, self_tuple, other_tuple,
  1108|         0|            0|            0|  0.00%|                                          globals=globals)):
  1109|         0|            0|            0|  0.00%|                raise TypeError(f'Cannot overwrite attribute {name} '
  1110|         0|            0|            0|  0.00%|                                f'in class {cls.__name__}. Consider using '
  1111|         0|            0|            0|  0.00%|                                'functools.total_ordering')
  1112|         0|            0|            0|  0.00%|
  1113|         0|            0|            0|  0.00%|    if frozen:
  1114|         0|            0|            0|  0.00%|        for fn in _frozen_get_del_attr(cls, field_list, globals):
  1115|         0|            0|            0|  0.00%|            if _set_new_attribute(cls, fn.__name__, fn):
  1116|         0|            0|            0|  0.00%|                raise TypeError(f'Cannot overwrite attribute {fn.__name__} '
  1117|         0|            0|            0|  0.00%|                                f'in class {cls.__name__}')
  1118|         0|            0|            0|  0.00%|
  1119|         0|            0|            0|  0.00%|    # Decide if/how we're going to create a hash function.
  1120|         0|            0|            0|  0.00%|    hash_action = _hash_action[bool(unsafe_hash),
  1121|         0|            0|            0|  0.00%|                               bool(eq),
  1122|         0|            0|            0|  0.00%|                               bool(frozen),
  1123|         0|            0|            0|  0.00%|                               has_explicit_hash]
  1124|         0|            0|            0|  0.00%|    if hash_action:
  1125|         0|            0|            0|  0.00%|        # No need to call _set_new_attribute here, since by the time
  1126|         0|            0|            0|  0.00%|        # we're here the overwriting is unconditional.
  1127|         0|            0|            0|  0.00%|        cls.__hash__ = hash_action(cls, field_list, globals)
  1128|         0|            0|            0|  0.00%|
  1129|         0|            0|            0|  0.00%|    if not getattr(cls, '__doc__'):
  1130|         0|            0|            0|  0.00%|        # Create a class doc-string.
  1131|         0|            0|            0|  0.00%|        try:
  1132|         0|            0|            0|  0.00%|            # In some cases fetching a signature is not possible.
  1133|         0|            0|            0|  0.00%|            # But, we surely should not fail in this case.
  1134|         0|            0|            0|  0.00%|            text_sig = str(inspect.signature(cls)).replace(' -> None', '')
  1135|         0|            0|            0|  0.00%|        except (TypeError, ValueError):
  1136|         0|            0|            0|  0.00%|            text_sig = ''
  1137|         0|            0|            0|  0.00%|        cls.__doc__ = (cls.__name__ + text_sig)
  1138|         0|            0|            0|  0.00%|
  1139|         0|            0|            0|  0.00%|    if match_args:
  1140|         0|            0|            0|  0.00%|        # I could probably compute this once
  1141|         0|            0|            0|  0.00%|        _set_new_attribute(cls, '__match_args__',
  1142|         0|            0|            0|  0.00%|                           tuple(f.name for f in std_init_fields))
  1143|         0|            0|            0|  0.00%|
  1144|         0|            0|            0|  0.00%|    # It's an error to specify weakref_slot if slots is False.
  1145|         0|            0|            0|  0.00%|    if weakref_slot and not slots:
  1146|         0|            0|            0|  0.00%|        raise TypeError('weakref_slot is True but slots is False')
  1147|         0|            0|            0|  0.00%|    if slots:
  1148|         0|            0|            0|  0.00%|        cls = _add_slots(cls, frozen, weakref_slot)
  1149|         0|            0|            0|  0.00%|
  1150|         0|            0|            0|  0.00%|    abc.update_abstractmethods(cls)
  1151|         0|            0|            0|  0.00%|
  1152|         0|            0|            0|  0.00%|    return cls
  1153|         0|            0|            0|  0.00%|
  1154|         0|            0|            0|  0.00%|
  1155|         0|            0|            0|  0.00%|# _dataclass_getstate and _dataclass_setstate are needed for pickling frozen
  1156|         0|            0|            0|  0.00%|# classes with slots.  These could be slightly more performant if we generated
  1157|         0|            0|            0|  0.00%|# the code instead of iterating over fields.  But that can be a project for
  1158|         0|            0|            0|  0.00%|# another day, if performance becomes an issue.
  1159|         0|            0|            0|  0.00%|def _dataclass_getstate(self):
  1160|         0|            0|            0|  0.00%|    return [getattr(self, f.name) for f in fields(self)]
  1161|         0|            0|            0|  0.00%|
  1162|         0|            0|            0|  0.00%|
  1163|         0|            0|            0|  0.00%|def _dataclass_setstate(self, state):
  1164|         0|            0|            0|  0.00%|    for field, value in zip(fields(self), state):
  1165|         0|            0|            0|  0.00%|        # use setattr because dataclass may be frozen
  1166|         0|            0|            0|  0.00%|        object.__setattr__(self, field.name, value)
  1167|         0|            0|            0|  0.00%|
  1168|         0|            0|            0|  0.00%|
  1169|         0|            0|            0|  0.00%|def _get_slots(cls):
  1170|         0|            0|            0|  0.00%|    match cls.__dict__.get('__slots__'):
  1171|         0|            0|            0|  0.00%|        # A class which does not define __slots__ at all is equivalent
  1172|         0|            0|            0|  0.00%|        # to a class defining __slots__ = ('__dict__', '__weakref__')
  1173|         0|            0|            0|  0.00%|        case None:
  1174|         0|            0|            0|  0.00%|            yield from ('__dict__', '__weakref__')
  1175|         0|            0|            0|  0.00%|        case str(slot):
  1176|         0|            0|            0|  0.00%|            yield slot
  1177|         0|            0|            0|  0.00%|        # Slots may be any iterable, but we cannot handle an iterator
  1178|         0|            0|            0|  0.00%|        # because it will already be (partially) consumed.
  1179|         0|            0|            0|  0.00%|        case iterable if not hasattr(iterable, '__next__'):
  1180|         0|            0|            0|  0.00%|            yield from iterable
  1181|         0|            0|            0|  0.00%|        case _:
  1182|         0|            0|            0|  0.00%|            raise TypeError(f"Slots of '{cls.__name__}' cannot be determined")
  1183|         0|            0|            0|  0.00%|
  1184|         0|            0|            0|  0.00%|
  1185|         0|            0|            0|  0.00%|def _add_slots(cls, is_frozen, weakref_slot):
  1186|         0|            0|            0|  0.00%|    # Need to create a new class, since we can't set __slots__
  1187|         0|            0|            0|  0.00%|    #  after a class has been created.
  1188|         0|            0|            0|  0.00%|
  1189|         0|            0|            0|  0.00%|    # Make sure __slots__ isn't already set.
  1190|         0|            0|            0|  0.00%|    if '__slots__' in cls.__dict__:
  1191|         0|            0|            0|  0.00%|        raise TypeError(f'{cls.__name__} already specifies __slots__')
  1192|         0|            0|            0|  0.00%|
  1193|         0|            0|            0|  0.00%|    # Create a new dict for our new class.
  1194|         0|            0|            0|  0.00%|    cls_dict = dict(cls.__dict__)
  1195|         0|            0|            0|  0.00%|    field_names = tuple(f.name for f in fields(cls))
  1196|         0|            0|            0|  0.00%|    # Make sure slots don't overlap with those in base classes.
  1197|         0|            0|            0|  0.00%|    inherited_slots = set(
  1198|         0|            0|            0|  0.00%|        itertools.chain.from_iterable(map(_get_slots, cls.__mro__[1:-1]))
  1199|         0|            0|            0|  0.00%|    )
  1200|         0|            0|            0|  0.00%|    # The slots for our class.  Remove slots from our base classes.  Add
  1201|         0|            0|            0|  0.00%|    # '__weakref__' if weakref_slot was given, unless it is already present.
  1202|         0|            0|            0|  0.00%|    cls_dict["__slots__"] = tuple(
  1203|         0|            0|            0|  0.00%|        itertools.filterfalse(
  1204|         0|            0|            0|  0.00%|            inherited_slots.__contains__,
  1205|         0|            0|            0|  0.00%|            itertools.chain(
  1206|         0|            0|            0|  0.00%|                # gh-93521: '__weakref__' also needs to be filtered out if
  1207|         0|            0|            0|  0.00%|                # already present in inherited_slots
  1208|         0|            0|            0|  0.00%|                field_names, ('__weakref__',) if weakref_slot else ()
  1209|         0|            0|            0|  0.00%|            )
  1210|         0|            0|            0|  0.00%|        ),
  1211|         0|            0|            0|  0.00%|    )
  1212|         0|            0|            0|  0.00%|
  1213|         0|            0|            0|  0.00%|    for field_name in field_names:
  1214|         0|            0|            0|  0.00%|        # Remove our attributes, if present. They'll still be
  1215|         0|            0|            0|  0.00%|        #  available in _MARKER.
  1216|         0|            0|            0|  0.00%|        cls_dict.pop(field_name, None)
  1217|         0|            0|            0|  0.00%|
  1218|         0|            0|            0|  0.00%|    # Remove __dict__ itself.
  1219|         0|            0|            0|  0.00%|    cls_dict.pop('__dict__', None)
  1220|         0|            0|            0|  0.00%|
  1221|         0|            0|            0|  0.00%|    # Clear existing `__weakref__` descriptor, it belongs to a previous type:
  1222|         0|            0|            0|  0.00%|    cls_dict.pop('__weakref__', None)  # gh-102069
  1223|         0|            0|            0|  0.00%|
  1224|         0|            0|            0|  0.00%|    # And finally create the class.
  1225|         0|            0|            0|  0.00%|    qualname = getattr(cls, '__qualname__', None)
  1226|         0|            0|            0|  0.00%|    cls = type(cls)(cls.__name__, cls.__bases__, cls_dict)
  1227|         0|            0|            0|  0.00%|    if qualname is not None:
  1228|         0|            0|            0|  0.00%|        cls.__qualname__ = qualname
  1229|         0|            0|            0|  0.00%|
  1230|         0|            0|            0|  0.00%|    if is_frozen:
  1231|         0|            0|            0|  0.00%|        # Need this for pickling frozen classes with slots.
  1232|         0|            0|            0|  0.00%|        if '__getstate__' not in cls_dict:
  1233|         0|            0|            0|  0.00%|            cls.__getstate__ = _dataclass_getstate
  1234|         0|            0|            0|  0.00%|        if '__setstate__' not in cls_dict:
  1235|         0|            0|            0|  0.00%|            cls.__setstate__ = _dataclass_setstate
  1236|         0|            0|            0|  0.00%|
  1237|         0|            0|            0|  0.00%|    return cls
  1238|         0|            0|            0|  0.00%|
  1239|         0|            0|            0|  0.00%|
  1240|         0|            0|            0|  0.00%|def dataclass(cls=None, /, *, init=True, repr=True, eq=True, order=False,
  1241|         0|            0|            0|  0.00%|              unsafe_hash=False, frozen=False, match_args=True,
  1242|         0|            0|            0|  0.00%|              kw_only=False, slots=False, weakref_slot=False):
  1243|         0|            0|            0|  0.00%|    """Add dunder methods based on the fields defined in the class.
  1244|         0|            0|            0|  0.00%|
  1245|         0|            0|            0|  0.00%|    Examines PEP 526 __annotations__ to determine fields.
  1246|         0|            0|            0|  0.00%|
  1247|         0|            0|            0|  0.00%|    If init is true, an __init__() method is added to the class. If repr
  1248|         0|            0|            0|  0.00%|    is true, a __repr__() method is added. If order is true, rich
  1249|         0|            0|            0|  0.00%|    comparison dunder methods are added. If unsafe_hash is true, a
  1250|         0|            0|            0|  0.00%|    __hash__() method is added. If frozen is true, fields may not be
  1251|         0|            0|            0|  0.00%|    assigned to after instance creation. If match_args is true, the
  1252|         0|            0|            0|  0.00%|    __match_args__ tuple is added. If kw_only is true, then by default
  1253|         0|            0|            0|  0.00%|    all fields are keyword-only. If slots is true, a new class with a
  1254|         0|            0|            0|  0.00%|    __slots__ attribute is returned.
  1255|         0|            0|            0|  0.00%|    """
  1256|         0|            0|            0|  0.00%|
  1257|         0|            0|            0|  0.00%|    def wrap(cls):
  1258|         0|            0|            0|  0.00%|        return _process_class(cls, init, repr, eq, order, unsafe_hash,
  1259|         0|            0|            0|  0.00%|                              frozen, match_args, kw_only, slots,
  1260|         0|            0|            0|  0.00%|                              weakref_slot)
  1261|         0|            0|            0|  0.00%|
  1262|         0|            0|            0|  0.00%|    # See if we're being called as @dataclass or @dataclass().
  1263|         0|            0|            0|  0.00%|    if cls is None:
  1264|         0|            0|            0|  0.00%|        # We're called with parens.
  1265|         0|            0|            0|  0.00%|        return wrap
  1266|         0|            0|            0|  0.00%|
  1267|         0|            0|            0|  0.00%|    # We're called as @dataclass without parens.
  1268|         0|            0|            0|  0.00%|    return wrap(cls)
  1269|         0|            0|            0|  0.00%|
  1270|         0|            0|            0|  0.00%|
  1271|         0|            0|            0|  0.00%|def fields(class_or_instance):
  1272|         0|            0|            0|  0.00%|    """Return a tuple describing the fields of this dataclass.
  1273|         0|            0|            0|  0.00%|
  1274|         0|            0|            0|  0.00%|    Accepts a dataclass or an instance of one. Tuple elements are of
  1275|         0|            0|            0|  0.00%|    type Field.
  1276|         0|            0|            0|  0.00%|    """
  1277|         0|            0|            0|  0.00%|
  1278|         0|            0|            0|  0.00%|    # Might it be worth caching this, per class?
  1279|         0|            0|            0|  0.00%|    try:
  1280|         0|            0|            0|  0.00%|        fields = getattr(class_or_instance, _FIELDS)
  1281|         0|            0|            0|  0.00%|    except AttributeError:
  1282|         0|            0|            0|  0.00%|        raise TypeError('must be called with a dataclass type or instance') from None
  1283|         0|            0|            0|  0.00%|
  1284|         0|            0|            0|  0.00%|    # Exclude pseudo-fields.  Note that fields is sorted by insertion
  1285|         0|            0|            0|  0.00%|    # order, so the order of the tuple is as the fields were defined.
  1286|         0|            0|            0|  0.00%|    return tuple(f for f in fields.values() if f._field_type is _FIELD)
  1287|         0|            0|            0|  0.00%|
  1288|         0|            0|            0|  0.00%|
  1289|         0|            0|            0|  0.00%|def _is_dataclass_instance(obj):
  1290|         0|            0|            0|  0.00%|    """Returns True if obj is an instance of a dataclass."""
  1291|         0|            0|            0|  0.00%|    return hasattr(type(obj), _FIELDS)
  1292|         0|            0|            0|  0.00%|
  1293|         0|            0|            0|  0.00%|
  1294|         8|  1.35899e-05|  1.69873e-06|  0.01%|def is_dataclass(obj):
  1295|         0|            0|            0|  0.00%|    """Returns True if obj is a dataclass or an instance of a
  1296|         0|            0|            0|  0.00%|    dataclass."""
  1297|         8|  2.36034e-05|  2.95043e-06|  0.02%|    cls = obj if isinstance(obj, type) else type(obj)
  1298|         8|  1.35899e-05|  1.69873e-06|  0.01%|    return hasattr(cls, _FIELDS)
  1299|         0|            0|            0|  0.00%|
  1300|         0|            0|            0|  0.00%|
  1301|         0|            0|            0|  0.00%|def asdict(obj, *, dict_factory=dict):
  1302|         0|            0|            0|  0.00%|    """Return the fields of a dataclass instance as a new dictionary mapping
  1303|         0|            0|            0|  0.00%|    field names to field values.
  1304|         0|            0|            0|  0.00%|
  1305|         0|            0|            0|  0.00%|    Example usage::
  1306|         0|            0|            0|  0.00%|
  1307|         0|            0|            0|  0.00%|      @dataclass
  1308|         0|            0|            0|  0.00%|      class C:
  1309|         0|            0|            0|  0.00%|          x: int
  1310|         0|            0|            0|  0.00%|          y: int
  1311|         0|            0|            0|  0.00%|
  1312|         0|            0|            0|  0.00%|      c = C(1, 2)
  1313|         0|            0|            0|  0.00%|      assert asdict(c) == {'x': 1, 'y': 2}
  1314|         0|            0|            0|  0.00%|
  1315|         0|            0|            0|  0.00%|    If given, 'dict_factory' will be used instead of built-in dict.
  1316|         0|            0|            0|  0.00%|    The function applies recursively to field values that are
  1317|         0|            0|            0|  0.00%|    dataclass instances. This will also look into built-in containers:
  1318|         0|            0|            0|  0.00%|    tuples, lists, and dicts. Other objects are copied with 'copy.deepcopy()'.
  1319|         0|            0|            0|  0.00%|    """
  1320|         0|            0|            0|  0.00%|    if not _is_dataclass_instance(obj):
  1321|         0|            0|            0|  0.00%|        raise TypeError("asdict() should be called on dataclass instances")
  1322|         0|            0|            0|  0.00%|    return _asdict_inner(obj, dict_factory)
  1323|         0|            0|            0|  0.00%|
  1324|         0|            0|            0|  0.00%|
  1325|         0|            0|            0|  0.00%|def _asdict_inner(obj, dict_factory):
  1326|         0|            0|            0|  0.00%|    if type(obj) in _ATOMIC_TYPES:
  1327|         0|            0|            0|  0.00%|        return obj
  1328|         0|            0|            0|  0.00%|    elif _is_dataclass_instance(obj):
  1329|         0|            0|            0|  0.00%|        # fast path for the common case
  1330|         0|            0|            0|  0.00%|        if dict_factory is dict:
  1331|         0|            0|            0|  0.00%|            return {
  1332|         0|            0|            0|  0.00%|                f.name: _asdict_inner(getattr(obj, f.name), dict)
  1333|         0|            0|            0|  0.00%|                for f in fields(obj)
  1334|         0|            0|            0|  0.00%|            }
  1335|         0|            0|            0|  0.00%|        else:
  1336|         0|            0|            0|  0.00%|            result = []
  1337|         0|            0|            0|  0.00%|            for f in fields(obj):
  1338|         0|            0|            0|  0.00%|                value = _asdict_inner(getattr(obj, f.name), dict_factory)
  1339|         0|            0|            0|  0.00%|                result.append((f.name, value))
  1340|         0|            0|            0|  0.00%|            return dict_factory(result)
  1341|         0|            0|            0|  0.00%|    elif isinstance(obj, tuple) and hasattr(obj, '_fields'):
  1342|         0|            0|            0|  0.00%|        # obj is a namedtuple.  Recurse into it, but the returned
  1343|         0|            0|            0|  0.00%|        # object is another namedtuple of the same type.  This is
  1344|         0|            0|            0|  0.00%|        # similar to how other list- or tuple-derived classes are
  1345|         0|            0|            0|  0.00%|        # treated (see below), but we just need to create them
  1346|         0|            0|            0|  0.00%|        # differently because a namedtuple's __init__ needs to be
  1347|         0|            0|            0|  0.00%|        # called differently (see bpo-34363).
  1348|         0|            0|            0|  0.00%|
  1349|         0|            0|            0|  0.00%|        # I'm not using namedtuple's _asdict()
  1350|         0|            0|            0|  0.00%|        # method, because:
  1351|         0|            0|            0|  0.00%|        # - it does not recurse in to the namedtuple fields and
  1352|         0|            0|            0|  0.00%|        #   convert them to dicts (using dict_factory).
  1353|         0|            0|            0|  0.00%|        # - I don't actually want to return a dict here.  The main
  1354|         0|            0|            0|  0.00%|        #   use case here is json.dumps, and it handles converting
  1355|         0|            0|            0|  0.00%|        #   namedtuples to lists.  Admittedly we're losing some
  1356|         0|            0|            0|  0.00%|        #   information here when we produce a json list instead of a
  1357|         0|            0|            0|  0.00%|        #   dict.  Note that if we returned dicts here instead of
  1358|         0|            0|            0|  0.00%|        #   namedtuples, we could no longer call asdict() on a data
  1359|         0|            0|            0|  0.00%|        #   structure where a namedtuple was used as a dict key.
  1360|         0|            0|            0|  0.00%|
  1361|         0|            0|            0|  0.00%|        return type(obj)(*[_asdict_inner(v, dict_factory) for v in obj])
  1362|         0|            0|            0|  0.00%|    elif isinstance(obj, (list, tuple)):
  1363|         0|            0|            0|  0.00%|        # Assume we can create an object of this type by passing in a
  1364|         0|            0|            0|  0.00%|        # generator (which is not true for namedtuples, handled
  1365|         0|            0|            0|  0.00%|        # above).
  1366|         0|            0|            0|  0.00%|        return type(obj)(_asdict_inner(v, dict_factory) for v in obj)
  1367|         0|            0|            0|  0.00%|    elif isinstance(obj, dict):
  1368|         0|            0|            0|  0.00%|        if hasattr(type(obj), 'default_factory'):
  1369|         0|            0|            0|  0.00%|            # obj is a defaultdict, which has a different constructor from
  1370|         0|            0|            0|  0.00%|            # dict as it requires the default_factory as its first arg.
  1371|         0|            0|            0|  0.00%|            result = type(obj)(getattr(obj, 'default_factory'))
  1372|         0|            0|            0|  0.00%|            for k, v in obj.items():
  1373|         0|            0|            0|  0.00%|                result[_asdict_inner(k, dict_factory)] = _asdict_inner(v, dict_factory)
  1374|         0|            0|            0|  0.00%|            return result
  1375|         0|            0|            0|  0.00%|        return type(obj)((_asdict_inner(k, dict_factory),
  1376|         0|            0|            0|  0.00%|                          _asdict_inner(v, dict_factory))
  1377|         0|            0|            0|  0.00%|                         for k, v in obj.items())
  1378|         0|            0|            0|  0.00%|    else:
  1379|         0|            0|            0|  0.00%|        return copy.deepcopy(obj)
  1380|         0|            0|            0|  0.00%|
  1381|         0|            0|            0|  0.00%|
  1382|         0|            0|            0|  0.00%|def astuple(obj, *, tuple_factory=tuple):
  1383|         0|            0|            0|  0.00%|    """Return the fields of a dataclass instance as a new tuple of field values.
  1384|         0|            0|            0|  0.00%|
  1385|         0|            0|            0|  0.00%|    Example usage::
  1386|         0|            0|            0|  0.00%|
  1387|         0|            0|            0|  0.00%|      @dataclass
  1388|         0|            0|            0|  0.00%|      class C:
  1389|         0|            0|            0|  0.00%|          x: int
  1390|         0|            0|            0|  0.00%|          y: int
  1391|         0|            0|            0|  0.00%|
  1392|         0|            0|            0|  0.00%|      c = C(1, 2)
  1393|         0|            0|            0|  0.00%|      assert astuple(c) == (1, 2)
  1394|         0|            0|            0|  0.00%|
  1395|         0|            0|            0|  0.00%|    If given, 'tuple_factory' will be used instead of built-in tuple.
  1396|         0|            0|            0|  0.00%|    The function applies recursively to field values that are
  1397|         0|            0|            0|  0.00%|    dataclass instances. This will also look into built-in containers:
  1398|         0|            0|            0|  0.00%|    tuples, lists, and dicts. Other objects are copied with 'copy.deepcopy()'.
  1399|         0|            0|            0|  0.00%|    """
  1400|         0|            0|            0|  0.00%|
  1401|         0|            0|            0|  0.00%|    if not _is_dataclass_instance(obj):
  1402|         0|            0|            0|  0.00%|        raise TypeError("astuple() should be called on dataclass instances")
  1403|         0|            0|            0|  0.00%|    return _astuple_inner(obj, tuple_factory)
  1404|         0|            0|            0|  0.00%|
  1405|         0|            0|            0|  0.00%|
  1406|         0|            0|            0|  0.00%|def _astuple_inner(obj, tuple_factory):
  1407|         0|            0|            0|  0.00%|    if type(obj) in _ATOMIC_TYPES:
  1408|         0|            0|            0|  0.00%|        return obj
  1409|         0|            0|            0|  0.00%|    elif _is_dataclass_instance(obj):
  1410|         0|            0|            0|  0.00%|        result = []
  1411|         0|            0|            0|  0.00%|        for f in fields(obj):
  1412|         0|            0|            0|  0.00%|            value = _astuple_inner(getattr(obj, f.name), tuple_factory)
  1413|         0|            0|            0|  0.00%|            result.append(value)
  1414|         0|            0|            0|  0.00%|        return tuple_factory(result)
  1415|         0|            0|            0|  0.00%|    elif isinstance(obj, tuple) and hasattr(obj, '_fields'):
  1416|         0|            0|            0|  0.00%|        # obj is a namedtuple.  Recurse into it, but the returned
  1417|         0|            0|            0|  0.00%|        # object is another namedtuple of the same type.  This is
  1418|         0|            0|            0|  0.00%|        # similar to how other list- or tuple-derived classes are
  1419|         0|            0|            0|  0.00%|        # treated (see below), but we just need to create them
  1420|         0|            0|            0|  0.00%|        # differently because a namedtuple's __init__ needs to be
  1421|         0|            0|            0|  0.00%|        # called differently (see bpo-34363).
  1422|         0|            0|            0|  0.00%|        return type(obj)(*[_astuple_inner(v, tuple_factory) for v in obj])
  1423|         0|            0|            0|  0.00%|    elif isinstance(obj, (list, tuple)):
  1424|         0|            0|            0|  0.00%|        # Assume we can create an object of this type by passing in a
  1425|         0|            0|            0|  0.00%|        # generator (which is not true for namedtuples, handled
  1426|         0|            0|            0|  0.00%|        # above).
  1427|         0|            0|            0|  0.00%|        return type(obj)(_astuple_inner(v, tuple_factory) for v in obj)
  1428|         0|            0|            0|  0.00%|    elif isinstance(obj, dict):
  1429|         0|            0|            0|  0.00%|        obj_type = type(obj)
  1430|         0|            0|            0|  0.00%|        if hasattr(obj_type, 'default_factory'):
  1431|         0|            0|            0|  0.00%|            # obj is a defaultdict, which has a different constructor from
  1432|         0|            0|            0|  0.00%|            # dict as it requires the default_factory as its first arg.
  1433|         0|            0|            0|  0.00%|            result = obj_type(getattr(obj, 'default_factory'))
  1434|         0|            0|            0|  0.00%|            for k, v in obj.items():
  1435|         0|            0|            0|  0.00%|                result[_astuple_inner(k, tuple_factory)] = _astuple_inner(v, tuple_factory)
  1436|         0|            0|            0|  0.00%|            return result
  1437|         0|            0|            0|  0.00%|        return obj_type((_astuple_inner(k, tuple_factory), _astuple_inner(v, tuple_factory))
  1438|         0|            0|            0|  0.00%|                          for k, v in obj.items())
  1439|         0|            0|            0|  0.00%|    else:
  1440|         0|            0|            0|  0.00%|        return copy.deepcopy(obj)
  1441|         0|            0|            0|  0.00%|
  1442|         0|            0|            0|  0.00%|
  1443|         0|            0|            0|  0.00%|def make_dataclass(cls_name, fields, *, bases=(), namespace=None, init=True,
  1444|         0|            0|            0|  0.00%|                   repr=True, eq=True, order=False, unsafe_hash=False,
  1445|         0|            0|            0|  0.00%|                   frozen=False, match_args=True, kw_only=False, slots=False,
  1446|         0|            0|            0|  0.00%|                   weakref_slot=False, module=None):
  1447|         0|            0|            0|  0.00%|    """Return a new dynamically created dataclass.
  1448|         0|            0|            0|  0.00%|
  1449|         0|            0|            0|  0.00%|    The dataclass name will be 'cls_name'.  'fields' is an iterable
  1450|         0|            0|            0|  0.00%|    of either (name), (name, type) or (name, type, Field) objects. If type is
  1451|         0|            0|            0|  0.00%|    omitted, use the string 'typing.Any'.  Field objects are created by
  1452|         0|            0|            0|  0.00%|    the equivalent of calling 'field(name, type [, Field-info])'.::
  1453|         0|            0|            0|  0.00%|
  1454|         0|            0|            0|  0.00%|      C = make_dataclass('C', ['x', ('y', int), ('z', int, field(init=False))], bases=(Base,))
  1455|         0|            0|            0|  0.00%|
  1456|         0|            0|            0|  0.00%|    is equivalent to::
  1457|         0|            0|            0|  0.00%|
  1458|         0|            0|            0|  0.00%|      @dataclass
  1459|         0|            0|            0|  0.00%|      class C(Base):
  1460|         0|            0|            0|  0.00%|          x: 'typing.Any'
  1461|         0|            0|            0|  0.00%|          y: int
  1462|         0|            0|            0|  0.00%|          z: int = field(init=False)
  1463|         0|            0|            0|  0.00%|
  1464|         0|            0|            0|  0.00%|    For the bases and namespace parameters, see the builtin type() function.
  1465|         0|            0|            0|  0.00%|
  1466|         0|            0|            0|  0.00%|    The parameters init, repr, eq, order, unsafe_hash, frozen, match_args, kw_only,
  1467|         0|            0|            0|  0.00%|    slots, and weakref_slot are passed to dataclass().
  1468|         0|            0|            0|  0.00%|
  1469|         0|            0|            0|  0.00%|    If module parameter is defined, the '__module__' attribute of the dataclass is
  1470|         0|            0|            0|  0.00%|    set to that value.
  1471|         0|            0|            0|  0.00%|    """
  1472|         0|            0|            0|  0.00%|
  1473|         0|            0|            0|  0.00%|    if namespace is None:
  1474|         0|            0|            0|  0.00%|        namespace = {}
  1475|         0|            0|            0|  0.00%|
  1476|         0|            0|            0|  0.00%|    # While we're looking through the field names, validate that they
  1477|         0|            0|            0|  0.00%|    # are identifiers, are not keywords, and not duplicates.
  1478|         0|            0|            0|  0.00%|    seen = set()
  1479|         0|            0|            0|  0.00%|    annotations = {}
  1480|         0|            0|            0|  0.00%|    defaults = {}
  1481|         0|            0|            0|  0.00%|    for item in fields:
  1482|         0|            0|            0|  0.00%|        if isinstance(item, str):
  1483|         0|            0|            0|  0.00%|            name = item
  1484|         0|            0|            0|  0.00%|            tp = 'typing.Any'
  1485|         0|            0|            0|  0.00%|        elif len(item) == 2:
  1486|         0|            0|            0|  0.00%|            name, tp, = item
  1487|         0|            0|            0|  0.00%|        elif len(item) == 3:
  1488|         0|            0|            0|  0.00%|            name, tp, spec = item
  1489|         0|            0|            0|  0.00%|            defaults[name] = spec
  1490|         0|            0|            0|  0.00%|        else:
  1491|         0|            0|            0|  0.00%|            raise TypeError(f'Invalid field: {item!r}')
  1492|         0|            0|            0|  0.00%|
  1493|         0|            0|            0|  0.00%|        if not isinstance(name, str) or not name.isidentifier():
  1494|         0|            0|            0|  0.00%|            raise TypeError(f'Field names must be valid identifiers: {name!r}')
  1495|         0|            0|            0|  0.00%|        if keyword.iskeyword(name):
  1496|         0|            0|            0|  0.00%|            raise TypeError(f'Field names must not be keywords: {name!r}')
  1497|         0|            0|            0|  0.00%|        if name in seen:
  1498|         0|            0|            0|  0.00%|            raise TypeError(f'Field name duplicated: {name!r}')
  1499|         0|            0|            0|  0.00%|
  1500|         0|            0|            0|  0.00%|        seen.add(name)
  1501|         0|            0|            0|  0.00%|        annotations[name] = tp
  1502|         0|            0|            0|  0.00%|
  1503|         0|            0|            0|  0.00%|    # Update 'ns' with the user-supplied namespace plus our calculated values.
  1504|         0|            0|            0|  0.00%|    def exec_body_callback(ns):
  1505|         0|            0|            0|  0.00%|        ns.update(namespace)
  1506|         0|            0|            0|  0.00%|        ns.update(defaults)
  1507|         0|            0|            0|  0.00%|        ns['__annotations__'] = annotations
  1508|         0|            0|            0|  0.00%|
  1509|         0|            0|            0|  0.00%|    # We use `types.new_class()` instead of simply `type()` to allow dynamic creation
  1510|         0|            0|            0|  0.00%|    # of generic dataclasses.
  1511|         0|            0|            0|  0.00%|    cls = types.new_class(cls_name, bases, {}, exec_body_callback)
  1512|         0|            0|            0|  0.00%|
  1513|         0|            0|            0|  0.00%|    # For pickling to work, the __module__ variable needs to be set to the frame
  1514|         0|            0|            0|  0.00%|    # where the dataclass is created.
  1515|         0|            0|            0|  0.00%|    if module is None:
  1516|         0|            0|            0|  0.00%|        try:
  1517|         0|            0|            0|  0.00%|            module = sys._getframemodulename(1) or '__main__'
  1518|         0|            0|            0|  0.00%|        except AttributeError:
  1519|         0|            0|            0|  0.00%|            try:
  1520|         0|            0|            0|  0.00%|                module = sys._getframe(1).f_globals.get('__name__', '__main__')
  1521|         0|            0|            0|  0.00%|            except (AttributeError, ValueError):
  1522|         0|            0|            0|  0.00%|                pass
  1523|         0|            0|            0|  0.00%|    if module is not None:
  1524|         0|            0|            0|  0.00%|        cls.__module__ = module
  1525|         0|            0|            0|  0.00%|
  1526|         0|            0|            0|  0.00%|    # Apply the normal decorator.
  1527|         0|            0|            0|  0.00%|    return dataclass(cls, init=init, repr=repr, eq=eq, order=order,
  1528|         0|            0|            0|  0.00%|                     unsafe_hash=unsafe_hash, frozen=frozen,
  1529|         0|            0|            0|  0.00%|                     match_args=match_args, kw_only=kw_only, slots=slots,
  1530|         0|            0|            0|  0.00%|                     weakref_slot=weakref_slot)
  1531|         0|            0|            0|  0.00%|
  1532|         0|            0|            0|  0.00%|
  1533|         0|            0|            0|  0.00%|def replace(obj, /, **changes):
  1534|         0|            0|            0|  0.00%|    """Return a new object replacing specified fields with new values.
  1535|         0|            0|            0|  0.00%|
  1536|         0|            0|            0|  0.00%|    This is especially useful for frozen classes.  Example usage::
  1537|         0|            0|            0|  0.00%|
  1538|         0|            0|            0|  0.00%|      @dataclass(frozen=True)
  1539|         0|            0|            0|  0.00%|      class C:
  1540|         0|            0|            0|  0.00%|          x: int
  1541|         0|            0|            0|  0.00%|          y: int
  1542|         0|            0|            0|  0.00%|
  1543|         0|            0|            0|  0.00%|      c = C(1, 2)
  1544|         0|            0|            0|  0.00%|      c1 = replace(c, x=3)
  1545|         0|            0|            0|  0.00%|      assert c1.x == 3 and c1.y == 2
  1546|         0|            0|            0|  0.00%|    """
  1547|         0|            0|            0|  0.00%|
  1548|         0|            0|            0|  0.00%|    # We're going to mutate 'changes', but that's okay because it's a
  1549|         0|            0|            0|  0.00%|    # new dict, even if called with 'replace(obj, **my_changes)'.
  1550|         0|            0|            0|  0.00%|
  1551|         0|            0|            0|  0.00%|    if not _is_dataclass_instance(obj):
  1552|         0|            0|            0|  0.00%|        raise TypeError("replace() should be called on dataclass instances")
  1553|         0|            0|            0|  0.00%|
  1554|         0|            0|            0|  0.00%|    # It's an error to have init=False fields in 'changes'.
  1555|         0|            0|            0|  0.00%|    # If a field is not in 'changes', read its value from the provided obj.
  1556|         0|            0|            0|  0.00%|
  1557|         0|            0|            0|  0.00%|    for f in getattr(obj, _FIELDS).values():
  1558|         0|            0|            0|  0.00%|        # Only consider normal fields or InitVars.
  1559|         0|            0|            0|  0.00%|        if f._field_type is _FIELD_CLASSVAR:
  1560|         0|            0|            0|  0.00%|            continue
  1561|         0|            0|            0|  0.00%|
  1562|         0|            0|            0|  0.00%|        if not f.init:
  1563|         0|            0|            0|  0.00%|            # Error if this field is specified in changes.
  1564|         0|            0|            0|  0.00%|            if f.name in changes:
  1565|         0|            0|            0|  0.00%|                raise ValueError(f'field {f.name} is declared with '
  1566|         0|            0|            0|  0.00%|                                 'init=False, it cannot be specified with '
  1567|         0|            0|            0|  0.00%|                                 'replace()')
  1568|         0|            0|            0|  0.00%|            continue
  1569|         0|            0|            0|  0.00%|
  1570|         0|            0|            0|  0.00%|        if f.name not in changes:
  1571|         0|            0|            0|  0.00%|            if f._field_type is _FIELD_INITVAR and f.default is MISSING:
  1572|         0|            0|            0|  0.00%|                raise ValueError(f"InitVar {f.name!r} "
  1573|         0|            0|            0|  0.00%|                                 'must be specified with replace()')
  1574|         0|            0|            0|  0.00%|            changes[f.name] = getattr(obj, f.name)
  1575|         0|            0|            0|  0.00%|
  1576|         0|            0|            0|  0.00%|    # Create the new object, which calls __init__() and
  1577|         0|            0|            0|  0.00%|    # __post_init__() (if defined), using all of the init fields we've
  1578|         0|            0|            0|  0.00%|    # added and/or left in 'changes'.  If there are values supplied in
  1579|         0|            0|            0|  0.00%|    # changes that aren't fields, this will correctly raise a
  1580|         0|            0|            0|  0.00%|    # TypeError.
  1581|         0|            0|            0|  0.00%|    return obj.__class__(**changes)
File: /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/pydantic/_migration.py
File duration: 2.71797e-05s (0.03%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|import sys
     2|         0|            0|            0|  0.00%|from typing import Any, Callable, Dict
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|from .version import version_short
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|MOVED_IN_V2 = {
     7|         0|            0|            0|  0.00%|    'pydantic.utils:version_info': 'pydantic.version:version_info',
     8|         0|            0|            0|  0.00%|    'pydantic.error_wrappers:ValidationError': 'pydantic:ValidationError',
     9|         0|            0|            0|  0.00%|    'pydantic.utils:to_camel': 'pydantic.alias_generators:to_pascal',
    10|         0|            0|            0|  0.00%|    'pydantic.utils:to_lower_camel': 'pydantic.alias_generators:to_camel',
    11|         0|            0|            0|  0.00%|    'pydantic:PyObject': 'pydantic.types:ImportString',
    12|         0|            0|            0|  0.00%|    'pydantic.types:PyObject': 'pydantic.types:ImportString',
    13|         0|            0|            0|  0.00%|    'pydantic.generics:GenericModel': 'pydantic.BaseModel',
    14|         0|            0|            0|  0.00%|}
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|DEPRECATED_MOVED_IN_V2 = {
    17|         0|            0|            0|  0.00%|    'pydantic.tools:schema_of': 'pydantic.deprecated.tools:schema_of',
    18|         0|            0|            0|  0.00%|    'pydantic.tools:parse_obj_as': 'pydantic.deprecated.tools:parse_obj_as',
    19|         0|            0|            0|  0.00%|    'pydantic.tools:schema_json_of': 'pydantic.deprecated.tools:schema_json_of',
    20|         0|            0|            0|  0.00%|    'pydantic.json:pydantic_encoder': 'pydantic.deprecated.json:pydantic_encoder',
    21|         0|            0|            0|  0.00%|    'pydantic:validate_arguments': 'pydantic.deprecated.decorator:validate_arguments',
    22|         0|            0|            0|  0.00%|    'pydantic.json:custom_pydantic_encoder': 'pydantic.deprecated.json:custom_pydantic_encoder',
    23|         0|            0|            0|  0.00%|    'pydantic.json:timedelta_isoformat': 'pydantic.deprecated.json:timedelta_isoformat',
    24|         0|            0|            0|  0.00%|    'pydantic.decorator:validate_arguments': 'pydantic.deprecated.decorator:validate_arguments',
    25|         0|            0|            0|  0.00%|    'pydantic.class_validators:validator': 'pydantic.deprecated.class_validators:validator',
    26|         0|            0|            0|  0.00%|    'pydantic.class_validators:root_validator': 'pydantic.deprecated.class_validators:root_validator',
    27|         0|            0|            0|  0.00%|    'pydantic.config:BaseConfig': 'pydantic.deprecated.config:BaseConfig',
    28|         0|            0|            0|  0.00%|    'pydantic.config:Extra': 'pydantic.deprecated.config:Extra',
    29|         0|            0|            0|  0.00%|}
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|REDIRECT_TO_V1 = {
    32|         0|            0|            0|  0.00%|    f'pydantic.utils:{obj}': f'pydantic.v1.utils:{obj}'
    33|         0|            0|            0|  0.00%|    for obj in (
    34|         0|            0|            0|  0.00%|        'deep_update',
    35|         0|            0|            0|  0.00%|        'GetterDict',
    36|         0|            0|            0|  0.00%|        'lenient_issubclass',
    37|         0|            0|            0|  0.00%|        'lenient_isinstance',
    38|         0|            0|            0|  0.00%|        'is_valid_field',
    39|         0|            0|            0|  0.00%|        'update_not_none',
    40|         0|            0|            0|  0.00%|        'import_string',
    41|         0|            0|            0|  0.00%|        'Representation',
    42|         0|            0|            0|  0.00%|        'ROOT_KEY',
    43|         0|            0|            0|  0.00%|        'smart_deepcopy',
    44|         0|            0|            0|  0.00%|        'sequence_like',
    45|         0|            0|            0|  0.00%|    )
    46|         0|            0|            0|  0.00%|}
    47|         0|            0|            0|  0.00%|
    48|         0|            0|            0|  0.00%|
    49|         0|            0|            0|  0.00%|REMOVED_IN_V2 = {
    50|         0|            0|            0|  0.00%|    'pydantic:ConstrainedBytes',
    51|         0|            0|            0|  0.00%|    'pydantic:ConstrainedDate',
    52|         0|            0|            0|  0.00%|    'pydantic:ConstrainedDecimal',
    53|         0|            0|            0|  0.00%|    'pydantic:ConstrainedFloat',
    54|         0|            0|            0|  0.00%|    'pydantic:ConstrainedFrozenSet',
    55|         0|            0|            0|  0.00%|    'pydantic:ConstrainedInt',
    56|         0|            0|            0|  0.00%|    'pydantic:ConstrainedList',
    57|         0|            0|            0|  0.00%|    'pydantic:ConstrainedSet',
    58|         0|            0|            0|  0.00%|    'pydantic:ConstrainedStr',
    59|         0|            0|            0|  0.00%|    'pydantic:JsonWrapper',
    60|         0|            0|            0|  0.00%|    'pydantic:NoneBytes',
    61|         0|            0|            0|  0.00%|    'pydantic:NoneStr',
    62|         0|            0|            0|  0.00%|    'pydantic:NoneStrBytes',
    63|         0|            0|            0|  0.00%|    'pydantic:Protocol',
    64|         0|            0|            0|  0.00%|    'pydantic:Required',
    65|         0|            0|            0|  0.00%|    'pydantic:StrBytes',
    66|         0|            0|            0|  0.00%|    'pydantic:compiled',
    67|         0|            0|            0|  0.00%|    'pydantic.config:get_config',
    68|         0|            0|            0|  0.00%|    'pydantic.config:inherit_config',
    69|         0|            0|            0|  0.00%|    'pydantic.config:prepare_config',
    70|         0|            0|            0|  0.00%|    'pydantic:create_model_from_namedtuple',
    71|         0|            0|            0|  0.00%|    'pydantic:create_model_from_typeddict',
    72|         0|            0|            0|  0.00%|    'pydantic.dataclasses:create_pydantic_model_from_dataclass',
    73|         0|            0|            0|  0.00%|    'pydantic.dataclasses:make_dataclass_validator',
    74|         0|            0|            0|  0.00%|    'pydantic.dataclasses:set_validation',
    75|         0|            0|            0|  0.00%|    'pydantic.datetime_parse:parse_date',
    76|         0|            0|            0|  0.00%|    'pydantic.datetime_parse:parse_time',
    77|         0|            0|            0|  0.00%|    'pydantic.datetime_parse:parse_datetime',
    78|         0|            0|            0|  0.00%|    'pydantic.datetime_parse:parse_duration',
    79|         0|            0|            0|  0.00%|    'pydantic.error_wrappers:ErrorWrapper',
    80|         0|            0|            0|  0.00%|    'pydantic.errors:AnyStrMaxLengthError',
    81|         0|            0|            0|  0.00%|    'pydantic.errors:AnyStrMinLengthError',
    82|         0|            0|            0|  0.00%|    'pydantic.errors:ArbitraryTypeError',
    83|         0|            0|            0|  0.00%|    'pydantic.errors:BoolError',
    84|         0|            0|            0|  0.00%|    'pydantic.errors:BytesError',
    85|         0|            0|            0|  0.00%|    'pydantic.errors:CallableError',
    86|         0|            0|            0|  0.00%|    'pydantic.errors:ClassError',
    87|         0|            0|            0|  0.00%|    'pydantic.errors:ColorError',
    88|         0|            0|            0|  0.00%|    'pydantic.errors:ConfigError',
    89|         0|            0|            0|  0.00%|    'pydantic.errors:DataclassTypeError',
    90|         0|            0|            0|  0.00%|    'pydantic.errors:DateError',
    91|         0|            0|            0|  0.00%|    'pydantic.errors:DateNotInTheFutureError',
    92|         0|            0|            0|  0.00%|    'pydantic.errors:DateNotInThePastError',
    93|         0|            0|            0|  0.00%|    'pydantic.errors:DateTimeError',
    94|         0|            0|            0|  0.00%|    'pydantic.errors:DecimalError',
    95|         0|            0|            0|  0.00%|    'pydantic.errors:DecimalIsNotFiniteError',
    96|         0|            0|            0|  0.00%|    'pydantic.errors:DecimalMaxDigitsError',
    97|         0|            0|            0|  0.00%|    'pydantic.errors:DecimalMaxPlacesError',
    98|         0|            0|            0|  0.00%|    'pydantic.errors:DecimalWholeDigitsError',
    99|         0|            0|            0|  0.00%|    'pydantic.errors:DictError',
   100|         0|            0|            0|  0.00%|    'pydantic.errors:DurationError',
   101|         0|            0|            0|  0.00%|    'pydantic.errors:EmailError',
   102|         0|            0|            0|  0.00%|    'pydantic.errors:EnumError',
   103|         0|            0|            0|  0.00%|    'pydantic.errors:EnumMemberError',
   104|         0|            0|            0|  0.00%|    'pydantic.errors:ExtraError',
   105|         0|            0|            0|  0.00%|    'pydantic.errors:FloatError',
   106|         0|            0|            0|  0.00%|    'pydantic.errors:FrozenSetError',
   107|         0|            0|            0|  0.00%|    'pydantic.errors:FrozenSetMaxLengthError',
   108|         0|            0|            0|  0.00%|    'pydantic.errors:FrozenSetMinLengthError',
   109|         0|            0|            0|  0.00%|    'pydantic.errors:HashableError',
   110|         0|            0|            0|  0.00%|    'pydantic.errors:IPv4AddressError',
   111|         0|            0|            0|  0.00%|    'pydantic.errors:IPv4InterfaceError',
   112|         0|            0|            0|  0.00%|    'pydantic.errors:IPv4NetworkError',
   113|         0|            0|            0|  0.00%|    'pydantic.errors:IPv6AddressError',
   114|         0|            0|            0|  0.00%|    'pydantic.errors:IPv6InterfaceError',
   115|         0|            0|            0|  0.00%|    'pydantic.errors:IPv6NetworkError',
   116|         0|            0|            0|  0.00%|    'pydantic.errors:IPvAnyAddressError',
   117|         0|            0|            0|  0.00%|    'pydantic.errors:IPvAnyInterfaceError',
   118|         0|            0|            0|  0.00%|    'pydantic.errors:IPvAnyNetworkError',
   119|         0|            0|            0|  0.00%|    'pydantic.errors:IntEnumError',
   120|         0|            0|            0|  0.00%|    'pydantic.errors:IntegerError',
   121|         0|            0|            0|  0.00%|    'pydantic.errors:InvalidByteSize',
   122|         0|            0|            0|  0.00%|    'pydantic.errors:InvalidByteSizeUnit',
   123|         0|            0|            0|  0.00%|    'pydantic.errors:InvalidDiscriminator',
   124|         0|            0|            0|  0.00%|    'pydantic.errors:InvalidLengthForBrand',
   125|         0|            0|            0|  0.00%|    'pydantic.errors:JsonError',
   126|         0|            0|            0|  0.00%|    'pydantic.errors:JsonTypeError',
   127|         0|            0|            0|  0.00%|    'pydantic.errors:ListError',
   128|         0|            0|            0|  0.00%|    'pydantic.errors:ListMaxLengthError',
   129|         0|            0|            0|  0.00%|    'pydantic.errors:ListMinLengthError',
   130|         0|            0|            0|  0.00%|    'pydantic.errors:ListUniqueItemsError',
   131|         0|            0|            0|  0.00%|    'pydantic.errors:LuhnValidationError',
   132|         0|            0|            0|  0.00%|    'pydantic.errors:MissingDiscriminator',
   133|         0|            0|            0|  0.00%|    'pydantic.errors:MissingError',
   134|         0|            0|            0|  0.00%|    'pydantic.errors:NoneIsAllowedError',
   135|         0|            0|            0|  0.00%|    'pydantic.errors:NoneIsNotAllowedError',
   136|         0|            0|            0|  0.00%|    'pydantic.errors:NotDigitError',
   137|         0|            0|            0|  0.00%|    'pydantic.errors:NotNoneError',
   138|         0|            0|            0|  0.00%|    'pydantic.errors:NumberNotGeError',
   139|         0|            0|            0|  0.00%|    'pydantic.errors:NumberNotGtError',
   140|         0|            0|            0|  0.00%|    'pydantic.errors:NumberNotLeError',
   141|         0|            0|            0|  0.00%|    'pydantic.errors:NumberNotLtError',
   142|         0|            0|            0|  0.00%|    'pydantic.errors:NumberNotMultipleError',
   143|         0|            0|            0|  0.00%|    'pydantic.errors:PathError',
   144|         0|            0|            0|  0.00%|    'pydantic.errors:PathNotADirectoryError',
   145|         0|            0|            0|  0.00%|    'pydantic.errors:PathNotAFileError',
   146|         0|            0|            0|  0.00%|    'pydantic.errors:PathNotExistsError',
   147|         0|            0|            0|  0.00%|    'pydantic.errors:PatternError',
   148|         0|            0|            0|  0.00%|    'pydantic.errors:PyObjectError',
   149|         0|            0|            0|  0.00%|    'pydantic.errors:PydanticTypeError',
   150|         0|            0|            0|  0.00%|    'pydantic.errors:PydanticValueError',
   151|         0|            0|            0|  0.00%|    'pydantic.errors:SequenceError',
   152|         0|            0|            0|  0.00%|    'pydantic.errors:SetError',
   153|         0|            0|            0|  0.00%|    'pydantic.errors:SetMaxLengthError',
   154|         0|            0|            0|  0.00%|    'pydantic.errors:SetMinLengthError',
   155|         0|            0|            0|  0.00%|    'pydantic.errors:StrError',
   156|         0|            0|            0|  0.00%|    'pydantic.errors:StrRegexError',
   157|         0|            0|            0|  0.00%|    'pydantic.errors:StrictBoolError',
   158|         0|            0|            0|  0.00%|    'pydantic.errors:SubclassError',
   159|         0|            0|            0|  0.00%|    'pydantic.errors:TimeError',
   160|         0|            0|            0|  0.00%|    'pydantic.errors:TupleError',
   161|         0|            0|            0|  0.00%|    'pydantic.errors:TupleLengthError',
   162|         0|            0|            0|  0.00%|    'pydantic.errors:UUIDError',
   163|         0|            0|            0|  0.00%|    'pydantic.errors:UUIDVersionError',
   164|         0|            0|            0|  0.00%|    'pydantic.errors:UrlError',
   165|         0|            0|            0|  0.00%|    'pydantic.errors:UrlExtraError',
   166|         0|            0|            0|  0.00%|    'pydantic.errors:UrlHostError',
   167|         0|            0|            0|  0.00%|    'pydantic.errors:UrlHostTldError',
   168|         0|            0|            0|  0.00%|    'pydantic.errors:UrlPortError',
   169|         0|            0|            0|  0.00%|    'pydantic.errors:UrlSchemeError',
   170|         0|            0|            0|  0.00%|    'pydantic.errors:UrlSchemePermittedError',
   171|         0|            0|            0|  0.00%|    'pydantic.errors:UrlUserInfoError',
   172|         0|            0|            0|  0.00%|    'pydantic.errors:WrongConstantError',
   173|         0|            0|            0|  0.00%|    'pydantic.main:validate_model',
   174|         0|            0|            0|  0.00%|    'pydantic.networks:stricturl',
   175|         0|            0|            0|  0.00%|    'pydantic:parse_file_as',
   176|         0|            0|            0|  0.00%|    'pydantic:parse_raw_as',
   177|         0|            0|            0|  0.00%|    'pydantic:stricturl',
   178|         0|            0|            0|  0.00%|    'pydantic.tools:parse_file_as',
   179|         0|            0|            0|  0.00%|    'pydantic.tools:parse_raw_as',
   180|         0|            0|            0|  0.00%|    'pydantic.types:ConstrainedBytes',
   181|         0|            0|            0|  0.00%|    'pydantic.types:ConstrainedDate',
   182|         0|            0|            0|  0.00%|    'pydantic.types:ConstrainedDecimal',
   183|         0|            0|            0|  0.00%|    'pydantic.types:ConstrainedFloat',
   184|         0|            0|            0|  0.00%|    'pydantic.types:ConstrainedFrozenSet',
   185|         0|            0|            0|  0.00%|    'pydantic.types:ConstrainedInt',
   186|         0|            0|            0|  0.00%|    'pydantic.types:ConstrainedList',
   187|         0|            0|            0|  0.00%|    'pydantic.types:ConstrainedSet',
   188|         0|            0|            0|  0.00%|    'pydantic.types:ConstrainedStr',
   189|         0|            0|            0|  0.00%|    'pydantic.types:JsonWrapper',
   190|         0|            0|            0|  0.00%|    'pydantic.types:NoneBytes',
   191|         0|            0|            0|  0.00%|    'pydantic.types:NoneStr',
   192|         0|            0|            0|  0.00%|    'pydantic.types:NoneStrBytes',
   193|         0|            0|            0|  0.00%|    'pydantic.types:StrBytes',
   194|         0|            0|            0|  0.00%|    'pydantic.typing:evaluate_forwardref',
   195|         0|            0|            0|  0.00%|    'pydantic.typing:AbstractSetIntStr',
   196|         0|            0|            0|  0.00%|    'pydantic.typing:AnyCallable',
   197|         0|            0|            0|  0.00%|    'pydantic.typing:AnyClassMethod',
   198|         0|            0|            0|  0.00%|    'pydantic.typing:CallableGenerator',
   199|         0|            0|            0|  0.00%|    'pydantic.typing:DictAny',
   200|         0|            0|            0|  0.00%|    'pydantic.typing:DictIntStrAny',
   201|         0|            0|            0|  0.00%|    'pydantic.typing:DictStrAny',
   202|         0|            0|            0|  0.00%|    'pydantic.typing:IntStr',
   203|         0|            0|            0|  0.00%|    'pydantic.typing:ListStr',
   204|         0|            0|            0|  0.00%|    'pydantic.typing:MappingIntStrAny',
   205|         0|            0|            0|  0.00%|    'pydantic.typing:NoArgAnyCallable',
   206|         0|            0|            0|  0.00%|    'pydantic.typing:NoneType',
   207|         0|            0|            0|  0.00%|    'pydantic.typing:ReprArgs',
   208|         0|            0|            0|  0.00%|    'pydantic.typing:SetStr',
   209|         0|            0|            0|  0.00%|    'pydantic.typing:StrPath',
   210|         0|            0|            0|  0.00%|    'pydantic.typing:TupleGenerator',
   211|         0|            0|            0|  0.00%|    'pydantic.typing:WithArgsTypes',
   212|         0|            0|            0|  0.00%|    'pydantic.typing:all_literal_values',
   213|         0|            0|            0|  0.00%|    'pydantic.typing:display_as_type',
   214|         0|            0|            0|  0.00%|    'pydantic.typing:get_all_type_hints',
   215|         0|            0|            0|  0.00%|    'pydantic.typing:get_args',
   216|         0|            0|            0|  0.00%|    'pydantic.typing:get_origin',
   217|         0|            0|            0|  0.00%|    'pydantic.typing:get_sub_types',
   218|         0|            0|            0|  0.00%|    'pydantic.typing:is_callable_type',
   219|         0|            0|            0|  0.00%|    'pydantic.typing:is_classvar',
   220|         0|            0|            0|  0.00%|    'pydantic.typing:is_finalvar',
   221|         0|            0|            0|  0.00%|    'pydantic.typing:is_literal_type',
   222|         0|            0|            0|  0.00%|    'pydantic.typing:is_namedtuple',
   223|         0|            0|            0|  0.00%|    'pydantic.typing:is_new_type',
   224|         0|            0|            0|  0.00%|    'pydantic.typing:is_none_type',
   225|         0|            0|            0|  0.00%|    'pydantic.typing:is_typeddict',
   226|         0|            0|            0|  0.00%|    'pydantic.typing:is_typeddict_special',
   227|         0|            0|            0|  0.00%|    'pydantic.typing:is_union',
   228|         0|            0|            0|  0.00%|    'pydantic.typing:new_type_supertype',
   229|         0|            0|            0|  0.00%|    'pydantic.typing:resolve_annotations',
   230|         0|            0|            0|  0.00%|    'pydantic.typing:typing_base',
   231|         0|            0|            0|  0.00%|    'pydantic.typing:update_field_forward_refs',
   232|         0|            0|            0|  0.00%|    'pydantic.typing:update_model_forward_refs',
   233|         0|            0|            0|  0.00%|    'pydantic.utils:ClassAttribute',
   234|         0|            0|            0|  0.00%|    'pydantic.utils:DUNDER_ATTRIBUTES',
   235|         0|            0|            0|  0.00%|    'pydantic.utils:PyObjectStr',
   236|         0|            0|            0|  0.00%|    'pydantic.utils:ValueItems',
   237|         0|            0|            0|  0.00%|    'pydantic.utils:almost_equal_floats',
   238|         0|            0|            0|  0.00%|    'pydantic.utils:get_discriminator_alias_and_values',
   239|         0|            0|            0|  0.00%|    'pydantic.utils:get_model',
   240|         0|            0|            0|  0.00%|    'pydantic.utils:get_unique_discriminator_alias',
   241|         0|            0|            0|  0.00%|    'pydantic.utils:in_ipython',
   242|         0|            0|            0|  0.00%|    'pydantic.utils:is_valid_identifier',
   243|         0|            0|            0|  0.00%|    'pydantic.utils:path_type',
   244|         0|            0|            0|  0.00%|    'pydantic.utils:validate_field_name',
   245|         0|            0|            0|  0.00%|    'pydantic:validate_model',
   246|         0|            0|            0|  0.00%|}
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|
   249|         0|            0|            0|  0.00%|def getattr_migration(module: str) -> Callable[[str], Any]:
   250|         0|            0|            0|  0.00%|    """Implement PEP 562 for objects that were either moved or removed on the migration
   251|         0|            0|            0|  0.00%|    to V2.
   252|         0|            0|            0|  0.00%|
   253|         0|            0|            0|  0.00%|    Args:
   254|         0|            0|            0|  0.00%|        module: The module name.
   255|         0|            0|            0|  0.00%|
   256|         0|            0|            0|  0.00%|    Returns:
   257|         0|            0|            0|  0.00%|        A callable that will raise an error if the object is not found.
   258|         0|            0|            0|  0.00%|    """
   259|         0|            0|            0|  0.00%|    # This avoids circular import with errors.py.
   260|         0|            0|            0|  0.00%|    from .errors import PydanticImportError
   261|         0|            0|            0|  0.00%|
   262|         2|  1.00136e-05|  5.00679e-06|  0.01%|    def wrapper(name: str) -> object:
   263|         0|            0|            0|  0.00%|        """Raise an error if the object is not found, or warn if it was moved.
   264|         0|            0|            0|  0.00%|
   265|         0|            0|            0|  0.00%|        In case it was moved, it still returns the object.
   266|         0|            0|            0|  0.00%|
   267|         0|            0|            0|  0.00%|        Args:
   268|         0|            0|            0|  0.00%|            name: The object name.
   269|         0|            0|            0|  0.00%|
   270|         0|            0|            0|  0.00%|        Returns:
   271|         0|            0|            0|  0.00%|            The object.
   272|         0|            0|            0|  0.00%|        """
   273|         2|  8.10623e-06|  4.05312e-06|  0.01%|        if name == '__path__':
   274|         2|  9.05991e-06|  4.52995e-06|  0.01%|            raise AttributeError(f'module {module!r} has no attribute {name!r}')
   275|         0|            0|            0|  0.00%|
   276|         0|            0|            0|  0.00%|        import warnings
   277|         0|            0|            0|  0.00%|
   278|         0|            0|            0|  0.00%|        from ._internal._validators import import_string
   279|         0|            0|            0|  0.00%|
   280|         0|            0|            0|  0.00%|        import_path = f'{module}:{name}'
   281|         0|            0|            0|  0.00%|        if import_path in MOVED_IN_V2.keys():
   282|         0|            0|            0|  0.00%|            new_location = MOVED_IN_V2[import_path]
   283|         0|            0|            0|  0.00%|            warnings.warn(f'`{import_path}` has been moved to `{new_location}`.')
   284|         0|            0|            0|  0.00%|            return import_string(MOVED_IN_V2[import_path])
   285|         0|            0|            0|  0.00%|        if import_path in DEPRECATED_MOVED_IN_V2:
   286|         0|            0|            0|  0.00%|            # skip the warning here because a deprecation warning will be raised elsewhere
   287|         0|            0|            0|  0.00%|            return import_string(DEPRECATED_MOVED_IN_V2[import_path])
   288|         0|            0|            0|  0.00%|        if import_path in REDIRECT_TO_V1:
   289|         0|            0|            0|  0.00%|            new_location = REDIRECT_TO_V1[import_path]
   290|         0|            0|            0|  0.00%|            warnings.warn(
   291|         0|            0|            0|  0.00%|                f'`{import_path}` has been removed. We are importing from `{new_location}` instead.'
   292|         0|            0|            0|  0.00%|                'See the migration guide for more details: https://docs.pydantic.dev/latest/migration/'
   293|         0|            0|            0|  0.00%|            )
   294|         0|            0|            0|  0.00%|            return import_string(REDIRECT_TO_V1[import_path])
   295|         0|            0|            0|  0.00%|        if import_path == 'pydantic:BaseSettings':
   296|         0|            0|            0|  0.00%|            raise PydanticImportError(
   297|         0|            0|            0|  0.00%|                '`BaseSettings` has been moved to the `pydantic-settings` package. '
   298|         0|            0|            0|  0.00%|                f'See https://docs.pydantic.dev/{version_short()}/migration/#basesettings-has-moved-to-pydantic-settings '
   299|         0|            0|            0|  0.00%|                'for more details.'
   300|         0|            0|            0|  0.00%|            )
   301|         0|            0|            0|  0.00%|        if import_path in REMOVED_IN_V2:
   302|         0|            0|            0|  0.00%|            raise PydanticImportError(f'`{import_path}` has been removed in V2.')
   303|         0|            0|            0|  0.00%|        globals: Dict[str, Any] = sys.modules[module].__dict__
   304|         0|            0|            0|  0.00%|        if name in globals:
   305|         0|            0|            0|  0.00%|            return globals[name]
   306|         0|            0|            0|  0.00%|        raise AttributeError(f'module {module!r} has no attribute {name!r}')
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|    return wrapper
File: /home/arseniy/Документы/Projects/Python/LLM_project/Azure OpenAI/main/app/backend/llm/llm_api.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends
     2|         0|            0|            0|  0.00%|from fastapi import FastAPI
     3|         0|            0|            0|  0.00%|from authentication.auth_api import verify_token
     4|         0|            0|            0|  0.00%|import logging
     5|         0|            0|            0|  0.00%|from .agent import ask_openai
     6|         0|            0|            0|  0.00%|import time
     7|         0|            0|            0|  0.00%|import pprofile
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|profiler = pprofile.Profile()
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|logger = logging.getLogger("uvicorn.error")
    12|         0|            0|            0|  0.00%|logger.setLevel(logging.DEBUG)
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|router = APIRouter()
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|# Dictionary to store active WebSocket connections for each user
    17|         0|            0|            0|  0.00%|active_connections = {}
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|class ConnectionManager:
    20|         0|            0|            0|  0.00%|    def __init__(self):
    21|         0|            0|            0|  0.00%|        self.active_connections = {}  # Key: user_id, Value: WebSocket
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|    async def connect(self, websocket: WebSocket, user_id: str):
    24|         0|            0|            0|  0.00%|        await websocket.accept()
    25|         0|            0|            0|  0.00%|        self.active_connections[user_id] = websocket
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|    def disconnect(self, user_id: str):
    28|         0|            0|            0|  0.00%|        if user_id in self.active_connections:
    29|         0|            0|            0|  0.00%|            del self.active_connections[user_id]
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|    async def send_personal_message(self, message: str, user_id: str):
    32|         0|            0|            0|  0.00%|        websocket = self.active_connections.get(user_id)
    33|         0|            0|            0|  0.00%|        if websocket:
    34|         0|            0|            0|  0.00%|            await websocket.send_text(message)
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|    async def broadcast(self, message: str):
    37|         0|            0|            0|  0.00%|        for connection in self.active_connections.values():
    38|         0|            0|            0|  0.00%|            await connection.send_text(message)
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|manager = ConnectionManager()
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|with profiler:
    43|         0|            0|            0|  0.00%|    @router.websocket("/chat/{user_id}")
(call)|         1|  6.27041e-05|  6.27041e-05|  0.06%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/routing.py:1015 websocket
(call)|         1|    0.0969172|    0.0969172| 99.63%|# /home/arseniy/.var/app/org.jupyter.JupyterLab/config/jupyterlab-desktop/jlab_server/envs/llamaCuda/lib/python3.12/site-packages/fastapi/routing.py:1074 decorator
    44|         0|            0|            0|  0.00%|    async def websocket_endpoint(websocket: WebSocket, user_id: str, token: str):
    45|         0|            0|            0|  0.00%|        try:
    46|         0|            0|            0|  0.00%|            # Verify the token and get the user ID
    47|         0|            0|            0|  0.00%|            payload = verify_token(token)
    48|         0|            0|            0|  0.00%|            logger.info(f"Token validated for user {user_id}")
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|            # Connect user
    51|         0|            0|            0|  0.00%|            await manager.connect(websocket, user_id)
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|            while True:
    54|         0|            0|            0|  0.00%|                try:
    55|         0|            0|            0|  0.00%|                    # Receive message timestamp
    56|         0|            0|            0|  0.00%|                    start_time = time.perf_counter()
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|                    # Receive and log the message from the user
    59|         0|            0|            0|  0.00%|                    data = await websocket.receive_text()
    60|         0|            0|            0|  0.00%|                    logger.debug(f"Message received from {user_id}: {data}")
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|                    # Process user message (e.g., through OpenAI API)
    63|         0|            0|            0|  0.00%|                    response = ask_openai(data)
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|                    # End timestamp for processing
    66|         0|            0|            0|  0.00%|                    end_time = time.perf_counter()
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|                    # Calculate response time in milliseconds
    69|         0|            0|            0|  0.00%|                    elapsed_time_ms = (end_time - start_time) * 1000
    70|         0|            0|            0|  0.00%|                    logger.info(f"Response time for user: {elapsed_time_ms:.3f} ms")
    71|         0|            0|            0|  0.00%|
    72|         0|            0|            0|  0.00%|                    # Optionally send the timing information back to the client
    73|         0|            0|            0|  0.00%|                    timing_info = f"Response time: {elapsed_time_ms:.3f} ms"
    74|         0|            0|            0|  0.00%|                    await manager.send_personal_message(f"{response}\n{timing_info}", user_id) ### remove timing info!!!
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|                except WebSocketDisconnect:
    77|         0|            0|            0|  0.00%|                    # Handle WebSocket disconnection gracefully
    78|         0|            0|            0|  0.00%|                    manager.disconnect(user_id)
    79|         0|            0|            0|  0.00%|                    logger.info(f"User {user_id} disconnected.")
    80|         0|            0|            0|  0.00%|                    break
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|                except Exception as e:
    83|         0|            0|            0|  0.00%|                    # Log any unexpected errors while receiving or sending messages
    84|         0|            0|            0|  0.00%|                    logger.error(f"Error in WebSocket communication for user {user_id}: {e}")
    85|         0|            0|            0|  0.00%|                    await manager.send_personal_message(f"An error occurred: {str(e)}", user_id)
    86|         0|            0|            0|  0.00%|
    87|         0|            0|            0|  0.00%|        except WebSocketDisconnect:
    88|         0|            0|            0|  0.00%|            manager.disconnect(user_id)
    89|         0|            0|            0|  0.00%|            logger.info(f"User {user_id} disconnected.")
    90|         0|            0|            0|  0.00%|
    91|         0|            0|            0|  0.00%|        except ValueError as ve:
    92|         0|            0|            0|  0.00%|            # Handle token validation errors or invalid tokens
    93|         0|            0|            0|  0.00%|            logger.error(f"Invalid token for user {user_id}: {ve}")
    94|         0|            0|            0|  0.00%|            await websocket.close(code=1008, reason="Invalid authentication token")
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|        except Exception as e:
    97|         0|            0|            0|  0.00%|            # Handle all other exceptions
    98|         0|            0|            0|  0.00%|            logger.error(f"Unexpected error for user {user_id}: {e}")
    99|         0|            0|            0|  0.00%|            await websocket.close(code=1011, reason="Internal server error")
   100|         0|            0|            0|  0.00%|profiler.dump_stats("profiler_stats.txt")
